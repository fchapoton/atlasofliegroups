
The "block" command prints out a list of representations in a single block.
A block is an equivalence class of irreducible representations, where the
equivalence relation is generated by the relation of two representations
having a non-split extension. At present we can consider only blocks of
representations having regular integral infinitesimal character.

The user must specify a (real form defining a) real group and a dual real form
(a real form of the dual complex group); unless these were already specified
before or only one choice is available, the program will prompt for a
selection. These data determine a block (up to the equivalences of categories
provided by the Jantzen-Zuckerman translation principle). For a given real
group $G$, the largest and most interesting block is the one containing a
finite-dimensional representation of $G$; it is selected by choosing in the
dual group the quasisplit real form (always the last choice provided).

Each row of the output corresponds to a single irreducible representation in
the block. The output may be saved to a file, or viewed on the terminal.

The first column is a numbering of the elements, from 0 to $n-1$ (with $n$ the
number of elements in the block), each followed by a pair $(x,y)$. Here $i$ is
the number of an orbit of $K$ on $G/B$, as enumerated by the 'kgb' command.
Similarly $j$ is the number of an orbit of $K^\vee$ on $G^\vee/B^\vee$, as
enumerated by the 'kgb' command for the dual group and the chosen dual real
form (or more simply by the 'dualkgb' command). The pair $(x,y)$ is a
parameter for a representation of $G$ (so the negative transpose of the
involution of $H$ associated to $i$ is the one of $H^\vee$ associated to $j$.)

The next two colums give the length of the parameter $(x,y)$ and the number of
the Cartan class determined by the abovementioned involution of $H$ (the
numbering of the latter matches the one produced by the 'cartan' command).

Then comes, in brackets, a sequence giving the types of all simple root:

i1: imaginary, non-compact, type 1 (single valued Cayley transform)
i2: imaginary, non-compact, type 2 (double valued Cayley transform)
ic: imaginary compact (no Cayley or inverse Cayley transforms)
r1: real, type 1 (double valued inverse Cayley transform)
r2: real, type 2 (single valued inverse Cayley transform)
rn: real, non-parity (no inverse Cayley or Cayley transforms)
C+: complex, cross action increases length
C-: complex, cross action decreases length

Type 1 real and imaginary roots correspond to a subgroup $SL(2,\R)$.
The imaginary Cayley transforms are single valued, and the inverse real
Cayley transforms are double valued. Type 2 real and imaginary roots
correpsond to a subgroup $PGL(2,\R)$, in which the situation is reversed.

A slightly different formulation of these explanations may be found in
the help file for the blocku command.

The next sequence of $r$ columns (where $r$ is the number of simple roots)
gives the cross actions of the simple roots: number $s$ of the sequence gives
the number of the parameter to which the current parameter is sent under the
cross action by simple root $s$.

The next $r$ columns give Cayley transform(s) or inverse Cayley transform(s)
of the current parameter by the respective simple root, if any are defined. In
case of a non-compact imaginary root there are one or two Cayley transforms,
and in the case of real type 1 or 2 root there are two or one inverse Cayley
transforms, and in ither cases none are defined. The format used is $(k,k')$
where $k$ and $k'$ are either the number of a parameter reached from the
current parameter by the Cayley transform or inverse Cayley transform, or '*'
if at that position no such transform is defined.

The final column gives the twisted involution of the Weyl group that specifies
the involution of $H$ (see the help for the 'kgb' command).

Example:

empty: type
Lie type: C2 sc s
main: block
(weak) real forms are:
0: sp(2)
1: sp(1,1)
2: sp(4,R)
enter your choice: 2
possible (weak) dual real forms are:
0: so(5)
1: so(4,1)
2: so(2,3)
enter your choice: 2
Name an output file (return for stdout, ? to abandon):
 0( 0,6):  0  0  [i1,i1]   1   2   ( 6, *)  ( 4, *)
 1( 1,6):  0  0  [i1,i1]   0   3   ( 6, *)  ( 5, *)
 2( 2,6):  0  0  [ic,i1]   2   0   ( *, *)  ( 4, *)
 3( 3,6):  0  0  [ic,i1]   3   1   ( *, *)  ( 5, *)
 4( 4,4):  1  2  [C+,r1]   8   4   ( *, *)  ( 0, 2)   2
 5( 5,4):  1  2  [C+,r1]   9   5   ( *, *)  ( 1, 3)   2
 6( 6,5):  1  1  [r1,C+]   6   7   ( 0, 1)  ( *, *)   1
 7( 7,2):  2  1  [i2,C-]   7   6   (10,11)  ( *, *)   2,1,2
 8( 8,3):  2  2  [C-,i1]   4   9   ( *, *)  (10, *)   1,2,1
 9( 9,3):  2  2  [C-,i1]   5   8   ( *, *)  (10, *)   1,2,1
10(10,0):  3  3  [r2,r1]  11  10   ( 7, *)  ( 8, 9)   1,2,1,2
11(10,1):  3  3  [r2,rn]  10  11   ( 7, *)  ( *, *)   1,2,1,2
