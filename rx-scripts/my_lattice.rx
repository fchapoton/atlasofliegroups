{some new commands, and fix of in_lattice from lattice.rx}
{lattice.rx could (probably) be replaced with this file}

<basic.rx
<matrix.rx { for 'minor' (this dependency might be eliminated) }
<misc.rx

{ M is an nxk matrix, columns of M define a Z-module W }

set submodule_basis(mat M) = mat:
  let (B,cs) = adapted_basis(M) in n_rows(B) # for c@j in cs do c*B[j] od

{ a basis representing the quotient by sublattice spanned by columns;
  tests that this sublattice is a direct factor, and throws an error if not }
set quotient_module_basis(mat M) = mat:
  let (B,cs) = adapted_basis(M) then l=#cs
  then ()= if cs!=ones(l) then error("sublattice is not a direct factor") fi
  in columns_with ((int j)bool: j>=l,B)

{ a basis representing the quotient by saturation of sublattice, so no test }
set saturation_quotient_module_basis(mat M) = mat:
  let (B,cs) = adapted_basis(M) then l=#cs
  in columns_with ((int j)bool: j>=l,B)

{ M is an n*k matrix whose columns span a rank k submodule W of V=Z^n
  A is an n*n matrix preserving W
  sub_matrix(M,W) is the k*k matrix giving the action of A on W,
  using columns of M as basis
}
set sub_matrix(mat A,mat M) = mat:
  let P = M#kernel(^M) then (Pinverse,d) = invert(P)
  then Q = minor(Pinverse*A*P,n_columns(M))
  in if Q%d!=null(#Q) then error("lattice not fixed") else Q\d fi

{ assuming M injective and Im(A*M)\subset Im(A), find unique C with A*M=M*C }
{ using decomposition M = L^{-1} * D * R^{-1} (B,L invertible, D diagonal)
  first find A' = L*A*L^{-1}, then A'' such that D*A'' = A'*D, which must
  exist, and finally compute C = R*A''*R^{-1}
}
set restrict_action (mat A, mat M) = mat:
  let (ds,L,R) = diagonalize(M), (l,r)=#M { also sizes of L,R; one has l>=r }
  then () = if #ds!=r then error("matrix has dependent columns") fi
  then A1 = L * A * inverse(L)
  then A1Dtr = l ^ for d@j in ds do d*A1[j] od { one has #A1Dtr=(r,l) }
  , A2tr= [vec]:[] { collects r vectors of size r } , zero=null(r)
  then () =
     for i: l { collect first r rows of A1, scaled; test remaining row are 0 }
     do if i<r
        then
          if A1Dtr[i]%ds[i]=zero then  A2tr #:=  A1Dtr[i]\ds[i]
          else error("matrix does not fix lattice")
	  fi
        elif A1Dtr[i]!=zero then error("matrix does not fix image")
        fi
     od
  in R * (r^A2tr) * inverse(R)

set corestrict_action (mat A, mat M) = mat: ^restrict_action(^A,^M)

{ M is an nxk matrix whose columns span a submodule W of V=Z^n
  A is an nxn matrix preserving W
  quotient_matrix(M,W) is the matrix of M on V/W,
  using the basis from quotient_module_basis(M)
}
set quotient_matrix(mat M,mat A) = mat:
  let P= submodule_basis(M)#quotient_module_basis(M), ncM=n_columns(M)
  then (Pinverse,d) = invert(P)
  then Q = minor(Pinverse*A*P,n_columns(A)-ncM,ncM)
  in Q\d

{ M is an nxk matrix whose columns span a submodule W of V=Z^n
  Projection of v onto V/W parallel to W in basis from adapted_basis
  Basis of image space: projection of final vectors of adapted_basis
}
set projection_mod_image (mat M) = mat:
  let (B,cs) = adapted_basis(M) then d=#cs
  in rows_with( (int i): i>=d, inverse(B) ) { coordinates on final part basis }

{ original code:
  let sub = submodule_basis(M), quotient = saturation_quotient_module_basis(M)
  then P = mat: sub#quotient, dim_sum = n_columns(sub)
  in rows_with( (int i): i>=dim_sum, inverse(P) )
}

{ M is an nxk matrix whose columns span a submodule  W of V=Z^n
  Projection to saturation of W, parallel to complement from adapted_basis(M)
  Basis of image space: initial vectors of adapted_basis
}
set projection_to_image (mat M) = mat:
  let (B,cs) = adapted_basis(M) then d=#cs
  in rows_with( (int i): i<d, inverse(B) )

set index_lattice (mat M) = int:
  let index = abs(product(let (d,,)=diagonalize(M) in d))
  in assert(index>0,"lattice has infinite index"); index

{ D=SMT weak Smith normal form, S,T are Z-invertible, D is diagonal
  with nonzero entries first, but not assuming divisibiliy; differs from
  diagonalize(M) only by replacing list of factors containing "diagonal" matrix
}
set weak_snf (mat M) = (mat,mat,mat):
  let (v,S,T)=diagonalize(M)
  then D=null(n_rows(S),n_columns(T))
  in for i:#v do D[i,i]:=v[i] od; (S,D,T)

{ solve Dw=v over Z, where D is diagonal square, if possible }
set diag_solve(mat D,vec v)=(vec, bool):
  let success=true
  then w =
    for vi@i in v
    do let Dii=D[i,i] in
      if Dii=0 then success := vi=0; vi
      else let (q,r)=vi\%Dii in success := r=0; q
      fi
    od
  in (w,success)

set Q_diag_solve(mat D,ratvec v) = (ratvec,bool):
  let success=true
  then w =
    for vi@i in v
    do let Dii=D[i,i] in
      if Dii=0 then success := vi=0; vi
      else vi/Dii
      fi
    od
  in (w,success)

{ solve Mw=v (over integers) maybe only works for M square }
set solve(mat M,vec v) = (vec, bool):
  let (S,D,T)=weak_snf(M)
  then (diag,success)=diag_solve(D,S*v)
  in (if success then T*diag else v fi, success)


set Q_solve(mat M, ratvec v) = (ratvec,bool):
  let (S,D,T)=weak_snf(M) then (diag,success)=Q_diag_solve(D,S*v)
  in (if success then T*diag else v fi, success )

set rank (mat M) = int: { number of (nonzero) invariant factors of M }
  let (ds,,)=diagonalize(M) in #ds

{ ratvec v is in Q-span of columns of M: rank([M, numerator(v)])=rank(M) }
set in_Q_span(mat M, ratvec v) = bool:
  rank(M#column(numer(v)))=rank(M)

{ product of non-zero invariant factors of M }
set pseudo_det(mat M) = int: { the same as |index| above, but without error }
  product(inv_fact(M))

{ this replaces flawed command in lattice.rx }
{ vec v is in Z-span of columns of M: in_Q_span(M,v), and
  pseudo_det(M)=pseudo_det(M,v), the product of (nonzero) invariant factors}
set in_lattice(mat M, vec v)=
  in_Q_span(M,v) and pseudo_det(M)=pseudo_det(M#(column(v)))


