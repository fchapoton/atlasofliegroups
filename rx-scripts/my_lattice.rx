{some new commands, and fix of in_lattice from lattice.rx}
{lattice.rx could (probably) be replaced with this file}

<basic.rx
<matrix.rx { for 'minor' (this dependency might be eliminated) }
<misc.rx

{ M is an nxk matrix, columns of M define a Z-module W }

set submodule_basis(mat M) = mat:
  let (B,cs) = adapted_basis(M) in n_rows(B) # for c@j in cs do c*B[j] od

{ a basis representing the quotient by sublattice spanned by columns;
  tests that this sublattice is a direct factor, and throws an error if not }
set quotient_module_basis(mat M) = mat:
  let (B,cs) = adapted_basis(M) then l=#cs
  then ()= if cs!=ones(l) then error("sublattice is not a direct factor") fi
  in columns_with ((int j)bool: j>=l,B)

{ a basis representing the quotient by saturation of sublattice, so no test }
set saturation_quotient_module_basis(mat M) = mat:
  let (B,cs) = adapted_basis(M) then l=#cs
  in columns_with ((int j)bool: j>=l,B)

{ M is an n*k matrix whose columns span a rank m submodule W of V=Z^n
  A is an n*n matrix preserving W
  sub_matrix(M,W) is the m*m matrix giving the action of M on W,
  using columns of M as basis
}
set sub_matrix(mat A,mat M) = mat:
  let P = M#kernel(^M) then (Pinverse,d) = invert(P)
  then Q = minor(Pinverse*A*P,n_columns(M))
  in if Q%d!=null(#Q) then error("lattice not fixed") else Q\d fi

{ assuming M injective and Im(A*M)\subset Im(A), find unique C with A*M=M*C }
{ using decomposition M = L^{-1} * D * R^{-1} (B,L invertible, D diagonal)
  first find A' = L*A*L^{-1}, then A'' such that D*A'' = A'*D, which must
  exist, and finally compute C = R*A''*R^{-1}
}
set restrict_action (mat A, mat M) = mat:
  let (ds,L,R) = diagonalize(M), (l,r)=#M { also sizes of L,R; one has l>=r }
  then () = if #ds!=r then error("matrix has dependent columns") fi
  then A1 = L * A * inverse(L)
  then A1Dtr = l ^ for d@j in ds do d*A1[j] od { one has #A1Dtr=(r,l) }
  , A2tr= [vec]:[] { collects r vectors of size r } , zero=null(r)
  then () =
     for i: l { collect first r rows of A1, scaled; test remaining row are 0 }
     do if i<r
        then
          if A1Dtr[i]%ds[i]=zero then  A2tr #:=  A1Dtr[i]\ds[i]
          else error("matrix does not fix lattice")
	  fi
        elif A1Dtr[i]!=zero then error("matrix does not fix image")
        fi
     od
  in R * (r^A2tr) * inverse(R)

set corestrict_action (mat A, mat M) = mat: ^restrict_action(^A,^M)

{ M is an nxk matrix whose columns span a submodule W of V=Z^n
  A is an nxn matrix preserving W
  quotient_matrix(M,W) is the matrix of M on V/W,
  using the basis from quotient_module_basis(M)
}
set quotient_matrix(mat M,mat A) = mat:
  let P= submodule_basis(M)#quotient_module_basis(M), ncM=n_columns(M)
  then (Pinverse,d) = invert(P)
  then Q = minor(Pinverse*A*P,n_columns(A)-ncM,ncM)
  in Q\d

{ M is an nxk matrix whose columns span a submodule W of V=Z^n
  Projection of v onto V/W parallel to W in basis from adapted_basis
  Basis of image space: projection of final vectors of adapted_basis
}
set projection_mod_image (mat M) = mat:
  let (B,cs) = adapted_basis(M) then d=#cs
  in rows_with( (int i): i>=d, inverse(B) ) { coordinates on final part basis }

{ original code:
  let sub = submodule_basis(M), quotient = saturation_quotient_module_basis(M)
  then P = mat: sub#quotient, dim_sum = n_columns(sub)
  in rows_with( (int i): i>=dim_sum, inverse(P) )
}

{ M is an nxk matrix whose columns span a submodule  W of V=Z^n
  Projection to saturation of W, parallel to complement from adapted_basis(M)
  Basis of image space: initial vectors of adapted_basis
}
set projection_to_image (mat M) = mat:
  let (B,cs) = adapted_basis(M) then d=#cs
  in rows_with( (int i): i<d, inverse(B) )

{ original code:
  let sub=submodule_basis(M), quotient=saturation_quotient_module_basis(M)
  then P= mat: sub#quotient
  in rows_with( (int i): i<d, inverse(P) )
}

set index_lattice(mat M)=int:
let rv=product(inv_fact(M)) in
if rv=0 then error("lattice has infinite index") fi;rv


{D=SMT weak Smith normal form, S,T are Z-invertible, D is diagonal
with nonzero entries first, but not assuming divisibiliy
diagonalize(M)=(v,S,T), v->D->SMT=D}
set weak_snf(mat M)=
let (v,S,T)=diagonalize(M) in
let D=null(n_rows(S),n_columns(T))  in
let ()=for i:#v do D[i,i]:=v[i] od in (S,D,T)

{solve Dw=v where D pseudo-diagonal (non necessarily square), over Z, if possible}
set diag_solve(mat D,vec v)=(vec, bool):
let success=true in
let w=v in
let ()=for i:#v do
   if ((D[i,i]=0 and v[i] !=0) or (D[i,i]!=0 and not is_integer(v[i]/D[i,i])))
   then success:=false else
     w[i]:= if D[i,i] !=0 then rat_as_int(v[i]/D[i,i]) else 0 fi fi
        od in (w,success)

set Q_diag_solve(mat D,[rat] v)=([rat],bool):
let success=true in
let w=v in
let ()=for i:#v do
   if (D[i,i]=0 and v[i] !=0)
   then success:=false else
     w[i]:= if D[i,i] !=0 then v[i]/D[i,i] else 0 fi fi
        od in (w,success)

{solve Mw=v (over integers) maybe only works for M square}
set solve(mat M,vec v)=(vec, bool):
let (S,D,T)=weak_snf(M) in
let (diag,success)=diag_solve(D,S*v) in
if (success=false) then (v,false) else (T*diag,true) fi


set Q_solve(mat M, [rat] v)=([rat],bool):
let (S,D,T)=weak_snf(M) in
let (diag,success)=Q_diag_solve(D,S*v) in
if (success=false) then (v,false) else (T*diag,true) fi


set rank (mat M)=int:let (S,D,T)=weak_snf(M) in
let rv=0 in for i:min(n_columns(D),n_rows(D)) do if (D[i,i]!=0) then  rv+:=1 fi od;rv

{ratvec v is in Q-span of columns of M: rank([M, numerator(v)])=rank(M)}
set in_Q_span(mat M, ratvec v)=let (w,d)=%v in  bool:rank(M#(mat:[w]))-rank(M)=0

{product of non-zero invariant factors of M}
set pseudo_det(mat M)=product(inv_fact(M))

{this replaces flawed command in lattice.rx}
{vec v is in Z-span of columns of M: in_Q_span(M,v),
and pseudo_det(M)=pseudo_det(M,v) where Det is product of (nonzero) invariant factors}
set in_lattice(mat M, vec v)=
in_Q_span(M,v) and pseudo_det(M)=pseudo_det(M#(mat:[v]))


