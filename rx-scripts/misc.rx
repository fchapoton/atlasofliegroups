<basic.rx

{ test if an integer is even, or a rational is an integer }
set is_even (int i)    = bool: i%2=0
set is_odd (int i)    = bool: i%2=1
set is_integer (rat r) = bool: denom(r)=1
set is_nonnegative (vec v) = bool:
  let n=#v-1 in while n>=0 and v[n]>=0 do n-:=1 od; n<0
set is_positive (vec v) = bool:
  let n=#v-1 in while n>=0 and v[n]>0 do n-:=1 od; n<0

{ test if a ratvec is in fact a vec (integers)}
set is_integer (ratvec v) = bool: denom(v)=1
set is_positive (ratvec v) = bool: is_positive(numer(v))
set is_nonnegative (ratvec v)= bool: is_nonnegative(numer(v))

{ make a rational into an integer if possible }
set rat_as_int (rat r) = int:
  let (n,d)=%r in if d=1 then n else error("Not an integer") fi

{ make a rational vector into an integer one if possible }
set ratvec_as_vec(ratvec v) = vec:
  let (w,d)=%v in if d=1 then w else error("Not an integer vector") fi

{ transform ParamPol into a list of (Split,Param) pairs; previously built-in }
set %(ParamPol P) = [(Split,Param)]: for c@p in P do (c,p) od

set root_datum(Param p) = RootDatum: root_datum(real_form(p))
set root_datum(ParamPol P) = RootDatum: root_datum(real_form(P))

set is_dominant(RootDatum rd, ratvec v) = bool:
  is_nonnegative(numer(v)*simple_coroots(rd))
set is_regular(RootDatum rd,ratvec v)= bool: { tests all positive coroots }
  let w=numer(v)*poscoroots(rd), i=semisimple_rank(rd)-1
  in while i>=0 and w[i]!=0 do i-:=1 od; i<0
set is_strictly_dominant(RootDatum rd, ratvec v) = bool:
  is_positive(numer(v)*simple_coroots(rd))

set is_regular(Param p)=is_regular(real_form(p),infinitesimal_character(p))

{ make rho as a vector of integers if possible }
set rho_as_vec (RootDatum r)= vec: ratvec_as_vec(rho(r))

{ some data defined by a Param p }
set integrality_datum(Param p)= RootDatum:
  integrality_datum(root_datum(p),infinitesimal_character(p))

{ simpler syntax for param command: param(G,3,...) for param(KGB(G,3),...)  }
set param(RealForm G,int k, vec lambda_rho,ratvec nu) = Param:
  param(KGB(G,k),lambda_rho,nu)

{ parameter(G,x,lambda,nu)=param(G,x,lambda-rho(G),nu), so you can enter
  lambda without the rho shift; lambda may have denominator 2 or be a vec }
set parameter (RealForm G,int x,ratvec lambda,ratvec nu) = Param:
  param(KGB(G,x),ratvec_as_vec(lambda-rho(G)),nu)
set parameter (KGBElt x,ratvec lambda,ratvec nu) = Param:
  param(x,ratvec_as_vec(lambda-rho(real_form(x))),nu)


{ get just the parameters from a block, just a shorcut to: (params,)=block(p) }
set block_of (Param p) = [Param]: let (params,)=block(p) in params

{ replace non-final parameter with [Param p] of final ones
  uses this feature of ParamPol, but ignores any coefficients }
set make_finals (Param p)= [Param]: for c@q in ParamPol: p do q od

{ nicer display of Splits }
set split_format (Split w) = string:
  let (a,b)=%w in
  if a=0 and b!=0
  then if abs(b)>1 then int_format(b) elif b=1 then "" else "-" fi #"s"
  else int_format(a) #
    if abs(b)>1 then if b<0 then "" else "+" fi #int_format(b)#"s"
    elif b=0 then "" elif b=1 then "+s" else "-s"
    fi
  fi

{ nice output of ParamPol:
  split_format the coefficients, print terms in order of x }
set pol_format (ParamPol P)= void:
  for w@p in P
  do prints("(",split_format(w),")*",p,", ",infinitesimal_character(p)) od

{ evaluate at s=t for t integer (or rational?): replace w=a+bs with a+bt }
{ would seem to make sense only if t^2=1, so if either t=1 or t=-1 }
set  #(Split w,int t)=let (a,b)=%w in int: a+t*b
set  #(Split w,rat t)=let (a,b)=%w in rat: a+t*b
set  #(ParamPol P,int t)= ParamPol: { with integer coefficiens }
  null_module(real_form(P)) +  for w@q in P do (w#t,q) od

{ evaluate polynomial at split }
set eval(vec v,Split w)= Split:
  let sum=Split:0 in  for i:#v downto 0 do sum:= v[i] + w*sum od; sum

set at_s(vec v) = Split: eval(v,s)

{ evaluate polynomial at integer }
set eval(vec v,int k) = int:
  let sum=0 in  for i:#v downto 0 do sum:= v[i] + k*sum od; sum

{properties of groups}

set fiber_partition(RealForm G) = [int]: fiber_partition(Cartan_class(G,0),G)

set in_distinguished_fiber(KGBElt x) = bool:
  involution(x)=distinguished_involution(real_form(x))

set distinguished_fiber (RealForm G) = [int]:
  let i=0 in
  while i<KGB_size(G) and in_distinguished_fiber(KGB(G,i)) do i next i:=i+1 od

set ss_rank (RootDatum rd)= semisimple_rank(rd)

set dimension (RootDatum rd) = 2*nr_of_posroots(rd)+rank(rd)

set root_length(RootDatum rd,vec alpha) = int: rat_as_int(alpha*rho_check(rd))
set is_simple_root(RootDatum rd,[int] alpha) = bool: root_length(rd,alpha)=1

set get_simple_number(RootDatum rd,vec alpha) = int:
  let i=semisimple_rank(rd)-1, sr=simple_roots(rd)
  in while i>=0 and alpha!=sr[i] do i-:=1 od; i

set is_simple_for (vec dual_two_rho) = (vec->bool):
  (vec alpha): dual_two_rho*alpha=2

set simple_imaginary_subsystem (KGBElt x) = (mat,mat): { simple (co)roots }
  let ipr=imaginary_posroots(x), ipcr=imaginary_poscoroots(x)
  in ( columns_with(is_simple_for(sum(ipcr)),ipr)
     , columns_with(is_simple_for(sum(ipr)),ipcr) )

set simple_real_subsystem (KGBElt x) = (mat,mat): { simple (co)roots }
  let rpr=real_posroots(x), rpcr=real_poscoroots(x)
  in ( columns_with(is_simple_for(sum(rpcr)),rpr)
     , columns_with(is_simple_for(sum(rpr)),rpcr) )

set split_rank(RealForm G) = int:
  let ((c,C,s),,,) = Cartan_info(most_split_Cartan(G)) in C+s

set to_binary (int length, int n) = vec:
  let v=null(length) in
  while (length-:=1)>=0 and n!=0 do let (q,r)=n\%2 in v[length]:=r; n:=q od; v

set generate_all_binary (int length) = [vec]:
  let start=null(length)
  then binary (int n) = vec:
    let v=start, l=length { we need working copies here }
    in while (l-:=1)>=0 and n!=0 do let (q,r)=n\%2 in v[l]:=r; n:=q od; v
  in for i:2^length do binary(i) od

set generate_all_subsets([int] S) = [[int]]:
  let len=#S
  , gen (int i) = [[int]]: [] { recursive stub; generate subset of S[i:] }
  in
  ( gen :=
    ((int i):
      if i=len then [[]]
      else let r=gen(i+1) in r # for x in r do S[i]#x od
      fi)
  )(0)
