<basic.rx

{ various ways of defining parameters }

{ torus_factor, aka "normalized torus factor", is theta-fixed,
  xi=exp(2\pi i*(torus_factor)/2)exp(rho^\vee/2)\sigma_w\xi_0
  note over 2 in exp terms, Marc writes e_1(x)=exp(\pi ix)
  xi=exp(2\pi i*(unnormalized_torus_factor))\sigma_w\xi_0
   =>
  unnormalized_torus_factor=(torus_factor+rho^\vee)/2
  NOTE: (unnormalized_torus_factor-rho^vee/2) is theta-fixed
     (unnormalized_torus_factor is not theta-fixed)
  torus_factor=2*unnormalized_torus_factor-rho^\vee
  probably better not to use unnormalized_torus_factor
}
set unnormalized_torus_factor(KGBElt x) = ratvec:
  (torus_factor(x)+rho_check(real_form(x)))/2

{ compute xi^2 and test if it is central
  v is unnormalized torus factor
  (e(v)sigma_w*xi_0)^2=e((1+^theta)v+(1-^theta)rho^v/2)
  ^theta since v,rho^v are  in X_*\otimes Q
{ this is formula when v= unnormalized_torus_factor
  xi=exp(2\pi iv)\sigma_w\xi_0
  xi^2=exp(2\pi i[(1+^theta)*v+(1-^theta)*rho^v/2]
      =v*(1+theta)+rho^v*(1-theta)/2
      =rho^v + (2*v-rho^v)*(1+theta)/2
}
{(v*(1+theta)+rho_check(ic))%1 ??? }
}
set square_unnormalized (
  InnerClass ic,mat theta,ratvec unnormalized_torus_factor) = ratvec:
  (unnormalized_torus_factor*(1+theta)+rho_check(ic)*(1-theta)/2)%1

set square_normalized(InnerClass ic,mat theta,ratvec torus_factor) = ratvec:
  square_unnormalized(ic,theta,(torus_factor+rho_check(ic))/2)

{ for valid arguments one should have
  square(ic,theta,tf)=square(real_form(ic,theta,tf))
}
set square = square_normalized@(InnerClass,mat,ratvec)
set square2(InnerClass ic,mat theta,ratvec tf) = ratvec:
  (tf*(1+theta)+2*rho_check(ic))%2 { this should always be twice |square| }

{ the following is ths same as central_cocharacter@RealForm in Vogan-dual.rx }
set square (RealForm G) = ratvec: (base_grading_vector(G)+rho_check(G))%1
set square (KGBElt x) = ratvec: square(real_form(x))
{should equal square(inner_class(x), involution(x), torus_factor(x))}


{ in duality, y is a KGBElt for G^\vee(gamma), but we need to compute its
  square as an element of G^\vee; the difference is in the rho-shift coming
  from the difference between the Tits groups }

{ tf=normalized torus_factor: xi=exp(\pi i(tf\rho^v))\sigma_w\xi_0
  so square_is_central(ic,theta(x),torus_factor(x)) should always be true
}
set square_is_central(InnerClass ic,mat theta,ratvec tf) = bool:
  let sq = square(ic,theta,tf), alpha = simple_roots(ic) in
  all(n_columns(alpha), (int i): is_integer(sq*alpha[i]) )

set parity(Param p,vec alpha_hat) = bool: { parity condition }
  let x = x(p) then theta = involution(x)
  in if alpha_hat*theta != -alpha_hat then error("root not real")
     else let rat_wt= infinitesimal_character(p)-lambda(p)+rho_r(x)
     in rat_as_int(alpha_hat * rat_wt) % 2 = 1
     fi

{ to compute y values over a block of parameters, precompute dual inner class }
set dual_inner_class(Param p) = InnerClass:
  let id = integrality_datum(real_form(p),infinitesimal_character(p))
  in dual(inner_class(id,involution(x(p))))

set y(Param p, InnerClass G_vee) = KGBElt:
  let x = x(p) then dual_theta = -^involution(x)
  then grading_vector = infinitesimal_character(p) - lambda(p) + rho_r(x)
  , dual_shift = sum(imaginary_poscoroots(G_vee,dual_theta))/2
  in KGB_elt(G_vee,dual_theta,grading_vector-dual_shift)

set y(Param p) = KGBElt: y(p,dual_inner_class(p))

set lambda(ratvec gamma,mat theta,KGBElt y)= ratvec:
  if theta != -^involution(y) then error("incompatible involutions")
  else gamma-torus_factor(y)
  fi

set lambda(ratvec gamma,KGBElt x,KGBElt y) = ratvec:
  lambda(gamma,involution(x),y)

set nu(ratvec gamma,KGBElt x)=ratvec: (1-involution(x))*gamma/2
set nu(ratvec gamma,KGBElt x,KGBElt y)=ratvec: nu(gamma,x) { allow unused y }

{sometimes gamma returned by y^2 is not regular, need to make it regular}
set make_regular(RootDatum rd, ratvec v)=ratvec:
  for alpha@i in simple_coroots(rd) do
    if alpha*v=0 { singular, so add something integral that solves just this }
    then v+:=numer(fundamental_weight(rd,i))
    fi
  od; v

{ choose infinitesimal character appropriate for dual parameter }
set choose_g (RealForm G, RootDatum dual_integral) = ratvec:
  make_regular(dual_integral,base_grading_vector(G)+rho(dual_integral))

set choose_g(KGBElt x, KGBElt y)=ratvec:
  let Gx=real_form(x), Gy=real_form(y) { could have taken these as arguments }
{ then ()= begin prints("square(x):", square(Gx))
  ; prints("rho_check(G):", rho_check(Gx))
  ; prints("square(x)-rho_check(G):", square(Gx)-rho_check(Gx))
  ; prints("square(y):", square(Gy))
  ; prints("rho':", rho(Gy)) end }
  in choose_g(Gx,root_datum(Gy))

set choose_g(Param p) = ratvec:
  choose_g(real_form(p),dual(integrality_datum(p)))

{ gamma=infinitesimal character to combine with x, found from real_form(y) }
set parameter(KGBElt x,KGBElt y,ratvec gamma)=Param:
  parameter(x,lambda(gamma,x,y),nu(gamma,x)) { final argument gamma would work }

{ the next function used to be wrong, with choose_g(x,y) instead }
set parameter(KGBElt x, KGBElt y)=Param:
  parameter(x,y,choose_g(y,x)) { computes gamma from real_form(y), x-dominant }

{this gives a parameter for the dual group with infinitesimal character g}
{
set dual_parameter(KGBElt x, KGBElt y,ratvec g)=Param:parameter(y,x,g)
set parameter_pair( KGBElt x, KGBElt y,ratvec gamma,ratvec g) = (Param,Param):
  (parameter(x,y,gamma), dual_parameter(x,y,g))
}

{copied from Vogan-dual.rx}
{ shift (up) a candidate dual infinitesimal character to strictly dominant }
set shift_g_regular (RootDatum rd, ratvec g) = ratvec:
  for alpha@i in simple_roots(rd)
  do let (v,d) = %fundamental_coweight(rd,i)
     in g +:= (1-ceil(g*alpha/d)) * v
  od; g
