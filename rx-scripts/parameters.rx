<basic.rx
<misc.rx { is_integer }

{various ways of defining parameters}

set actual_torus_factor(KGBElt x)=ratvec:
  (torus_factor(x)+rho_check(real_form(x)))/2

{compute xi^2 and test if it is central}
{(e(v)sigma_w*xi_0)^2=e((1+^theta)v)e((1-^theta)rho^v/2)}
{^theta since v,rho^v are  in x_*\otimes Q}

set square(InnerClass ic,ratvec v,mat theta)=ratvec:
  v*(1+theta)+rho_check(ic)/2*(1-theta) { or: rho^v + (2*v-rho^v)*(1+theta)/2 }

set square (RealForm G) = ratvec: (base_grading_vector(G)+rho_check(G))%1
set square(KGBElt x)=ratvec: square(real_form(x))
  { used to be: square(real_form(x), actual_torus_factor(x), involution(x)) }

{ in duality, y is a KGBElt for G^\vee(gamma), but we need to compute its
  square as an element of G^\vee; the difference is in the rho-shift coming
  from the difference between the Tits groups }

set square_is_central(InnerClass ic,ratvec v,mat theta) = bool:
  let sq = square(ic,v,theta), alpha = simple_roots(ic) in
  all((int i)bool: is_integer(sq*alpha[i]),n_columns(alpha))

set parity(Param p,vec alpha_hat) = bool: { parity condition }
  let x = x(p) then theta = involution(x)
  in if alpha_hat*theta != -alpha_hat then error("root not real")
     else let rat_wt= infinitesimal_character(p)-lambda(p)+rho_r(x)
     in rat_as_int(alpha_hat * rat_wt) % 2 = 1
     fi

{ to compute y values over a block of parameters, precompute dual inner class }
set dual_inner_class(Param p) = InnerClass:
  let id = integrality_datum(real_form(p),infinitesimal_character(p))
  in dual(inner_class(id,involution(x(p))))

set y(Param p, InnerClass G_vee) = KGBElt:
  let (x,lambda_rho,nu) = %p
  then dual_theta = -^involution(x)
  then grading_vector = infinitesimal_character(p) - lambda(p) + rho_r(x)
  , dual_shift = sum(imaginary_poscoroots(G_vee,dual_theta))/2
  in KGB_elt(G_vee,dual_theta,grading_vector-dual_shift)

set y(Param p) = KGBElt: y(p,dual_inner_class(p))


set lambda(ratvec gamma,mat theta,KGBElt y)= ratvec:
  if theta != -^involution(y) then error("incompatible involutions")
  else gamma-torus_factor(y)
  fi

set lambda(ratvec gamma,KGBElt x,KGBElt y) = ratvec:
  lambda(gamma,involution(x),y)

set nu(ratvec gamma,KGBElt x)=ratvec: (1-involution(x))*gamma/2
set nu(ratvec gamma,KGBElt x,KGBElt y)=ratvec: nu(gamma,x) { allow unused y }

{sometimes gamma returned by y^2 is not regular, need to make it regular}
set make_regular(RootDatum rd, ratvec v)=ratvec:
  for alpha@i in simple_coroots(rd) do
    if alpha*v=0 { singular, so add something integral that solves just this }
    then v+:=numer(fundamental_weight(rd,i))
    fi
  od; v

{ choose infinitesimal character appropriate for dual parameter }
set choose_g (RealForm G, RootDatum dual_integral) = ratvec:
  make_regular(dual_integral,base_grading_vector(G)+rho(dual_integral))

set choose_g(KGBElt x, KGBElt y)=ratvec:
  let Gx=real_form(x), Gy=real_form(y) { could have taken these as arguments }
{ then ()= begin prints("square(x):", square(Gx))
  ; prints("rho_check(G):", rho_check(Gx))
  ; prints("square(x)-rho_check(G):", square(Gx)-rho_check(Gx))
  ; prints("square(y):", square(Gy))
  ; prints("rho':", rho(Gy)) end }
  in choose_g(Gx,root_datum(Gy))

set choose_g(Param p) = ratvec:
  choose_g(real_form(p),dual(integrality_datum(p)))

{ gamma=infinitesimal character to combine with x, found from real_form(y) }
set parameter(KGBElt x,KGBElt y,ratvec gamma)=Param:
  parameter(x,lambda(gamma,x,y),nu(gamma,x)) { final argument gamma would work }

{ the next function used to be wrong, with choose_g(x,y) instead }
set parameter(KGBElt x, KGBElt y)=Param:
  parameter(x,y,choose_g(y,x)) { computes gamma from real_form(y), x-dominant }

{this gives a parameter for the dual group with infinitesimal character g}
{
set dual_parameter(KGBElt x, KGBElt y,ratvec g)=Param:parameter(y,x,g)
set parameter_pair( KGBElt x, KGBElt y,ratvec gamma,ratvec g) = (Param,Param):
  (parameter(x,y,gamma), dual_parameter(x,y,g))
}

{copied from Vogan-dual.rx}
{ shift (up) a candidate dual infinitesimal character to strictly dominant }
set shift_g_regular (RootDatum rd, ratvec g) = ratvec:
  for alpha@i in simple_roots(rd)
  do let (v,d) = %fundamental_coweight(rd,i)
     in g +:= (1-ceil(g*alpha/d)) * v
  od; g