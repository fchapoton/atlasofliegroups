<basic

set null_wt(int r) = ratvec: null(r)/1
set nu (Param p) = let (,,nu)=%p in nu
set has_nu0 (Param p) = bool: let nu=nu(p) in nu=null_wt(#nu)

set weak_lower (RootDatum rd,ratvec nu) = ratvec: { first decomposable down }
  let ip=integrality_points (rd,nu)
  in if #ip=0 then null_wt(#nu) else ip[#ip-1]*nu fi

set lower (RootDatum rd,ratvec nu) = ratvec: { push nu strictly down }
  let ip=integrality_points (rd,nu)
  then lim = let nip=#ip in if nip>0 and ip[nip-1]=1/1 then nip-1 else nip fi
  in if lim=0 then null_wt(#nu) else ip[lim-1] *nu fi

set lower (Param p) =
  let (x,lambda,nu)=%p then rd=root_datum(inner_class(real_form(x)))
  in param(x,lambda,lower(rd,nu))

set deformation (Param p) = (lower(p),deform(p))

set iterate_deform (Param p) =
  begin
    let d=[(int,Param)]:[], d_done=[(int,Param)]:[]
    in p :=
      (let (x,lambda,nu)=%p then rd=root_datum(inner_class(real_form(x)))
       in param(x,lambda,weak_lower(rd,nu))) { snap to first decomp. point }
  ; while #d>0 or not has_nu0(p)
    do
      let (new_p,d_new)=deformation(p)
      in print(p:=new_p)
    ; for (k,q):t in d
      do if has_nu0(q) then d_done #:= t
         else
           let (new_q,deformation_terms)=deformation(q)
           in d_new #:= (k,new_q)
         ; for (l,r) in deformation_terms do d_new #:= (2*k*l,r) od
         fi
      od
    ; d:=d_new; print(#d)
    od
  ; (p,d_done)
  end


