<ap.rx

{K_norm@Param
 p=(x,lambda,nu)
 K_norm(p)= <d\lambda,2rho^vee> 
          = <(1+theta_x)lambda/2,2rho^vee> 
          = <(1+theta_x)lambda,rho^vee> \in Z
 to see this is an integer: up to integer can replace theta_x with distinguished involution delta
 <(1+delta)lambda,rho^vee>=<lambda,2rho^vee> \in Z since lambda\in X^*+rho\subset weights,
and 2rho^vee is a sum of coroots

need variant of this where rho_check is replaced by an arbitrary ratvec:v
application: L is a subgroup of G, p is a parameter for L, and v=rho_check(G)
Assuming no cpt torus in the center of G, number of parameters of L of bounded 
K_norm(p,rho_check(G)) is finite

For purposes of sorting it is helpful to proceed as follows. Define:
K_norm(ratvec v)=(Param->int)
K_norm(Param p)=K_norm(rho_check)(p)
}

{primary definition
K_norm(v) is a function taking a parameter to an integer
}
set K_norm(ratvec v)=(Param->int):(Param p):
let q=make_dlambda_dominant(p) 
in rat_as_int((1+involution(x(q)))*lambda(q)*v)

{for convenience write this a different way:}
set K_norm(ratvec v,Param p)=K_norm(v)(p)
{also define K_norm(v) of  (Split,Param)}
set K_norm(ratvec v,Split s,Param p)=int:K_norm(v)(p)

{sort [Param] by K_norm(v)}
set sort_by_K_norm(ratvec v) = ([Param] -> [Param]): sort_by( K_norm(v))

{for sorting purposes, need different name: K_norm_alt(v) takes (Split,Param) -> int
 this is an internal function, user shouldn't need to call it
 use K_norm(ratvec v,Split s,Param p) instead
}
set K_norm_alt(ratvec v)=(Split,Param->int):(Split s,Param p):K_norm(v)(p)
set sort_ParamPol_by_K_norm(ratvec v) = ([(Split,Param)] -> [(Split,Param)]): sort_by(K_norm_alt(v))

set print_by_K_norm(ratvec v)=(ParamPol->void):(ParamPol P):
let result=sort_ParamPol_by_K_norm(v)(for c@p in P do (c,p) od) in 
for (c,p) in result do prints(split_as_int(c),"*",p, " ", K_norm(v)(p)) od

set print_by_K_norm(ratvec v,ParamPol P)=void:print_by_K_norm(v)(P)

set maximal_K_norm(ratvec v)=(ParamPol->int):(ParamPol P):
let rv=int:0 in
for p in monomials(P) do let m=K_norm(v)(p) in if m>rv then rv:=m fi od;rv

set leading_terms(ratvec v)=(ParamPol->ParamPol):(ParamPol P):
let max=maximal_K_norm(v)(P) then
rv=null_module(real_form(P)) in 
for c@p in P do if K_norm(v)(p)=max then rv+:=c*p fi od;rv

set all_K_norms(ratvec v)=(ParamPol->[int]):(ParamPol P):
let rv=[int]:[] in
for c@p in P do rv#:=K_norm(v)(p) od;sort(rv)

{  default versions: v=rho_check }

set K_norm(Param p)=int:K_norm(rho_check(real_form(p)))(p)
set K_norm(Split s,Param p)=int:K_norm(p)

set sort_by_K_norm = ([Param] -> [Param]): sort_by( K_norm@Param )
set sort_by_K_norm = ([(Split,Param)] -> [(Split,Param)]): sort_by(K_norm@(Split,Param))

set print_by_K_norm(ParamPol P)=void:print_by_K_norm(rho_check(real_form(P)),P)

set maximal_K_norm(ParamPol P)=int:maximal_K_norm(rho_check(real_form(P)))(P)

set leading_terms(ParamPol P)=ParamPol:leading_terms(rho_check(real_form(P)))(P)

set all_K_norms(ParamPol P)=[int]:all_K_norms(rho_check(real_form(P)))(P)
