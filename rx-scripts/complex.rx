<LKT

set left(ratvec v)=v[:#v\2]
set right(ratvec v)=v[#v\2:#v]
set left(vec v)=v[:#v\2]
set right(vec v)=v[#v\2:#v]

{upper right-hand corner of square matrix
application: in a complex group, theta is of the form
(0 w)
(w 0)
upper_right_corner(theta) gives the matrix of w
}
set up_right_corner(mat M)=mat:
let (m,n)=#M in if m!=n then error("matrix is not square") else
let a=m\2 in ^(^M[a:m])[0:a]
fi

set left_w(KGBElt x)=up_right_corner(involution(x))

set mu(Param p)=vec:
let lambda=lambda(p) then
x=x(p) then
w=left_w(x) in
{inverse(w)*left(lambda)+right(lambda)}
ratvec_as_vec(left(lambda)+w*right(lambda))

set nu_C(Param p)=
let nu=nu(p) then
x=x(p) then
w=left_w(x) in
{inverse(w)*left(nu)-right(nu)}
left(nu)-w*right(nu)

set gamma_L(Param p)=(mu(p)+nu_C(p))/2
set gamma_R(Param p)=(mu(p)-nu_C(p))/2



{


set complex_LKT(Param p)=let v=(1+involution(p))*lambda(p) in ratvec_as_vec(left(v))


set complex_normalize(Param p)=
let G=real_form(p) then
delta=distinguished_involution(G) then
x=x(p) then
theta=involution(x) then
(,u)=twisted_involution (G,theta) then
w=right(u) then
y=W_cross(w,twist(x)) in 
parameter(y, act(G,w,lambda(p)), act(G,w,nu(p))) 
}