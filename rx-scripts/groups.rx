<basic.rx

set show (string s) = if s="" then "empty" else s fi

set print_Cartan_info (CartanClass cc)=
let ((cr,Cr,sr),ww,(orbit_size,fiber_size),(i_tp,r_tp,C_tp))=Cartan_info(cc) in
begin
  prints("compact: ",cr,", complex: ",Cr,", split: ",sr)
; (let str="canonical twisted involution: " in
     if #ww=0 then str #:= "e"
     else str +:= ww[0]+1; for i : #ww-1 from 1 do str #:= ","+(ww[i]+1) od
     fi
   ; prints(str)
  )
; prints("twisted involution orbit size: ",orbit_size,
         "; fiber size: ",fiber_size,"; strong inv: ",orbit_size*fiber_size)
; prints("imaginary root system: ",show(str(i_tp)))
; prints("real root system: ",show(str(r_tp)))
; prints("complex factor: ",show(str(C_tp)))
end

{ Cartan matrix information for positions at distance d(<=2) off diagonal }
set Cartan_dispatch(int type, int r, int min, int d, bool lower)=
if d=0 then 2    { diagonal entry }
elif type=4 then { Dn }
 if if min<r-3 then d=1 else min=r-3 fi then -1 else 0 fi
elif type=5 then { En }
 if d=if min<2 then 2 else 1 fi then -1 else 0 fi
elif d=2 then 0  { nodes far apart in liear diagrams }
elif type<4 then { classical linear diagrams }
 if type = if lower then 2 else 3 fi and min=r-2 then -2 else -1 fi
elif type=6 then if lower and min=1 then -2 else -1 fi { F4 }
elif lower then -1 else -3 { G2 }
fi

set Cartan_entry(int type, int r,int i, int j)=
if type=0 then 0 { null Cartan entries for torus factors }
else let (min,d) = if i<j then (i,j-i) else (j,i-j) fi
     in  if d>2 then 0 else Cartan_dispatch(type,r,min,d,i<j) fi
fi

set Cartan_matrix(int type, int r)= mat:
for j:r do for i:r do Cartan_entry(type,r,i,j) od od

set Lie_type((int,int) p) =
  let (type,) = Cartan_matrix_type(Cartan_matrix(p)) in type

set block_repeat(mat m, int n) =
let (r,c)=#m then result = null(n*r,n*c)
in for k:n do for i:r do for j:c do
      result[k*r+i,k*c+j]:=m[i,j]
   od od od; result

set complex(RootDatum rd) = { complex group for |rd| viewed as real form }
let r=rank(rd)
then C_inv=null(2*r,2*r)
, rd_C = root_datum(block_repeat(simple_roots(rd),2)
                   ,block_repeat(simple_coroots(rd),2)
                   ,2*r)
in (for i:r do C_inv[i,i+r]:=1; C_inv[i+r,i]:=1 od
   ; quasisplit_form(inner_class(rd_C,C_inv)))


set GL_roots (int n) = [vec]:
for i : n-1
do for j : n
   do if j=i then 1 elif j=i+1 then -1 else 0 fi od
od

set SL_coroots (int n) = [vec]:
for i : n-1
do for j : n-1
   do if j=i then 1 elif j=i+1 then -1 else 0 fi od
od

set SL_roots (int n) = [vec]:
for col@j in SL_coroots(n)
do if j<n-2 then col
   else for e in col do e+1 od
   fi
od

set GL_datum(int n)= let r=GL_roots(n) in root_datum(r,r,n)
set SL_datum(int n)= root_datum(SL_roots(n),SL_coroots(n),n-1)

set type_B_roots (int n) = [vec]:
for i : n
do if i<n-1
   then for j : n
        do if j=i then 1 elif j=i+1 then -1 else 0 fi od
   else for j : n do if j<n-1 then 0 else 1 fi od
   fi
od

set type_C_roots (int n) = [vec]:
for i : n
do if i<n-1
   then for j : n
        do if j=i then 1 elif j=i+1 then -1 else 0 fi od
   else for j : n do if j<n-1 then 0 else 2 fi od
   fi
od

set type_D_roots (int n) = [vec]:
if n<2 then [] { SO(2) is pure torus }
else
  for i : n
  do if i<n-1
     then for j : n
          do if j=i then 1 elif j=i+1 then -1 else 0 fi od
     else for j : n do if j<n-2 then 0 else 1 fi od
     fi
  od
fi

set SO_datum(int n)=
let m=n\2 in
if n%2=1
then root_datum(type_B_roots(m),type_C_roots(m),m)
else let r=type_D_roots(m) in root_datum(r,r,m)
fi

set Sp_datum(int n)=
let (m,r)=n\%2 in
( if r=1 then error("Odd symplectic datum") fi
; root_datum(type_C_roots(m),type_B_roots(m),m)
)

set su(int p,int q)=
let n=p+q
then rd = SL(n)
then ic = inner_class(rd,if n>1 then "c" else "" fi)
in real_form(ic,min(p,q))

set su(int n) = su(n,0)

set sl_R(int n) = quasisplit_form(inner_class(SL(n),if n>1 then "s" else "" fi))
set sl_C(int n) = complex(SL(n))
set sl_H(int n) = real_form(inner_class(SL(2*n),"s"),0)

set gl_R(int n) =
  quasisplit_form(inner_class(GL(n),if n>1 then "ss" else "s" fi))
set gl_C(int n) = complex(GL(n))
set gl_H(int n) = RealForm: error("gl(n,H) is not yet implemented")

set so(int p,int q)=
let n=p+q, (p,q) = if p<q then (q,p) else (p,q) fi { make q the smallest one }
then rd = SO_datum(n)
, inv = let M=id_mat(n\2)
        in (if p%2=1 and q%2=1 then M[n\2-1,n\2-1]:=-1 fi; M)
, i = if n<=2 then 0        { inner classes without noncompact form, SO(2)=T1 }
      elif n%2=1 then q     { type B_{n\2} }
      elif q%2=1 then q\2   { type D_{n\2}, unequal rank }
      elif q\2<n\4 then q\2 { type D_{n\2}, equal rank, more compact forms }
      elif n%4=2 then q\2+1 { type D_{n\2}odd, equal rank, more split forms }
      else q\2+2            { type D_{n\2}even, equal rank, more split forms }
      fi
in real_form(inner_class(rd,inv),i)

set so(int n) = so(n,0)

set sp(int p,int q)=
real_form(inner_class(Sp_datum(2*(p+q)),"e"),min(p,q))

set sp(int p) = sp(p,0)

set sp_R(int n)=
let (q,r)= n\%2 in
( if r=1 then error("Odd symplectic group") fi
; real_form(inner_class(Sp_datum(n),"e"),q\2+1)
)

set sp_C(int n) = complex(Sp_datum(n)) { |Sp_datum| will test |n| even }
set sp_H(int n) = RealForm: error("sp(n,H) is not yet implemented")

{ to allow alternate syntax: for instance sp(4,R) instead of sp_R(4) }
set (R,C,H)=("R","C","H")

set by_field((int->RealForm) f_R,(int->RealForm) f_C,(int->RealForm) f_H) =
(string K): if K=R then f_R elif K=C then f_C elif K=H then f_H
                   else error("unknown field "+K)
                   fi
set sl(int n, string K) = by_field (sl_R@int,sl_C@int,sl_H@int) (K)(n)
set gl(int n, string K) = by_field (gl_R@int,gl_C@int,gl_H@int) (K)(n)
set sp(int n, string K) = by_field (sp_R@int,sp_C@int,sp_H@int) (K)(n)

set E6_ic_e = inner_class (simply_connected ("E6"),"e")

set E6_c = real_form(E6_ic_e,0)
set E6_h = real_form(E6_ic_e,1)
set E6_D5T = real_form(E6_ic_e,1)
set E6_q = real_form(E6_ic_e,2)

set E6_ic_s = inner_class (simply_connected ("E6"),"s")

set E6_F4 = real_form(E6_ic_s,0)
set E6_s = real_form(E6_ic_s,1)
set E6_C4 = real_form(E6_ic_s,1)

set E7_ic_e = inner_class (simply_connected ("E7"),"e")

set E7_ic = inner_class (simply_connected ("E7"),"e")
set E7_c = real_form(E7_ic_e,0)
set E7_h = real_form(E7_ic_e,1)
set E7_E6T = real_form(E7_ic_e,1)
set E7_q = real_form(E7_ic_e,2)
set E7_D6A1 = real_form(E7_ic_e,2)
set E7_D6A1 = real_form(E7_ic_e,3)
set E7_s = real_form(E7_ic_e,3)
set E7_A7 = real_form(E7_ic_e,3)

set E8_ic = let ic=inner_class("T0",[],""), first=true in ():
  if first then ic:=inner_class(simply_connected("E8"),"e") next first:=false
  else ic
  fi

set E8_c() = real_form(E8_ic(),0)
set E8_q() = real_form(E8_ic(),1)
set E8_s() = real_form(E8_ic(),2)
