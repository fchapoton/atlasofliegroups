{thetastable.rx}
<induction.rx
<finite_dimensional.rx {for is_finite_dimensional}

{routines for constructing theta-stable Levis and parabolics}

{
returns the list of roots of the nilpotent algebra u(x,v) 
a root is in u(x,v) iff <(1+theta_x)v,alpha^\vee>>0
this set is automatically theta_x-stable
v should be weakly dominant, and all complex roots should be C+ for x
if so, then u(x,v) is guaranteed to be contained in n (the standard positive roots)
otherwise it might still be ok, so return a warning but don't fail
}  
set u(KGBElt x, ratvec v)=[vec]:
let G=real_form(x) in let theta=involution(x) in let w=(1+theta)*v then
()=if not no_Cminus_roots(x) then prints("warning: some roots are of type C-") fi then
()=if not is_dominant(G,w) then   prints("warning: argument is not weakly dominant") fi in
let u_roots=[] in
for i:nr_of_posroots(G)  do
 let alpha_check=poscoroots(G)[i] then
 alpha=posroots(G)[i] then
 c=w*alpha_check in 
 if c!=0 then u_roots#:=sign(c)*alpha fi od;\
 if not all_positive_roots(G,u_roots) then prints("warning: u is not contained in n") fi; u_roots

set u(KGBElt x)=[vec]:
let rv=[vec]:[] in
for alpha in posroots(real_form(x)) do if not is_real(alpha,x) then rv#:=alpha fi od;rv
{-----------}
set dim_u_cap_k(KGBElt x, ratvec H)=
let u=u(x,H) then
(number_compact,number_complex)=(0,0) then
()=for v in u do if is_compact(v,x) then number_compact+:=1 
elif is_complex(v,x) then number_complex+:=1 fi od  in rat:number_compact+number_complex/2

set dim_u_cap_k(KGBElt x)=
let u=u(x) then
(number_compact,number_complex)=(0,0) then
()=for v in u do if is_compact(v,x) then number_compact+:=1 
elif is_complex(v,x) then number_complex+:=1 fi od  in rat:number_compact+number_complex/2

set dim_u_cap_p(KGBElt x, ratvec H)=
let u=u(x,H) then
(number_noncompact,number_complex)=(0,0) then
()=for v in u do if is_noncompact(x)(v) then number_noncompact+:=1 
elif is_complex(v,x) then number_complex+:=1 fi od  in rat:number_noncompact+number_complex/2

set dim_u_cap_p(KGBElt x)=
let u=u(x) then
(number_noncompact,number_complex)=(0,0) then
()=for v in u do if is_noncompact(x)(v) then number_noncompact+:=1 
elif is_complex(v,x) then number_complex+:=1 fi od  in rat:number_noncompact+number_complex/2
{-----------}
set dim_u_cap_k_2(KGBElt x, ratvec H)=
let u=u(x,H) then
(number_compact,number_complex)=(0,0) then
()=for v in u do if v*H=2 then if 
  is_compact(v,x) then number_compact+:=1 
  elif is_complex(v,x) then number_complex+:=1 fi fi od  in rat:number_compact+number_complex/2

{-----------}
set dim_u_cap_k_ge2(KGBElt x, ratvec H)=
let u=u(x,H) then
(number_compact,number_complex)=(0,0) then
()=for v in u do if v*H>=2 then if 
  is_compact(v,x) then number_compact+:=1 
  elif is_complex(v,x) then number_complex+:=1 fi fi od  in rat:number_compact+number_complex/2

set dim_u_cap_p_ge2(KGBElt x, ratvec H)=
let u=u(x,H) then
(number_noncompact,number_complex)=(0,0) then
()=for v in u do  if v*H>=2 then  if is_noncompact(x)(v) then number_noncompact+:=1 
elif is_complex(v,x) then number_complex+:=1 fi fi od  in rat:number_noncompact+number_complex/2

{-----------}
set dim_u_cap_k_1(KGBElt x, ratvec H)=
let u=u(x,H) then
(number_compact,number_complex)=(0,0) then
()=for v in u do if v*H=1 then if 
  is_compact(v,x) then number_compact+:=1 
  elif is_complex(v,x) then number_complex+:=1 fi fi od  in rat:number_compact+number_complex/2


set dim_u_cap_p_1(KGBElt x, ratvec H)=
let u=u(x,H) then
(number_noncompact,number_complex)=(0,0) then
()=for v in u do  if v*H=1 then  if is_noncompact(x)(v) then number_noncompact+:=1 
elif is_complex(v,x) then number_complex+:=1 fi fi od  in rat:number_noncompact+number_complex/2

set dim_u(KGBElt x,ratvec H)=#u(x,H)

{similar to u(x,v), except now it returns the RealForm L(x,v)}
set L(KGBElt x, ratvec v)=RealForm:
let G=real_form(x) in let theta=involution(x) in let w=(1+theta)*v  then
()=if not no_Cminus_roots(x) then prints("warning: some roots are of type C-") fi then
()=if not is_dominant(G,w) then   prints("warning: argument is not weakly dominant") fi in
let (l_roots,l_coroots)=([vec]:[],[vec]:[]) in
let ()=for i:nr_of_posroots(G)  do
 let alpha_check=poscoroots(G)[i] then
 alpha=posroots(G)[i] then
{ c=w*alpha_check in }
 c=w*alpha in 
 if c=0 then l_roots#:=alpha;l_coroots#:=alpha_check fi od then
 simple_roots_and_coroots=
 if #l_roots=0 then simple_from_positive(null(rank(G),0),null(rank(G),0)) 
  else simple_from_positive(l_roots,l_coroots) fi then
 rd=root_datum(simple_roots_and_coroots) then
 ic=inner_class(rd,theta) in
 real_form(ic,theta,torus_factor(x)) 


{return both RealForm: L(x,v) and [vec]: u(x,v)}
set theta_stable_q(KGBElt x,ratvec v)=(KGBElt,RealForm,[vec]):(x,L(x,v),u(x,v))
set theta_stable_q(KGBElt x)=(KGBElt,RealForm,[vec]):(x,L(x),u(x))


set rho_u(KGBElt x, ratvec v)=let roots=u(x,v) in if #roots=0 then null(rank(real_form(x))) else ratvec:sum(roots)/2 fi
set rho_L(KGBElt x, ratvec v)=ratvec:rho(L(x,v))

{---------------------------some representations------------------------------------}

{Note: theta_induce_irreducible(pi_L,G) has infinitesimal character 
infinitesimal character(pi_L)+rho(u)}

{
Aq(x,lambda,lambda_q) defined as follows
if lambda_q is weakly dominant set q=q(x,\lambda_q)
apply derived functor to one dimensional lambda-rho(u) of L
(lambda+rho(L))-rho(u)+rho(u)=lambda+rho_L
REQUIRE: lamda-rho(L)\in X^*
Aq(x,lambda,lambda_q) has infinitesimal character lambda+rho_L,
thus lambdma has infinitesimal character lambda+rho_L for L, goes to a
infinitesimal character lambda+rho_L for G; i.e.
Aq takes infinitesimal character gamma_L to SAME infinitesimal character for G
for example, equal rank, x on compact Cartan Aq(x,rho(G),rho(G))
is a discrete series with infinitesimal character rho(G)
if lambda_q isn't weakly dominant define Aq(x,lambda,lambda_q)=Aq(wx,w\lambda,w\lambda_q)
where w\lambda_q is weakly dominant
}

{first defined Aq as a ParamPol, in case it isn't irreducible}
set Aq_param_pol(KGBElt x_in,ratvec lambda_in, ratvec lambda_q)=ParamPol:
let G=real_form(x_in) then
{find w making lambda_q (or lambda_in?) weakly dominant}
{(lambda_in_new,w)=make_dominant(G,lambda_in) then}
(lambda_q_new,w)=make_dominant(G,lambda_q) then
x_new=W_cross(inverse(w),x_in) then
{lambda_q_new=act(w,lambda_q) then}
lambda_in_new=act(inverse(w),lambda_in) then
(x_new,L,u)=theta_stable_q(x_new,lambda_q_new) then
t_L=trivial(L) then
{pi_L=parameter(x(t_L),lambda(t_L)+lambda_in_new-rho_u(x_new,lambda_q_new),nu(t_L)) in }{this was apparently wrong}
pi_L=parameter(x(t_L),lambda(t_L)+lambda_in_new-rho_u(x_new,lambda_q_new),nu(t_L)+lambda_in_new-rho_u(x_new,lambda_q_new)) in
let ()=prints("in Aq, p_L=", pi_L) in 
theta_induce_irreducible(pi_L,G) 

set Aq(KGBElt x_in,ratvec lambda_in, ratvec lambda_q)=Param:
let P=Aq_param_pol(x_in,lambda_in,lambda_q) then
P=%P in 
if #P>1 then error("Aq is not irreducible. Use Aq_param_pol(x,lambda) instead")  else
let (c,p)=P[0] in 
 if c!=1 then error("Aq has multiplicity. Use Aq_param_pol(x,lambda) instead") 
else p fi fi

{if not provided, assume lambda_q=lambda}
set Aq(KGBElt x,ratvec lambda_in)=Param:Aq(x,lambda_in,lambda_in)

{specify G, and not x, to use x=KGB(G,0)}

set Aq(RealForm G,ratvec lambda_in, ratvec lambda_q)=Param:Aq(KGB(G)[0],lambda_in,lambda_q)
set Aq(RealForm G,ratvec lambda_in)=Param:Aq(G,lambda_in,lambda_in)

{  ----------------------   inverse theta-stable induction   ------------------------------------------}

set inverse_theta_induce_standard(Param p, RealForm L)=
let x_G=x(p) then
x_L=inverse_embed_KGB(x_G,L) in
parameter(x_L,lambda(p)-rho(real_form(p))+rho_r(x_G)+rho(L)-rho_r(x_L),nu(p))

set is_lambda_dominant(Param p)=bool:let rd=root_datum(p) then lam=lambda(p) in
prints("lambda+theta(lambda)=",lam+involution(x(p))*lam); is_dominant(rd,lam+involution(x(p))*lam)

set make_lambda_dominant(Param p)= let rd=root_datum(p) in
let lam_a=lambda(p)+involution(x(p))*lambda(p) in
let (lam_new,w)=make_dominant(rd,lam_a) in
let W=w_matrix(w) in let W_inv=w_matrix(inverse(w)) in 
let x=KGB_elt(real_form(p),W*involution(x(p))*W_inv,act((w),torus_factor(x(p))))
in (w,x,act((w),lambda(p)),act((w),nu(p)),L(x,lam_new)) 

set theta_stable_data(Param p)=
if is_lambda_dominant(p) then
let p_L=inverse_theta_induce_standard(p,L(x(p),lambda(p))) 
in (real_form(p_L),p_L)
else
let (w,x,lam,nu,L)=make_lambda_dominant(p) in let x_L=inverse_embed_KGB(x,L) in
let p_L=parameter(x_L,lam-rho(real_form(p))+rho_r(x)+rho(L)-rho_r(x_L),nu)
in (L,p_L) 
fi



{----------------------Good/Fair conditions------------------}

{Good/Fair
condition on roots of u
theta_induce(pi_L,G)
gamma_L -> gamma_G=gamma_L+rho_u
good: <gamma_L+rho_u,alpha^vee> > 0
weakly good: <gamma_L+rho_u,alpha^vee> \ge 0
fair: <gamma_L-rho_L+rho_u,alpha^vee> > 0

Aq(x,lambda,lambda_q):
gamma_L=lambda+rho_L
gamma_L -> gamma_G=gamma_L = lambda+rho_L
Aq(x,lambda)=theta_induce(x,lambda-rho_u)
good: <lambda+rho_L,alpha^vee> > 0
fair: <lambda,alpha^vee> > 0
weakly fair: <lambda,alpha^vee> \ge 0

theta_induce(pi_L,G) = Euler-Poincare characteristic of cohomological induction functor
fair => vanishing outside middle degree => honest representation 
weakly fair: same implication
NB: <gamma_L-rho_L_rho_U,alpha^vee> >= 0 does NOT imply vanishing (in general) if pi_L is not one dimensional
hence "weakly fair" is only defined if pi_L is one dimensional
}

set is_good(Param p_L,RealForm G)=bool:
let L=real_form(p_L) then
rho_u=rho(G)-rho(L) in
is_strictly_dominant(G,infinitesimal_character(p_L)+rho_u)

set is_weakly_good(Param p_L,RealForm G)=bool:
let L=real_form(p_L) then
rho_u=rho(G)-rho(L) in
is_dominant(G,infinitesimal_character(p_L)+rho_u)

set is_fair(Param p_L,RealForm G)=bool:
let L=real_form(p_L) then
rho_u=rho(G)-rho(L) in
is_strictly_dominant(G,infinitesimal_character(p_L)+rho_u-rho(L))

{weakly fair only defined if pi_L is finite dimensional}
set is_weakly_fair(Param p_L,RealForm G)=bool:
let L=real_form(p_L) then
rho_u=rho(G)-rho(L) in
is_finite_dimensional(p_L) and dimension(p_L)=1 and is_dominant(G,infinitesimal_character(p_L)+rho_u-rho(L))

set is_good(KGBElt x,ratvec lambda_in,ratvec lambda_q)=bool:
let L=L(x,lambda_q) in 
is_strictly_dominant(real_form(x),lambda_in+rho(L))

set is_weakly_good(KGBElt x,ratvec lambda_in,ratvec lambda_q)=bool:
let L=L(x,lambda_q) in 
is_dominant(real_form(x),lambda_in+rho(L))

set is_fair(KGBElt x,ratvec lambda_in,ratvec lambda_q)=bool:
is_strictly_dominant(real_form(x),lambda_in)

set is_weakly_fair(KGBElt x,ratvec lambda_in,ratvec lambda_q)=bool:
is_dominant(real_form(x),lambda_in)

set goodness(Param p_L,RealForm G)=void:
if is_good(p_L,G) then prints("Good") 
elif is_weakly_good(p_L,G) then prints("Weakly good") 
elif is_fair(p_L,G) then prints("Fair") 
elif is_weakly_fair(p_L,G) then prints("Weakly fair")  else
prints("None") fi

set goodness(KGBElt x,ratvec lambda_in,ratvec lambda_q)=void:
if is_good(x,lambda_in,lambda_q) then prints("Good") 
elif is_weakly_good(x,lambda_in,lambda_q) then prints("Weakly good") 
elif is_fair(x,lambda_in,lambda_q) then prints("Fair") 
elif is_weakly_fair(x,lambda_in,lambda_q) then prints("Weakly fair")  else
prints("None") fi





