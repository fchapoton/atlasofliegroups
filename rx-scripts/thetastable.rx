<induction.rx
<finite_dimensional.rx {for is_finite_dimensional}

{basic functions are in parabolics.rx
 these are some additional functions related to theta-stable parabolics

from parabolics.rx:
Parabolic:([int] P,KGBElt x)
theta_stable_parabolic(KGBElt x) returns a theta-stable parabolic provided all complex roots of x are type C-
parabolic(ratvec lambda,KGBElt x)= returns a theta-stable parabolic if \theta_x(lambda)=lambda
and all x-complex roots are type C-
}

{
P=LU, return roots in U
a root is in U iff it is positive and not in L
these are the positive roots in G which are positive on (1+^theta_x)*rho_check(G)
}  
set u(Parabolic P)=[vec]:
let (S,x)=P then
u_roots=assert(is_parabolic_theta_stable(P),"parabolic is not theta-stable");[vec]:[] then
gamma_vee=(1+^involution(x))*rho_check(root_datum(x)) in
for alpha in posroots(root_datum(x)) do if alpha*gamma_vee>0 then u_roots#:=alpha fi od;u_roots

set u(KGBElt x)=[vec]:u(theta_stable_parabolic(x))

set rho_u_cx(Parabolic P)=ratvec:
assert(is_parabolic_theta_stable(P),"P is not theta-stable");
let rv=ratvec:null(rank(root_datum(P))) then
x=x(P) in
for alpha in u(P) do if is_complex(alpha,x) then rv+:=alpha fi od;rv/2

set dim_u_cap_k(Parabolic P)=int:
let u=u(P) then
(S,x)=P then
(number_compact,number_complex)=(0,0) then
()=for v in u do if is_compact(v,x) then number_compact+:=1 
elif is_complex(v,x) then number_complex+:=1 fi od  in rat_as_int(number_compact+number_complex/2)

set dim_u_cap_k(KGBElt x)=int:dim_u_cap_k(theta_stable_parabolic(x))

set dim_u_cap_p(Parabolic P)=int:
let u=u(P) then
(S,x)=P then
(number_noncompact,number_complex)=(0,0) then
()=for v in u do if is_noncompact(x)(v) then number_noncompact+:=1 
elif is_complex(v,x) then number_complex+:=1 fi od  in rat_as_int(number_noncompact+number_complex/2)

set dim_u_cap_p(KGBElt x)=int:dim_u_cap_p(theta_stable_parabolic(x))
set dim_u_cap_p(ratvec lambda,KGBElt x)=int:dim_u_cap_p(parabolic(lambda,x))

set dim_u_cap_k_2(Parabolic P,ratvec H)=int:
let u=u(P) then
(S,x)=P then
(number_compact,number_complex)=(0,0) then
()=for v in u do if v*H=2 then if 
  is_compact(v,x) then number_compact+:=1 
  elif is_complex(v,x) then number_complex+:=1 fi fi od  in rat_as_int(number_compact+number_complex/2)

set dim_u_cap_k_ge2(Parabolic P,ratvec H)=int:
let u=u(P) then
(S,x)=P then
(number_compact,number_complex)=(0,0) then
()=for v in u do if v*H>=2 then if 
  is_compact(v,x) then number_compact+:=1 
  elif is_complex(v,x) then number_complex+:=1 fi fi od  in rat_as_int(number_compact+number_complex/2)

set dim_u_cap_p_ge2(Parabolic P,ratvec H)=int:
let u=u(P) then
(S,x)=P then
(number_noncompact,number_complex)=(0,0) then
()=for v in u do  if v*H>=2 then  if is_noncompact(x)(v) then number_noncompact+:=1 
elif is_complex(v,x) then number_complex+:=1 fi fi od  in rat_as_int(number_noncompact+number_complex/2)

set dim_u_cap_k_1(Parabolic P,ratvec H)=
let u=u(P) then
(S,x)=P then
(number_compact,number_complex)=(0,0) then
()=for v in u do if v*H=1 then if 
  is_compact(v,x) then number_compact+:=1 
  elif is_complex(v,x) then number_complex+:=1 fi fi od  in rat:number_compact+number_complex/2

set dim_u_cap_p_1(Parabolic P, ratvec H)=
let u=u(P) then
(S,x)=P then
(number_noncompact,number_complex)=(0,0) then
()=for v in u do  if v*H=1 then  if is_noncompact(x)(v) then number_noncompact+:=1 
elif is_complex(v,x) then number_complex+:=1 fi fi od  in rat_as_int(number_noncompact+number_complex/2)

set dim_u(ratvec H,KGBElt x)=#u(H,x)

{---------------------------some representations------------------------------------}

{Note: theta_induce_irreducible(pi_L,G) has infinitesimal character 
infinitesimal character(pi_L)+rho(u)}

{
Aq(x,lambda,lambda_q) defined as follows
if lambda_q is weakly dominant set q=q(x,\lambda_q)
apply derived functor to one dimensional lambda-rho(u) of L
(lambda+rho(L))-rho(u)+rho(u)=lambda+rho_L
REQUIRE: lamda-rho(L)\in X^*
Aq(x,lambda,lambda_q) has infinitesimal character lambda+rho_L,
thus lambdma has infinitesimal character lambda+rho_L for L, goes to a
infinitesimal character lambda+rho_L for G; i.e.
Aq takes infinitesimal character gamma_L to SAME infinitesimal character for G
for example, equal rank, x on compact Cartan Aq(x,rho(G),rho(G))
is a discrete series with infinitesimal character rho(G)
if lambda_q isn't weakly dominant define Aq(x,lambda,lambda_q)=Aq(wx,w\lambda,w\lambda_q)
where w\lambda_q is weakly dominant
}

{first defined Aq as a ParamPol, in case it isn't irreducible}
set Aq_param_pol(KGBElt x_in,ratvec lambda_in, ratvec lambda_q)=ParamPol:
let G=real_form(x_in) then
{find w making lambda_q (or lambda_in?) weakly dominant}
{(lambda_in_new,w)=make_dominant(G,lambda_in) then}
(lambda_q_new,w)=make_dominant(G,lambda_q) then
x_new=cross(inverse(w),x_in) then
{lambda_q_new=act(w,lambda_q) then}
lambda_in_new=act(inverse(w),lambda_in) then
P=parabolic(lambda_q_new,x_new) then
L=Levi(P) then
t_L=trivial(L) then
{pi_L=parameter(x(t_L),lambda(t_L)+lambda_in_new-rho_u(lambda_q_new,x_new),nu(t_L)) in }{this was apparently wrong}
pi_L=parameter(x(t_L),lambda(t_L)+lambda_in_new-rho_u(lambda_q_new,x_new),nu(t_L)+lambda_in_new-rho_u(lambda_q_new,x_new)) in
let ()=prints("in Aq, p_L=", pi_L) in 
theta_induce_irreducible(pi_L,G) 

set Aq(KGBElt x_in,ratvec lambda_in, ratvec lambda_q)=Param:
let P=Aq_param_pol(x_in,lambda_in,lambda_q) then
P=%P in 
if #P>1 then error("Aq is not irreducible. Use Aq_param_pol(x,lambda) instead")  else
let (c,p)=P[0] in 
 if c!=1 then error("Aq has multiplicity. Use Aq_param_pol(x,lambda) instead") 
else p fi fi

{if not provided, assume lambda_q=lambda}
set Aq(KGBElt x,ratvec lambda_in)=Param:Aq(x,lambda_in,lambda_in)

{specify G, and not x, to use x=KGB(G,0)}

set Aq(RealForm G,ratvec lambda_in, ratvec lambda_q)=Param:Aq(KGB(G)[0],lambda_in,lambda_q)
set Aq(RealForm G,ratvec lambda_in)=Param:Aq(G,lambda_in,lambda_in)




{----------------------Good/Fair conditions------------------}

{Good/Fair
condition on roots of u
theta_induce(pi_L,G)
gamma_L -> gamma_G=gamma_L+rho_u
good: <gamma_L+rho_u,alpha^vee> > 0
weakly good: <gamma_L+rho_u,alpha^vee> \ge 0
fair: <gamma_L-rho_L+rho_u,alpha^vee> > 0

Aq(x,lambda,lambda_q):
gamma_L=lambda+rho_L
gamma_L -> gamma_G=gamma_L = lambda+rho_L
Aq(x,lambda)=theta_induce(x,lambda-rho_u)
good: <lambda+rho_L,alpha^vee> > 0
fair: <lambda,alpha^vee> > 0
weakly fair: <lambda,alpha^vee> \ge 0

theta_induce(pi_L,G) = Euler-Poincare characteristic of cohomological induction functor
fair => vanishing outside middle degree => honest representation 
weakly fair: same implication
NB: <gamma_L-rho_L_rho_U,alpha^vee> >= 0 does NOT imply vanishing (in general) if pi_L is not one dimensional
hence "weakly fair" is only defined if pi_L is one dimensional
}

set is_good(Param p_L,RealForm G)=bool:
let L=real_form(p_L) then
rho_u=rho(G)-rho(L) in
is_strictly_dominant(G,infinitesimal_character(p_L)+rho_u)

set is_weakly_good(Param p_L,RealForm G)=bool:
let L=real_form(p_L) then
rho_u=rho(G)-rho(L) in
is_dominant(G,infinitesimal_character(p_L)+rho_u)

set is_fair(Param p_L,RealForm G)=bool:
let L=real_form(p_L) then
rho_u=rho(G)-rho(L) in
is_strictly_dominant(G,infinitesimal_character(p_L)+rho_u-rho(L))

{weakly fair only defined if pi_L is finite dimensional}
set is_weakly_fair(Param p_L,RealForm G)=bool:
let L=real_form(p_L) then
rho_u=rho(G)-rho(L) in
is_finite_dimensional(p_L) and dimension(p_L)=1 and is_dominant(G,infinitesimal_character(p_L)+rho_u-rho(L))

set is_good(KGBElt x,ratvec lambda_in,ratvec lambda_q)=bool:
let L=Levi(lambda_q,x) in 
is_strictly_dominant(real_form(x),lambda_in+rho(L))

set is_weakly_good(KGBElt x,ratvec lambda_in,ratvec lambda_q)=bool:
let L=Levi(lambda_q,x) in is_dominant(root_datum(x),lambda_in+rho(L))

set is_fair(KGBElt x,ratvec lambda_in,ratvec lambda_q)=bool:
is_strictly_dominant(real_form(x),lambda_in)

set is_weakly_fair(KGBElt x,ratvec lambda_in,ratvec lambda_q)=bool:
is_dominant(real_form(x),lambda_in)

set goodness(Param p_L,RealForm G)=void:
if is_good(p_L,G) then prints("Good") 
elif is_weakly_good(p_L,G) then prints("Weakly good") 
elif is_fair(p_L,G) then prints("Fair") 
elif is_weakly_fair(p_L,G) then prints("Weakly fair")  else
prints("None") fi

set goodness(KGBElt x,ratvec lambda_in,ratvec lambda_q)=void:
if is_good(x,lambda_in,lambda_q) then prints("Good") 
elif is_weakly_good(x,lambda_in,lambda_q) then prints("Weakly good") 
elif is_fair(x,lambda_in,lambda_q) then prints("Fair") 
elif is_weakly_fair(x,lambda_in,lambda_q) then prints("Weakly fair")  else
prints("None") fi





