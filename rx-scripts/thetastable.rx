<induction.rx
<finite_dimensional.rx {for is_finite_dimensional}

{routines for constructing theta-stable Levis and parabolics}

{
returns the list of roots of the nilpotent algebra u(x,v) 
a root is in u(x,v) iff <(1+theta_x)v,alpha^\vee>>0
this set is automatically theta_x-stable
v should be weakly dominant, and all complex roots should be C+ for x
if so, then u(x,v) is guaranteed to be contained in n (the standard positive roots)
otherwise it might still be ok, so return a warning but don't fail
}  
set u(KGBElt x, ratvec v)=[vec]:
let G=real_form(x) then
()=if not no_Cminus_roots(x) then prints("warning: some roots are of type C-") fi then
()=if not is_dominant(G,v) then   prints("warning: argument is not weakly dominant") fi in
let theta=involution(x) then
w=(1+theta)*v then
u_roots=[] in
for i:nr_of_posroots(G)  do
 let alpha_check=poscoroots(G)[i] then
 alpha=posroots(G)[i] then
 c=w*alpha_check in 
 if c!=0 then u_roots#:=sign(c)*alpha fi od;\
 if not all_positive_roots(G,u_roots) then prints("warning: u is not contained in n") fi; u_roots

{similar to u(x,v), except now it returns the RealForm L(x,v)}
set L(KGBElt x, ratvec v)=RealForm:
let G=real_form(x) then
()=if not no_Cminus_roots(x) then prints("warning: some roots are of type C-") fi then
()=if not is_dominant(G,v) then   prints("warning: argument is not weakly dominant") fi in
let theta=involution(x) then
w=(1+theta)*v in
let (l_roots,l_coroots)=([vec]:[],[vec]:[]) in
let ()=for i:nr_of_posroots(G)  do
 let alpha_check=poscoroots(G)[i] then
 alpha=posroots(G)[i] then
 c=w*alpha_check in 
 if c=0 then l_roots#:=alpha;l_coroots#:=alpha_check fi od then
 simple_roots_and_coroots=
 if #l_roots=0 then simple_from_positive(null(rank(G),0),null(rank(G),0)) 
  else simple_from_positive(l_roots,l_coroots) fi then
 rd=root_datum(simple_roots_and_coroots) then
 ic=inner_class(rd,theta) in
 real_form(ic,theta,torus_factor(x)) 


{return both RealForm: L(x,v) and [vec]: u(x,v)}
set theta_stable_q(KGBElt x,ratvec v)=(RealForm,[vec]):(L(x,v),u(x,v))

set rho_u(KGBElt x, ratvec v)=let roots=u(x,v) in if #roots=0 then null(rank(real_form(x))) else ratvec:sum(roots)/2 fi
set rho_L(KGBElt x, ratvec v)=ratvec:rho(L(x,v))

{---------------------------some representations------------------------------------}

{Note: theta_induce_irreducible(pi_L,G) has infinitesimal character 
infinitesimal character(pi_L)+rho(u)}

{
Aq(x,lambda,lambda_q) defined as follows
if lambda_q is weakly dominant set q=q(x,\lambda_q)
apply derived functor to one dimensional lambda-rho(u) of L
(lambda+rho(L))-rho(u)+rho(u)=lambda+rho_L
REQUIRE: lamda-rho(L)\in X^*
Aq(x,lambda,lambda_q) has infinitesimal character lambda+rho_L,
thus lambdma has infinitesimal character lambda+rho_L for L, goes to a
infinitesimal character lambda+rho_L for G; i.e.
Aq takes infinitesimal character gamma_L to SAME infinitesimal character for G
for example, equal rank, x on compact Cartan Aq(x,rho(G),rho(G))
is a discrete series with infinitesimal character rho(G)
if lambda_q isn't weakly dominant define Aq(x,lambda,lambda_q)=Aq(wx,w\lambda,w\lambda_q)
where w\lambda_q is weakly dominant
}

{first defined Aq as a ParamPol, in case it isn't irreducible}
set Aq_param_pol(KGBElt x_in,ratvec lambda_in, ratvec lambda_q)=ParamPol:
let G=real_form(x_in) then
{find w making lambda_q (or lambda_in?) weakly dominant}
{(lambda_in_new,w)=make_dominant(G,lambda_in) then}
(lambda_q_new,w)=make_dominant(G,lambda_q) then
x_new=W_cross(inverse(w),x_in) then
{lambda_q_new=act(w,lambda_q) then}
lambda_in_new=act(inverse(w),lambda_in) then
(L,u)=theta_stable_q(x_new,lambda_q_new) then
t_L=trivial(L) then
pi_L=parameter(x(t_L),lambda(t_L)+lambda_in_new-rho_u(x_new,lambda_q_new),nu(t_L)) in 
let ()=prints("in Aq, p_L=", pi_L) in 
theta_induce_irreducible(pi_L,G) 

set Aq(KGBElt x_in,ratvec lambda_in, ratvec lambda_q)=Param:
let P=Aq_param_pol(x_in,lambda_in,lambda_q) then
P=%P in 
if #P>1 then error("Aq is not irreducible. Use Aq_param_pol(x,lambda) instead")  else
let (c,p)=P[0] in 
 if c!=1 then error("Aq has multiplicity. Use Aq_param_pol(x,lambda) instead") 
else p fi fi

{if not provided, assume lambda_q=lambda}
set Aq(KGBElt x,ratvec lambda_in)=Param:Aq(x,lambda_in,lambda_in)

{specify G, and not x, to use x=KGB(G,0)}

set Aq(RealForm G,ratvec lambda_in, ratvec lambda_q)=Param:Aq(KGB(G)[0],lambda_in,lambda_q)
set Aq(RealForm G,ratvec lambda_in)=Param:Aq(G,lambda_in,lambda_in)


{----------------------Good/Fair conditions------------------}

{Good/Fair
condition on roots of u
theta_induce(pi_L,G)
gamma_L -> gamma_G=gamma_L+rho_u
good: <gamma_L+rho_u,alpha^vee> > 0
weakly good: <gamma_L+rho_u,alpha^vee> \ge 0
fair: <gamma_L-rho_L+rho_u,alpha^vee> > 0

Aq(x,lambda,lambda_q):
gamma_L=lambda+rho_L
gamma_L -> gamma_G=gamma_L = lambda+rho_L
Aq(x,lambda)=theta_induce(x,lambda-rho_u)
good: <lambda+rho_L,alpha^vee> > 0
fair: <lambda,alpha^vee> > 0
weakly fair: <lambda,alpha^vee> \ge 0

theta_induce(pi_L,G) = Euler-Poincare characteristic of cohomological induction functor
fair => vanishing outside middle degree => honest representation 
weakly fair: same implication
NB: <gamma_L-rho_L_rho_U,alpha^vee> >= 0 does NOT imply vanishing (in general) if pi_L is not one dimensional
hence "weakly fair" is only defined if pi_L is finite dimensional
}

set is_good(Param p_L,RealForm G)=bool:
let L=real_form(p_L) then
rho_u=rho(G)-rho(L) in
is_strictly_dominant(G,infinitesimal_character(p_L)+rho_u)

set is_weakly_good(Param p_L,RealForm G)=bool:
let L=real_form(p_L) then
rho_u=rho(G)-rho(L) in
is_dominant(G,infinitesimal_character(p_L)+rho_u)

set is_fair(Param p_L,RealForm G)=bool:
let L=real_form(p_L) then
rho_u=rho(G)-rho(L) in
is_strictly_dominant(G,infinitesimal_character(p_L)+rho_u-rho(L))

{weakly fair only defined if pi_L is finite dimensional}
set is_weakly_fair(Param p_L,RealForm G)=bool:
let L=real_form(p_L) then
rho_u=rho(G)-rho(L) in
is_finite_dimensional(p_L) and is_dominant(G,infinitesimal_character(p_L)+rho_u-rho(L))

set is_good(KGBElt x,ratvec lambda_in,ratvec lambda_q)=bool:
let L=L(x,lambda_q) in 
is_strictly_dominant(real_form(x),lambda_in+rho(L))

set is_weakly_good(KGBElt x,ratvec lambda_in,ratvec lambda_q)=bool:
let L=L(x,lambda_q) in 
is_dominant(real_form(x),lambda_in+rho(L))

set is_fair(KGBElt x,ratvec lambda_in,ratvec lambda_q)=bool:
is_strictly_dominant(real_form(x),lambda_in)

set is_weakly_fair(KGBElt x,ratvec lambda_in,ratvec lambda_q)=bool:
is_dominant(real_form(x),lambda_in)

set goodness(Param p_L,RealForm G)=void:
if is_good(p_L,G) then prints("Good") 
elif is_weakly_good(p_L,G) then prints("Weakly good") 
elif is_fair(p_L,G) then prints("Fair") 
elif is_weakly_fair(p_L,G) then prints("Weakly fair")  else
prints("None") fi

set goodness(KGBElt x,ratvec lambda_in,ratvec lambda_q)=void:
if is_good(x,lambda_in,lambda_q) then prints("Good") 
elif is_weakly_good(x,lambda_in,lambda_q) then prints("Weakly good") 
elif is_fair(x,lambda_in,lambda_q) then prints("Fair") 
elif is_weakly_fair(x,lambda_in,lambda_q) then prints("Weakly fair")  else
prints("None") fi


