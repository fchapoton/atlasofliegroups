{block of trivial representation, extended block has 6 elements}

expr> set (B,)=block(trivial(G))
Identifier B (overriding previous): [Param]
expr> ext_print_block (delta,B)
0  1i1 1i1: final parameter (x=0,lambda=[1,1,0]/1,nu=[0,0,0]/1)
1  1i1 1i1: final parameter (x=1,lambda=[1,1,0]/1,nu=[0,0,0]/1)
2  1r1f 1i2f: final parameter (x=3,lambda=[1,1,0]/1,nu=[1,0,0]/2)
3  1i2f 1r1f: final parameter (x=2,lambda=[1,1,0]/1,nu=[1,2,0]/2)
4  1r2 1r2: final parameter (x=4,lambda=[1,1,0]/1,nu=[1,1,0]/1)
5  1r2 1r2: final parameter (x=4,lambda=[2,1,0]/1,nu=[1,1,0]/1)
expr> set gamma=infinitesimal_character (trivial(G))
Identifier gamma (overriding previous): ratvec
expr> set g=rho_check(G)
Identifier g (overriding previous): ratvec
expr> set v=get_central_shift(B[0])
Identifier v (overriding previous): ratvec
expr> v
Value: [ 0, 0, 0 ]/1
expr> set E=E(delta,B[0],g,v)
Identifier E (overriding previous): (InnerClass,mat,ratvec,[int],mat,ratvec,[int],mat,[int],[int],ratvec)
expr> set basis=generate_subspace(0,1,E)
Identifier basis (overriding previous): [(KGBElt,KGBElt)]
expr> #basis
Value: 6
expr> set M=hecke_matrix(0,delta,gamma,g,basis,v)
signs in 1i1_cross: 1, 1, 1
signs in 1i1_cross: 1, 1, 1
Identifier M (overriding previous): [[[int]]]
expr> set N=hecke_matrix(1,delta,gamma,g,basis,v)
signs in 1i1_cross: 1, 1, 1
signs in 1i1_cross: 1, 1, 1
Identifier N (overriding previous): [[[int]]]
expr> printPolyMatrix (M)
 0 +1 0 +1 0 0
 +1 0 0 +1 0 0
 0 0 +1 0 +1 +1
 -1+q -1+q 0 -2+q 0 0
 0 0 -1+q 0 -1+q -1
 0 0 -1+q 0 -1 -1+q
expr> printPolyMatrix (N)
 0 +1 +1 0 0 0
 +1 0 +1 0 0 0
 -1+q -1+q -2+q 0 0 0
 0 0 0 +1 +1 +1
 0 0 0 -1+q -1+q -1
 0 0 0 -1+q -1 -1+q
expr> quadratic(M,2
Value: false
expr> quadratic(M,1)
Value: true
expr> quadratic(N,1)
Value: true
expr> braid(M,N,2)
Value: true
expr> 

{new block at infinitesimal character (3,2,0),extended block has 4 elements}

expr> ext_print_block (delta,B_p)
0  1i1 1i1: final parameter (x=0,lambda=[2,1,1]/1,nu=[0,0,0]/1)
1  1i1 1i1: final parameter (x=1,lambda=[2,1,1]/1,nu=[0,0,0]/1)
2  1r1f 1i2s: final parameter (x=3,lambda=[1,1,1]/1,nu=[1,0,0]/1)
3  1i2s 1r1f: final parameter (x=2,lambda=[2,3,-1]/1,nu=[1,2,0]/2)
expr>{notice the two 1i2s entries}
expr> set gamma=infinitesimal_character (p)
Identifier gamma (overriding previous): ratvec
expr> gamma
Value: [ 3, 2, 0 ]/2
expr> set v=get_central_shift(Bp[0])
Identifier v (overriding previous): ratvec
expr> v
Value: [ 1, 0, 2 ]/2
expr> set E=E(delta,B_p[0],g,v)
Identifier E (overriding previous): (InnerClass,mat,ratvec,[int],mat,ratvec,[int],mat,[int],[int],ratvec)
expr> display(E)
 gamma=[ 3, 2, 0 ]/2
     g=[  2,  0, -1 ]/2

lambda=[1,0,1]
   tau=[0,0,-1]
     l=[0,0,0]
     t=[0,0,0]
expr> set basis=generate_subspace(0,1,E)
Identifier basis (overriding previous): [(KGBElt,KGBElt)]
expr> #basis
Value: 4
expr> set M=hecke_matrix(0,delta,gamma,g,basis,v)
signs in 1i1_cross: 1, -1, -1
sign_1i1_cross=-1 in computing Hecke operator of type 1i1
signs in 1i1_cross: 1, -1, -1
sign_1i1_Cayley=-1 in computing Hecke operator of type 1i1
sign_1i1_cross=-1 in computing Hecke operator of type 1i1
sign_1r1f_Cayley_1=-1 in computing Hecke operator of type 1r1f
Identifier M (overriding previous): [[[int]]]
expr> set N=hecke_matrix(1,delta,gamma,g,basis,v)
signs in 1i1_cross: 1, 1, 1
signs in 1i1_cross: 1, 1, 1
Identifier N (overriding previous): [[[int]]]
expr> printPolyMatrix (M)
 0 -1 0 +1
 -1 0 0 -1
 0 0 -1 0
 -1+q +1-q 0 -2+q
expr> printPolyMatrix (N)
 0 +1 +1 0
 +1 0 +1 0
 -1+q -1+q -2+q 0
 0 0 0 -1
expr> quadratic(M,1)
Value: true
expr> quadratic(N,1)
Value: true
expr> braid(M,N,2)
Value: true
expr> 
