set debug=false
<deform
<misc

{define w^k for w in Z[s], k an integer }
set ^(Split w,int k)=
if (k=0) then Split:1 else let u=w in for i:abs(k)-1 from 0 do u:=u*w od;u fi

{nicer display of Splits}
set prettyPrint (Split w)=
let (a,b)=%w in  
let rv="" in  
 if b=0 then int_format(a) else
 if a=0 then 
  if b=1 then "s" elif b=-1 then "-s" else int_format(b)#"s" fi
 else
  if b=1 then int_format(a)#"+s" 
   elif b=-1 then int_format(a)#"-s" 
   elif b<-1 then int_format(a)#int_format(b)#"s"  
   else int_format(a)#"+"#int_format(b)#"s"
  fi
 fi
fi

{nice output of ParamPol: prettyPrint the coefficients, print terms in order of x}
set prettyPrint (ParamPol P)=
let G=real_form(P) then
Q=%P in 
for x in KGB(G) do
 for (w,p) in Q do 
  let (y,,)=%p in 
  if (x=y) then prints("(",prettyPrint(w),")*",p,", ",infinitesimal_character(p)) fi
 od
od;""

{replace w=a+bs with a+bt for t rational or integer}
set  #(Split w,rat t)=let (a,b)=%w in rat:a+t*b
set  #(Split w,int t)=let (a,b)=%w in int:a+t*b
set  #(ParamPol P,int t)=
 let Q=null_module(real_form(P)) in
 let x=for (w,q) in %P do Q:=Q+(w#t)*q od in Q
set =(ParamPol P,ParamPol Q)=
 if (#(P+(-1)*Q)=0) then true else false fi

{set nu=0 in Param (x,lambda,nu)}
set zeronu (Param p)=param(x(p),lambdaminusrho(p),null(rank(real_form(p)))/1)
set zeronu (ParamPol P)=
let Q=null_module(real_form(P)) in
 let x=for (w,q) in %P do Q:=Q+w*zeronu(q) od in Q

{
length difference of block elements
length(block element i)-length(block element j) from block containing p
uses lengths, as returned by KL_block(p)
explanation, from functions.help:
The length of v is the largest index i such that len[i]<=v, so the
length difference between v and w is the number of indices with
v<len[i]<=w.
}
set length_diff (int i,int j,Param p)=
let (,,,,lengths)=KL_block(p) then
ld=0 in for k :#lengths from 0 do if (lengths[k]>i and lengths[k]<=j) then ld:=ld+1 fi od;ld

{orientation_number_term[p,q]=s^{[\ell_0(i)-\ell_0(j)]/2}= 1 or s }
set orientation_number_term (Param p,Param q)=
let on_p=orientation_nr(p) then
on_q=orientation_nr(q) in 
if (not is_even(on_p-on_q)) then error("computing orientation number for odd difference of lengths") 
else Split:(0,1)^(on_p-on_q) fi

{extract coefficient of  (Param p) from (ParamPol P)}
set coeff (ParamPol P,Param p)=
let mult=Split:0 in for (w,q) in %P do if p=q then  mult:=mult+w fi od;mult

{c_form_std:
write c-invariant form on standard module in terms of standardrepks,
as a ParamPol
just adds the initial term to iterate_deform(p)
}

set c_form_std (Param p)=let (p,poly)=
(if debug then prints("computing c-form on standard module: ",p) fi);iterate_deform(p) in p+poly

{c_form_irreducible(p) returns a ParamPol of standardrepks
giving the c-invariant form on irreducible(p)}
set c_form_irreducible (Param p)=
let G=real_form(p) then
P=null_module(G) then
(params,k,KL,)=KL_at_s(p) in
 for i:#KL[k] from 0 do
 let q=params[i] in
 let kl=KL[k][i] then
 ld=length_diff(i,k,p) then
 on=orientation_number_term(p,q) then
 coeff=(-1)^ld*on*kl then
 poly=c_form_std(q) in 
 P:=P+coeff*poly
od;P

{c_form_irreducible_long(p) returns:
(ParamPol P,[(Param,Split,ParamPol)]
P=c_form_irreducible(p) is ParamPol giving the formula for the c-invariant form
the second factor is 
[q_i,w_i,Q_i]
where Q_i is the c-form on standard module q_i
and the formula for P is
P=\sum_i w_i*Q_i}
set c_form_irreducible_long (Param p)=
let G=real_form(p) then
P=null_module(G) then
(params,k,KL,)=KL_at_s(p) in
 let standards=for i:#KL[k] from 0 do
 let q=params[i] in
 let kl=KL[k][i] then
 ld=length_diff(i,k,p) then
 on=orientation_number_term(p,q) then
 coeff=(-1)^ld*on*kl then
 poly=c_form_std(q) in 
 P:=P+coeff*poly;
 (q,coeff,poly)
od in (P,standards)

set character_formula (Param p)=
let G=real_form(p) then
P=null_module(G) then
(params,k,KL,)=KL_at_s(p) in
let x=for i:#KL[k] from 0 do
 let q=params[i] in
 let kl=KL[k][i] then
 ld=length_diff(i,k,p) then
 w=(-1)^ld*kl then
 coeff=w#1 in
 P:=P+coeff*q
od in P

set print_character_formula (Param p)=
let char=character_formula(p) in
for (w,p) in %char do prints(prettyPrint(w),"*",p) od;""

{just print terms with both a,b\ne 0 in (a+bs)}

set mixed (Split w)= let (a,b)=%w in (not a*b=0)
set analyse (ParamPol P)=
let G=real_form(P) then
Q=%P then
a=prints("Mixed terms:");
for x in KGB(G) do
 for (w,p) in Q do 
  let (y,,)=%p in 
  if (x=y) then 
   if mixed(w) then prints("(",prettyPrint(w),")*",p,", ",infinitesimal_character(p)) fi fi
 od
od in ()

set print_c_form_irreducible_long (Param p)=
let G=real_form(p) then
(f,b)=c_form_irreducible_long(p) then 
b=for (q,coeff,Q) in b do 
 prints("");
 prints("standard module: ",q);
 prints("coefficient: ",prettyPrint(coeff));
 prints("form on standard: ");
 prettyPrint(Q) od
in
 prints("");prints("c-form on irreducible module:");prints(p, " at ",infinitesimal_character(p));prettyPrint(f);prints("");analyse(f)

{----------------------------------------}
{commands for converting from c-form to hermitian-form}
{compute (lambda+rho) restricted to T}

{lambda\in X^*+rho=> can define a parameter with this lambda, as param(x,lambda-rho,0)
then 
infinitesimal_character(param(x,lambda-rho,0))=(1-theta)lambda/2=lambda restricted to T-tilde
apply this with lambda-rho=0, returns (1-theta)rho/2     (on T-tilde)
apply this with lambda-rho,   return  (1-theta)lambda/2  (on T-tilde)
then the sum is (1-theta)(lambda+rho)/2 on T
}
set lambda_plus_rho_res_T(KGBElt x,ratvec lambda)=
let G=real_form(x) then
nu=null(rank(G))/1 then
rho_res_T_tilde=infinitesimal_character(param(x,null(rank(G)),nu)) then
lambda_minus_rho_res_T_tilde=infinitesimal_character(param(x,ratvectovec(lambda-rho(G)),nu)) in
rho_res_T_tilde+lambda_minus_rho_res_T_tilde

{mu(p) is the value of the lowest K-type of p, evaluated at x(p)}
{formula: <(1-theta_x)(lambda+rho)/2, torus_factor(x)+rho^\vee>}
set mu(Param p)=lambda_plus_rho_res_T(x(p),lambda(p))*(torus_factor(x(p))+rhocheck(real_form(p)))

{ParamPol giving the hermitian form on irreducible p}
set hermitian_form_irreducible(Param p) =
let G=
(if debug then prints("Computing Hermitian form on irreducible: ",p) fi);real_form(p) then
pol=c_form_irreducible(p) then
s=Split:(0,1) then
pols=%pol then
(w0,p0)=pols[0] then
P=null_module(G) in
for (w,p) in pols do  
P:=P+s^(rattoint(mu(p)-mu(p0)))*w*p od;P

{nice output of hermitian_form_irreducible}
set print_hermitian_form_irreducible(Param p) =
prettyPrint(hermitian_form_irreducible(p));()

{nice output of Hermitian forms on list of parameters}
set print_hermitian_form_irreducible([Param] P)=
for p in P do 
 prints("");prints("Hermitian form on irreducible: ",p);
 print_hermitian_form_irreducible(p)
od;()

{check the following property:
J(p)=\sum a_i I_i(nu)  (character formula)
J(P)=\sum w_jI_j (formula for c-form or hermitian-form)
Then
\sum a_i I_i[nu=0]=\sum_j w_j[s=1]I_j
}
set test_form (ParamPol P,Param p)=
if ((P#1)=zeronu(character_formula(p))) then
prints("Passed") else prints("Failed") fi


{assuming is the ParamPol of the Hermitian
form on an irreducible, is_unitary(P) tests
if it is unitary: <=> every Split w=a+bs has a=0,
or all have b=0}

set is_unitary(ParamPol P)=
let coeffs=for (w,p) in %P do w od in 
let pos=for w in coeffs do let (x,y)=%w in x od in 
let neg=for w in coeffs do let (x,y)=%w in y od in
if (pos=null(#pos) or neg=null(#neg)) then true else false fi

{compute Hermitian form on p, and report if it is unitary}

set is_unitary(Param p)=is_unitary(hermitian_form_irreducible(p))

