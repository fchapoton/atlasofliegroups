<misc.rx
<iterate_deform.rx  {the old deform.rx has been renamed}
<kl.rx

{ a varable used in this file; set to true for more output from functions }
set hermitian_debug = false

set -(ParamPol P,ParamPol Q) = ParamPol: P+(-1)*Q

{ test equality of ParamPols }
set =(ParamPol P,ParamPol Q) = bool: #(P-Q)=0

{set nu=0 in Param (x,lambda,nu) }
set zeronu (Param p) = Param:
  let (x,lamrho,nu) = %p in param(x,lamrho,null_wt(#nu))
set zeronu (ParamPol P)= ParamPol:
  let Q=null_module(real_form(P)) in
  for (w,q) in %P do Q +:= w*zeronu(q) od ; Q

{ orientation_number_term(p,q) = s^{[\ell_0(p)-\ell_0(q)]/2}= 1 or s }
set orientation_number_term (Param p,Param q) = Split:
  let on_p=orientation_nr(p), on_q=orientation_nr(q) in
  if is_even(on_p-on_q)
  then s^((on_p-on_q)\2)
  else error("computing orientation number for odd difference of lengths")
  fi

{ extract coefficient of (Param p) from (ParamPol P) }
set coeff (ParamPol P,Param p)= Split:
  let mult=Split:0 in for (w,q) in %P do if p=q then mult +:= w fi od; mult

{ c_form_std:
  write c-invariant form on standard module in terms of standardrepks,
  as a ParamPol
  just adds the initial term to iterate_deform(p)
}
set c_form_std (Param p) = (ParamPol,int):
( if hermitian_debug then prints("computing c-form on standard module: ",p) fi
; (let ((p_deformed,poly),count) = iterate_deform(p)
   in (poly+p_deformed,count))
)

{ c_form_irreducible(y) returns a ParamPol of standardrepks
  giving the c-invariant form on irreducible(y)
  formula used: when
    J(y)  =sum_x               (-1)^{ell(x)-ell(y)}P(x,y)(q=1)I(x)
  then
    J(y)_c=sum_x (-1)^{on(x,y)}(-1)^{ell(x)-ell(y)}P(x,y)(q=s)I(x)_c
  where
    P(x,y) is a cumulated KL polyomial
    (-1)^{ell(x)-ell(y)}P(x,y) is given by signedKL(y)[i] with indices[i]=x
       (note sign is taken care of already)
    on(x,y)=orientation number given by orientation_number_term()
    I(x)_c given as combination of standards x' with nu(x')=0 by c_form_std(x)
  algorithm: just compute the sum for J(y)_c, using signedKL and c_form_std
}


set c_form_irreducible_long (Param p) =
  (ParamPol,[(Param,Split,ParamPol)],int):
( let (block,init,kl,polys,stops,indices,cumulation)=KL_block (p) then
 klpolys=signedKL(init,kl,polys,stops,indices,cumulation)
  , count=0, P=null_module(real_form(p))
  , standards=[(Param,Split,ParamPol)]: []
  in
  for i:#indices do { careful: first check if poly is zero polynomial }
   let poly=strip(klpolys[i]) in
   if #poly>0 then
     let q=block[indices[i]]
     then (form_on_standard,std_count)=c_form_std(q)
     , factor=orientation_number_term(q,p)*eval(poly,s)
     in
       count +:= std_count
     ; P +:= factor*form_on_standard
     ; standards #:= (q,factor,form_on_standard)
   fi
  od
; (P,standards,count)
)

set c_form_irreducible (Param p)= ParamPol:
  let (rv,,)=c_form_irreducible_long(p) in rv

set print_c_form_irreducible_long (Param p) = void:
  let (f,b,count)=c_form_irreducible_long(p) in
( for (q,coeff,Q) in b
  do prints("")
  ; prints("standard module: ",q)
  ; prints("coefficient: ",prettyPrint(coeff))
  ; prints("form on standard: ")
  ; prettyPrint(Q)
  od
; prints(""); prints("c-form on irreducible module:")
; prints(p, " at ",infinitesimal_character(p)); prettyPrint(f)
; prints(""); prints("Number of deformations: ",count)
)

{ analyse }
{ print one terms with "mixed" coefficient (a+bs), i.e., both a,b\ne 0 }
set mixed (Split w)= bool: let (a,b)=%w in a*b!=0
set analyse (ParamPol P) = void:
begin prints("Mixed terms:")
; for x in KGB(real_form(P)) do
    for (w,p) in %P do
      let (y,,)=%p in
      if x=y and mixed(w)
      then prints("(",prettyPrint(w),")*",p,", ",infinitesimal_character(p))
      fi
    od
  od
end


{ ---------------------------------------- }

{ commands for converting from c-form to hermitian-form}
{ compute (lambda+rho) restricted to torus T }

{ lambda\in X^*+rho =>
    one can define a parameter with this lambda, as param(x,lambda-rho,0)
  then
    infinitesimal_character(param(x,lambda-rho,0))=
    (1+theta)lambda/2=lambda restricted to T-tilde
  apply this with lambda-rho=0, returns (1+theta)rho/2     (on T-tilde)
  apply this with lambda-rho,   return  (1+theta)lambda/2  (on T-tilde)
  then the sum is (1+theta)(lambda+rho)/2 on T
}
set lambda_plus_rho_res_T(KGBElt x,ratvec lambda) = ratvec:
  let G=real_form(x)
  then nu=null(rank(G))/1
  then rho_res_T_tilde=infinitesimal_character(param(x,null(rank(G)),nu))
  , lambda_minus_rho_res_T_tilde =
      infinitesimal_character(param(x,ratvectovec(lambda-rho(G)),nu))
  in rho_res_T_tilde+lambda_minus_rho_res_T_tilde

set lprrT(KGBElt x,ratvec lambda) = ratvec: { a simpler way to do the same }
  let lpr=lambda+rho(real_form(x)) in (lpr+involution(x)*lpr)/2

{ mu(p) is the value of the lowest K-type of p, evaluated at x(p) }
{ formula: < (1+theta_x)(lambda+rho)/2 , torus_factor(x)+rho^\vee > }
set mu(Param p) = rat:
  lambda_plus_rho_res_T(x(p),lambda(p))*
  (torus_factor(x(p))+rhocheck(real_form(p)))

set convert_cform_hermitian (ParamPol P)= ParamPol:
  if #P=0 then P
  else
    let pols=%P, sum=null_module(real_form(P))
    then (,p0)=pols[0]
    in  for (w,p) in pols do sum +:= s^(rattoint(mu(p)-mu(p0)))*w*p od
  ; sum
  fi

{ ParamPol giving the hermitian form on irreducible p }
set hermitian_form_irreducible(Param p) = ParamPol:
( if hermitian_debug
  then prints("Computing Hermitian form on irreducible: ",p)
  fi
; convert_cform_hermitian(c_form_irreducible(p))
)

{ nice output of hermitian_form_irreducible }
set print_hermitian_form_irreducible(Param p) = void:
  prettyPrint(hermitian_form_irreducible(p))

{ nice output of Hermitian forms on list of parameters }
set print_hermitian_form_irreducible([Param] P) = void:
  for p in P do
    prints("");prints("Hermitian form on irreducible: ",p)
  ; print_hermitian_form_irreducible(p)
  od

{ check the following property: let
  J(p)=\sum a_i I_i(nu)  (character formula)
  J(P)=\sum w_jI_j (formula for c-form or hermitian-form)
  Then test whether
   \sum a_i I_i[nu=0]=\sum_j w_j[s=1]I_j
}
{ set test_form (ParamPol P,Param p)=
  if P#1 = zeronu(character_formula(p)) then
    prints("Passed") else prints("Failed")
  fi
}

{ assuming P is the ParamPol of the Hermitian
  form on an irreducible, is_unitary(P) tests
  if it is unitary: <=> every Split w=a+bs has a=0, or all have b=0 }

set is_unitary(ParamPol P)= bool:
( let OK=true, no_coef_1=true, no_coef_s=true, list=%P then i=#list in
  while OK and (i-:=1)>=0
  do let (x,y)= let (w,)=list[i] in %w
     in if x=0 then { must have y!=0 } no_coef_s:=false; OK:= no_coef_1
        else no_coef_1:=false; OK:= no_coef_s and y=0
        fi
  od
; OK
)
{ body used to be:
  let coeffs =for (w,) in %P do w od
  then pos=for w in coeffs do let (x,)=%w in x od
  ,    neg=for w in coeffs do let (,y)=%w in y od
  in  pos=null(#pos) or neg=null(#neg)
}

{ compute Hermitian form on p, and report if it is unitary }

set is_unitary (Param p) = bool: is_unitary(hermitian_form_irreducible(p))

set test_spherical_unitary(RealForm G,[ratvec] nus)= void:
  for nu in nus do
    prints(nu,", ", is_unitary(spherical_principal_series(G,nu)))
  od

set test_line (Param p) = void:
( let (x,lambdaminusrho,nu) = %p
  then points=reducibility_points(p)
  ,   ipoints=integrality_points(root_datum(p),2*nu)
  in prints("testing line through ", p)
; prints("reducibility points: ",points)
; prints("integrality points (for 2*nu): ",ipoints)
; if #points=0 and is_final(zeronu(p))
  then prints("entire line is irreducible and unitary")
  elif #points=0 and not is_final(zeronu(p))
  then prints
    ("entire line (nu>0) is irreducible and unitary (nu=0 is not final)")
  else
    let points=0#points in
    if not points[#points-1]=1/1 then points:=points#1/1 fi
  ; for i:#points-1 from 1 do
      let t=(points[i]+points[i-1])/2
      then q=param(x,lambdaminusrho,t*nu)
      then r=param(x,lambdaminusrho,points[i]*nu)
      in prints(t*nu,": ", is_unitary(q))
      ;  prints(points[i]*nu,": ", is_unitary(r))
    od
  fi
)
