<misc.rx
<iterate_deform.rx  {the old deform.rx has been renamed}
<kl.rx

set hermitian_debug=false{set to true for more output}

{test equality of ParamPols}
set =(ParamPol P,ParamPol Q)=
 if (#(P+(-1)*Q)=0) then true else false fi

{set nu=0 in Param (x,lambda,nu)}
set zeronu (Param p)=param(x(p),lambdaminusrho(p),null(rank(real_form(p)))/1)
set zeronu (ParamPol P)=
let Q=null_module(real_form(P)) in
 let x=for (w,q) in %P do Q:=Q+w*zeronu(q) od in Q

{orientation_number_term[p,q]=s^{[\ell_0(i)-\ell_0(j)]/2}= 1 or s }
set orientation_number_term (Param p,Param q)=
let on_p=orientation_nr(p) then
on_q=orientation_nr(q) in
if (not is_even(on_p-on_q)) then error("computing orientation number for odd difference of lengths")
else Split:(0,1)^((on_p-on_q)\2) fi

{extract coefficient of  (Param p) from (ParamPol P)}
set coeff (ParamPol P,Param p)=
let mult=Split:0 in for (w,q) in %P do if p=q then  mult:=mult+w fi od;mult

{c_form_std:
write c-invariant form on standard module in terms of standardrepks,
as a ParamPol
just adds the initial term to iterate_deform(p)
}

set c_form_std (Param p)=
let ((p,poly),count)=
(if hermitian_debug then prints("computing c-form on standard module: ",p) fi);
iterate_deform(p) in (p+poly,count)


{c_form_irreducible(p) returns a ParamPol of standardrepks
giving the c-invariant form on irreducible(p)
algorithm:
J(y)=sum (-1){ell(x)-ell(y)}P(x,y)(q=1)I(x)
J(y)_c=sum (-1)^{on(x,y)}(-1)^{ell(x)-ell(y)}P(x,y)(q=s)I(x)_c
P(x,y) is a cumulated KL polyomial
(-1)^{ell(x)-ell(y)}P(x,y) is given by KL_block(p)
note sign is taken care of already
on(x,y)=orientation number given by orientation_number_term()
I(x)_c given by c_form_std(x)
}

set c_form_irreducible_long (Param p)=
let count=0 then
G=real_form(p) then
P=null_module(G) then
(block,k,klmatrix,polys,stops,indices,cumulated)=KL_block (p) then
klpolys=signedKL(p) in
let standards=[] in
for i:#indices do
{careful: check if poly=[] or poly=[0]}
 let poly=klpolys[i] in
 if #poly>0 and poly[0]!=0
 then
   let poly_at_s=eval(poly,s)
   , q=block[indices[i]]
   then on=orientation_number_term(p,q)
   , (form_on_standard,std_count)=c_form_std(q)
   in
     count +:= std_count;
     P +:= on*poly_at_s*form_on_standard;
   standards #:= (q,on*poly_at_s,form_on_standard)
 fi
od;(P,standards,count)


set c_form_irreducible (Param p)=
let (rv,standards,count)=c_form_irreducible_long(p) in rv

set print_c_form_irreducible_long (Param p)=
let G=real_form(p) then
(f,b,count)=c_form_irreducible_long(p) then
b=for (q,coeff,Q) in b do
 prints("");
 prints("standard module: ",q);
 prints("coefficient: ",prettyPrint(coeff));
 prints("form on standard: ");
 prettyPrint(Q) od
in
( prints("");prints("c-form on irreducible module:")
; prints(p, " at ",infinitesimal_character(p));prettyPrint(f);prints("")
; prints("Number of deformations: ",count)
)

{;analyse}
{just print terms with both a,b\ne 0 in (a+bs)}
set mixed (Split w)= let (a,b)=%w in (not a*b=0)
set analyse (ParamPol P)=
let G=real_form(P) then
Q=%P then
a=prints("Mixed terms:");
for x in KGB(G) do
 for (w,p) in Q do
  let (y,,)=%p in
  if (x=y) then
   if mixed(w) then prints("(",prettyPrint(w),")*",p,", ",infinitesimal_character(p)) fi fi
 od
od in ()


{----------------------------------------}
{commands for converting from c-form to hermitian-form}
{compute (lambda+rho) restricted to T}

{lambda\in X^*+rho=> can define a parameter with this lambda, as param(x,lambda-rho,0)
then
infinitesimal_character(param(x,lambda-rho,0))=(1-theta)lambda/2=lambda restricted to T-tilde
apply this with lambda-rho=0, returns (1-theta)rho/2     (on T-tilde)
apply this with lambda-rho,   return  (1-theta)lambda/2  (on T-tilde)
then the sum is (1-theta)(lambda+rho)/2 on T
}
set lambda_plus_rho_res_T(KGBElt x,ratvec lambda)=
let G=real_form(x) then
nu=null(rank(G))/1 then
rho_res_T_tilde=infinitesimal_character(param(x,null(rank(G)),nu)) then
lambda_minus_rho_res_T_tilde=infinitesimal_character(param(x,ratvectovec(lambda-rho(G)),nu)) in
rho_res_T_tilde+lambda_minus_rho_res_T_tilde

{mu(p) is the value of the lowest K-type of p, evaluated at x(p)}
{formula: <(1-theta_x)(lambda+rho)/2, torus_factor(x)+rho^\vee>}
set mu(Param p)=lambda_plus_rho_res_T(x(p),lambda(p))*(torus_factor(x(p))+rhocheck(real_form(p)))

set convert_cform_hermitian (ParamPol P)=
let s=Split:(0,1) then
pols=%P then
(w0,p0)=pols[0] then
P=null_module(real_form(P)) in
for (w,p) in pols do
P:=P+s^(rattoint(mu(p)-mu(p0)))*w*p od;P

{ParamPol giving the hermitian form on irreducible p}
set hermitian_form_irreducible(Param p) =
if hermitian_debug then prints("Computing Hermitian form on irreducible: ",p) fi;convert_cform_hermitian(c_form_irreducible(p))

{nice output of hermitian_form_irreducible}
set print_hermitian_form_irreducible(Param p) =
prettyPrint(hermitian_form_irreducible(p));()

{nice output of Hermitian forms on list of parameters}
set print_hermitian_form_irreducible([Param] P)=
for p in P do
 prints("");prints("Hermitian form on irreducible: ",p);
 print_hermitian_form_irreducible(p)
od;()

{check the following property:
J(p)=\sum a_i I_i(nu)  (character formula)
J(P)=\sum w_jI_j (formula for c-form or hermitian-form)
Then
\sum a_i I_i[nu=0]=\sum_j w_j[s=1]I_j
}
{set test_form (ParamPol P,Param p)=
if ((P#1)=zeronu(character_formula(p))) then
prints("Passed") else prints("Failed") fi}

{assuming is the ParamPol of the Hermitian
form on an irreducible, is_unitary(P) tests
if it is unitary: <=> every Split w=a+bs has a=0,
or all have b=0}

set is_unitary(ParamPol P)=
let coeffs=for (w,p) in %P do w od in
let pos=for w in coeffs do let (x,y)=%w in x od in
let neg=for w in coeffs do let (x,y)=%w in y od in
if (pos=null(#pos) or neg=null(#neg)) then true else false fi

{compute Hermitian form on p, and report if it is unitary}

set is_unitary(Param p)=is_unitary(hermitian_form_irreducible(p))

set test_spherical_unitary(RealForm G,[ratvec] nus)=
for nu in nus do prints(nu,", ", is_unitary(spherical_principal_series(G,nu))) od

set test_line (Param p)=
let nu=nu(p) then
x=x(p) then
lambdaminusrho=lambdaminusrho(p) then
points=reducibility_points(p) then
ipoints=integrality_points(root_datum(p),2*nu) in
prints("testing line through ", p);prints("reducibility points: ",points);prints("integrality points: ",ipoints);if #points=0 and is_final(zeronu(p)) then prints("entire line is irreducible and unitary")
elif #points=0 and not is_final(zeronu(p)) then prints("entire line (nu>0) is irreducible and unitary (nu=0 is not final)")
else
 let points=0#points in
  if not points[#points-1]=1/1 then points:=points#1/1 fi;
  for i:#points-1 from 1 do
   let t=(points[i]+points[i-1])/2  then
   q=param(x,lambdaminusrho,t*nu) then
   r=param(x,lambdaminusrho,points[i]*nu) in
   prints(t*nu,": ", is_unitary(q));
   prints(points[i]*nu,": ", is_unitary(r))
  od
fi;()
