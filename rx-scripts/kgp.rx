<orbits.rx {for sort_u}


{K orbits on G/P
P is a set of simple roots
P -> partial order on KGB, generated by ascents not in P
  -> equivalence relation generated by this 
KGB/equivalence <-> K\G/P
Define KGP to be the set of equivalence classes
Write KGP=[y_1,...,y_r] where each y_i is an equivalence class (a subset of KGB)
The last element y_i is maximal, uniquely determined
y_i is closed if and only if the first element in it is closed in KGB
}

:KGPElt=([int], [KGBElt])   {data type for element of K\G/P}

set number(KGBElt x)=let (,n)=%x in n
set sort_by((KGBElt -> int) f)= ([KGBElt] v) [KGBElt]:
  for index in inv_standardisation(for x in v do f(x) od) do v[index] od
set sort=([KGBElt] -> [KGBElt]):sort_by((KGBElt x) int: number(x))

set min([KGBElt] y)=sort(y)[0]
set max([KGBElt] y)=sort(y)[#sort(y)-1]

set P(KGPElt x)=[int]:let (P,)=x in P
set kgb(KGPElt x)=[KGBElt]:let (,kgb)=x in kgb 
set max(KGPElt x)=KGBElt:max(kgb(x))

{complement of subset of simple roots in rank n}
set complement(int n,[int] P)=[int]:
let rv=for i:n do i od in for j in reverse_sort(P) do  rv:=delete(rv,j) od;rv

{add i to list if (and only if) it is new}
set add_new(int i,[int] list)=[int]: if find(i,list)=-1 then list#i else list fi 

{elements above x one step in the partial order given by ascents in P}
set up_neighbors(KGBElt x,[int] P)=[int]:
let rv=[int]:[] in
for i in P do
 let t=status(i,x) in 
  if t=3 then rv#:=number(Cayley(i,x))
  elif t=4 then rv#:=number(cross(i,x)) fi od;sort_u(rv)

{elements below x one step in the partial order}
set down_neighbors(KGBElt x,[int] P)=[int]:
let rv=[int]:[] in
for i in P do
 let t=status(i,x) in 
  if t=2 then 
   let y=Cayley(i,x) in 
    rv#:=number(y); rv#:=number(cross(i,y)) 
  elif t=0 then rv#:=number(cross(i,x)) fi od;sort_u(rv)
 
set is_maximal_in_partial_order(KGBElt x,[int] P)=bool:#up_neighbors(x,P)=0

{maximal elements in the partial order}
set maximal_in_partial_order(RealForm G,[int] P)=[KGBElt]:
let rv=[int]:[] in for x in KGB(G) do if is_maximal_in_partial_order(x,P) then rv#:=number(x) fi od;
for i in sort(rv) do KGB(G,i) od

{maximal element in equivalence class of x}
set maximal(KGBElt x,[int] P)=KGBElt:
let rec_fun f(KGBElt x,[int] P)=KGBElt:
if is_maximal_in_partial_order(x,P) then x else f(KGB(real_form(x),up_neighbors(x,P)[0]),P) fi in f(x,P)

{equivalence class of KGB element in partial order defined by P; this is an element of KGP}
set equivalence_class_of(KGBElt x, [int] P)=[KGBElt]:
let x_max=maximal(x,P) in 
let G=real_form(x_max),rv=[number(x_max)], to_do=[number(x_max)] in 
while #to_do>0 do
 let y=KGB(G,to_do[0]) then
 new=down_neighbors(y,P) in
 for i in new do rv:=add_new(i,rv);to_do:=add_new(i,to_do) od;
 to_do:=delete(to_do,0) od;for i in sort(rv) do KGB(G,i) od 

{set of KGP elements (P,S), S=[KGBElt] is an equivalence class
KGP(G,P) is in bijection with K\G/P}
set KGP(RealForm G,[int] P)=[KGPElt]:
for x in maximal_in_partial_order(G,P) do (P,equivalence_class_of(x,P)) od

{sometimes convenient to just keep the numbers, although this loses the information of what G is}
set KGP_numbers(RealForm G,[int] P) =[([int],[int])]:let kgp=KGP(G,P) in for (,S) in kgp do 
(P,for x in S do number(x) od) od 

{test if y\in K\G/P is closed: <=> length(first element)=0}
set is_closed(KGPElt x)=bool:length(min(kgb(x)))=0

set KGP_elt(KGBElt x,[int] P)=KGPElt:(P,equivalence_class_of(x,P))

set KGP_elt(KGBElt x,ratvec v)=KGPElt:
let G=real_form(x),P=[int]:[] in
assert(is_dominant(G,v),"v is not dominant");
for a@i in simple_roots(G) do if a*v=0 then P#:=i fi od;
KGP_elt(x,P)

{test if set of simple roots is delta stable}
set is_stable(InnerClass ic,[int] P)=bool:
let Q=for i in P do root_index(ic,distinguished_involution(ic)*simple_roots(ic)[i]) od in
sort(P)=sort(Q) 

{test if y\in K\G/P is theta-stable: <=>
1) P is delta stable (delta=distinguished involution of G)
2) y is closed and 
3) alpha simple, not in P => alpha is imaginary or C+ for (wrt x=max(y))
}
set is_theta_stable(KGPElt x)=bool:
let x_max=max(x),P=P(x) in 
is_stable(real_form(x_max),P) and
is_closed(x) and
all( for j in complement(semisimple_rank(real_form(x_max)),P) do
 let s=status(j,x_max) in s=1 or s=3 or s=4 od ) 

set theta_stable_parabolics(RealForm G,[int] P)=[KGPElt]:
let rv=[KGPElt]:[] in  for y in KGP(G,P) do if is_theta_stable(y) then rv#:=y fi od;rv

{list of parabolics: [([int] P,[int] x)] where for each P, each x is the maximal 
element of an element of KGP
}
set all_theta_stable_parabolics(RealForm G)=[KGPElt]:
let n=semisimple_rank(G) then
all=generate_all_subsets(for i:n do i od) then
rv=[KGPElt]:[] in
for P in all do 
for y in theta_stable_parabolics(G,P)  do rv#:=y od od;rv

{ let rv_P=[KGBElt]:[] in  for y in KGP(G,P) do if is_theta_stable(y,P) then rv_P#:=max(y) fi od;rv#:=(P,rv_P) od;rv}

set Levi([int] P,KGBElt x)=real_form(Levi(real_form(x),P),involution(x),torus_factor(x))

set print_all_theta_stable_parabolics(RealForm G)=void:
let total=0 in for (P,v) in all_theta_stable_parabolics(G) do
let L=Levi(G,P) in 
prints();
prints("P:",P);
prints("Complex Levi: ", L);
total+:=#v;
prints("x: ",for x in v do number(x) od, " (",#v,")");
prints("Real forms: ");
for x in v do prints(number(x), ": ",real_form(L,involution(x),torus_factor(x))) od
od;prints("Total: ",total) 

set theta_stable_Levi(KGPElt x)=RealForm:
let x_max=max(x),P=P(x) then
G=real_form(x_max) then 
theta=involution(x_max) then
L_C=Levi(G,P) then
ic=inner_class(L_C,theta) in
real_form(ic,theta,torus_factor(x_max))

set L(KGPElt x)=RealForm:theta_stable_Levi(x)

set rho_u(KGPElt x)=ratvec:rho(real_form(max(x))) - rho(L(x))

set u(KGPElt x)=[vec]:
let G=real_form(max(x)) then
rho_u=rho_u(x) then
rv=[vec]:[] in
for alpha in posroots(G) do if alpha*rho_u>0 then rv#:=alpha fi od;rv

set theta_stable_q(KGPElt x)=(L(x),u(x))

