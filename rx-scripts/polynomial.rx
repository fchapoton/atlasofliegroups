<basic.rx
<kl.rx

: poly = vec
: poly_mat = [[poly]]

{simple linear algebra over Z[q]}
{ vector [a_0,...,a_n] represents polynomial a_0+a_1q+...+a_nq^n
  multiplication, addition, subtraction, scalar multiplication defined below }

set - (poly v,poly w) = poly: { use vector addition from kl.rx for subtraction }
  v+-w {in basic.rx this was only allowed for vectors of the same length}

{ M=poly_mat is a polynomial matrix; e.g.
expr> set M= poly_mat: [[ [0,1], [0,0,1]], [[0], [1]]]
expr> printPolyMatrix (M)
 +q +q^2
 0 +1
}

set printPolyMatrix(poly_mat M)=void:
  let rv="", n=#M in
    for i:n do
      let line="" in
      for j:n do line+:=" "+stringPoly(M[i][j],"q") od; prints(line)
    od

{ multiply two polynomials (slightly prefers g to be the smaller one) }
set poly_product(poly f, poly g) = poly:
  if #f=0 then f { avoid useless traversal of g, and avoid needing strip }
  else let k=#g, s=null(0) in while (k-:=1)>=0 do s:= (0#s)+g[k]*f od; s
  fi

set transpose(poly_mat M)=poly_mat: { sublists must be of equal length }
  let n=#M in
  if n=0 then M { not much we can do for an empty list }
  else for j:#M[0] do for i:n do M[i][j] od od
  fi

{ multiply (dot product) of two vectors of polynomials }
set vector_poly_product([poly] v,[poly] w) = poly:
  let sum=null(0) in
  for p@i in v do sum +:= poly_product(p,w[i]) od; strip(sum)

{ multiply two matrices of polynomials; here operator * is unambiguous }
set *(poly_mat A,poly_mat B) = poly_mat:
  let n=#A, B=transpose(B) { best to rearrange B once and for all }
  then m=#B
  in for i:n do for j:m do vector_poly_product(A[i],B[j]) od od

{ add two vectors of polynomials, assumed of same length }
set vector_poly_sum([poly] v,[poly] w) = [poly]:
  if #v!=#w then error("length mismatch adding lists of polynomials")
  else for p@i in v do strip(p+w[i]) od
  fi

{ add matrices of the same size }
set +(poly_mat A,poly_mat B)=poly_mat:
  if #A!=#B then error("depth mismatch adding matrices of polynomials")
  else for row@i in A do vector_poly_sum(row,B[i]) od
  fi

set poly_times_vector(poly f,[poly] v) = [poly]:
  for p in v do poly_product(f,p) od

{ polynomial scalar times polynomial matrix }
set *(poly f,poly_mat M) = poly_mat:
  for row in M do poly_times_vector(f,row) od
set *(int c, poly_mat M)=(poly:[c])*M

 { set %(poly f,poly_mat M)=poly_mat:poly_times_matrix(f,M) }
set -(poly_mat M) = poly_mat: for row in M do for p in row do -p od od
set -(poly_mat A,poly_mat B) = poly_mat: A + -B

{ update one entry in a vector of polynomials and one row of a matrix }
set update_row([poly] R, int j,poly v) = [poly]: R[j]:=v; R
{ update one row of a matrix }
set update_matrix_row(poly_mat M, int i, [poly] row)= poly_mat: M[i]:=row; M
{ update one entry in a matrix }
set update_matrix_entry(poly_mat M, int i, int j, poly v)= poly_mat:
  let row=M[i] in row[j]:=v; M[i]:=row; M

set zero_poly_row(int n) = [poly]: for i:n do [] od
set zero_poly_matrix(int n) = poly_mat: for i:n do zero_poly_row(n) od
set scalar_poly_matrix(int n, int c)= poly_mat:
  for i:n do for j:n do if i=j then [c] else [] fi od od
set identity_poly_matrix(int n) = scalar_poly_matrix(n,1)

set +(poly_mat M, poly p) = poly_mat: { add polynomial scalar matrix }
  for row@i in M  do for e@j in row do if i=j then e+p else e fi od od
set -(poly_mat M, poly p) = poly_mat: M+-p

set ^(poly p,int n) = poly: { power of a polynomial }
  if n=0 then [1]
  else { no point in trying to do this by squaring, it is not faster }
    let f=p in while (n-:=1)>0 do f:=poly_product(f,p) od; f
  fi

{ equality of polynomial matrices }
set =(poly_mat A,poly_mat B) = bool:
  all((int i):bool: let r=A[i],s=B[i] in all((int j): r[j]=s[j],#r),#A)

{ polynomial is 0 }
set is_zero(poly_mat M)= bool:
  all((int i):bool: let r=M[i] in all((int j): #r[j]=0,#r),#M)

{for convenience}
set one=poly: [1]
set sgn_poly(int k) = poly:
  [if k<0 then -1 elif k>0 then 1 else error("taking sign of 0") fi]
set two=poly: [2]
set q=poly: [0,1]
set q2=poly: [0,0,1]
set evaluate_at_1 = sum@poly

{ compute PMP^{-1} where P is a permutation of [1,,,n]
  and M is a polynomial matrix
}
set poly_permute_basis(poly P, poly_mat A) = poly_mat: { P is permutation }
  for i:#A do let row=A[P[i]] in for j:#row do row[P[j]] od od

