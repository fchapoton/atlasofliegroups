<K_parameters.rx
<Weylgroup_aux.rx
<cross_W_orbit.rx { find_W_cross }
<finite_dimensional.rx { highest_weight, finite_dimensional }
<K.rx    { K_0 }
<sort.rx { inv_standardisation }

{Three ways of parametrizing K-types

1. KParam: (x,lambda) 
   this is a final standard limit tempered parameter
   see K_parameters.rx
   this parametrization is perfect
   LKT(p)=[KParam] returns the list of LKTs of p
   
2) KHighestWeight: (x,mu), x in distinguished fiber, mu in X^*(H^delta)
   LKT_highest_weights(p)=[KHighestWeight]
   this is a highest weight for K_#=H^delta.K_0
   not bijective if K_#\ne K
3) LKT as parameters for K_0
   LKT_K0(p)=[Param]
   list of parameters for finite dimensional representations of K_0
   not bijective if K_0\ne K
}

{KHighestWeight(KGBElt x,vec mu)
x is required to be in the fundamental fiber
mu is in X^*
equivalence will be modulo (1-delta)X^*, see function = below
}
:KHighestWeight = (KGBElt,vec)   

{ given (x,lambda): x in distinguished fiber, lambda in  X^*
  lambda restricted to H^\delta is the highest weight of a representation of K_x
  replace (x,lambda) with (y,mu) where mu is highest weight for K_y
  algorithm: find w\in W_G taking rho(K_x) to rho(K_y) using cross_W_orbit
  (x,lambda)->(y,w\lambda)
}
set move_weight (KGBElt x,KGBElt y,vec lambda) = (KGBElt,vec):
( let G=real_form(x) in assert(real_form(y)=G,"Real form mismatch")
; let w=find_W_cross(x,y) in (y,act(w,lambda))
)
set move_weight (KGBElt x,KGBElt y,ratvec lambda) = (KGBElt,ratvec):
( let G=real_form(x) in assert(real_form(y)=G,"Real form mismatch")
; let w=find_W_cross(x,y) in (y,act(w,lambda))
)

set move_finite_dimensional (KGBElt x,KGBElt y,Param p) = Param:
  let (,hw)=move_weight(x,y,highest_weight(p))
  in finite_dimensional(K_0(real_form(y)),hw)

{ sum of the roots of K as an element of X^* (where it can be half-integer)
  x is assumed to be in the distinguished fiber, defining K
  in particular alpha complex posroot implies theta(alpha) is a posroot too
}
set tworho_K (KGBElt x) = ratvec:
( if not in_distinguished_fiber(x)
  then prints("Warning: x is not in distinguished fiber") fi
; let G=real_form(x) in sum(compact_posroots(x)) + sum(complex_posroots(x))/2
)

{ x is assumed to be in the distinguished fiber, defining K; y on any Cartan
  all complex roots of type C+ (alpha>0 => theta(alpha)>0)
  returns sum of compact roots of centralizer of H^{\theta_y},
  as an element of X^*
}
set tworho_Kr (KGBElt x, KGBElt y) = ratvec:
( if not in_distinguished_fiber(x)
  then prints("Warning: x is not in distinguished fiber")
  elif not no_Cminus_roots(y)
  then prints("Warning: not all complex roots for y are type C+")
  fi
; let rpry = real_posroots(y), imx=is_imaginary(x), cpx=is_compact(x) in
  sum(columns_with((vec alpha): imx(alpha) and cpx(alpha),rpry)) +
  sum(columns_with(is_complex(x),rpry))/2
)

{ lowest K-type of (limit of) discrete series on M }
set M_LKT (Param p) = ratvec:
  let x=x(p)
  then lambda = involution(x)* { why? what follows is already fixed by theta }
      (infinitesimal_character(p)-nu(p))
  , delta = distinguished_involution(real_form(p))
  , rho_i=rho_i(x), tworho_ic=2*rho_ic(x)
{ , (,rv)=projection(1-delta,ratvec_as_vec(lambda+rho_i-tworho_ic)) in rv }
  in projection_mod_image(1-delta)*ratvec_as_vec(lambda+rho_i-tworho_ic)


{ if all complex roots for x are of type C+, then conjecturally
  the torus parts (torus_factor) of all elements in the fiber are a subset of those
  for the distinguished fiber:
  KGB_elt(G,theta(x),torus_bits(x))=KGB_elt(G,theta(x),torus_bits(x_f)) for some x_f in the fundamental fiber
  Mapping x to x_K in the distinguished fiber
  gives the version of K=K_{x_K} appropriate to y
  aborts with an error if the conjecture is false for x
 
  Note: this is false, but may be true with torus_bits in place of torus_factor:
  KGB_elt(G,theta(x),torus_bits(x))=KGB_elt(G,theta(x),torus_bits(x_f)) for some x_f in the fundamental fiber
  this differs from the same identity for torus_factor because
  torus_factor(x)=(1+^theta(x))(torus_bits(x)+base_grading_vector)
  the (1+^theta(x)) terms messes this up. An example is G=SO(6,2), x=KGB(G,11), which 
  should map to KGB(G,5)
}

set map_into_distinguished_fiber (KGBElt x)=KGBElt:
begin assert(no_Cminus_roots(x),"Only defined if no C- roots")
; let G=real_form(x) then F=distinguished_fiber(G)
  then index=#F-1, t=torus_factor(x), tb=torus_bits(x)
  in
{  while index>=0 and t!=torus_factor(KGB(G,F[index])) do index-:=1 od}
  while  index>=0 and tb!= torus_bits(KGB(G,F[index])) do index-:=1 od
; if index<0
  then prints("x:", x)
  ; error("the torus parts for the fiber over x" +
          " do not embed in those for the distinguished fiber")
  fi
; KGB(G,F[index])
end

{ first use complex cross actions to move to a fiber with no C-roots }
set strong_map_into_distinguished_fiber (KGBElt x) = KGBElt:
  let (y,)=make_no_Cminus(x) in map_into_distinguished_fiber(y)

set canonical_x_K (KGBElt x) = KGBElt: strong_map_into_distinguished_fiber(x)
set canonical_x_K (Param p)  = KGBElt: canonical_x_K(x(p))

{---------------- LKT in terms of KParams----------------}
{ simplest definition:
  K-types are parametrized by final tempered limit parameters
  lowest_K_types(p) are found by setting nu=0, and applying finalize
}
set LKT (Param p) = [KParam]: for q in finalize(p*0) do Kparameter(q) od

{---------------- LKT in terms of highest weights for K_#----------------}
{K_#=H^delta K_0, if K_# \ne K this loses some information}
{ this is the heart of the matter
  LKT of final tempered limit parameter is unique
  K=K_{x_K} where x_K=map_into_distinguished_fiber(x(p))
  K-type is a pair (x_K,mu) where 
   x_K is in the distinguished fiber
   mu\in X^* is the "highest weight"
   mu is viewed as an element of X^*/(1-\delta)X^*\simeq X^*(H^\delta)
  H^\delta is the "small" Cartan subgroup of K; the map from 
  K-types to highest weights is not necessarily injective 
   (for this you need a "large" Cartan subgroup, which may be nonabelian)
}
set LKT_highest_weight_final_tempered_limit (Param p) = KHighestWeight:
( assert(=nu(p),"The parameter is not tempered");
  assert(is_final(p),"The parameter is not final");
  let  y=x(p) then
  x_K=map_into_distinguished_fiber(y) then
  lambda=infinitesimal_character(p)-nu(p) {=(1+\theta)\lambda/2} then
  mu=ratvec_as_vec(lambda+rho(root_datum(y))-rho_r(y)-tworho_K(x_K)+tworho_Kr(x_K,y)) in
{prints("mu:", mu)
; prints("lambda =", lambda)
; prints("theta:", involution(y))
; prints("rho: ", rho(real_form(y)), ", rho_r: ", rho_r(y))
; prints("tworho_K(x_K): ", tworho_K(x_K), ", tworho_Kr(x_K,y): ",  tworho_Kr(x_K,y), " ",  x_K, "  ",  y);}
(x_K, mu)
)

{ returns [KHighestWeight] 
  algorithm:
  compute LKT_highest_weight_final_tempered_limit(q) for each q in LKT(p)
}
set LKT_highest_weights (Param p) = [KHighestWeight]:
  for q in LKT(p) do LKT_highest_weight_final_tempered_limit(parameter(q)) od

{ just list the highest weights of lowest K-types, with respect to given x_K }
set LKT_highest_weights (Param p,KGBElt x_K) = [vec]:
  for (x,mu) in LKT_highest_weights(p)  do let (,mu_1)= move_weight(x,x_K,mu) in mu_1 od

{---------------- LKT as parameter for the identity component of K----------------}

set LKT_K0(Param p,KGBElt x_K)=[Param]:
  let K=K_0(x_K) in
  for lambda in LKT_highest_weights(p,x_K) do finite_dimensional(K,lambda) od

{ mu is a highest weight for K_0=identity component of K_x
  returns fundamental weight coordinates
}
set fundamental_weight_coordinates (vec mu, KGBElt x) = vec:mu*simple_coroots(K_0(x))

set LKT_dimensions (Param p, KGBElt x_K) = [int]:for pi in LKT_K0(p,x_K) do dimension(pi) od
set LKT_dimensions (Param p) = [int]:   LKT_dimensions(p,KGB(real_form(p),0))
set LKT_dimensions ([Param] B)= [[int]]: for p in B do LKT_dimensions(p) od

{-----------------------equality of KHighestWeights------------}

{given G,x in distinguished fiber, K_0=K_0(x), Weyl group element w for W(K_0,H_{K_0})
 lift this to an element of W(G,H)
 should satisfy:
 P*lift_action(x,w)=w_matrix(w)*P
 where P is projection X^*(H)->X^*(H_{K_0})
 need this to define equality of K-highest weights (see below)
lift_action(x,w) assumes x is in the distinguished fiber, and 
w is a W_word for K_0(x)
}
set lift_action(KGBElt x, W_word w)=mat:
let (rd_K,w_K)=w then
rd=root_datum(x) then
((roots,coroots),(inj,pullback))=G_K_roots_and_coroots_raw(x) then
rv=id_mat(rank(rd)) in
for i in w_K do  
let alpha=roots[i] in
 let ()=prints("alpha=",alpha) in
 if is_imaginary(alpha,x) then rv*:=reflection(rd,alpha) else
 rv*:=reflection(rd,alpha)*reflection(rd,involution(x)*alpha) fi od;rv

{given G,x in distinguished fiber, K_0=K_0(x), Weyl group element w for W(K,H),
 w acts on X^*(H)
 w factors to an action on X^*(T_K)=X^*(H)/X^*(H)^{-delta}
 algorithm: 
 set inj = cocharacter_lattice_K(x) { isomorphism (X_*(T_K)->X_*(T)^\delta) }
 set proj=left_inverse(inj)  {NOT projection_to_K_matrix(x)}
 w -> proj*matrix(w)*inj
}
set factor_action(KGBElt x,W_word w)=mat:
let inj=cocharacter_lattice_K(x) then
proj=left_inverse(inj) in proj*w_matrix(w)*inj


{see "K-types in atlas notes", currently in dropbox, soon on the atlas web site}
set =(KHighestWeight (x,mu), KHighestWeight (y,tau))=
if not (real_form(x)=real_form(y)) then false
else 
 let x_0=KGB(real_form(x),0) then
 (,mu_0)=move_weight(x,x_0,mu) then
 (,tau_0)=move_weight(y,x_0,tau) then
 K_0=K_0(x_0) then
 mu_1=project_K(x_0,mu_0) then
 tau_1=project_K(x_0,tau_0) then
 ()=prints("mu_1: ", mu_1, " tau_1 :", tau_1) then
 (mu_2,w)=make_dominant(K_0,mu_1) then
 (tau_2,w)=make_dominant(K_0,tau_1) then
 ()=prints("mu_2: ", mu_2, " tau_2 :", tau_2) in 
 if not (mu_2=tau_2) then false 
 else 
 {lift action of w up to H, and then compare projection of w\mu and \tau to X^*(H^\delta)=X^*/(1-delta)X^*}
 let w_G=lift_action(x,w) then
 mu_3=w_G*mu_0 then
 tau_3=w_G*tau_0 then
 ()=prints("mu_3: ", mu_3, " tau_3 :", tau_3) in 
 in_lattice((1-involution(x_0)),mu_3-tau_3) fi fi

{-----------------printing and other auxiliary routines -------------}
 
set print_LKT ([Param] B, KGBElt x_K) = void:
( let G=real_form(B[0]), K_0=K_0(x_K) in
  prints("K_0: ", K_0)
{ ; prints("rho_K:", rho(K_0)) }
; for p in B
  do let lkt=LKT_K0(p,x_K)
  in prints(""); prints(p); prints(" Lowest K-types:")
  ; for pi in lkt
    do prints(" ", pi, "  dim=", dimension(pi)
             ," highest weight:", highest_weight(pi))
    od
  od
)

set print_LKT ([Param] B) = void: print_LKT(B,KGB(real_form(B[0]),0))
set print_LKT (Param p, KGBElt x_K) = void: print_LKT([p],x_K)
set print_LKT (Param p) = void: print_LKT([p])

set test_LKT (RealForm G) = void:
  for p in block_of(trivial(G)) do prints(p, ", ", LKT(p)) od

set testps (RealForm G, KGBElt x) = void:
begin prints("Minimal K-types of all principal series of")
; prints(G); prints("K=",K_0(x)); prints("rho_K=", rho(K_0(x)))
; for p in all_principal_series(G)
  do let lkt=LKT_highest_weights(p,x) in
{   prints(p,lkt)
  ; for mu in lkt do prints(fundamental_weight_coordinates(mu,x)) od od
}
  prints("lambda=", lambda(p), "  tau=", tau(p), "  LKT: ", lkt,
         ",  dims:", LKT_dimensions(p,x))
  od
end

set testps (RealForm G) = void: testps(G,KGB(G,0))

set testpsdims (RealForm G) = void:
  for p in all_principal_series(G) do prints(LKT_dimensions(p)) od

{ compute all lowest K-types of minimal principal series of split group
  algorithm: p -> lowest_K_types(p)
    =list of (final tempered limit) parameters, some are repeated,
 v make into a ParamPol=sum of distinct parameters with multiplicity,
  compute unique LKT of each parameter occuring
}


{			    sorting by dimension			}

set sort_by_dimension = ([(Split,Param)] -> [(Split,Param)]):
 sort_by( (Split s,Param p) int: LKT_dimensions(p)[0] )
