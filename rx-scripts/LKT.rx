<K_parameters.rx
<thetastable.rx
<cross_W_orbit.rx { find_W_cross }
<W_K.rx {make_strongly_dominant}

set LKT_verbose=false

{Three ways of parametrizing K-types

1. KParam: (x,lambda) 
   this is a final standard limit tempered parameter
   see K_parameters.rx
   this parametrization is perfect
   LKT(p)=[KParam] returns the list of LKTs of p
   
2) KHighestWeight: (x,mu), x in distinguished fiber, mu in X^*(H^delta)
   this is a highest weight for K_#=H^delta.K_0
   LKT_highest_weights(p)=[KHighestWeight]
   not bijective if K_#\ne K

3) LKT as parameters for K_0
   LKT_K0(p)=[Param]
   list of parameters for finite dimensional representations of K_0
   not bijective if K_0\ne K
}

{KHighestWeight(KGBElt x,vec mu)
x is required to be in the fundamental fiber
mu is in X^*, viewed as a weight of T_K=H^delta
X^*(T_K)=X^*/(1-delta)X^*
equivalence includes modding out by (1-delta)X^*, see function = below
}
{:KHighestWeight = (KGBElt,[int])   }
:KHighestWeight = (KGBElt,vec)   

{ given (x,lambda): x in distinguished fiber, lambda in  X^*
  lambda restricted to H^\delta is the highest weight of a representation of K_x
  replace (x,lambda) with (y,mu) where mu is highest weight for K_y
  algorithm: find w\in W_G taking rho(K_x) to rho(K_y) using cross_W_orbit
  (x,lambda)->(y,w\lambda)
}
set move_weight (KGBElt x,KGBElt y,vec lambda) = (KGBElt,vec):
( let G=real_form(x) in assert(real_form(y)=G,"Real form mismatch")
; let w=find_W_cross(x,y) in (y,act(w,lambda))
)

set move_weight (KGBElt x,KGBElt y,ratvec lambda) = (KGBElt,ratvec):
( let G=real_form(x) in assert(real_form(y)=G,"Real form mismatch")
; let w=find_W_cross(x,y) in (y,act(w,lambda))
)

set move_finite_dimensional (KGBElt x,KGBElt y,Param p) = Param:
  let (,hw)=move_weight(x,y,highest_weight(p))
  in finite_dimensional(K_0(real_form(y)),hw)

{ sum of the roots of K as an element of X^*(H^delta)
  x is assumed to be in the distinguished fiber, defining K
  in particular alpha complex posroot implies delta(alpha) is a posroot also
  return value is an element of X^*
  which restricts to give an element of X^*(H^delta)=X^*/(1-delta)X^*
  mu is not unique (of course), and mu is not necessarily fixed by delta
  to get an element fixed by delta we need to allow 1/2X^*, see tworho_K_fixed(x) below
  if {alpha,delta(alpha)} is a pair of positive roots, these contribute
  alpha (which is in X^*) or (1+delta)alpha/2 (which is delta-fixed)
  in order to get in X^* (not 1/2X^*), contribution of a positive complex pair
  {alpha,theta(alpha)} is alpha, rather than (1+theta)\alpha/2
  see rho_S(x) in induction.rx
}

set tworho_K (KGBElt x) = vec:
( if not in_distinguished_fiber(x)
  then prints("Warning: x is not in distinguished fiber") fi;
  let G=real_form(x) in sum(compact_posroots(x)) + ratvec_as_vec(2*rho_S(x))
)

{ sum of the roots of K as an element of (X^*)^delta\otimes Q (it can be half-integral)
  x is assumed to be in the distinguished fiber, defining K
  in particular alpha complex posroot implies theta(alpha) is a posroot too
  tworho_K(x)\in X^* and tworho_K_fixed(x)\in 1/2(X^*)^delta map to same element
  2*rho_K(x) in X^*(T_{K_0})
}
set tworho_K_fixed (KGBElt x) = ratvec:
( if not in_distinguished_fiber(x)
  then prints("Warning: x is not in distinguished fiber") fi
; let G=real_form(x) in sum(compact_posroots(x)) + sum(complex_posroots(x))/2
)

{ x is assumed to be in the distinguished fiber, defining K; y on any Cartan
  all complex roots of type C+ (alpha>0 => theta(alpha)>0)
  returns sum of compact roots of centralizer of H^{\theta_y},
  as an element of X^*
}
{set tworho_Kr (KGBElt x, KGBElt y) = ratvec:
( if not in_distinguished_fiber(x)
  then prints("Warning: x is not in distinguished fiber")
  elif not no_Cminus_roots(y)
  then prints("Warning: not all complex roots for y are type C+")
  fi
; let rpry = real_posroots(y), imx=is_imaginary(x), cpx=is_compact(x) in
  sum(columns_with((vec alpha): imx(alpha) and cpx(alpha),rpry)) +
  sum(columns_with(is_complex(x),rpry))/2
)}

set tworho_Kr (KGBElt x, KGBElt y) = vec:
( if not in_distinguished_fiber(x)
  then prints("Warning: x is not in distinguished fiber")
  elif not no_Cminus_roots(y)
  then prints("Warning: not all complex roots for y are type C+")
  fi;
  let real_roots=root_datum(simple_from_positive(real_sys(y))) then
  imx=is_imaginary(x), cpx=is_compact(x) in
  ratvec_as_vec(sum(columns_with((vec alpha): imx(alpha) and cpx(alpha),posroots(real_roots)))+2*rho_S(involution(x),real_roots))
)




{ lowest K-type of (limit of) discrete series on M }
set M_LKT (Param p) = ratvec:
  let x=x(p)
  then lambda = involution(x)* { why? what follows is already fixed by theta }
      (infinitesimal_character(p)-nu(p))
  , delta = distinguished_involution(real_form(p))
  , rho_i=rho_i(x), tworho_ic=2*rho_ic(x)
{ , (,rv)=projection(1-delta,ratvec_as_vec(lambda+rho_i-tworho_ic)) in rv }
  in projection_mod_image(1-delta)*ratvec_as_vec(lambda+rho_i-tworho_ic)



{---------------- LKT in terms of KParams----------------}
{ simplest definition:
  K-types are parametrized by final tempered limit parameters
  lowest_K_types(p) are found by setting nu=0, and applying finalize
}
set LKT (Param p) = [KParam]: for q in finalize(p*0) do Kparameter(q) od


{---------------- LKT in terms of highest weights for K_#----------------}

{algorithm:
1) if G is relatively split, Cartan is (relatively) split, all roots in the tau-invariant,
   this is the "G-spherical" case of KHatHowe, section 8
2) if p is final standard limit tempered, it has a unique LKT, use theta_stable_data to 
   write p as cohomologically induced from a relatively split L
3) apply 2) to all terms of finalize(p*0)
}
set is_split_spherical(Param p)=bool:
assert(is_final(p), "parameter is not final");
if not is_relatively_split(real_form(p)) then false elif
number(x(p)) != KGB_size(real_form(p))-1 then false else
all(for alpha_check in simple_coroots(root_datum(p)) do is_even(rat_as_int(  (lambda(p)-rho(root_datum(p)))  *alpha_check)) od) fi

set is_split_spherical(KParam p)=bool:is_split_spherical(parameter(p))

set LKT_highest_weight_split_spherical(KParam p)=KHighestWeight:
assert(is_split_spherical(p), "p is not a spherical rep of a split group");
let x=x(p) then
lambda=lambda(p) then
rd=root_datum(x) then
fcw=fundamental_coweights(rd) then
rv=ratvec:lambda(p)-rho(rd) in
for alpha@i in simple_roots(rd) do rv-:=rv*fcw[i]*alpha od;(KGB(real_form(x),0),ratvec_as_vec(rv))

set LKT_highest_weight_split_spherical(Param p)=KHighestWeight:LKT_highest_weight_split_spherical(Kparameter(p*0))

set LKT_highest_weight_split_spherical(KParam p,KGBElt x_K)=KHighestWeight:
let (x,mu)=LKT_highest_weight_split_spherical(p) in move_weight(x,x_K,mu)

set LKT_highest_weight_split_spherical(Param p,KGBElt x_K)=KHighestWeight:
let (x,mu)=LKT_highest_weight_split_spherical(p) in move_weight(x,x_K,mu)

set LKT_highest_weight(KParam p)=KHighestWeight:
assert(is_final(parameter(p)),"parameter is not final");
let p=make_no_Cminus(p) in
let (Q,pL)=theta_stable_data(parameter(p)) then
(x_L,mu_L)=LKT_highest_weight_split_spherical(pL) then 
x_G=canonical_x_K(x(p)) then
mu_G=mu_L+2*rho_u_cap_s(Q)  then
{this might be a ratvec, denominator 1/2, by restriction it defines a character of T_{K_0}
need to replace mu_G\in 1/2X^*theta with mu_G_integral\in X^*
so that restriction take  mu_G_integral to mu_G restricted to T_{K_0}
}
mu_K=project_K(x_G,mu_G) then
mu_G_integral=ratvec_as_vec(mu_K*left_inverse(injection_from_K_matrix(x_G))) in
{prints("L=", Levi(Q));
prints("pL=", pL);
prints("mu_L=", mu_L);
prints("rho_u_cap_s:=", rho_u_cap_s(Q));
prints("rho_u_cap_k:=", rho_u_cap_k(Q));
prints("mu_G=", mu_G);}
(x_G,mu_G_integral)

set LKT_highest_weight(KParam p,KGBElt x_K)=KHighestWeight:
let (x,mu)=LKT_highest_weight(p) in move_weight(x,x_K,mu)

set LKT_highest_weights(Param p)=[KHighestWeight]:
for q in finalize(p*0) do LKT_highest_weight(Kparameter(q)) od

set LKT_highest_weights (Param p,KGBElt x_K) = [KHighestWeight]:
  for (x,mu) in LKT_highest_weights(p) do  move_weight(x,x_K,mu) od

{although LKT is unique, allow call using plural weights}
set LKT_highest_weights(KParam p) =KHighestWeight:LKT_highest_weight(p)

{ just list the highest weights of lowest K-types, with respect to given x_K }
set LKT_highest_weights (Param p,KGBElt x_K) = [vec]:
  for (x,mu) in LKT_highest_weights(p)  do let (,mu_1)= move_weight(x,x_K,mu) in mu_1 od


set test([Param] params)=void:
for p in params do let
pf=finalize(p*0) in
for q in pf do 
let (Q,pL)=theta_stable_data(q) in 
prints();prints("q=",q);prints("L:", Levi(Q));prints(q);prints(LKT_highest_weight_split_spherical(pL)) od od



{---------------- LKT as parameter for the identity component of K----------------}

set LKT_K0(Param p,KGBElt x_K)=[Param]:
  let K=K_0(x_K) in
  for lambda in LKT_highest_weights(p,x_K) do finite_dimensional(K,lambda) od

{ mu is a highest weight for K_0=identity component of K_x
  returns fundamental weight coordinates
}
set fundamental_weight_coordinates (vec mu, KGBElt x) = vec:mu*simple_coroots(K_0(x))

set LKT_dimensions (Param p, KGBElt x_K) = [int]:for pi in LKT_K0(p,x_K) do dimension(pi) od
set LKT_dimensions (Param p) = [int]:   LKT_dimensions(p,KGB(real_form(p),0))
set LKT_dimensions ([Param] B)= [[int]]: for p in B do LKT_dimensions(p) od

{-----------------------equality of KHighestWeights------------}


{see "K-types in atlas notes", currently in dropbox, soon on the atlas web site}
set =(KHighestWeight (x,mu), KHighestWeight (y,tau))=
if not (real_form(x)=real_form(y)) then false
else 
 let x_0=KGB(real_form(x),0) then
 (,mu_0)=move_weight(x,x_0,mu) then
 (,tau_0)=move_weight(y,x_0,tau) then
 K_0=K_0(x_0) then
 mu_1=project_K(x_0,mu_0) then
 tau_1=project_K(x_0,tau_0) then
 (mu_2,w_mu2,y_mu2,)=make_strongly_dominant(x_0,mu_1) then
 (tau_2,w_tau2,y_tau2,)=make_strongly_dominant(x_0,tau_1) in
 if not (mu_2=tau_2) then false 
 else 
 {lift action of w up to H, and then compare projection of w\mu and \tau to X^*(H^\delta)=X^*/(1-delta)X^*}
 let m_w_mu2=lift_action(x,w_mu2) then
 m_G_mu_2=lift_action(x,w_mu2)*w_matrix(y_mu2) then
 m_G_tau_2=lift_action(x,w_tau2)*w_matrix(y_tau2) then
 mu_3=m_G_mu_2*mu_0 then
 tau_3=m_G_tau_2*tau_0 in
 let ()=if LKT_verbose then 
 prints("m_G_mu_2:", m_G_mu_2);
 prints("m_G_tau_2:", m_G_tau_2);
 prints("mu_0: ", mu_0, " tau_0 :", tau_0);
 prints("mu_1: ", mu_1, " tau_1 :", tau_1);
 prints("mu_2: ", mu_2, " tau_2 :", tau_2);
 prints("mu_3: ", mu_3, " tau_3 :", tau_3) fi in 
 in_lattice((1-involution(x_0)),mu_3-tau_3) fi fi

{-----------------printing and other auxiliary routines -------------}
 
set print_LKT ([Param] B, KGBElt x_K) = void:
( let G=real_form(B[0]), K_0=K_0(x_K) in
  prints("K_0: ", K_0)
{ ; prints("rho_K:", rho(K_0)) }
; for p in B
  do let lkt=LKT_K0(p,x_K)
  in prints(""); prints(p); prints(" Lowest K-types:")
  ; for pi in lkt
    do prints(" ", pi, "  dim=", dimension(pi)
             ," highest weight:", highest_weight(pi))
    od
  od
)

set print_LKT ([Param] B) = void: print_LKT(B,KGB(real_form(B[0]),0))
set print_LKT (Param p, KGBElt x_K) = void: print_LKT([p],x_K)
set print_LKT (Param p) = void: print_LKT([p])

set test_LKT (RealForm G) = void:
  for p in block_of(trivial(G)) do prints(p, ", ", LKT(p)) od

set testps (RealForm G, KGBElt x) = void:
begin prints("Minimal K-types of all principal series of")
; prints(G); prints("K=",K_0(x)); prints("rho_K=", rho(K_0(x)))
; for p in all_principal_series(G)
  do let lkt=LKT_highest_weights(p,x) in
{   prints(p,lkt)
  ; for mu in lkt do prints(fundamental_weight_coordinates(mu,x)) od od
}
  prints("lambda=", lambda(p), "  tau=", tau(p), "  LKT: ", lkt,
         ",  dims:", LKT_dimensions(p,x))
  od
end

set testps (RealForm G) = void: testps(G,KGB(G,0))

set testpsdims (RealForm G) = void:
  for p in all_principal_series(G) do prints(LKT_dimensions(p)) od

{ compute all lowest K-types of minimal principal series of split group
  algorithm: p -> lowest_K_types(p)
    =list of (final tempered limit) parameters, some are repeated,
 v make into a ParamPol=sum of distinct parameters with multiplicity,
  compute unique LKT of each parameter occuring
}


{			    sorting by dimension			}

set sort_by_dimension = ([(Split,Param)] -> [(Split,Param)]):
 sort_by( (Split s,Param p) int: LKT_dimensions(p)[0] )

{-----------------------Vogan algorithm---------------------}

{project vector mu on dominant cone (spanned by positive sums of fundamental coweights)
 algorithm from KHatHowe Section 13, modification of BGB Proposition 5.3.3
 used in map from highest weights to LKT below
}

set centralizer(KGBElt x,ratvec v)=
assert(^involution(x)*v=v, "v is not theta-stable");
let rd=root_datum(x) then
pr=posroots(rd) then
pcr=poscoroots(rd) then
(roots,coroots)=([vec]:[],[vec]:[]) then
()=for alpha@i in pr do 
 if alpha*v=0 then roots#:=pr[i];coroots#:=pcr[i] fi od then
 subrd=if #roots !=0 then 
  root_datum(simple_from_positive(roots,coroots)) 
 else 
  root_datum([vec]:[],[vec]:[],rank(rd)) fi in 
 (KGB_elt(subrd,involution(x),torus_factor(x)),subrd)

set find_nci_root(KGBElt x)=
let rd=root_datum(x) then
sr=simple_roots(rd) then
j=first(rank(rd), (int i)bool:(is_noncompact(x)(sr[i]))) in 
if j !=-1 then j else 
let j=first(rank(rd),
  (int i)bool:(is_complex(i,x) 
   and sr[i]*^involution(x)*simple_coroots(rd)[i]=-1   {<alpha,theta(alpha^vee)>=-1}
   and is_noncompact(x)(sr[i]+involution(x)*sr[i]))) in 
   root_index(rd,sr[j]+involution(x)*sr[j]) fi

{(x,mu) is a KHighestWeight (see top of this file)
 x in the distinguished fiber, theta_x=delta
 mu\in X^*, viewed modulo (1-delta)X^*
in (X^*)^delta project it to X^*(T_K) where T_K=identity component of H^delta}
{(x,mu) equivalent to (wx,w\mu) so WLOG mu is G-dominant}


{This is the Vogan algorithm, version in khatHowe Section 13,
which is a slight modification of BGB Proposition 5.3.3
given (x,mu) -> mu+2rho_K(x) -> choose positive chamber for G -> mu+2rho_K(x)-rho
 project on given dominant chamber
 }
set project_on_dominant_cone(KGBElt x, ratvec mu)=(KGBElt,ratvec,ratvec):
let rd=root_datum(x) then
mu=(1+involution(x))*mu/2 then
(mu_1,w)=make_dominant(rd,mu) then
x_1=cross(inverse(w),x) in 
{let ()=prints("mu_1:", mu_1);
prints("x_1: ", x_1) in }
{Note: tworho_K_fixed(x) (above) is in (\h^*)^theta, while rho_K(x) is in \t^*, need the former}
let mu_2=mu_1+tworho_K_fixed(x_1) in
{let ()=prints("mu_2:", mu_2) in}
let (,y)=make_dominant(rd,mu_2) in
let x_2=cross(inverse(y),x_1) in
{let ()=prints("y=", y) in}
{let ()=prints("x_2=", x_2) in}
let rho=act(y,rho(rd)) then
mu_3=mu_2-rho in
{let ()=prints("mu_3=", mu_3) in}
let rec_fun f(KGBElt x, ratvec mu_3_orig,ratvec tau)=(KGBElt,ratvec,ratvec):
let rd=root_datum(x) in
{let ()=prints();prints("f with: ", x, " ", real_form(x), " tau= ", tau) in
let ()=prints("rd:", rd) in
let ()=prints("tau=",tau) in
}
if is_dominant(rd,tau) then  (x_2,mu_3_orig,tau) else
let j=find_nci_root(x) then
{()=prints("beta=", posroots(rd)[j]) then}
new_tau=tau-poscoroots(rd)[j]*tau*posroots(rd)[j]/2 then
(sub_x,sub_rd)=centralizer(x,poscoroots(rd)[j]) in
f(sub_x,mu_3_orig,new_tau) fi in f(x_1,mu_3,mu_3)

set project_on_dominant_cone(KGBElt x, [int] mu)=(KGBElt,ratvec,ratvec):project_on_dominant_cone(x,ratvec:mu)


{uses the Vogan algorithm, see project.rx}


{-----------------------map from highest weights to LKT---------------------}

set highest_weight_to_parabolic(KHighestWeight (x,mu))=
let rd=root_datum(x) then
(y,mu_3_orig,lambda)=project_on_dominant_cone(x,mu) then
diff=lambda-mu_3_orig then
S=[int]:[] in
let ()=for i:ss_rank(rd) do if fundamental_coweight(rd,i)*diff>0 then S#:=i fi od
in parabolic(S,y) 

set highest_weight_to_K_type(KHighestWeight(x,mu))=[KParam]:
let (y,mu_3_orig,dlambda)=project_on_dominant_cone(x,mu) then
Q=highest_weight_to_parabolic(x,mu) then  {Q is theta-stable}
L=Levi(Q) then
pl=parameter(KGB(L,#KGB(L)-1), dlambda-rho_u(Q)+rho_l(Q), null(#dlambda))  in
{let ()=prints("Q=",Q);prints("L= ", L);prints("dlambda=" , dlambda,  "  pl=", pl) in}
for ql in finalize(pl) do
Kparameter(last_param(induce_standard(ql,Q,real_form(x)))) od 

set test(KHighestWeight mu)=[bool]:
let ktypes=highest_weight_to_K_type(mu) then
rv=[bool]:[] in
for p in ktypes do
let lkthw=LKT_highest_weights(p) in
rv#:=(lkthw=mu);
prints("p=",p);
prints("LKT_highest_weights of p:",lkthw);
prints("mu=", mu);
prints("mu=LKT(p): ",lkthw=mu)
  od;rv
