<misc.rx
<Weylgroup.rx
<representations.rx
<hermitian.rx

{ some special operations defined only for complex groups }

set is_finite_dimensional(Param p) = bool:
  let ssr = semisimple_rank(real_form(p))
  in semisimple_rank(integrality_datum(p))=ssr and #tau(p)=ssr


set fd_only (Param p) = Param:
  assert(is_finite_dimensional(p),"representation is infinite dimensional"); p

set complex_LKT(Param p) = vec:
  let mu=(1+involution(x(p)))*lambda(p)
  then (rv,)=make_dominant(real_form(p),mu)
  in ratvec_as_vec(for i:rank(real_form(p))\2 do rv[i] od) { first half }

{ dimension of finite dimensional with given highest weight }
set dimension(RootDatum rd, vec lambda_in) = int:
  let lambda=
    if is_dominant(rd,lambda_in) then lambda_in
    else
      let (lambda_dominant,)=make_dominant(rd,lambda_in)
      in prints("Warning: changed ", lambda_in, ", to ", lambda_dominant
               ," to make it dominant")
      ; lambda_dominant
    fi
  then rho=rho(rd), dim=1/1
  in ( for a in poscoroots(rd) do dim*:=(lambda+rho)*a/(rho*a) od
     ; rat_as_int(dim) )

set dimension(RealForm G, [int] lambda)=int: dimension(root_datum(G),lambda)

set highest_weight(Param p) = vec:
  ratvec_as_vec(infinitesimal_character(fd_only(p)) - rho(real_form(p)))

set dimension(Param p) = int:
  dimension(root_datum(p),highest_weight(p))

set fundamental_weight_coordinates (Param p) = vec:
  for a in simple_coroots(real_form(p)) do a*highest_weight(p) od

{ set dimension_complex_Ktype(RealForm G,[int] lambda) = int:
  weyl_dimension_formula(K_0(G),lambda) }

set testcomplex(RealForm G) = void:
  let t=trivial(G)
  then b=block_of(t), P=c_form_irreducible(t)
  then rho_check = for i:rank(G)\2 do rho_check(G)[i] od
  , Q= for c@p in P do (c,p) od
  then (,last)=Q[#Q-1]
  then shift=complex_LKT(last)
  then ()=prints("rho_check= ", rho_check, "shift:", shift)
  ; for (w,p) in Q
    do prints(complex_LKT(p), ", ", shift-complex_LKT(p), ", "
             ,split_format(w), ", ", ((shift-complex_LKT(p))*rho_check))
    od
  ; prints("")
  in
  for i:#b downto 0
  do let p=b[i]
     in prints(complex_LKT(p), ", ", length(p), ", ", p, ", "
              ,twist(x(p))=x(p))
  od

