{ computing the twist of an external involution on a KGB set, and on a Block }

<basic.rx

set check (InnerClass ic, mat delta) = bool:
  let rd = root_datum(ic)
  then pred = is_simple_for(sum(poscoroots(rd))), i=semisimple_rank(rd)-1
  , alpha = posroots(rd), theta = distinguished_involution(ic)
  in ( while i>=0 and pred(delta*alpha[i]) do i-:=1 od
     ; i<0 and delta*theta=theta*delta
     )

set KGB_twist (InnerClass ic, mat delta) = (KGBElt x) KGBElt:
  KGB_elt(ic,delta*involution(x)*delta, torus_factor(x) * delta)

set is_twist_fixed ((InnerClass, mat) icm) = (RealForm->bool):
  let twist = KGB_twist(icm) in
  (RealForm rf) bool: real_form(twist(KGB(rf,0)))=rf

set test (RealForm rf) = bool:
  let mytwist=KGB_twist(rf,distinguished_involution(rf)), i=KGB_size(rf)-1 in
  while i>=0 and (let x=KGB(rf,i) in twist(x) = mytwist(x)) do i-:=1 od; i<0

set real_form (Block b) = let (x,) = element(b,0) in real_form(x)

set show (Block b, int i) = void:
  let ssr = semisimple_rank(real_form(b))
  then statuses = string: let str="[" in
    for s: ssr
    do str#:= block_status_text(status(s,b,i))
            # if s<ssr-1 then "," else "]" fi
    od; str
  , crosses = [int]: for s: ssr do cross(s,b,i) od
  , Cayleys = [int]: for s: ssr do Cayley(s,b,i) od
  in prints(i,": ",statuses, ", ", crosses, ", ", Cayleys)

set block_twist (InnerClass ic, mat delta) = (Block->(int->int)):
  let dual_ic = dual@InnerClass(ic), dual_delta = ^delta
  then x_twist = KGB_twist(ic,delta), y_twist=KGB_twist(dual_ic,dual_delta)
  in
  (Block b) (int->int):
  let (x,y)=element(b,0)
  then ()=
    if real_form(x)!=real_form(x_twist(x))
    then error("Real form non fixed")
    elif real_form(y)!=real_form(y_twist(y))
    then error("Dual real form non fixed")
    fi
  in  (int i) int: let (x,y)=element(b,i) in index(b,x_twist(x),y_twist(y))
