{miscellaneous test of extended paramter functions}

set test(mat delta,[Param] P, int start, int stop)=void:
let G=real_form(P[0]) in 
for i:stop-start+1 from start do 
 if (is_fixed(delta,P[i])) then 
 let ()=prints(i,": ", P[i]) in
 for j:ss_rank(G) do
   prints("j=",j, ",length=", ext_length(G,delta,j), ", ", status_text(j,P[i]), ", ", ext_type(delta,j,P[i])) od 
 else prints(i, ": parameter not fixed by delta") 
 fi od
set test([Param] P, int start, int stop)=void:test(distinguished_involution(real_form(P[0])),P,start,stop)
set test(mat delta,[Param] P)=test(delta,P,0,#P-1)
set test([Param] P)=test(P,0,#P-1)
set test(RealForm G, int start, int stop)=void:let (b,)=block(trivial(G)) in test(b,start,stop)
set test(RealForm G)=void: let (b,)=block(trivial(G)) in test(G,0,#b-1) 
set test(RealForm G, int i)=void:test(G,0,i)

set test_make_extended(mat delta,[Param] B, int start, int stop)=
let G=real_form(B[0]) in 
let passed=true in 
let rv=[] in
for i:stop-start+1 from start do 
 let p=B[i] in 
 if (is_fixed(delta,p)) then 
{ let ()=prints(i,": ",p) in}
 let xp=make_extended(delta,p) in 
 let result=verify(xp)  in 
 let ()=if not result then passed:=false fi in
 rv#:=result; prints(result);prints("")
 else prints(i, ": parameter not fixed by delta") 
 fi od;prints("Result: ", passed);rv

set test_make_extended(mat delta,[Param] B)=test_make_extended(delta,B,0,#B-1)

set test_z_values(mat delta, [Param] B)=
let rv=[] in 
for p@i in B do if is_fixed(delta,p) then
let xp=(make_extended (delta,p)) in 
let valid=verify(xp) in 
let z=z(xp) in 
rv#:=(valid,z);
prints(i, ", ", valid, ", ", z);prints("") fi od;rv


set test_Cayleys(mat delta,[Param] P, int start, int stop)=
let G=real_form(P[0]) in 
let rv=[] in
for i:stop-start+1 from start do
 let p=P[i] in 
 if (is_fixed(delta,p)) then 
 let ()=prints(i,": ",p) in
 let xp=make_extended(delta,p) in 
  for j:ss_rank(G) do 
  let ()=prints("root #:", j, "  type=", status_text(j,p), "/", ext_type(j,xp)) in 
   if is_imaginary(j,x(p)) then
{      let ()=prints("j=",j, " ,type= ", ext_type(j,xp)) in }
      let cayleys=ext_Cayley(j,xp) in 
      let ()=prints("testing Cayley transform of type ", ext_type(delta,j,p)) in 
       for xq@k in cayleys do 
       let valid=verify(xq) in if valid=false then rv#:=i else prints("Cayley transform ",k+1," is valid") fi od 
 fi od fi od;prints("number of failures:", #rv);rv

set test_Cayleys(mat delta,[Param] P)=test_Cayleys(delta,P,0,#P-1)

set test_2i12(mat delta,[Param] P, int start, int stop)=
let G=real_form(P[0]) in 
let rv=[] in
for i:stop-start+1 from start do
 let p=P[i] in 
 if (is_fixed(delta,p)) then 
 let xp=make_extended(delta,p) in 
  for j:ss_rank(G) do 
  if (ext_type(j,xp)="2i12") then 
  let ()=prints("parameter # ",i,": ") in
  let ()=prints(p) in
  let ()=prints("root #", j, " of type 2i12")  in 
  let q=cross(j,p) in 
  let ()=prints("p: ", p) in
  let ()=prints("q: ", q) in
  let xq=make_extended(delta,q) in 
  let cayleys_xp=ext_Cayley(j,xp) in 
  let cayleys_xq=ext_Cayley(j,xq) in 
  let ()=if not
     (verify(cayleys_xp[0]) and verify(cayleys_xp[1]) and verify(cayleys_xq[0]) and verify(cayleys_xq[1])) 
      then prints("one or more Cayley transforms are not valied");rv#:=i else prints("Cayley transforms are valid")  fi in
   let a=compare(cayleys_xp[0],cayleys_xq[0]) in
   let b=compare(cayleys_xp[1],cayleys_xq[1]) in
   prints("signs: ", a, ", ", b) 
fi od fi od;rv

set test_2i12(mat delta,[Param] P)=test_2i12(delta,P,0,#P-1)

set test_2Ci(mat delta,[Param] P, int start, int stop)=
let G=real_form(P[0]) in 
let rv=[] in
let signs1=[] in
let signs2=[] in
for i:stop-start+1 from start do
 let p=P[i] in 
 if (is_fixed(delta,p)) then 
 let xp=make_extended(delta,p) in 
  for j:ss_rank(G) do 
  if (ext_type(j,xp)="2Ci") then 
  let ()=prints("");prints("parameter # ",i,": ") in
  let ()=prints(p) in
  let ()=prints("root #", j, " of type 2Ci")  in 
  let ()=prints("p: ", p) in
  let cayley=ext_Cayley(j,xp)[0] in 
  let valid=verify(cayley) in 
  let ()=if (not valid) then rv#:=i fi in
  let ()=prints("Cayley transform is valid:", valid)  in
  let q=cross(j,p) in 
  let xq=make_extended(delta,q) in
  let cq=parameter(cayley) in 
  let ()=  if (cq=q) then prints("extended Cayley transform is consistent with cross action") else 
  prints("extended Cayley transform is NOT consistent with cross action") fi in
  let sign1=compare(cayley,xq) in 
  let ()=prints("sign relating Cayley and default:", sign1);signs1#:=(i,j,sign1) in
  let sign2=compare(ext_cross(j,xp),xp) in 
  prints("sign comparing double cross action of xp and xp:", sign2);signs2#:=(i,j,sign2)
fi od fi od;prints("number failures: ", #rv);(rv,signs1,signs2)

set test_2Ci(mat delta,[Param] B)=test_2Ci(delta,B,0,#B-1)

{for each fixed parameter p
compute xp=make_extended(delta,p)
ext_cross(j,xp) (j gets replaced by kappa(j) in W^delta of length 1, 2 or 3)
verify this is valid, and parameter(ext_cross(j,xp))=cross(kappa(j),p)
ext_Cayley(j,xp) where defined, verify these parameters
}
set big_test(mat delta, [Param] B, int start, int stop)=
let G=real_form(B[0]) in 
let rv=[] in
for i:stop-start+1 from start do
let ()=prints("") in
let p=B[i] in 
let ()=prints("parameter #", i, ", ", p) in     
if (is_fixed(delta,p)) then 
     let ()=prints("making xp") in
  let xp=make_extended(delta,p) in 
  let ()=prints("made xp") in
  let valid=verify(xp) in 
  let ()=if not valid then 
   prints("parameter from make_extended(p) is not valid");rv#:=i
   else prints("parameter from make_extended(p) is valid") fi in
  let ()=prints("checking extended cross action") in 
  let ()=for j:ss_rank(G) do 
    let kappa=kappa(G,delta,j) in 
    let xq=ext_cross(j,xp) in 
    let valid=verify(xq) in 
     let ()=if not valid then 
     prints("cross action extended parameter is not valid");rv#:=i
     else prints("cross action extended parameter is valid") fi in 
    let valid=parameter(xq) = cross(kappa,p) in 
     if not valid then 
      prints("extended cross action parameter doesn't match ordinary cross action");
      prints("ordinary cross action:", cross(kappa,p));
      prints("extended cross action:",  parameter(xq));
      prints("");prints("");
      rv#:=i
      else prints("ext cross action parameter matches ordinary cross action");
      prints("");prints("") fi 
  od in 1 fi od;prints("number of failures:", #rv);rv
set big_test(mat delta, [Param] B, int k)=big_test(delta,B,k,k)

set big_test(mat delta, [Param] B)=big_test(delta,B,0,#B-1)

set signs(mat delta, [Param] B, int start, int stop)=
let G=real_form(B[0]) in 
let rv=[] in
let cross_signs=[] in 
let cayley_signs=[] in
for i:stop-start+1 from start do
let p=B[i] in 
let ()=prints("parameter #", i, ", ", p) in     
if (is_fixed(delta,p)) then 
  let xp=make_extended(delta,p) in 
  let ()= for j:ss_rank(G) do 
    let kappa=kappa(G,delta,j) in 
    let xq=ext_cross(j,xp) in
    let sign=default_sign(xq) in 
    cross_signs#:=(i,j,ext_type(j,xp),sign) od{j} in
for k:ss_rank(G) do 
let type=ext_type(k,xp) in 
if (type ="1i1") then 
 let xq=ext_Cayley(k,xp)[0] in 
 let  sign=default_sign(xq) in
 cayley_signs#:=(i,k,type,sign) 
elif (type="1i2f") then
  let xq=ext_Cayley(k,xp) in 
  let xq0=xq[0] in
  let xq1=xq[1] in
  cayley_signs#:=(i,k,type,default_sign(xq0));
  cayley_signs#:=(i,k,type,default_sign(xq1))
elif (type="2Ci") then 
  let xq=ext_Cayley(k,xp)[0] in 
 cayley_signs#:=(i,k,type,default_sign(xq))
elif (type="2i11") then
  let xq=ext_Cayley(k,xp)[0] in 
  cayley_signs#:=(i,k,type,default_sign(xq))
elif (type="2i12" or type="2i22") then 
  let xq=ext_Cayley(k,xp) in 
  let xq0=xq[0] in
  let xq1=xq[1] in
  cayley_signs#:=(i,k,type,default_sign(xq0));
  cayley_signs#:=(i,k,type,default_sign(xq1))
fi {type}
 od{k} fi{is_fixed} od{i};(cross_signs,cayley_signs)


set signs(mat delta, [Param] B, int start)=signs(delta,B,start,start)
set signs(mat delta, [Param] B)=signs(delta,B,0,#B-1)

