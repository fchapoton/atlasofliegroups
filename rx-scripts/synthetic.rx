<basic.rx
<Weylgroup  
<parameters

{ using postive root indices allows using simple roots indices as well }
set posroot_reflection(RootDatum rd, int r) = mat: { r indexes root }
  1 - [root(rd,r)] * ^[coroot(rd,r)]

set rho_check_i (RootDatum rd, mat theta) = ratvec:
  sum(imaginary_poscoroots(rd,theta))/2

set rho_r (RootDatum rd, mat theta) = ratvec:
  sum(real_posroots(rd,theta))/2

set grading_coweight (KGBElt x) = ratvec: torus_factor(x) + rho_check_i(x)

{ alternative to KGB_elt that incorporates shift by rho_check_i }
set make_KGB(RealForm G, mat theta, ratvec grading_cowt) = KGBElt:
  KGB_elt(G,theta,grading_cowt - rho_check_i(G,theta))

{--------------------cross actions---------------------}

set cross (mat w, KGBElt x) = KGBElt:
  let theta=involution(x), G=real_form(x), w1=inverse(w)
  in make_KGB(G, w*theta*w1, grading_coweight(x)*w1 )

set posroot_cross (int i, KGBElt x) = KGBElt:
  cross(posroot_reflection(real_form(x),i),x)

{cross action of mat:w of Weyl group on parameters
assuming integral infinitesimal character, otherwise see nonintegral.rx
if w\in W(gamma) this is the usual cross action
if w\not\in W(gamma) this has different (dominant) infinitesimal character
}
set cross (mat w, Param p) = Param:
  let x0 = x(p), gamma = infinitesimal_character(p)
  then rd = root_datum(real_form(x0)),
  x1=cross(w,x0), grading_wt=gamma-lambda(p)+rho_r(x0)
  then theta1= involution(x1)
  then (new_gamma,)=make_dominant_using_roots(rd, w*gamma)
  in parameter(x1,new_gamma - w*grading_wt + rho_r(rd,theta1), new_gamma)

{--------------------Cayley transforms-------------------}

set posroot_Cayley (int i, KGBElt x) = KGBElt:
  let G=real_form(x), theta0=involution(x)
  then rd=root_datum(G)
  then beta = root(rd,i), theta3=posroot_reflection(rd,i)*theta0
  then (w,s) = make_simple(rd,beta) { root(rd,s) = w(beta) }
  then w1=inverse(w)
  then theta1 = w*theta0*w1 { involution for Cayley by root(rd,s) }
  then theta2 = posroot_reflection(rd,s)*theta1 { for simple imaginary Cayley }
  then diff1 = rho_check_i(rd,theta1)*w - rho_check_i(rd,theta0)
  ,    diff2 = rho_check_i(rd,theta2)*w - rho_check_i(rd,theta3)
  in KGB_elt (G, theta3, torus_factor(x) + diff1 - diff2)

set posroot_cross (int i, Param p) = Param:
  let x0 = x(p), gamma = infinitesimal_character(p)
  then rd = root_datum(real_form(x0))
  , x1=posroot_cross(i,x0), grading_wt=gamma-lambda(p)+rho_r(x0)
  then theta1= involution(x1), w=posroot_reflection(rd,i)
  in parameter(x1, gamma - w*grading_wt + rho_r(rd,theta1), gamma)

set posroot_Cayley (int i, Param p) = Param:
  let x0=x(p), gamma=infinitesimal_character(p)
  then G = real_form(x0), x3=posroot_Cayley(i,x0), theta0=involution(x0)
  then rd=root_datum(G), theta3=involution(x3)
  then ()= if denom(coroot(rd,i)*gamma)!=1
           then error("coroot is not integral for parameter")
           fi
  , id = integrality_datum(rd,gamma), beta=root(rd,i)
  then (w,s) = make_simple(id,beta)
  then w1=inverse(w)
  then theta1 = w*theta0*w1 { involution for Cayley by root(id,s) }
  then theta2 = posroot_reflection(id,s)*theta1 { for simple imaginary Cayley }
  then diff1 = w1*rho_r(id,theta1) - rho_r(rd,theta0)
  ,    diff2 = w1*rho_r(id,theta2) - rho_r(rd,theta3)
  in parameter(x3,lambda(p) + diff1 - diff2, gamma)

set posroot_inv_Cayley (int i, Param p) = Param:
  let x0=x(p), gamma=infinitesimal_character(p)
  then G = real_form(x0), x3=posroot_Cayley(i,x0), theta0=involution(x0)
  then rd=root_datum(G), theta3=involution(x3)
  then ()= if denom(coroot(rd,i)*gamma)!=1
           then error("coroot is not integral for parameter")
           fi
  , id = integrality_datum(rd,gamma), beta=root(rd,i)
  then (w,s) = make_simple(id,beta)
  then w1=inverse(w)
  then theta1 = w*theta0*w1 { involution for Cayley by root(id,s) }
  then theta2 = posroot_reflection(id,s)*theta1 { for simple imaginary Cayley }
  then diff1 = w1*rho_r(id,theta1) - rho_r(rd,theta0)
  ,    diff2 = w1*rho_r(id,theta2) - rho_r(rd,theta3)
  then projection = (1-theta3) * (gamma-lambda(p) - diff1 + diff2) /2
  in parameter(x3, gamma-projection, gamma)

{ some visualisation procedures }

set find ([Param] B, Param p) = int:
  let i = #B-1 in while i>=0 and B[i]!=p do i-:=1 od; i

set find_posroot (RootDatum rd, vec alpha) = int:
  let pr=posroots(rd) then i = n_columns(pr)-1
  in while i>=0 and pr[i]!=alpha do i-:=1 od; i

set concat ([string] l,string a, string b, string c) = string:
  let s = a then last=#l-1 in
  for t@i in l do s#:= t # if i=last then c else b fi od; s

set posroot_status (int i, Param p) = int:
  let rd=RootDatum: real_form(p) then st=status(root(rd,i),x(p)) in
  if st<=1 or st=4 then st { complex and imaginary compact cases keep old code }
  elif st=3 { imaginary non-compact }
  then if posroot_cross(i,p)=p then 7 else 6 fi { types i2, i1 respectively }
  elif not parity(p,coroot(rd,i)) then 5 { real nonparity }
  elif posroot_cross(i,p)=p then 2 else 3 { types r1, r2 respectively }
  fi

set new_block_line ([Param] B,int i) = string:
begin let p=B[i]
  then rd=root_datum(p), id = integrality_datum(p)
  then i_simple = for alpha in simple_roots(id) do find_posroot(rd,alpha) od
  then stats = for a in i_simple do posroot_status(a,p) od
  then line = concat(for st in stats do block_status_text(st) od ,"[",",","]")
  , v0(int alpha) = "(*,*)"
  , vi1(int alpha) = "(" + find(B,posroot_Cayley(alpha,p)) + ",*)"
  , vi2(int alpha) = let q=posroot_Cayley(alpha,p) in
          "(" + find(B,q) + ","+ find(B,posroot_cross(alpha,q))+")"
  , vr2(int alpha) = "(" + find(B,posroot_inv_Cayley(alpha,p)) + ",*)"
  , vr1(int alpha) = let q=posroot_inv_Cayley(alpha,p) in
          "(" + find(B,q) + ","+ find(B,posroot_cross(alpha,q))+")"
  in for alpha in i_simple
     do line #:= "  " + find(B,posroot_cross(alpha,p)) od
  ; for alpha@i in i_simple
     do line #:= "  " # [v0,v0,vr1,vr2,v0,v0,vi1,vi2][stats[i]](alpha) od
; line
end

{v,w are unnormalized torus factors
exp(2\pi i v)\xi is conjugate to exp(2\pi i w)\xi where \xi acts on H by theta
condition: v-w\in (1-theta)X_Q+X, equivalent to
 (1+theta)(v-w)\in (1-theta)X
Caution: when dealing with normalized torus factors need to divide by 2
see is_conjugate(x,y) below
}
set is_conjugate(ratvec v,ratvec w,mat theta)=bool:
let z=(1+theta)*(v-w) in 
if not is_integer(z) then false else
in_lattice((1+theta),ratvec_as_vec(z)) fi

{  generalized KGB elements: x^2 not necessarily central }

{KGBElt_gen(ic,theta,v)=exp(2\pi i v/2)\sigma_w\xi_0
Recall (see parameters.rx)
xi=exp(2\pi i*(torus_factor)/2)exp(rho^\vee/2)\sigma_w\xi_0
}

: KGBElt_gen=(InnerClass,mat,ratvec)
set inner_class    (KGBElt_gen(ic,,))    = InnerClass: ic
set involution     (KGBElt_gen(,theta,)) = mat:theta
set torus_factor   (KGBElt_gen(,,t))     = ratvec:t
set unnormalized_torus_factor   (KGBElt_gen(ic,,t))     =ratvec:(t+rho_check(ic))/2

{Note: square_is_central(KGB_elt y) gives the correct answer
=square_is_central(inner_class(y),involution(y), torus_factor(y))
square_is_central is defined in parameters.rx
Note: generalized KGB elements x,y are conjugate 
<=> is_conjugate(torus_factor(x)/2,torus_factor(y)/2,theta)=true
see discussion of unnormalized_torus_factor in parameters.rx
}

set =(KGBElt_gen x1,KGBElt_gen x2)=bool:
if not (inner_class(x1)=inner_class(x2) and involution(x1)=involution(x2)) then false
else is_conjugate(unnormalized_torus_factor(x1),unnormalized_torus_factor(x2),^involution(x1)) fi  
{
Dangerous bend: this formula appears to be right, with the 
unnormalized torus factors, no dividing by 2, and the transpose
I'm not 100% sure this is correct
}

set *(mat delta,KGBElt_gen(ic,theta,t))=KGBElt_gen:(ic,delta*theta*delta,t*delta)

set is_fixed(mat delta,KGBElt_gen y)=bool:y=delta*y






