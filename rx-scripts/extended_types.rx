{types of extended parameters: 
1C+,1C-,1i1,1i2f,1i2s,1ic,1r1f,1r1s,1r2,1rn
2C+,2C-,2Ci,2Cr,2i11,2i12,2i22,2r22,2r21,2r11,2rn,2rc
3C+,3C-,3Ci,3Cr,3i,3r,3rn,3ic}

{ext_length(rd,delta,j)=1,2,3}
set ext_length(RootDatum rd,mat delta, int j)=int:
let alpha=simple_roots(rd)[j] in 
let beta=delta*alpha in 
let alphavee=simple_coroots(rd)[j] in
if (alpha=beta) then 1 elif alphavee*beta=0 then 2 else 3 fi

{E=extended parameter, ext_length(j,E)=ext_length(ic(E),delta(E),j)}
set ext_length((int,(InnerClass,mat,ratvec,[int],mat,ratvec,[int],mat,[int],[int],rat,rat,ratvec))(j,(ic,delta,gamma,lambda,theta,g,l,omega,t,tau,central_shift)))=int:ext_length(ic,delta,j)

{ext_length has many cases, split cases by length}
{ext_type_1(delta,j,p)=1C+,1C-,1i1,1i2f,1i2s,1ic,1r1f,1r1s,1r2,1rn}
set ext_type_1(mat delta,int j,Param p)=string:
let type=status_text(j,p) in 
if type="i2" then 
 let q=Cayley(0,p) in if is_fixed(delta,q) then type+:="f" else type+:="s" fi
elif type ="r1" then
 let q=inv_Cayley(0,p) in if is_fixed(delta,q) then type+:="f" else type+:="s" fi  
fi;"1"+type

{ext_type_2(delta,j,p)=2C+,2C-,2Ci,2Cr,2i11,2i12,2i22,2r22,2r21,2r11,2rn,2rc}
set ext_type_2(mat delta,int j,Param p)=string:
let rd=root_datum(p) in 
let alpha=simple_roots(rd)[j] in
let beta=delta*alpha in 
let type=status_text(j,p) in 
let theta=involution(x(p)) in
let ext_type=
if is_complex(j,x(p)) then 
 if theta*alpha=beta then "2Ci"
 elif theta*alpha=-beta then "2Cr"
 else 2+type fi
elif (is_imaginary(j,x(p))) then 
 if (status_text(j,p)="ic") then "2ic" 
 elif (status_text(j,p)="i2") then "2i22" 
 else
 let k=get_simple_number(rd,beta) in 
 if status_text(k,Cayley(j,p))="i1" then "2i11" else "2i12" fi  fi
else
 if (status_text(j,p)="rn") then "2rn" 
 elif (status_text(j,p)="r1") then "2r11" 
 else
  let k=get_simple_number(rd,beta) in 
  if status_text(k,inv_Cayley(j,p))="r1" then "2r21" else "2r22" fi fi
 fi in ext_type

{ext_type_e(delta,j,p)=3C+3C-,3Ci,3Cr,3i,3r,3rn,3ic}
set ext_type_3(mat delta,int j,Param p)=string:
let rd=root_datum(p) in 
let alpha=simple_roots(rd)[j] in
let beta=delta*alpha in 
let type=status_text(j,p) in 
let theta=involution(x(p)) in
let ext_type=
if is_complex(j,x(p)) then 
 if theta*alpha=beta then "3Ci" 
 elif theta*alpha=-beta then "3Cr" 
 else 3+type fi
elif is_imaginary(j,x(p)) then
 if is_compact(j,x(p)) then "3ic" else "3i" fi
else 
 if status_text(j,p)="rn" then "3rn" else "3r" fi fi in ext_type

{ext_type(delta,j,p)=ext_type_i(delta,j,p) where i=ext_length(G,delta,j)}
set ext_type(mat delta,int j,Param p)=string:
if (not is_fixed(delta,p)) then"" else
let l=ext_length(root_datum(p),delta,j) in 
if l=1 then ext_type_1(delta,j,p) 
elif l=2 then ext_type_2(delta,j,p) 
else ext_type_3(delta,j,p)  fi fi

{E=extended parameter, ext_type(j,E)=ext_type(delta,j,parameter(E))}
set ext_type((int,(InnerClass,mat,ratvec,[int],mat,ratvec,[int],mat,[int],[int],ratvec))(j,(ic,delta,gamma,lambda,theta,g,l,omega,t,tau,central_shift)))=string:
ext_type(delta,j,parameter(ic,delta,gamma,lambda,theta,g,l,omega,t,tau,central_shift))

{E=extended parameter, ext_types=[ext_type(j,E)]}
set ext_types(InnerClass ic, mat delta, ratvec gamma, [int] lambda, mat theta, ratvec g, [int] l, mat omega, [int] t, [int] tau,ratvec central_shift)=[string]:for j:ss_rank(ic) do ext_type(j,(ic,delta,gamma,lambda,theta,g,l,omega,t,tau,central_shift)) od


