<basic.rx  { for assert, #@int,... }
<Weylgroup.rx

{ compute orbit of W(S).v: orbit of vector v under Weyl group
  under simple roots of S of root datum rd,

  algorithm: keep two lists and a counter
  words: list of elements of W
  orbit: list of vectors of orbit
  done: number of pairs in the above for which successors have been computed
  iteratively, set (w,y)= = (W_word,vec) pair at index done; advance done
  apply each simple reflection j from S to y
  if s_j.y is not in orbit
    add  s_j.y to orbit and (s_j*w,s_j.y) to todo
    delete (w,y) from todo
  continue until todo is empty

  returns: where orbit is list of vectors of orbit,
  and for each i one has act(rd,words[i],x)=orbit[i]
}

set generate ([(vec->vec)] S,vec v) = ([W_word],[vec]):
  let words=[W_word]:[[]], orbit=[v], done=0
  then absent (vec y) = bool:
         let i=#orbit-1 in while i>=0 and y!=orbit[i] do i-:=1 od; i<0
  in
  while done<#orbit
  do
    let w = words[done], a=orbit[done] in
    done+:=1
  ; for f@i in S
    do let b= f(a) in
      if absent(b) then ( words #:= i#w, orbit #:= b ) fi
    od
  od; (words,orbit)

set W_orbit_extra (RootDatum rd,[int] S,vec v) = ([W_word],[vec]):
  generate(for i in S do (vec x) vec: reflect(rd,i,x) od, v)

{ just the W(S)-orbit W.v }
set W_orbit((RootDatum,[int],vec) triple) = [vec]:
  let (,orbit) = W_orbit_extra(triple) in orbit

{ just the coset representatives for the stabilizer of v }
set W_orbit_W_elements((RootDatum,[int],vec) triple) = [W_word]:
  let (W_elements,)=W_orbit_extra(triple) in W_elements

{ assume S=all simple roots }
set W_orbit_extra(RootDatum rd,vec v) = ([W_word],[vec]):
  generate(for i:semisimple_rank(rd) do (vec x) vec: reflect(rd,i,x) od,v)
set W_orbit((RootDatum,vec) pair) = [vec]:
  let (,orbit) = W_orbit_extra(pair) in orbit
set W_orbit_W_elements((RootDatum,vec) pair) = [W_word]:
  let (W_elements,) = W_orbit_extra(pair) in W_elements

{ all Weyl group elements of W(rd) or W(G), in no particular order }
set generate_W (RootDatum rd) = [W_word]:
  W_orbit_W_elements(rd,numer(rho(rd)))

{ orbit of <w_1,..,w_n> acting on v where w_i is an element of W (W_word),
  (not always a simple reflection). Use: for W^{\delta}-orbit of a root
}
set W_orbit_extra (RootDatum rd,[W_word] S,vec v) = ([W_word],[vec]):
  generate(for g in S do (vec x) vec: act(rd,g,x) od, v)

{ find Weyl group element x in <S> taking v to w
  returns (true,x) or (false,null(0))
}
set conjugate_to(RootDatum rd, [W_word] S, vec v,vec w) = (bool,vec):
( let (words,orbit) = W_orbit_extra(rd,S,v), i=0 in
  while i>=0 and orbit[i]!=w do i-:=1 od
; if i>=0 then (true,words[i]) else (false,null(0)) fi
)
