<LKT.rx
{Conversions between three ways of parametrizing K-types, see LKT.rx

1. KParam: (x,lambda), call these K-types
2) KHighestWeight: (x,mu), x in distinguished fiber, mu in X^*(H^delta) call these highest_weights
3) LKT as parameters for K_0: Param (for K_0), call these K_0_reps
}
{------------map from KParams (K-types) to highest weights-----------}

{see LKT_highest_weights(...) in LKT.rx}

{-----------------------Vogan algorithm---------------------}

{project vector mu on dominant cone (spanned by positive sums of fundamental coweights)
 algorithm from KHatHowe Section 13, modification of BGB Proposition 5.3.3
 used in map from highest weights to LKT below
}

set centralizer(KGBElt x,ratvec v)=
assert(^involution(x)*v=v, "v is not theta-stable");
let rd=root_datum(x) then
pr=posroots(rd) then
pcr=poscoroots(rd) then
(roots,coroots)=([vec]:[],[vec]:[]) then
()=for alpha@i in pr do 
 if alpha*v=0 then roots#:=pr[i];coroots#:=pcr[i] fi od then
 subrd=if #roots !=0 then 
  root_datum(simple_from_positive(roots,coroots)) 
 else 
  root_datum([vec]:[],[vec]:[],rank(rd)) fi in 
 (KGB_elt(subrd,involution(x),torus_factor(x)),subrd)

set find_nci_root(KGBElt x,ratvec tau)=
let rd=root_datum(x) then
sr=simple_roots(rd) then
scr=simple_coroots(rd) then
j=first(ss_rank(rd),(int i)bool:scr[i]*tau<0 and (is_noncompact(x)(sr[i]))) in 
if j!=-1 then j else
let j=first(ss_rank(rd),(int i)bool:scr[i]*tau<0 and 
(is_complex(i,x) 
   and sr[i]*^involution(x)*simple_coroots(rd)[i]=-1   {<alpha,theta(alpha^vee)>=-1}
   and is_noncompact(x)(sr[i]+involution(x)*sr[i]))) in root_index(rd,sr[j]+involution(x)*sr[j]) fi

{(x,mu) is a KHighestWeight (see top of this file)
 x in the distinguished fiber, theta_x=delta
 mu\in X^*, viewed modulo (1-delta)X^*
in (X^*)^delta project it to X^*(T_K0) where T_K0=identity component of H^delta}
{(x,mu) equivalent to (wx,w\mu) so WLOG mu is G-dominant}


{This is the Vogan algorithm, version in khatHowe Section 13,
which is a slight modification of BGB Proposition 5.3.3
given (x,mu) -> mu+2rho_K(x) -> choose positive chamber for G -> mu+2rho_K(x)-rho
 project on given dominant chamber
 returns (x,mu_2rho_K(x)-rho,tau) where tau is dominant
 need the second argument for the modified Vogan algorithm
 }
set project_on_dominant_cone(KGBElt x, ratvec mu)=(KGBElt,ratvec,ratvec):
let rd=root_datum(x) then
mu=(1+involution(x))*mu/2 then
(mu_1,w)=make_dominant(rd,mu) then
x_1=cross(inverse(w),x) in 
let ()=prints("mu_1:", mu_1);
prints("x_1: ", x_1) in 
{Note: tworho_K_fixed(x) (above) is in (\h^*)^theta, while rho_K(x) is in \t^*, need the former}
let mu_2=mu_1+tworho_K_fixed(x_1) in
let ()=prints("mu_2:", mu_2) in
let (,y)=make_dominant(rd,mu_2) in
let x_2=cross(inverse(y),x_1) in
let ()=prints("y=", y) in
let ()=prints("x_2=", x_2) in
let rho=act(y,rho(rd)) then
mu_3=mu_2-rho in
let ()=prints("mu_3=", mu_3) in
let rec_fun f(KGBElt x, ratvec mu_3_orig,ratvec tau)=(KGBElt,ratvec,ratvec):
let rd=root_datum(x) in
let ()=prints();prints("f with: ", x, " ", real_form(x), " tau= ", tau) in
let ()=prints("rd:", rd) in
let ()=prints("tau=",tau) in
let ()=prints("x=",x) in
if is_dominant(rd,tau) then  (x_2,mu_3_orig,tau) else
let j=find_nci_root(x,tau) then
()=prints("got root: ", j, ", ", posroots(rd)[j]) then
()=prints("beta=", posroots(rd)[j]) then
new_tau=tau-poscoroots(rd)[j]*tau*posroots(rd)[j]/2 then
()=prints("new_tau=",new_tau) then
(sub_x,sub_rd)=centralizer(x,poscoroots(rd)[j]) in
f(sub_x,mu_3_orig,new_tau) fi in f(x_1,mu_3,mu_3)

set project_on_dominant_cone(KGBElt x, vec mu)=(KGBElt,ratvec,ratvec):project_on_dominant_cone(x,ratvec:mu)


{uses the Vogan algorithm, see project.rx}

{-----------------------map from highest weights to K-types---------------------}
{possibly multivalued, coming from G-spherical case}

{characters_order_2@KGBElt
returns [v_0,...,v_k], v_i\in X^*, 
the characters of H^{theta_x} with differential 0
are \sum a_i v_i with a_i=0,1 (or [] -> [0,...,0])
}
set characters_order_2(KGBElt x)=[vec]:
let theta=involution(x) then
zero_vector=vec:null(rank(real_form(x))) {default value} then
K=kernel(1+theta) then
(r,c)=#K in
if c=0 then [vec]:[]  else let
M=submodule_basis(K,1-theta) in
if #M=0 then [vec]:[] else let
(A,v)=adapted_basis(M) then
B=K*A in
{prints("K=",K);
prints("A=",A);
prints("v=",v);
prints ("B=",B);}
let rv=[vec]:[]
 in 
 for i:#v do if v[i]=2 then rv#:=B[i] fi od;
rv fi fi


set all_G_spherical_same_differential(KParam p)=
{assert(is_split_spherical(p),"parameter is not spherical for a (relatively) split group");}
let chars=characters_order_2(x(p)) then
coeffs=generate_all_binary(#chars) then
scr=simple_coroots(root_datum(p)) then
rv=[KParam]:[] in
 for v in coeffs do 
 let mu=vec:null(rank(root_datum(x(p)))) in
  for j:#v do mu+:=v[j]*chars[j] od; 
  if all(for alpha_check in scr do is_even(alpha_check*mu) od) then rv#:=(x(p),lambda(p)+mu) fi od;rv

set all_G_spherical_same_differential(Param p)=all_G_spherical_same_differential(Kparameter(p*0))

{see KHatHowe, end of Section 13
 mu-> phi=mu_2rho_c-rho-lambda (=lambda-mu_3_orig from project_on_dominant_cone)
 write phi is a non-negative rational combination of simple roots
 the simple roots with strictly positive coefficient give the Levi factor L, 
 and q=l+u is the corresponding standard parabolic
}
set highest_weight_to_parabolic(KHighestWeight (x,mu))=
let rd=root_datum(x) then
(y,mu_3_orig,lambda)=project_on_dominant_cone(x,mu) then
diff=lambda-mu_3_orig then
S=[int]:[] in
let ()=for i:ss_rank(rd) do if fundamental_coweight(rd,i)*diff>0 then S#:=i fi od
in parabolic(S,y) 

{go from highest weight to K_types [KParam]  mu -> [p_1,...,p_r]
 multivalued: LKT_highest_weight(p_i)=mu 
 algorithm: 
 1) G-spherical case: mu\in X^*/(1-delta)X^*, satisfying <mu,\alpha^\vee>=0 
    for all alpha in Delta(G,T_{K_0})<
}
set fix(KHighestWeight mu)=KHighestWeight:
let (x,tau)=mu then
i_root_system=root_datum(simple_imaginary_subsystem(x)) in
let (tau_dom,w)=make_dominant(i_root_system,tau) in 
(cross(inverse(w),x),tau_dom)

set highest_weight_to_K_types(KHighestWeight mu)=[KParam]:
let mu=fix(mu) in
let ()=assert(mu=fix(mu),"error: mu\ne fix(mu)") in
let (x,mu)=mu in
let (y,mu_3_orig,dlambda)=project_on_dominant_cone(x,mu) then
Q=highest_weight_to_parabolic(x,mu) then  {Q is theta-stable}
L=Levi(Q) then  {L is relatively split}
()=prints("mu:", mu) then
()=prints("dlambda:", dlambda) then
()=prints("L=", L) then
()=prints("rho_u_cap_s(Q)", rho_u_cap_s(Q)) then
()=prints("rho_l(Q)", rho_l(Q)) then
()=prints("arg:", mu-2*rho_u_cap_s(Q)+rho_l(Q)) then
()=assert(is_relatively_split(L),"L is not relatively split") then
pL=parameter(KGB(L,#KGB(L)-1), mu-2*rho_u_cap_s(Q)+rho_l(Q), null(#dlambda))  then
pL=finalize(pL) then
()=prints("pL:", pL) then
rv=[KParam]:[] then
()=assert(#pL=1,"finalized parameter has more than one term")  then
all_pL=all_G_spherical_same_differential(pL[0]) in
for qL in all_pL do 
{ let ()=prints("qL:", qL) in}
 let ind=monomials(induce_standard(parameter(qL),Q,real_form(x))) then 
 ()=assert(#ind=1,"induced has more than one term") in
 rv#:=Kparameter(ind[0]) od;rv

set highest_weight_to_K_type(KHighestWeight(x,mu))=KParam:
let ktypes=highest_weight_to_K_types(x,mu) in
assert(#ktypes=1,"more than one K-type maps to this KHighestWeight; use highest_weight_to_K_types to get them all");ktypes[0]


{------------------convert between weights of H and weights of T_K----------}

{given mu in X^*(T_K)=X^*(H)/(1-delta)X^*(H), choose representative in X^*(H)
giving a KHighestWeight (x,mu)
cannot necessarily take mu to be \delta-fixed
}

set H_weight(KGBElt x,vec mu_K)=KHighestWeight:(x,vec:mu_K*left_inverse(injection_from_K_matrix(x)))

{this may be a ratvec, not vec}
set fundamental_weights_K_H(KGBElt x)=[ratvec]:
let M=left_inverse(injection_from_K_matrix(x)) in for v in fundamental_weights(K_0(x)) do v*M od

{---------------- K-type as parameter for the identity component of K----------------}

set LKT_K0(KParam p,KGBElt x_K)=Param:
let (,tau)=LKT_highest_weight(p,x_K) in finite_dimensional(K_0(x_K),tau) 

set LKT_K0(KParam p)=Param:LKT_K0(p,KGB(real_form(x(p)),0))

set LKT_K0(Param p,KGBElt x_K)=[Param]:
for (,tau) in LKT_highest_weights(p,x_K) do finite_dimensional(K_0(x_K),tau)  od

set LKT_K0(KParam p)=Param:LKT_K0(p,KGB(real_form(x(p)),0))

{ mu is a highest weight for K_0=identity component of K_x
  returns fundamental weight coordinates
}
set fundamental_weight_coordinates (vec mu, KGBElt x) = vec:mu*simple_coroots(K_0(x))

{if possible, take weight of K_0, in fundamental weight coordinates, to KHighestWeight (x,mu)}
set K_highest_weight_from_fundamental_weights(KGBElt x,vec tau)=
let K_0=K_0(x) then
fw=fundamental_weights_K_H(x) then
weight=ratvec:null(rank(real_form(x))) then
()=for i:#tau do weight+:=tau[i]*fw[i] od in
assert(is_integer(weight),"Weight is not integral");(x,ratvec_as_vec(weight))





set LKT_dimensions (Param p, KGBElt x_K) = [int]:for pi in LKT_K0(p,x_K) do dimension(pi) od
set LKT_dimensions (Param p) = [int]:   LKT_dimensions(p,KGB(real_form(p),0))
set LKT_dimensions ([Param] B)= [[int]]: for p in B do LKT_dimensions(p) od


{			    sorting by dimension			}

set sort_by_dimension = ([(Split,Param)] -> [(Split,Param)]):
 sort_by( (Split s,Param p) int: LKT_dimensions(p)[0] )