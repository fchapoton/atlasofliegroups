{ KL stuff, including character formulas and composition series
  This implementation seeks to avoid using KL_block, and instead uses
  KL_sum_at_s as mush as possible, as this function stores earlier results
  Also (compared to old implementation) no regular/singular case distinction
}

<misc.rx

{
  Basic object: column of KL matrix (P-matrix), of polynomials evaluted as s,
  which by setting s=1 gives formula for irreducible as sum of standards

  main functions:

  KL_mat_at_one(p): P-matrix evaluated at 1 (integral matrix)
  KL_singular_inverse_mat_at_one(p): Q-matrix evaluated at 1
  character_formula(p): irreducible(p) as sum of standards
  composition_series(p): standard(p) as sum of irreducibles

  also
    print_character_formula,print_composition_series
}

{ ------------------------------------------------------------------- }

{ basic definitions, not usually called by the user }

set s_to_1(Split x) = int: +%x        { let (a,b)=%x in +(a,b) }
set s_to_minus_1(Split x) = int: -%x  { let (a,b)=%x in -(a,b) }

set s_to_1(ParamPol p) = null_module(real_form(p)) + for x@q in p do (+%x,q) od
set s_to_minus_1(ParamPol p) =
  null_module(real_form(p)) + for x@q in p do (-%x,q) od

{ variants that multiply a parameter-dependent factor into each term }
set s_to_1(ParamPol p, (Param->int) f) =
  null_module(real_form(p)) + for x@q in p do (f(q)*+%x,q) od
set s_to_minus_1(ParamPol p, (Param->int) f) =
  null_module(real_form(p)) + for x@q in p do (f(q)*-%x,q) od

{ addition of vectors (overrides definition in basic.rx) to allow vectors of
  possibly different lengths, implicitly extending on the right by zeros as
  needed. This gives the right thing for coefficient vectors of polynomials. }
set +(vec v,vec w)= vec:
  let add_ext =
    (vec v, vec w, int l_w) vec: { add w to v under assumption l_w=#w<=#v }
      for vi@i in v do if i<l_w then vi+w[i] else vi fi od
  , a=#v, b=#w
  in add_ext(if a>=b then (v,w,b) else (w,v,a) fi)

set strip (vec v) = vec: { reduce polynomial by dropping trailing zeros }
( let k=#v in
  while k>0 and v[k-1]=0 do k -:=1 od
; if k=#v then v else for i:k do v[i] od fi
)

{ ------------------------------------------------------------------- }

{-------------------------------------------------------------------}

set character_formula (Param p) = ParamPol: s_to_1(KL_sum_at_s(p))

{-------------------------------------------------------------------}

{ composition series }

set composition_series (Param p) = ParamPol:
( let block=partial_block(p)
  , result= null_module(real_form(p)), acc=ParamPol: p in
  for i:#block downto 0
  do let coef = acc[block[i]] in
    if coef!=0
    then result +:= (coef,block[i])
     ; acc +:= (-coef)*character_formula(block[i])
    fi
  od
; if #acc>0
  then error("Internal error: Failed to completely decompose module")
  fi
; result
)

{ some printing functions }

{ make a printable string out of a polynomial and name of indeterminate,
  for use in other print functions }
set stringPoly (vec v, string q)= string:
  if #(v:=strip(v))=0 then "0"
  else
    let rv="" in
    for c@k in v do
      if c!=0 then
	let coef = if c<0 then "-" else "+" fi #
            if abs(c)=1 and k>0 then "" else int_format(abs(c)) fi
	,   term = if k>1 then q#"^"#int_format(k) elif k=0 then "" else q fi
	in rv #:= coef#term
      fi
    od
  ; rv
  fi

{ nice printing of a polynomial }
set printPoly (vec v)= void: prints(stringPoly(v,"q"))

{ nice printing of a column of KL matrix of polynomials }
