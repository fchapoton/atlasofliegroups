set first (int n)= for i = n do i od  # [0,1,...,n-1]

set string_rep(string s, int n)=
let r="" in (for i = n do r:=r+s od; r)

set sm_prod(int c,mat m) = mat: for col in m do for e in col do c*e od od

# Cartan matrix information for positions at distance d(<=2) off diagonal
set Cartan_dispatch(int type, int r, int min, int d, bool lower)=
if d=0 then 2    # diagonal entry
elif type=4 then # Dn
 if if min<r-3 then d=1 else min=r-3 fi then -1 else 0 fi
elif type=5 then # En
 if d=if min<2 then 2 else 1 fi then -1 else 0 fi
elif d=2 then 0  # nodes far apart in liear diagrams
elif type<4 then # classical linear diagrams
 if type = if lower then 2 else 3 fi and min=r-2 then -2 else -1 fi
elif type=6 then if lower and min=1 then -2 else -1 fi # F4
elif lower then -1 else -3 # G2
fi

set simple_Cartan_entry(int type, int r,int i, int j)=
if type=0 then 0 # null Cartan entries for torus factors
else let (min,d) = if i<j then (i,j-i) else (j,i-j) fi
     in  if d>2 then 0 else Cartan_dispatch(type,r,min,d,i<j) fi
fi

set simple_Cartan_matrix(int type, int r)= mat:
for j = r
do for i = r
   do simple_Cartan_entry(type,r,i,j)
   od
od

set simple_Lie_type((int,int) p) =
  let (type,) = Cartan_matrix_type(simple_Cartan_matrix(p)) in type

set GL_roots (int n) = [vec]:
for i = n-1
do for j = n
   do if j=i then 1 elif j=i+1 then -1 else 0 fi od
od

set SL_coroots (int n) = [vec]:
for i = n-1
do for j = n-1
   do if j=i then 1 elif j=i+1 then -1 else 0 fi od
od

set SL_roots (int n) = [vec]:
for col@j in SL_coroots(n)
do if j<n-2 then col
   else for e in col do e+1 od
   fi
od

set GL_datum(int n)= let r=GL_roots(n) in root_datum(r,r,n)
set SL_datum(int n)= root_datum(SL_roots(n),SL_coroots(n),n-1)

set type_B_roots (int n) = [vec]:
for i = n
do if i<n-1
   then for j = n
        do if j=i then 1 elif j=i+1 then -1 else 0 fi od
   else for j = n do if j<n-1 then 0 else 1 fi od
   fi
od

set type_C_roots (int n) = [vec]:
for i = n
do if i<n-1
   then for j = n
        do if j=i then 1 elif j=i+1 then -1 else 0 fi od
   else for j = n do if j<n-1 then 0 else 2 fi od
   fi
od

set type_D_roots (int n) = [vec]:
if n<2 then [] # SO(2) is pure torus
else
  for i = n
  do if i<n-1
     then for j = n
          do if j=i then 1 elif j=i+1 then -1 else 0 fi od
     else for j = n do if j<n-2 then 0 else 1 fi od
     fi
  od
fi

set SO_datum(int n)=
let m=n\2 in
if n%2=1
then root_datum(type_B_roots(m),type_C_roots(m),m)
else let r=type_D_roots(m) in root_datum(r,r,m)
fi

set Sp_datum(int n)=
let m=n\2 in root_datum(type_C_roots(m),type_B_roots(m),m)

set su(int p,int q)=
let n=p+q, q = if p<q then p else q fi
; rd = SL(n)
; ic = inner_class(rd,if n>1 then "c" else "" fi)
in real_form(ic,q)

set so(int p,int q)=
let n=p+q, (p,q) = if p<q then (q,p) else (p,q) fi # make q the smallest one
; rd = SO_datum(n)
, inv = let M=id_mat(n\2)
        in (if p%2=1 and q%2=1 then M[n\2-1,n\2-1]:=-1 fi; M)
, i = if n<=2 then 0        # inner classes without noncompact form, SO(2)=T1
      elif n%2=1 then q     # type B_{n\2}
      elif q%2=1 then q\2   # type D_{n\2}, unequal rank
      elif q\2<n\4 then q\2 # type D_{n\2}, equal rank, more compact forms
      elif n%4=2 then q\2+1 # type D_{n\2}odd, equal rank, more split forms
      else q\2+2            # type D_{n\2}even, equal rank, more split forms
      fi
in real_form(inner_class(rd,inv),i)
