set # (int n)= [int]: for i:n do i od       { [0,1,...,n-1] }
set # (bool b) = int: if b then 1 else 0 fi { Iverson symbol }
set # (ratvec v)= int: let (n,)=%v in #n    { length }

set ^ = !=@(bool,bool) { exclusive or }

{ bitsets encoded as functions (int->bool) and upper bound limit }

set list ((int->bool) filter, int limit) = [int]:
  let result=[int]:[]
  in for i:limit do if filter(i) then result#:=i fi od; result
set complement ((int->bool) filter, int limit) = [int]:
  let result=[int]:[]
  in for i:limit do if not filter(i) then result#:=i fi od; result

set count ((int->bool) filter, int limit) = int:
  let c=0 in for i:limit do if filter(i) then c+:=1 fi od; c

set all ((int->bool) filter, int limit) = bool:
  while limit-:=1; limit>=0 and filter(limit) do () od; limit<0
set none ((int->bool) filter, int limit) = bool:
  while limit-:=1; limit>=0 and not filter(limit) do () od; limit<0


{				Integers				}

{ absolute value and sign of integer}
set abs (int k)= int: if k<0 then -k else k fi
set sign (int k)= int: if k<0 then -1 elif k=0 then 0 else 1 fi

set odd  (int n) = bool: n%2=1
set even (int n) = bool: n%2=0

set min (int k, int l) = int: if k<l then k else l fi
set max (int k, int l) = int: if k<l then l else k fi

set =  ((int,int)(x0,y0),(int,int)(x1,y1)) = bool: x0=x1 and y0=y1
set != ((int,int)(x0,y0),(int,int)(x1,y1)) = bool: x0!=x1 or y0!=y1


{			    Rational numbers				}

set numer (rat a) = let (n,)=%a in n
set denom (rat a) = let (,d)=%a in d

set floor (rat a) = int: \ %a     { decompose, then integer division }
set ceil  (rat a) = int: -\ %-a   { same, sandwiched in negations }

set \((rat,int)p) = int: floor(/p)
set \((rat,rat)p) = int: floor(/p)

{ these are mostly for ratvec arguments, but avoid coercing from vec }
set floor ([rat] v) = vec: for a in v do floor(a) od
set ceil  ([rat] v) = vec: for a in v do  ceil(a) od

{ make a rational into an integer if possible }
set rat_as_int (rat r) = int:
  let (n,d)=%r in if d=1 then n else error("Not an integer") fi

{				Strings					}

set new_line = ascii(10) { including this in a string passes to a new line }

set + (string s,string t) = string: s # t { alias for concatenation }
set * (string s, int n)= string: let r="" in (for i:n do r#:=s od; r)

set + (string s, int i)= string: s # int_format(i)
set + (int i, string s)= string: int_format(i) # s

set + (string s, (int,int)(x,y)) = s + "(" + x + "," + y + ")"


{				Vectors					}

set vector(int n,(int->int)f) = vec: for i:n do f(i) od

set ones (int n)= vec: for i:n do 1 od

{ for computing greatest common divisors, inv_fact can do most of the work }
set gcd ([int] v)= int:
  let f=inv_fact(stack_rows([v])) in if #f=0 then 0 else f[0] fi

set raw_add (vec v,vec w)= vec:  for e@i in v do e+w[i] od
set raw_sub (vec v,vec w)= vec:  for e@i in v do e-w[i] od

set + ((vec,vec) (v,w):p)= vec:
  if #v != #w then error("Size mismatch " + #v + ":" + #w) else raw_add(p) fi
set - ((vec,vec) (v,w):p)= vec:
  if #v != #w then error("Size mismatch " + #v + ":" + #w) else raw_sub(p) fi

{ scalar multiplication }
set * (int c,vec v) = vec: for e in v do c*e od
set * (vec v,int c) = vec: for e in v do c*e od
set - (vec w)= vec: for e in w do -e od

{ integer division }
set \ (vec v,int d) = vec: for x in v do x\d od

{ entrywise modulo }
set % (vec v,int d) = vec: for x in v do x%d od

{ sum, product of entries }
set sum (vec v)= let s=0 in for e in v do s+:=e od; s
set product (vec v)= let s=1 in for e in v do s*:=e od; s

set reverse (vec v)= vec: for i:#v downto 0 do v[i] od
set lower (int k,vec v)= vec: for i:k do v[i] od
set upper (int k,vec v)= vec: for i:#v-k from k do v[i] od

set is_member (vec v) = (int->bool):
  let start = #v-1
  in (int val)bool: let i=start in while i>=0 and v[i]!=val do i-:=1 od; i>=0

set contains (int val) = (vec->bool): (vec v)bool: is_member(v)(val)

{				Matrices				}

set matrix ((int,int)(r,c),(int,int->int) f) = mat:
  r#for j:c do for i:r do f(i,j) od od

set n_rows (mat m)= int: let (r,)=#m in r
set n_columns (mat m)= int: let (,c)=#m in c

set column (vec v) = mat: [v] { interpret v as single column }
set row (vec v)    = mat: ^v  { interpret v as single row }

set + (mat M,mat N)= mat:
  let (n,):sm = #M, sn = #N
  in if sm != sn then error("Size mismatch " + sm + ":" + sn)
     else n # for col@j in M do raw_add(col,N[j]) od
     fi
set - (mat M,mat N)= mat:
  let (n,):sm = #M, sn = #N
  in if sm != sn then error("Size mismatch " + sm + ":" + sn)
     else n # for col@j in M do raw_sub(col,N[j]) od
     fi

{ apply a function to all matrix entries }
set map_on (mat m) = ((int->int)->mat):
  let nr = n_rows(m)
  in ((int->int)f) mat: nr # for c in m do for e in c do f(e) od od

{ scalar multiplication }
set * (int c,mat m) = mat: map_on(m)((int e) int: c*e)
set - (mat m)= mat: map_on(m)(-@int)

{ integer division }
set \ (mat m,int d) = mat: map_on(m)((int e) int: e\d)

{ entrywise modulo }
set % (mat m,int d) = mat: map_on(m)((int e) int: e%d)

{ matrix exponentiation }
set ^ =
  let matrix_power (mat m,int n)= mat: m { dummy for recursion } in
  begin matrix_power := { assign recursive function body }
    ( (mat m,int n): { we hall have n>0 }
      if n=1 then m
      else let (q,r)=n\%2 then mm=matrix_power(m,q) in
	mm*if r=0 then mm else mm*m fi
      fi
    )
  ; ( { operator ^ = } (mat m,int n) mat:
      if n>0 then matrix_power(m,n) elif n=0 then id_mat(n_rows(m))
      else error("Negative matrix power "+n)
      fi
    )
  end

set inverse (mat M) = mat:
  let (inv,d)=invert(M) in
  if d=1 then inv else error("Matrix not invertible over the integers") fi

set det (mat M) = int:
  let (diag,,)=diagonalize(M), (n,):shape = #M
  then () = if != shape then error("Determinant of non-square matrix") fi
  in
    if #diag<n then 0 { there is at least one zero on the diagonal }
    else product(diag) { otherwise multiply out }
    fi

{ surprisingly coercion allows, and does not provide, the following overload }
set # (mat A, mat B) = mat: { concatenate horizontally, must have same depth }
   n_rows(B)#(([vec]:A)#([vec]:B))

set columns_with ((int,vec->bool) p,mat m) = mat:
  let res = [vec]: [] in
  for col@j in m do if p(j,col) then res #:= col fi od; n_rows(m)#res
set columns_with ((vec->bool) p,mat m) = mat:
  columns_with (((int,vec)(,col))bool: p(col),m)
set columns_with ((int->bool) p,mat m) = mat:
  columns_with (((int,vec)(j,))bool: p(j),m)

set rows_with ((int,vec->bool) p,mat m) = mat:
  let res = [vec]: [] in
  for row@i in ^m do if p(i,row) then res #:= row fi od; n_columns(m)^res
set rows_with ((vec->bool) p,mat m) = mat:
  rows_with (((int,vec)(,row))bool: p(row),m)
set rows_with ((int->bool) p,mat m) = mat:
  rows_with (((int,vec)(i,))bool: p(i),m)

set lookup (vec v,mat m) = int:
  let i=n_columns(m)-1 in while i>=0 and m[i]!=v do i-:=1 od; i

{ sum of columns of a matrix }
set sum (mat m)= vec: m*ones(n_columns(m))

set oneplus(mat M)= mat: 1+M
set oneminus(mat M)= mat: 1-M

{			    Rational vectors				}

set numer (ratvec a) = vec: let (n,)=%a in n
set denom (ratvec a) = int: let (,d)=%a in d
set * (int i,ratvec v) = ratvec: v*i
set * (rat r,ratvec v) = ratvec: v*r

{ extend built-in scalar product of vectors to rational vector case }
set * (ratvec v, ratvec w) = rat: let (nv,dv)=%v,(nw,dw)=%w in nv*nw/(dv*dw)

set * (vec v, ratvec w) = rat: let (nw,dw)=%w in v*nw/dw { more efficient }
{ cannot also define: *(ratvec v, vec w) = rat: let (nv,dv)=%v in nv*w/dv }

{ make a rational vector into an integer one if possible }
set ratvec_as_vec(ratvec v) = vec:
  let (w,d)=%v in if d=1 then w else error("Not an integer vector") fi



{			    Split integers				}

set s = Split:(0,1)
set + (Split x) = let (r,)=%x in r { real part }
set ^ (Split x) = let (,y)=%x in y { s part }

set ^ = { exponentiation of split integers }
  let split_power (Split x,int n) = Split: x { dummy }
  then () = split_power := ((Split x,int n): { we shall have n>0 }
    if n=1 then x
    else let (q,r)=n\%2 then y=split_power(x,q) in y*if r=0 then y else x*y fi
    fi)
  in { set ^ = } (Split x,int n): Split:
    if n>0 then split_power(x,n) elif n=0 then Split:(1,0)
    elif let (a,b)=%x in abs(a)+abs(b)=1 then if n%2=0 then 1 else x fi
    else error("Negative power "+n+" of split integer")
    fi

set - (ParamPol a, (Split,Param) (c,p)) = ParamPol: a+(-c,p)


{				Root data 				}

{ backwards compatibility function; used to be the built-in prototype }
set root_datum ([vec] simple_roots, [vec] simple_coroots, int r) = RootDatum:
  root_datum(r#simple_roots,r#simple_coroots)

set root_datum (LieType t, [ratvec] gens) = RootDatum:
  root_datum(t,quotient_basis(t,gens))

{ allow single kernel generator in root datum construction }
set root_datum (LieType t, ratvec gen) = RootDatum: root_datum(t,[gen])

set is_root((RootDatum,vec) (rd,):p) = bool:
  root_index(p)<nr_of_posroots(rd)
set is_coroot((RootDatum,vec) (rd,):p) = bool:
  coroot_index(p)<nr_of_posroots(rd)
set is_posroot((RootDatum,vec)(rd,):p) = bool:
  let ri=root_index(p) in ri>=0 and ri<nr_of_posroots(rd)
set is_coposroot((RootDatum,vec)(rd,):p) = bool:
  let cri=coroot_index(p) in cri>=0 and cri<nr_of_posroots(rd)

set posroot_index((RootDatum,vec)p) = int: { fold roots to positive }
  let i=root_index(p) in if i<0 then -1-i else i fi
set poscoroot_index((RootDatum,vec)p) = int: { fold coroots to positive }
  let i=coroot_index(p) in if i<0 then -1-i else i fi

set reflection (RootDatum rd, int i) = mat: { i indexes a root/coroot pair }
  1 - column(root(rd,i))*row(coroot(rd,i))


set rho (RootDatum rd) = ratvec:
  let res= ratvec: null(rank(rd))
  in for i:semisimple_rank(rd) do res +:= fundamental_weight(rd,i) od; res
{ this uses fewer additions than computing half sum of the positive roots }

{ make rho as a vector of integers if possible }
set rho_as_vec (RootDatum r)= vec: ratvec_as_vec(rho(r))

set rho_check (RootDatum rd) = ratvec: { rho(dual(rd)), but a bit faster }
  let res= ratvec: null(rank(rd))
  in for i:semisimple_rank(rd) do res +:= fundamental_coweight(rd,i) od; res

{ see also rho_i@KGBElt and rho_r@KGBElt defined below }

set is_positive_root (RootDatum rd,vec alpha) = bool: rho_check(rd)*alpha>0
set is_positive_coroot (RootDatum rd,vec alphav) = bool: alphav*rho(rd)>0

{reflection through an arbitrary root}
set reflection(RootDatum rd, vec v)=mat:
if not is_positive_root(rd,v) then v:=-v fi;reflection(rd,root_index(rd,v))

set roots (RootDatum rd) = mat:
  let npr=nr_of_posroots(rd)
  in rank(rd)#for i:2*npr from -npr do root(rd,i) od
set coroots (RootDatum rd) = mat:
  let npr=nr_of_posroots(rd)
  in rank(rd)#for i:2*npr from -npr do coroot(rd,i) od

set root(RootDatum rd, vec alpha_v) = vec: root(rd,coroot_index(rd,alpha_v))
set coroot(RootDatum rd, vec alpha) = vec: coroot(rd,root_index(rd,alpha))

set singular_roots (RootDatum rd,ratvec v)=[int]:
  let rv=[int]:[] { cannot use columns_with: must find _indices_ of columns }
  in for a@j in simple_coroots(rd) do if a*v=0 then rv:=rv#j fi od; rv

set is_imaginary (mat theta) = (vec->bool): (vec alpha): theta*alpha=alpha
set is_real      (mat theta) = (vec->bool): (vec alpha): theta*alpha=-alpha
set is_complex   (mat theta) = (vec->bool): (vec alpha):
  let ta = theta*alpha in ta!=alpha and ta!=-alpha



set imaginary_roots (RootDatum rd, mat theta) = mat:
  columns_with(is_imaginary(theta),roots(rd))
set real_roots (RootDatum rd, mat theta) = mat:
  columns_with(is_real(theta),roots(rd))

{ for coroots we need to use the transpose matrix }
set imaginary_coroots (RootDatum rd, mat theta) = mat:
  columns_with(is_imaginary(^theta),coroots(rd))
set real_coroots (RootDatum rd, mat theta) = mat:
  columns_with(is_real(^theta),coroots(rd))

{ positive (co)roots versions are actually more useful }
set imaginary_posroots (RootDatum rd,mat theta) = mat:
  columns_with(is_imaginary(theta),posroots(rd))
set real_posroots (RootDatum rd,mat theta) = mat:
  columns_with(is_real(theta),posroots(rd))
set imaginary_poscoroots (RootDatum rd,mat theta) = mat:
  columns_with(is_imaginary(^theta),poscoroots(rd))
set real_poscoroots (RootDatum rd,mat theta) = mat:
  columns_with(is_real(^theta),poscoroots(rd))
set imaginary_sys ((RootDatum,mat)p) = (mat,mat):
  (imaginary_posroots(p),imaginary_poscoroots(p))
set real_sys ((RootDatum,mat)p) = (mat,mat):
  (real_posroots(p),real_poscoroots(p))

{ the following funtions give but partial information; giving a more complete
  definition for InnerClass values requires more work (group_operations.rx) }
set derived (RootDatum rd) = RootDatum: let (d,)=derived_info(rd) in d
set mod_central_torus (RootDatum rd) = RootDatum:
  let (d,)=mod_central_torus_info(rd) in d
set adjoint (RootDatum rd) = RootDatum: { change weight basis to simple roots }
  root_datum(id_mat(semisimple_rank(rd)),Cartan_matrix(rd))

{ from appropriate (subsystem) dual 2rho value, deduce test for being simple }
set is_simple_for (vec dual_two_rho) = (vec->bool):
  (vec alpha): dual_two_rho*alpha=2

{ get generating simple system from set of matching posroots and poscoroots }
set simple_from_positive (mat posroots,mat poscoroots) = (mat,mat):
  ( columns_with(is_simple_for(sum(poscoroots)),posroots)
  , columns_with(is_simple_for(sum(posroots)),poscoroots)
  )

{ using postive root indices allows using simple roots indices as well }
set posroot_reflection(RootDatum rd, int r) = mat: { r indexes root }
  1 - [root(rd,r)] * ^[coroot(rd,r)]


{				Inner classes				}

set != (InnerClass x,InnerClass y) = bool: not(x=y)

{ integrality inner class (dual side) defined by inf. character and involution }
set dual_integral (InnerClass ic, ratvec gamma) = InnerClass:
  inner_class(dual(integrality_datum(ic,gamma)),-^distinguished_involution(ic))


{				Cartan classes				}

set Cartan_classes (InnerClass ic) = [CartanClass]:
  for i:nr_of_Cartan_classes(ic) do Cartan_class(ic,i) od

set print_Cartan_info (CartanClass cc) = void:
  let show (string s) = string: if s="" then "empty" else s fi
  , ((cr,Cr,sr),ww,(orbit_size,fiber_size),(i_tp,r_tp,C_tp)) = Cartan_info(cc)
  in
  begin
    prints("compact: ",cr,", complex: ",Cr,", split: ",sr)
  ; (let str = "canonical twisted involution: " in
       if #ww=0 then str #:= "e"
       else str +:= ww[0]+1; for i : #ww-1 from 1 do str #:= ","+(ww[i]+1) od
       fi
     ; prints(str)
    )
  ; prints("twisted involution orbit size: ",orbit_size,
	   "; fiber size: ",fiber_size,"; strong inv: ",orbit_size*fiber_size)
  ; prints("imaginary root system: ",show(str(i_tp)))
  ; prints("real root system: ",show(str(r_tp)))
  ; prints("complex factor: ",show(str(C_tp)))
  end


set fundamental_Cartan (InnerClass ic) = CartanClass: Cartan_class(ic,0)
set fundamental_Cartan (RealForm f) = CartanClass:
  fundamental_Cartan(inner_class(f)) { this is constant on the inner class }
set most_split_Cartan (InnerClass ic) = CartanClass:
  Cartan_class(ic,nr_of_Cartan_classes(ic)-1)
{ also most_split_Cartan@RealForm is built-in, but is not that of inner class }

set split_rank (CartanClass cc) = int:
  let ((,C,s),,,) = Cartan_info(cc) in C+s
set compact_rank (CartanClass cc) = int:
  let ((c,C,),,,) = Cartan_info(cc) in c+C


{				Real forms				}

set != (RealForm f, RealForm g) = bool: not(f=g)

set form_name (RealForm f) = string: form_names(f)[form_number(f)]

set real_forms (InnerClass ic)= [RealForm]:
  real_forms(fundamental_Cartan(ic))
set dual_real_forms (InnerClass ic) = [RealForm]:
  dual_real_forms(most_split_Cartan(ic))

set split_form (RootDatum r) = quasisplit_form(inner_class(r,-id_mat(rank(r))))

{ split form of a Lie type is taken simply connected (times a split torus) }
set split_form (LieType t) = split_form(simply_connected(t))

set quasicompact_form (InnerClass ic) = RealForm: real_forms(ic)[0]
{ quasisplit_form is built-in }

set is_compatible (RealForm f, RealForm g) = bool:
  let ic = inner_class(f)
  then oc = occurrence_matrix(ic)*^dual_occurrence_matrix(ic)
  in inner_class(g)=dual(ic) and oc[form_number(f),form_number(g)]>0


{			       KGB elements				}

set != (KGBElt x,KGBElt y) = bool: not(x=y)
set real_form (KGBElt x) = let (rf,) = %x in rf
set # (KGBElt x) = let (,n) = %x in n
set inner_class(KGBElt x)=InnerClass:inner_class(real_form(x))
set inner_class(Param p)=InnerClass:inner_class(real_form(p))

set KGB (RealForm rf) = [KGBElt]: for i:KGB_size(rf) do KGB(rf,i) od

set KGB_elt ((InnerClass, mat, ratvec) (,theta,v):all) = KGBElt:
  let rf = real_form(all)   { find real form within ic }
  in KGB_elt(rf,theta,v)    { find KGB element within rf }

{ NB: elements produced by the following function test unequal to any others }
set KGB_elt (RootDatum rd, mat theta, ratvec v) = KGBElt:
  let ic = inner_class(rd,theta)   { find the proper inner class }
  then rf = real_form(ic,theta,v)  { find real form within ic }
  in KGB_elt(rf,theta,v)           { find KGB element within rf }

set Cartan_class (InnerClass ic, mat theta) = CartanClass:
  Cartan_class(KGB_elt(ic,theta,ratvec:null(rank(ic))))

set status(vec alpha,KGBElt x) = int: status(root_index(real_form(x),alpha),x)
set cross(vec alpha,KGBElt x) = KGBElt:
  cross(root_index(real_form(x),alpha),x)
set Cayley(vec alpha,KGBElt x) = KGBElt:
  Cayley(root_index(real_form(x),alpha),x)

set KGB_status_text (int i) = string: ["C-","ic","r ","nc","C+"][i]

set status_text ((int,KGBElt)p) = string: KGB_status_text(status(p))
set status_text ((vec,KGBElt)p) = string: KGB_status_text(status(p))
set status_texts (KGBElt x) = [string]:
  for s:semisimple_rank(real_form(x)) do status_text(s,x) od

set is_complex ((int,KGBElt)p) = status(p)%4=0
set is_real ((int,KGBElt)p) = status(p)=2
set is_imaginary ((int,KGBElt)p) = status(p)%2=1
set is_noncompact ((int,KGBElt)p) = status(p)=3
set is_compact ((int,KGBElt)p) = status(p)=1
set is_descent ((int,KGBElt)p) = status(p)<3
set is_ascent ((int,KGBElt)p) = status(p)>=3



{ status of general roots for a KGBElt (which here just represents its fiber) }

set is_imaginary (KGBElt x) = (vec->bool): is_imaginary(involution(x))
set is_real (KGBElt x)      = (vec->bool): is_real(involution(x))
set is_complex (KGBElt x)   = (vec->bool): is_complex(involution(x))


set imaginary_posroots (KGBElt x) = mat:
  imaginary_posroots(real_form(x),involution(x))
set real_posroots (KGBElt x) = mat:
  real_posroots(real_form(x),involution(x))
set imaginary_poscoroots (KGBElt x) = mat:
  imaginary_poscoroots(real_form(x),involution(x))
set real_poscoroots (KGBElt x) = mat:
  real_poscoroots(real_form(x),involution(x))

set rho_i (KGBElt x) = ratvec: sum(imaginary_posroots(x))/2
set rho_r (KGBElt x) = ratvec: sum(real_posroots(x))/2
set rho_check_i (KGBElt x) = ratvec: sum(imaginary_poscoroots(x))/2
set rho_check_r (KGBElt x) = ratvec: sum(real_poscoroots(x))/2

{ status for a given KGBElt of general imaginary roots }
set is_compact (KGBElt x) = (vec->bool):
  let coweight = rho_check_i(x)+torus_factor(x)
  in (vec alpha) bool: rat_as_int(coweight*alpha)%2=0
set is_noncompact (KGBElt x) = (vec->bool):
  let coweight = rho_check_i(x)+torus_factor(x)
  in (vec alpha) bool: rat_as_int(coweight*alpha)%2!=0


set is_imaginary(vec v,KGBElt x)=bool:is_imaginary(x)(v)
set is_real(vec v,KGBElt x)=bool:is_real(x)(v)
set is_complex(vec v,KGBElt x)=bool:is_complex(x)(v)
set is_compact(vec v,KGBElt x)=bool:is_compact(x)(v)

set print_KGB(KGBElt x) = void:
( prints(); prints("Element is number ",#x, " in following KGB set")
; print_KGB(real_form(x)) )


{				Blocks					}

set blocks (InnerClass ic) = [Block]:
  let result = [Block]: [] in
  for rf in real_forms(ic)
  do for drf in dual_real_forms(ic)
     do if is_compatible(rf,drf) then result #:= block(rf,drf) fi
     od
  od; result

set raw_KL  ((RealForm,RealForm) p) = (mat,[vec],vec): raw_KL(block(p))
set dual_KL ((RealForm,RealForm) p) = (mat,[vec],vec): dual_KL(block(p))

set print_block  ((RealForm,RealForm) p) = void: print_block (block(p))
set print_blocku ((RealForm,RealForm) p) = void: print_blocku(block(p))
set print_blockd ((RealForm,RealForm) p) = void: print_blockd(block(p))
set print_KL_basis ((RealForm,RealForm) p) = void: print_KL_basis(block(p))
set print_prim_KL  ((RealForm,RealForm) p) = void: print_prim_KL(block(p))
set print_KL_list  ((RealForm,RealForm) p) = void: print_KL_list(block(p))
set print_W_cells  ((RealForm,RealForm) p) = void: print_W_cells(block(p))
set print_W_graph  ((RealForm,RealForm) p) = void: print_W_cells(block(p))

{			    Module parameters				}

set != (Param x,Param y) = bool: not(x=y)

{ deforming |nu| (operand order avoids conflicting with *@(int,ParamPol) ) }
set * (Param p,rat alpha) = let (x,lambda,nu)=%p in param(x,lambda,alpha*nu)

set x (Param p) = KGBElt: let (x,,) =%p in x
set lambda_minus_rho (Param p) = vec: let (,lambda_rho,) =%p in lambda_rho
set lambda(Param p) = ratvec: lambda_minus_rho(p)+rho(real_form(p))
set nu (Param p) = ratvec: let (,,nu) =%p in nu

{ simulate coercion (KGBElt->RealForm) in some cases }
set root_datum(Param p) = RootDatum: root_datum(real_form(p))
set root_datum(ParamPol P) = RootDatum: root_datum(real_form(P))

set involution (Param p)=involution(x(p))

set integrality_datum(Param p)= RootDatum:
  integrality_datum(root_datum(p),infinitesimal_character(p))


{ parameter(G,x,lambda,nu)=param(G,x,lambda-rho(G),nu), so you can enter
  lambda without the rho shift; lambda may have denominator 2 or be a vec }
set parameter (RealForm G,int x,ratvec lambda,ratvec nu) = Param:
  param(KGB(G,x),ratvec_as_vec(lambda-rho(G)),nu)
set parameter (KGBElt x,ratvec lambda,ratvec nu) = Param:
  param(x,ratvec_as_vec(lambda-rho(real_form(x))),nu)

{ get just the parameters from a block, just a shorcut to: (params,)=block(p) }
set block_of (Param p) = [Param]: let (params,)=block(p) in params

{ status of a parameter with respect of a Weyl generator s }

set imaginary_type (int s, Param p) = int: if cross(s,p)=p then 2 else 1 fi
set real_type (int s,Param p) = int: if cross(s,p)=p then 1 else 2 fi

set is_non_parity (int s,Param p)=bool: is_real(s,x(p)) and inv_Cayley(s,p)=p
set is_parity (int s,Param p)= bool: is_real(s,x(p)) and inv_Cayley(s,p)!=p

set status (int s,Param p) = int: { enum: C-, ic, r1, r2, C+, rn, i1, i2 }
  let st=status(posroots(integrality_datum(p))[s],x(p)) in
  if st<=1 or st=4 then st { complex and imaginary compact cases keep old code }
  elif st=3 then { imaginary non-compact } 5+imaginary_type(s,p)
  elif inv_Cayley(s,p)=p then { real non-parity } 5
  else 1+real_type(s,p)
  fi

set block_status_text (int i) = string:
  ["C-","ic","r1","r2","C+","rn","i1","i2"][i]

set status_text (int s,Param p) = string: block_status_text(status(s,p))
set status_texts(Param p) = [string]:
  for s:semisimple_rank(real_form(p)) do status_text(s,p) od

set is_descent (int s,Param p) = bool: status(s,p)<4
set tau_bitset(Param p) = ((int->bool),int):
  ((int s): is_descent(s,p), semisimple_rank(real_form(p)))

set tau (Param p)            = [int]: list(tau_bitset(p))
set tau_complement (Param p) = [int]: complement(tau_bitset(p))

set lookup (Param p, [Param] block) = int:
  let i=#block-1 in while i>=0 and block[i]!=p do i-:=1 od; i

{		    Polynomials in module parameters			}

set null_module (ParamPol P)= 0*P { also handles null_module(Param) }


set virtual(Param p) = ParamPol: p { for making implicit conversion explcit }

set - (ParamPol P) = ParamPol: (-1)*P
set - (ParamPol P,Param p)=ParamPol:P+(-1)*virtual(p)
set + (Param p,Param q)=ParamPol:virtual(p)+virtual(q)
set - (Param p,Param q)=ParamPol:virtual(p)+(-1)*virtual(q)


set find([[int]] list,[int] v)=int:
 let i=#list-1 in while i>=0 and list[i]!=v do i-:=1 od;i

set in_string_list(string s,[string] S)=bool:
let rv=false,i=0 in for i:#S do if s=S[i] then i:=#S;rv:=true else i+:=1 fi od;rv
