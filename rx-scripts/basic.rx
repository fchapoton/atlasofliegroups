set #(int n)= [int]: for i:n do i od       { [0,1,...,n-1] }
set #(bool b) = int: if b then 1 else 0 fi { Iverson symbol }
set #(ratvec v)= int: let (n,)=%v in #n    { length }

{ bitsets encoded as functions (int->bool) and upper bound limit }

set list ((int->bool) filter, int limit) = [int]:
  let result=[int]:[]
  in for i:limit do if filter(i) then result#:=i fi od; result
set complement ((int->bool) filter, int limit) = [int]:
  let result=[int]:[]
  in for i:limit do if not filter(i) then result#:=i fi od; result

set count ((int->bool) filter, int limit) = int:
  let c=0 in for i:limit do if filter(i) then c+:=1 fi od; c

set all ((int->bool) filter, int limit) = bool:
  while limit-:=1; limit>=0 and filter(limit) do () od; limit<0
set none ((int->bool) filter, int limit) = bool:
  while limit-:=1; limit>=0 and not filter(limit) do () od; limit<0


{				Integers				}

{ absolute value and sign of integer}
set abs (int k)= int: if k<0 then -k else k fi
set sign (int k)= int: if k<0 then -1 elif k=0 then 0 else 1 fi

set min (int k, int l) = int: if k<l then k else l fi
set max (int k, int l) = int: if k<l then l else k fi

set = ((int,int)(x0,y0),(int,int)(x1,y1)) = bool: x0=x1 and y0=y1
set !=((int,int)(x0,y0),(int,int)(x1,y1)) = bool: x0!=x1 or y0!=y1


{			    Rational numbers				}

set numer (rat a) = let (n,)=%a in n
set denom (rat a) = let (,d)=%a in d

set floor (rat a) = int: \ %a     { decompose, then integer division }
set ceil  (rat a) = int: -\ %-a   { same, sandwiched in negations }

{ these are mostly for ratvec arguments, but avoid coercing from vec }
set floor ([rat] v) = vec: for a in v do floor(a) od
set ceil  ([rat] v) = vec: for a in v do  ceil(a) od


{				Strings					}

set != ((string,string)p) = bool: not =p
set > ((string,string)p) = bool: not <=p
set >= (string x, string y) = bool: y<=x
set < (string x, string y) = bool: y>x

set +(string s,string t) = string: s # t { alias for concatenation }
set *(string s, int n)= string: let r="" in (for i:n do r#:=s od; r)

set +(string s, int i)= string: s # int_format(i)
set +(int i, string s)= string: int_format(i) # s

set +(string s, (int,int)(x,y)) = s + "(" + x + "," + y + ")"


{				Vectors					}

set ones(int n)= vec: for i:n do 1 od

{ for computing greatest common divisors, inv_fact can do most of the work }
set gcd(vec v)= int: let f=inv_fact([v]) in if #f=0 then 0 else f[0] fi

set +(vec v,vec w)= vec:
( if #v != #w then error("Size mismatch " + #v + ":" + #w) fi
; for e@i in v do e+w[i] od
)

set -(vec v,vec w)= vec:
( if #v != #w then error("Size mismatch " + #v + ":" + #w) fi
; for e@i in v do e-w[i] od
)

{ scalar multiplication }
set *(int c,vec v) = vec: for e in v do c*e od
set -(vec w)= vec: for e in w do -e od

{ integer division }
set \(vec v,int d) = vec: for x in v do x\d od

{ entrywise modulo }
set %(vec v,int d) = vec: for x in v do x%d od

{ sum, product of entries }
set sum (vec v)= let s=0 in for e in v do s+:=e od; s
set product (vec v)= let s=1 in for e in v do s*:=e od; s

set reverse (vec v)= vec: for i:#v downto 0 do v[i] od


{				Matrices				}

set n_rows(mat m)= int: let (r,)=#m in r
set n_columns(mat m)= int: let (,c)=#m in c

{ scalar multiplication }
set *(int c,mat m) = mat: for col in m do for e in col do c*e od od
set -(mat m)= mat: for c in m do for e in c do -e od od

{ integer division }
set \(mat m,int d) = mat: for v in m do v\d od

{ entrywise modulo }
set %(mat m,int d) = mat: for v in m do v%d od

set ^ =
  let matrix_power (mat m,int n)= mat: m { dummy for recursion }
  then () = matrix_power := { assign recusive function body }
    ( (mat m,int n): { we hall have n>0 }
      if n=1 then m
      else let (q,r)=n\%2 then mm=matrix_power(m,q) in
	mm*if r=0 then mm else mm*m fi
      fi
    )
  in { operator ^ = } (mat m,int n) mat:
  if n>0 then matrix_power(m,n) elif n=0 then id_mat(n_rows(m))
  else error("Negative matrix power "+n)
  fi

set inverse (mat M) = mat:
  let (inv,d)=invert(M) in
  if d=1 then inv else error("Matrix not invertible over the integers") fi

{ surprisingly coercion allows, and does not provide, the following overload }
set # (mat A, mat B) = mat: ([vec]:A)#([vec]:B)

set columns_with ((int,vec->bool) p,mat m) = mat:
( let res = [vec]: [] in for col@j in m do if p(j,col) then res #:= col fi od
; if #res=0 then null(n_rows(m),0) else res fi
)
set columns_with ((vec->bool) p,mat m) = mat:
  columns_with (((int,vec)(,col))bool: p(col),m)
set columns_with ((int->bool) p,mat m) = mat:
  columns_with (((int,vec)(j,))bool: p(j),m)

set rows_with ((int,vec->bool) p,mat m) = mat: ^columns_with(p,^m)
set rows_with ((    vec->bool) p,mat m) = mat: ^columns_with(p,^m)
set rows_with ((int    ->bool) p,mat m) = mat: ^columns_with(p,^m)


{ sum of columns of a matrix }
set sum (mat m)= vec: m*ones(n_columns(m))


{			    Rational vectors				}

set numer (ratvec a) = vec: let (n,)=%a in n
set denom (ratvec a) = int: let (,d)=%a in d
set =(ratvec v,ratvec w) = bool: let (n,d)=%v, (m,e)=%w in e*n=d*m
set -(ratvec v) = ratvec: let (n,d)=%v in (-n)/d
set *(int m,ratvec v) = ratvec: let (n,d)=%v in m*n/d
set *(rat r,ratvec v) = ratvec: let (n,d)=%r, (nv,dv)=%v in (n*nv)/(d*dv)
set /(ratvec v,int m) = ratvec: let (n,d)=%v in n/(m*d)
set /(ratvec v,rat r) = ratvec: let (nv,dv)=%v, (n,d)=%r in (d*nv)/(n*dv)

{ extend built-in scalar product of vectors to rational vector case }
set *(ratvec v, ratvec w) = rat: let (nv,dv)=%v,(nw,dw)=%w in nv*nw/(dv*dw)

set *(vec v, ratvec w) = rat: let (nw,dw)=%w in v*nw/dw { more efficient }
{ cannot also define: *(ratvec v, vec w) = rat: let (nv,dv)=%v in nv*w/dv }


{			    Split integers				}

set = (Split x,Split y) = %x = %y
set != (Split x,Split y) = %x != %y

set s = Split:(0,1)
set + (Split x) = let (r,)=%x in r { real part }
set ^ (Split x) = let (,y)=%x in y { s part }

set ^ = { exponentiation of split integers }
  let split_power (Split x,int n) = Split: x { dummy }
  then () = split_power := ((Split x,int n): { we shall have n>0 }
    if n=1 then x
    else let (q,r)=n\%2 then y=split_power(x,q) in y*if r=0 then y else x*y fi
    fi)
  in { set ^ = } (Split x,int n): Split:
    if n>0 then split_power(x,n) elif n=0 then Split:(1,0)
    elif let (a,b)=%x in abs(a)+abs(b)=1 then if n%2=0 then 1 else x fi
    else error("Negative power "+n+" of split integer")
    fi

set -(ParamPol a, (Split,Param) (c,p)) = ParamPol: a+(-c,p)

set +(mat M,mat N)= mat:
( if #M != #N then error("Size mismatch " + #M + ":" + #N) fi
; for col@j in M do for e@i in col do e+N[i,j] od od
)

set -(mat M,mat N)= mat:
( if #M != #N then error("Size mismatch " + #M + ":" + #N) fi
; for col@j in M do for e@i in col do e-N[i,j] od od
)


{				Root data 				}

{ transitional function; the built-in function should have this prototype }
set root_datum(mat simple_roots, mat simple_coroots) = RootDatum:
  root_datum(simple_roots,simple_coroots,n_rows(simple_roots))

set rho (RootDatum rd) = ratvec:
  let res= ratvec: null(rank(rd))
  in for i:semisimple_rank(rd) do res +:= fundamental_weight(rd,i) od; res
{ this uses fewer additions than computing half sum of the positive roots }

set rho_check (RootDatum rd) = ratvec: { rho(dual(rd)), but a bit faster }
  let res= ratvec: null(rank(rd))
  in for i:semisimple_rank(rd) do res +:= fundamental_coweight(rd,i) od; res

{ see also rho_i@KGBElt and rho_r@KGBElt defined below }

set singular_roots(RootDatum rd,ratvec v)=[int]:
  let rv=[int]:[]
  in for a@i in simple_coroots(rd) do if a*v=0 then rv:=rv#i fi od; rv

set is_imaginary (mat theta) = (vec->bool): (vec alpha): theta*alpha=alpha
set is_real      (mat theta) = (vec->bool): (vec alpha): theta*alpha=-alpha
set is_complex   (mat theta) = (vec->bool): (vec alpha):
  let ta = theta*alpha in ta!=alpha and ta!=-alpha

set imaginary_roots (RootDatum rd, mat theta) = mat:
  columns_with(is_imaginary(theta),roots(rd))
set real_roots (RootDatum rd, mat theta) = mat:
  columns_with(is_real(theta),roots(rd))

{ for coroots we need to use the transpose matrix }
set imaginary_coroots (RootDatum rd, mat theta) = mat:
  columns_with(is_imaginary(^theta),coroots(rd))
set real_coroots (RootDatum rd, mat theta) = mat:
  columns_with(is_real(^theta),coroots(rd))

{ positive (co)roots versions are actually more useful }
set imaginary_posroots (RootDatum rd,mat theta) = mat:
  columns_with(is_imaginary(theta),posroots(rd))
set real_posroots (RootDatum rd,mat theta) = mat:
  columns_with(is_real(theta),posroots(rd))
set imaginary_poscoroots (RootDatum rd,mat theta) = mat:
  columns_with(is_imaginary(^theta),poscoroots(rd))
set real_poscoroots (RootDatum rd,mat theta) = mat:
  columns_with(is_real(^theta),poscoroots(rd))


{ get just the derived root datum, forgetting about weight embedding }
set derived (RootDatum rd) = RootDatum: let (d,)=derived_info(rd) in d

{				Inner classes				}

set != (InnerClass x,InnerClass y) = bool: not(x=y)

{ integrality inner class (dual side) defined by inf. character and involution }
set dual_integral(InnerClass ic, ratvec gamma) = InnerClass:
  inner_class(dual(integrality_datum(ic,gamma)),-^distinguished_involution(ic))


{				Real forms				}

set = (RealForm f, RealForm g) = bool:
  inner_class(f) = inner_class(g) and form_number(f)=form_number(g)
set != (RealForm f, RealForm g) = bool: not(f=g)


{			       KGB elements				}

set != (KGBElt x,KGBElt y) = bool: not(x=y)

set KGB(RealForm rf) = [KGBElt]: for i:KGB_size(rf) do KGB(rf,i) od

set status_text(int s,KGBElt x) = string:
  ["C-","ic","r ","nc","C+"][status(s,x)]
set status_texts(KGBElt x) = [string]:
  for s:semisimple_rank(real_form(x)) do status_text(s,x) od

set is_complex(int s,KGBElt x) = status(s,x)%4=0
set is_real(int s,KGBElt x) = status(s,x)=2
set is_imaginary(int s,KGBElt x) = status(s,x)%2=1
set is_noncompact(int s,KGBElt x) = status(s,x)=3
set is_compact(int s,KGBElt x) = status(s,x)=1
set is_descent(int s,KGBElt x) = status(s,x)<3
set is_ascent(int s,KGBElt x) = status(s,x)>=3


{ status of general roots for a KGBElt (which here just represents its fiber) }

set is_imaginary (KGBElt x) = (vec->bool): is_imaginary(involution(x))
set is_real (KGBElt x)      = (vec->bool): is_real(involution(x))
set is_complex (KGBElt x)   = (vec->bool): is_complex(involution(x))

set imaginary_posroots (KGBElt x) = mat:
  imaginary_posroots(real_form(x),involution(x))
set real_posroots (KGBElt x) = mat:
  real_posroots(real_form(x),involution(x))
set imaginary_poscoroots (KGBElt x) = mat:
  imaginary_poscoroots(real_form(x),involution(x))
set real_poscoroots (KGBElt x) = mat:
  real_poscoroots(real_form(x),involution(x))

set rho_i (KGBElt x) = ratvec: sum(imaginary_posroots(x))/2
set rho_r (KGBElt x) = ratvec: sum(real_posroots(x))/2


{			    Module parameters				}

set != (Param x,Param y) = bool: not(x=y)

{ deforming |nu| (operand order voids conflicting with *@(int,ParamPol) ) }
set *(Param p,rat alpha) = let (x,lambda,nu)=%p in param(x,lambda,alpha*nu)

set x(Param p) = KGBElt: let (x,,) =%p in x
set lambda_minus_rho(Param p) = vec: let (,lambda_rho,) =%p in lambda_rho
set lambda(Param p) = ratvec: lambda_minus_rho(p)+rho(real_form(p))
set nu(Param p) = ratvec: let (,,nu) =%p in nu

{ simulate coercion (KGBElt->RealForm) in some cases }
set involution(Param p)=involution(x(p))

{ status of a parameter with respect of a Weyl generator s }

set imaginary_type(int s, Param p) = int: if cross(s,p)=p then 2 else 1 fi
set real_type(int s,Param p) = int: if cross(s,p)=p then 1 else 2 fi

set is_non_parity(int s,Param p)=bool: is_real(s,x(p)) and inv_Cayley(s,p)=p
set is_parity(int s,Param p)= bool: is_real(s,x(p)) and inv_Cayley(s,p)!=p

set status(int s,Param p) = int: { enum: C-, ic, r1, r2, C+, rn, i1, i2 }
let st=status(s,x(p)) in
if st<=1 or st=4 then st { complex and imaginary compact cases keep old code }
elif st=3 then { imaginary non-compact } 5+imaginary_type(s,p)
elif inv_Cayley(s,p)=p then { real non-parity } 5
else 1+real_type(s,p)
fi

set status_text(int s,Param p) = string:
  ["C-","ic","r1","r2","C+","rn","i1","i2"][status(s,p)]
set status_texts(Param p) = [string]:
  for s:semisimple_rank(real_form(p)) do status_text(s,p) od

set is_descent (int s,Param p) = bool: status(s,p)<4
set tau_bitset(Param p) = ((int->bool),int):
  ((int s): is_descent(s,p), semisimple_rank(real_form(p)))

set tau(Param p)            = list(tau_bitset(p))
set tau_complement(Param p) = complement(tau_bitset(p))


{		    Polynomials in module parameters			}

set -(ParamPol P,ParamPol Q) = ParamPol: P+(-1)*Q
set =(ParamPol P,ParamPol Q) = bool: #(P-Q)=0
set !=(ParamPol P,ParamPol Q) = bool: #(P-Q)>0

set null_module(ParamPol P)= 0*P { also handles null_module(Param) }

set virtual(Param p) = ParamPol: p

set -(ParamPol P) = ParamPol: (-1)*P
set -(ParamPol P,Param p)=ParamPol:P+(-1)*virtual(p)
set +(Param p,Param q)=ParamPol:virtual(p)+virtual(q)
set -(Param p,Param q)=ParamPol:virtual(p)+(-1)*virtual(q)
