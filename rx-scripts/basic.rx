set #(int n)= for i:n do i od  { [0,1,...,n-1] }
set #(bool b) = if b then 1 else 0 fi { Iverson symbol }
set #(ratvec v)= let (n,)=%v in #n { length }

set n_rows(mat m)= let (r,)=#m in r
set n_columns(mat m)= let (,c)=#m in c

set *(string s, int n)= let r="" in (for i:n do r#:=s od; r)

set *(int c,vec v) = vec: for e in v do c*e od
set *(int c,mat m) = mat: for col in m do for e in col do c*e od od

{ a necessary global auxiliary, as realex cannot handle recursive operators }
set matrix_power = (mat,int->mat):
let p = (mat m,int n): m
in p:= ((mat m,int n): { we hall have n>0 }
  if n=1 then m
  else let (q,r)=n\%2 then mm=p(m,q) in mm*if r=0 then mm else mm*m fi
  fi)
set ^(mat m,int n) =
  if n>0 then matrix_power(m,n) elif n=0 then id_mat(n_rows(m))
  else error("Negative matrix power " # int_format(n))
  fi

set +(string s, int i)= s # int_format(i)
set +(int i, string s)= int_format(i) # s
set +(string s,string t) = s # t { alias for concatenation }

set -(vec w)= vec: for e in w do -e od
set -(mat m)= mat: for c in m do for e in c do -e od od

set +(vec v,vec w)= vec:
  ( if #v != #w then error("Size mismatch " + #v + ":" + #w) fi
  ; for e@i in v do e+w[i] od
  )

set -(vec v,vec w)= vec:
  ( if #v != #w then error("Size mismatch " + #v + ":" + #w) fi
  ; for e@i in v do e-w[i] od
  )

set %(vec v,int d) = vec: for x in v do x%d od

set sum (vec v)= let s=0 in for e in v do s+:=e od; s

set sum (mat m)= { sum of columns of m }
  let (r,)=#m then sum = null(r) in for col in m do sum+:=col od; sum

set +(string s, (int,int)(x,y)) = s + "(" + x + "," + y + ")"

set floor (rat a) = \ %a
set ceil  (rat a) = -\ %-a

{absolute value and sgn of integer}
set abs (int k)=if k<0 then -k else k fi
set sgn (int k)=if k<0 then -1 else 1 fi

set numer (rat a) = let (n,)=%a in n
set denom (rat a) = let (,d)=%a in d
set numer (ratvec a) = let (n,)=%a in n
set denom (ratvec a) = let (,d)=%a in d
set =(ratvec v,ratvec w) = let (n,d)=%v, (m,e)=%w in e*n=d*m
set -(ratvec v) = let (n,d)=%v in (-n)/d
set *(int m,ratvec v) = let (n,d)=%v in m*n/d
set *(mat m,ratvec v) = let (n,d)=%v in m*n/d
set /(ratvec v,int m) = let (n,d)=%v in n/(m*d)
set *(rat r,ratvec v) = let (n,d)=%r, (nv,dv)=%v in (n*nv)/(d*dv)
set *(ratvec r, vec v) = let (n,d)=%r in n*v/d

set floor ([rat] v) = for a in v do floor(a) od
set ceil  ([rat] v) = for a in v do  ceil(a) od

set s = Split:(0,1)
set split_power = (Split,int->Split):
let p = (Split x,int n): x
in p:= ((Split x,int n): { we shall have n>0 }
  if n=1 then x
  else let (q,r)=n\%2 then y=p(x,q) in y*if r=0 then y else x*y fi
  fi)
set ^(Split x,int n) =
  if n=0 then Split:(1,0) else split_power(x,abs(n)) fi

{previously did not allow negative powers}
{set ^(Split x,int n) =
  if n>0 then split_power(x,n) elif n=0 then Split:(1,0)
  else error("Negative split integer power " # int_format(n))
  fi}

set =((int,int)(x0,y0),(int,int)(x1,y1)) = x0=x1 and y0=y1
set !=((int,int)(x0,y0),(int,int)(x1,y1)) = x0!=x1 or y0!=y1

set -(ParamPol a, (Split,Param) (c,p)) = a+(-c,p)

{ these cases ought to be handled by the coercion code, but currently aren't }
set +(ParamPol a, (int,Param) (c,p)) = a+(Split:  c,p)
set -(ParamPol a, (int,Param) (c,p)) = a+(Split: -c,p)

set +(mat M,mat N)= mat:
  ( if #M != #N then error("Size mismatch " + #M + ":" + #N) fi
  ; for col@j in M do for e@i in col do e+N[i,j] od od
  )

set -(mat M,mat N)= mat:
  ( if #M != #N then error("Size mismatch " + #M + ":" + #N) fi
  ; for col@j in M do for e@i in col do e-N[i,j] od od
  )

set min (int k, int l) = if k<l then k else l fi
set max (int k, int l) = if k<l then l else k fi

set ones(int n)= vec: for i:n do 1 od

set rho (RootDatum rd) = let pr=positive_roots(rd) in pr*ones(n_columns(pr))/2

set imaginary_roots (RootDatum rd, mat theta) =
  let ir = [vec]: []
  in ( for alpha in roots(rd)
       do if theta*alpha = alpha then ir #:= alpha fi od
     ; if #ir=0 then null(rank(rd),0) else mat: ir fi )

set real_roots (RootDatum rd, mat theta) =
  let rr = [vec]: []
  in ( for alpha in roots(rd)
       do if theta*alpha = -alpha then rr #:= alpha fi od
     ; if #rr=0 then null(rank(rd),0) else mat: rr fi )

set imaginary_coroots (RootDatum rd, mat theta) =
  let ic = [vec]: []
  in ( for alpha in coroots(rd)
       do if alpha*theta = alpha then ic #:= alpha fi od
     ; if #ic=0 then null(rank(rd),0) else mat: ic fi )

set real_coroots (RootDatum rd, mat theta) =
  let rc = [vec]: []
  in ( for alpha in coroots(rd)
       do if alpha*theta = -alpha then rc #:= alpha fi od
     ; if #rc=0 then null(rank(rd),0) else mat: rc fi )

set simple_reflection (RootDatum rd, int s) =
  id_mat(rank(rd))- [simple_roots(rd)[s]] * ^[simple_coroots(rd)[s]]

set reflection (RootDatum rd, int alpha) =
  id_mat(rank(rd))- [roots(rd)[alpha]] * ^[coroots(rd)[alpha]]

set involution (InnerClass ic, [int] tw) =
( let rd = root_datum(ic), theta = distinguished_involution(ic)
  in for i : #tw downto 0 do theta := simple_reflection(rd,tw[i])*theta od
  ; theta
)

set imaginary_roots (InnerClass ic, [int] tw) =
  imaginary_roots(root_datum(ic),involution(ic,tw))
set real_roots (InnerClass ic, [int] tw) =
  real_roots(root_datum(ic),involution(ic,tw))
set imaginary_coroots (InnerClass ic, [int] tw) =
  imaginary_coroots(root_datum(ic),involution(ic,tw))
set real_coroots (InnerClass ic, [int] tw) =
  real_coroots(root_datum(ic),involution(ic,tw))

{ integrality inner class (dual side) defined by inf. character and involution }
set dual_integral(InnerClass ic, ratvec gamma) =
  let rd = root_datum(ic) then drd = dual(integrality_datum(rd,gamma))
  in inner_class(drd,-^distinguished_involution(ic))

set KGB(RealForm rf) = for i:KGB_size(rf) do KGB(rf,i) od
