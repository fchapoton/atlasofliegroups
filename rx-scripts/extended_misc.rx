<basic.rx
<lattice { added functions, function in_lattice }
<parameters.rx { for parameter(x,y,gamma) }
<Weylgroup


{next two commands have been copied from Vogan-dual.rx}
{ shift (up) a candidate dual infinitesimal character to strictly dominant }
set shift_g_regular (RootDatum rd, ratvec g) = ratvec:
  for alpha@i in simple_roots(rd)
  do let (v,d) = %fundamental_coweight(rd,i)
     in g +:= (1-ceil(g*alpha/d)) * v
  od; g

{canonical_g(x) is a dominant regular element g such that e(g)=x^2
this only depends on real_form(x)
note: square(G)=(base_grading_vector(G)+rho_check(G))%1
}
{set canonical_g(RealForm G)=ratvec:shift_g_regular(G,square(G))}
set canonical_g(RealForm G)=ratvec:base_grading_vector(G)+rho_check(G)
set square (RealForm G) = ratvec: (base_grading_vector(G)+rho_check(G))%1

set canonical_g(KGBElt x)=ratvec:canonical_g(real_form(x))
set canonical_g(Param p)=ratvec:canonical_g(real_form(p))

{dual_gamma(p) differs from canonical_g(p) by rho_check(integrality_datum(p))
choice of infinitesimal character for integrality subgroup on the dual side
}
set dual_gamma (Param p) = ratvec: { we want this to be strictly dominant }
  let G = real_form(p), dual_rho = rho_check(integrality_datum(p))
  in shift_g_regular(G,base_grading_vector(G) + dual_rho)

{ some variants of Cayley transforms }

{ inv_Cayley terminology is not necessary }
set Cayley(int i,Param p) = Param:
  if is_real(i,x(p)) then inv_Cayley(i,p) else Cayley(i,p) fi

{ Cayley transform as a set (actually an array, but the order doesn't matter) }
set Cayley_set(int j,Param p) = [Param]:
  let q=Cayley(j,p) in
  if status(j,p)%5=2 { r1 or i2 } then [q,cross(j,q)] else [q] fi

{ doubly iterated Cayley }
set Cayley_set(int j, int k, Param p) = [Param]:
  let rv=[Param]: [] in
  for q in Cayley_set(k,p) do rv #:=Cayley_set(j,q) od; rv

{ uniform syntax for single or iterated Cayley }
set Cayley_set([int] kappa, Param p) = [Param]:
  if #kappa=1 then Cayley_set(kappa[0],p)
  elif #kappa=2 then Cayley_set(kappa[0],kappa[1],p)
  else error("iterated Cayley only defined for 1 or 2 steps")
  fi

set W_cross([int] s,KGBElt x)=for i:#s downto 0 do x:=cross(s[i],x) od;x
set W_cross([int] s,Param p)=for i:#s downto 0 do p:=cross(s[i],p) od;p

{ action of delta on KGB for general distinguished delta
 if delta=distinguished_involution(real_form(x)) then twist(delta,x)=twist(x)
}
set twist(mat delta,KGBElt x) = KGBElt:
  KGB_elt(real_form(x),delta*involution(x)*delta,torus_factor(x)*delta)

{ action of general distinguished delta on parameter }
set twist(mat delta,Param p)=
  let (x,lambda_rho,nu) = %p
  in parameter(twist(delta,x),delta*(lambda_rho+rho(real_form(x))),delta*nu)

set is_fixed (mat delta, Param p) = bool: 
{let ()=prints("is_fixed p:", p) in} p=twist(delta,p)

set is_fixed (ratvec gamma, mat delta, KGBElt x,KGBElt y) = bool:
  is_fixed(delta,parameter(x,y,gamma))

{ KGBElt is fixed by twist by matrix delta }
set is_fixed (mat delta, KGBElt x) = bool: x=twist(delta,x)
set is_fixed (mat delta, KGBElt x, KGBElt y) = bool:is_fixed(delta,x) and is_fixed(^delta,y)

{ Stuff related to KGB }
{ KGB element x is represented by xi=t\sigma_w\xi_0
  { defition: e(v)=exp(2i\pi v) }
  t=e(v) for v in X_*\otimes Q
  in realex: torus_factor(x)=2*v-rho_check(G) (NB: v is multiplied by 2)
  I prefer to work with the "actual torus factor" v
}

: x_rep = (ratvec,mat)

{ in_A(v,theta): test if e(v) is in A:=(H^{-theta})^0 }
{ test: (1+theta)v in (1+theta)X_*, see definition of conjugator a few lines
  down in this file, and the miscelanneous section of the EPiA }
set in_A(x_rep(v,theta)) = bool:
  let M=1+theta then w=M*v
  in is_integer(w) and in_lattice(M,ratvec_as_vec(w))

{ e(v_1)theta_1 is H-conjugate to e(v_2)theta_2
  implicit: e(v_i)theta_i=e(v_i)sigma_i*xi_0 (i=1,2) in same extended group
  for G
  test: theta_1=theta_2, e(v_1-v_2) is in A=(H^{\theta_1})^0 }
set is_equivalent(x_rep(v_1,theta_1),x_rep(v_2,theta_2)) = bool:
  theta_1=theta_2 and in_A(v_1-v_2,theta_1)

set square_is_central(InnerClass ic,x_rep(v,theta)) = bool:
  square_is_central(ic,theta,v) { defined in parameters.rx }

{ in PFTR: z=i^<tau,(delta_0-1)l>(-1)^<lambda,t>
  PFTR:delta_0 is ^delta here }
set log_z(mat delta, vec lambda, vec l, vec tau,vec t) = rat: { modulo 1 }
  l*(delta-1)*tau/4+t*lambda/2
set log_zeta(mat delta, vec lambda, vec l,vec tau,vec t) = rat: { modulo 1 }
  l*(delta-1)*tau/4+l*tau/2

: extended_param = (InnerClass,mat,ratvec,vec  ,mat,ratvec,vec,mat,vec,vec)
  {                (ic       delta,gamma,lambda,theta,g,   l,omega,tau,t) }

set ic     (extended_param(ic,,,,,,,,,))     = InnerClass: ic
set delta  (extended_param(,delta,,,,,,,,))  = mat: delta
set gamma  (extended_param(,,gamma,,,,,,,))  = ratvec: gamma
set lambda (extended_param(,,,lambda,,,,,,)) = vec: lambda
set theta  (extended_param(,,,,theta,,,,,))  = mat: theta
set g      (extended_param(,,,,,g,,,,))      = ratvec: g
set l      (extended_param(,,,,,,l,,,))      = vec: l
set omega  (extended_param(,,,,,,,omega,,))  = mat: omega
set tau    (extended_param(,,,,,,,,tau,))    = vec: tau
set t      (extended_param(,,,,,,,,,t))      = vec: t

set root_datum     (extended_param(ic,,,,,,,,,))     = RootDatum:root_datum(ic)

set dual_parameter(extended_param
      (ic, delta, gamma, lambda, theta, g, l, omega, tau,t)) = extended_param:
  (dual(ic),^delta,g,l,omega,gamma,lambda,theta,t,tau)

set log_z(extended_param(ic,delta,gamma,lambda,theta,g,l,omega,tau,t)) = rat:
  log_z(delta,lambda,l,tau,t)

set log_zeta(extended_param(ic,delta,gamma,lambda,theta,g,l,omega,tau,t)) = rat:
  log_zeta(delta,lambda,l,tau,t)

{compute x,y,parameter and dual parameter of an extended parameter}

set y(extended_param
      (ic, delta, gamma, lambda, theta, g, l, omega, tau,t)) = KGBElt:
  KGB_elt(dual(ic),-theta,(gamma-lambda-rho(ic)))

set x (extended_param (ic, delta, gamma, lambda, theta, g, l, omega, tau,t)) = KGBElt:
  KGB_elt(ic,theta,(g-l-rho_check(ic)))

{set parameter (extended_param (,,gamma,,,,,,,):a) = Param:
  parameter(x(a),y(a),gamma)}
{better: use (x,lambda,gamma)}
set parameter (extended_param (,,gamma,lambda,,,,,,):a) = Param:
  parameter(x(a),lambda+rho(real_form(x(a))),gamma)

set integrality_datum(extended_param E)=integrality_datum(ic(E),gamma(E))

{assume gamma(E) is integrally dominant
 translate by sum of roots to make it dominant
 return (new extended parameter, sum of roots)
see nonintegral.rx
***should not need this any more, now that gamma is allowed to be integrally dominant 
I've disabled Weylgroup:make_dominant_using_roots and hence this function
}
set translate_to_dominant(extended_param E)=(extended_param,vec):
let (new_gamma,shift)=make_dominant_using_roots(root_datum(E),gamma(E)) in 
(extended_param:(ic(E),delta(E),gamma(E)+shift,lambda(E)+shift,theta(E), g(E), l(E), omega(E),tau(E),t(E)),shift)


set fixed_block_of(mat delta, Param p)=[Param]:
let rv=[Param]:[] in 
for p in block_of(p) do if twist(delta,p)=p then  rv#:=p fi od;rv

{ for debugging:
  test that an extended parameter satisfies the defining conditions }
set verify (extended_param
       (ic, delta, gamma, lambda, theta, g, l, omega, tau,t)) =
{  if not square_is_central(ic,theta,(g-l-rho_check(ic))/2)}
  if not square_is_central(ic,theta,(g-l-rho_check(ic)))
  then prints("xi^2 is not central"); false
  elif delta*gamma!=gamma then prints("gamma is not delta-fixed"); false
  elif g*delta!=g then prints("g is not ^delta-fixed"); false
  elif delta*theta != theta*delta
  then prints("involution is not fixed by delta"); false
  elif omega!=-^theta
  then prints("Cartan involutions are not compatible"); false
  elif g*(1-theta)!=(l+rho_check(ic))*(1-theta)
  then prints("(1-^theta)g\ne (1-^theta)(l+rho^v)"); false
  elif gamma*(1-omega)!=(lambda+rho(ic))*(1-omega)
  then prints("(1-^omega)gamma\ne (1-^omega)(lambda+rho)"); false
  elif -l*(1-delta)!=t*(1+theta)
  then prints("(^delta-1)l\ne (1+^theta)t"); false
  elif -(1-delta)*lambda!=(1-theta)*tau
  then prints("(delta-1)lambda\ne (1+^omega)tau"); false
  else true fi

{ fixed(delta,B): select array of parameters from B fixed by delta }
set fixed(mat delta, [Param] B)=[Param]:
  let rv=[Param]:[] in for p in B do if is_fixed(delta,p) then rv#:=p fi od; rv

{ display(E): terse output of E }
set display (extended_param (,,gamma,lambda,,g,l,,tau,t):E) = void:
( prints("     x=", x(E))
;prints(" gamma=",gamma)
; prints("     g=",g)
; prints("")
; prints("lambda=",lambda)
; prints("   tau=",tau)
; prints("     l=",l)
; prints("     t=",t)
)

set display_one_line (extended_param (,,,lambda,,,l,,tau,t)) = void:
  prints(lambda,", ", tau, ", ", l, ", ", t, ", ")
