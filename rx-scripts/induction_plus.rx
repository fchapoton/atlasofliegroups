<basic.rx
<kl.rx { for character_formula }
<groups.rx { for Sp }
<group_operations.rx { for real_Levi }
<coherent.rx {needed for standardize}

{convert a possibly non-standard parameter into a linear combination of standard ones} 
set standardize(Param p)=ParamPol:
if is_standard(p) then ParamPol:p else
let i_root_system=root_datum(simple_imaginary_subsystem(x(p))) then
lambda=lambda(p) then
(lambda_dom,w)=make_dominant(i_root_system,lambda) then
p_dom=parameter(x(p), act(inverse(w),lambda(p)), nu(p))
in coherent_std(w,p_dom) fi

set standardize(ParamPol P)=ParamPol:
let rv=null_module(P) in for c@p in P do rv+:=c*standardize(p) od;rv

{induction from a general real parabolic}
{L is a real Levi factor in G, having been constructed using real_Levi(x_G)}

{KGB(L) embeds in KGB(G): x_L -> embed_KGB(x_L,G)}
set embed_KGB(KGBElt x_L,RealForm G)=KGBElt:KGB_elt(G,involution(x_L), torus_factor(x_L))

{Given a kgb element x, construct a set S of complex roots containing one representative
of each pair (alpha,theta(alpha))}
set makeS (KGBElt x)=[([int],bool)]:
   let G=real_form(x) in let theta=involution(x) in
   let pr=posroots(G) in let list=[([int],bool)]: for al in pr do (al,true) od in
   for i:#list do let (al,b)=list[i] in if b then for j:#list do
      let (beta,c)=list[j] in if beta=theta*al  or beta=-theta*al then
      list[j]:=(beta,false) fi od fi od; list

{construct the complex rho shift rho_S:=(1-theta)rho(S)}
set rhoS (KGBElt x)=ratvec:
     let theta=involution(x) in	let list=makeS(x) in
     let (r,c)=#theta in let Q=null(r) in for (beta,b) in list do
    if b then Q:=Q+beta-theta*beta fi od; 1/2*Q

{construct the complex rho shift theta_rho_S:=(1+theta)rho(S)}
set theta_rhoS (KGBElt x)=ratvec:
     let theta=involution(x) in let list=makeS(x) in
     let (r,c)=#theta in let Q=null(r) in for (beta,b) in list do
    if b then Q:=Q+beta+theta*beta fi od; 1/2*Q

{parameters for real Levi L -> parameters for G:
p_L=(x_L,lambda,nu) -> p_G=(embed_KGB(x_L,G),lambda + appropriate rho-shift,nu)
rho-shift is: rho_r(G)-rho_r(L)+(1-theta)(rho_S(G)-rho_S(L))
Then Ind_L^G(I(p_L))=I(p_g)}
set induce_standard(Param p_L,RealForm G)=Param:
let L=real_form(x(p_L)) in let x_G=embed_KGB(x(p_L),G) in
parameter(x_G,lambda(p_L)+rho_r(x_G)+rhoS(x_G)-rho_r(x(p_L))-rhoS(x(p_L)), nu(p_L))

{parameters for theta stable Levi L -> parameters for G:
p_L=(x_L,lambda,nu) -> p_G=(embed_KGB(x_L,G),lambda + appropriate rho-shift,nu)
rho-shift is: rho_i(G)-rho_i(L)+(1+theta)(rho_S(G)-rho_S(L))
Then Ind_L^G(I(p_L))=I(p_g)}
set theta_induce_standard(Param p_L,RealForm G)=ParamPol:
let L=real_form(x(p_L)) in let x_G=embed_KGB(x(p_L),G) then
p_G=parameter(x_G,lambda(p_L)+rho_i(x_G)+theta_rhoS(x_G)-rho_i(x(p_L))-theta_rhoS(x(p_L)), nu(p_L)) in 
prints("p_L: ", p_L);prints("p_G before standardization: ", p_G); standardize(p_G)

{write Ind(J) as a sum of standards for G}
{write J(p_L)=sum_i a_i* I_L(p_i)
compute sum_i a_i*induce_standard(I_L(p_i))
probably won't use this function much, it is mainly used in induced_irreducible}
set induce_irreducible_as_sum_of_standards(Param p_L, RealForm G)=
let cf=character_formula(p_L) in
let rv=null_module(G) in
for coeff@p in cf do rv+:=coeff*induce_standard(p,G) od;rv

{write theta stable Ind(J) as a sum of standards for G}
{write J(p_L)=sum_i a_i* I_L(p_i)
compute sum_i a_i*theta_induce_standard(I_L(p_i))
probably won't use this function much, it is mainly used in theta_induce_irreducible}
set theta_induce_irreducible_as_sum_of_standards(Param p_L, RealForm G)=
let cf=character_formula(p_L) in
let rv=null_module(G) in
for coeff@p in cf do rv+:=coeff*theta_induce_standard(p,G) od;rv

{write Ind(J) as a sum of irreducibles for G
use composition series to convert induce_irreducible_as_sum_of_irreducibles
then convert to sum of irreducibles using composition_series()}
set induce_irreducible(Param p_L, RealForm G)=
let cf=induce_irreducible_as_sum_of_standards(p_L,G) in
let rv=null_module(G) in
for coeff@p in cf do rv+:=coeff*composition_series(p) od;rv

{write Ind(J) as a sum of irreducibles for G
use composition series to convert theta_induce_irreducible_as_sum_of_irreducibles
then convert to sum of irreducibles using composition_series()}
set theta_induce_irreducible(Param p_L, RealForm G)=
let cf=theta_induce_irreducible_as_sum_of_standards(p_L,G) in
let rv=null_module(G) in
for coeff@p in cf do rv+:=coeff*composition_series(p) od;rv



