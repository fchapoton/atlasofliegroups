<hermitian.rx { loads lots of other necessary stuff }
<my_lattice  { replacement for lattice.rx }

<parameters.rx { for square(x) }
<extended_misc  { basis for extended parameters }
<extended_types  { types of extended parameters }
<extended_cross  {cross action of extended parameters}
<extended_cayley  {Cayley transforms of extended parameters}

{       references:
  Parameters for Twisted Representations (Adams/Vogan)
  Extended Parameters in Atlas (Adams)
  Computing Twisted KLV Polynomials (Adams)
  More on the 2i12, 2Ci, 1i cases (Adams)
  Examples of extended paramters/braid relations (Adams)
  all found at www.liegroups.org/papers/extended (no public link)
}

{ extended parameter:
  the type abbreviation extended_param is defined in extended_misc.rx

  extended_param:(ic,delta,gamma,lambda,theta,g,l,omega,tau,t), is:

(InnerClass ic, {inner class}
 mat delta,     {twist}
 ratvec gamma,  {infinitesimal character, in X^*(H)\otimes Q}
 vec lambda,    {in X^*}
 mat theta,     {^theta_x = -theta_y}
 ratvec g,      {infinitesimal co-character, in X_*(H)\otimes Q}
 vec l,         {in X_*}
 mat omega,     {-^theta = ^theta_y = -theta_x}
 vec tau,       {in X^*}
 vec t          {in X_*}
)

 X^* = X^*(H) = X_*(H^v)
 X_* = X_*(H) = X^*(H^v)
 xi_0: distinguished involution of the inner class
 xi_0^v: distinguished involution of dual inner class
         (=-w_0\xi_0^t on level of root data)
 e(v)=exp(2i\pi v) (in \h=Lie(H) or \h^v=\h^*)

}

{ Reminders about what acts where
  delta, xi_0, theta, ^omega act on X^*,
                             which contains gamma,lambda,tau,rho,alpha
  ^delta, ^xi_0, omega, ^theta act on X_*,
                             which contains g,l,t,rho_check,alpha_check

 Warning: lambda is in X^*, NOT the same as lambda in (x,lambda,nu) in atlas,
 (which is in X^*+\rho) rather it is the weight vector atlas call lambda-rho

 (g,l,theta) -> xi:
 g = infinitesimal co-character, in X_*\otimes Q, delta-fixed
 precondition: (1-^theta)g=(1-^theta)(l+rho^v)
 l in X_*
    -> torus element e((g-l)/2) in H
 theta: involution of X^*(H), theta=^theta_x, acting on X^*
    -> w such that theta=w*\xi_0
 (g,l,theta)
    -> xi=e((g-l)/2)\sigma_w\xi_0
    -> x=image of xi in KGB space X of G

 (gamma,lambda,omega) -> eta
 entirely dual to construction of xi
 precondition: gamma*(1-omega)=(lambda+rho)*(1-omega)
 also: omega=-^theta
   -> e((gamma-lambda)/2)\in H^v
   -> eta=e((gamma-lambda)/2)\sigma_{ww_0}\xi^v_0
   -> y=image of eta in KGB space X^v of G^v

 t: solution in X_* to (1-^delta)l=(1+^theta)t
   -> h=e(t/2)\in H(w)
   -> h\delta in the extended Cartan, i.e. \xi(h\delta)\xi^{-1}=h\delta
 tau: solution to (1-delta)lambda=(1+^omega)tau
   -> e(tau/2)\in H^v(2)
   -> element of extended Cartan on dual side (don't give this element a name)
}

{ main construction of extended parameters
  E: (ic,delta,gamma,x,g,y) -> (ic,delta,gamma,lambda,theta,g,l,omega,tau,t)
  (ic inner class,
   delta involution of based root datum,
   gamma a logarithm of square(y),
   lambda=gamma-2*actual_torus_factor(y)
   theta=involution(x) (!!!)
   g a logarithm of square(x),
   l=g-2*actual_torus_factor(x)
   omega=involution(y) = -^theta
   tau: solve (1-delta)*lambda = (1+^omega)tau
   t:   solve l*(1-delta)      = t*(1+theta)
}

set E(mat delta, ratvec gamma, KGBElt x, ratvec g, KGBElt y) = extended_param:
  let () =
    if dual(inner_class(real_form(x)))!=inner_class(real_form(y))
    then error("inner classes are not dual")
    elif not is_fixed(delta,x) then error("x is not fixed by delta")
    elif not is_fixed(^delta,y) then error("y is not fixed by ^delta")
    elif square(y) != gamma%1
    then error("y is not compatible with infinitesimal character gamma")
    elif square(x) != g%1
    then error("x is not compatible with infinitesimal cocharacter g")
    fi
  then l = ratvec_as_vec(g-2*actual_torus_factor(x))
  , theta=involution(x), omega=involution(y) { NOTE ^theta=-omega }
  , lambda = ratvec_as_vec(gamma-2*actual_torus_factor(y))
  then (t,result1)=solve(1-omega,ratvec_as_vec(l*(delta-1)))
  ,  (tau,result2)=solve(1-theta,ratvec_as_vec((delta-1)*lambda))
  in
  if result1=false
  then error("(1-^delta)l=(1+^theta)t has no integral solution")
  elif result2=false
  then error("(1-delta)lambda=(1+theta)tau has no integral solution")
  else (inner_class(real_form(x)),delta,gamma,lambda,theta,g,l,omega,tau,t)
  fi

{ in case of an integral parameter, we can deduce gamma and y from it }
set E(mat delta, Param p, ratvec g) = extended_param:
  E(delta, infinitesimal_character(p), x(p), g, y(p))
{ a curious permutation of the arguments w.r.t. the main definition of E }
set E(mat delta, KGBElt x, KGBElt y, ratvec gamma, ratvec g) = extended_param:
  E(delta,gamma,x,g,y)

{ here we assume delta=distinguished_involution(G) }
set E(Param p, ratvec g) = extended_param:
  E(distinguished_involution(real_form(p)),p,g)

set torus_factor(extended_param(,,,,,g,l,,,)) = ratvec: (g-l)/2
set dual_torus_factor(extended_param(,,gamma,lambda,,,,,,)) = ratvec:
  (gamma-lambda)/2
set nu(extended_param e) = ratvec: nu(gamma(e),x(e))

{ sign(E,F)=\pm 1 (or 0): nonzero tells whether the parameters for G are
  equivalent up to sign, and gives that sign.
  If E,F lie over the same ordinary parameter then sign(E,F)=\pm 1.
  The formula is the last line of Proposition 6.12 of PFTR.
  The i term of this formula is not symmetric in G and G^\vee, hence
  we also have dual_sign(E,F)
}
set sign(
  extended_param(ic1,delta1,gamma1,lambda1,theta1,g1,l1,omega1,tau1,t1):E1,
  extended_param(ic2,delta2,gamma2,lambda2,theta2,g2,l2,omega2,tau2,t2):E2
 ) = int:
  if   ic1!=ic2 then prints("inner classes are not equal"); 0
  elif delta1!=delta2 then prints("involutions delta are not equal");0
  elif gamma1!=gamma2 then prints("infinitesimal characters are not equal");0
  elif g1!=g2 then prints("infinitesimal cocharacters are not equal");0
  elif theta1!=theta2 then prints("involutions theta_1,theta_2 are not equal");0
  elif x(E1)!=x(E2) then prints("KGB elements x_1,x_2 are not equal");0
  elif y(E1)!=y(E2) then prints("dual KGB elements y_1,y_2 are not equal");0
  else
  let exp=rat_as_int(
     (-l2*(1-delta1)*tau2
      +l1*(1-delta1)*tau1
     )/2 + (l2-l1)*tau1 + t2*(lambda2-lambda1)
   ) in (-1)^exp
fi

{ dual_sign(E,F) see sign(E,F); dual_sign(E,F) tells whether the extended
  parameters for G^\vee defined by E,F are equivalent or not
}
set dual_sign(
  extended_param(ic1,delta1,gamma1,lambda1,theta1,g1,l1,omega1,tau1,t1):E1,
  extended_param(ic2,delta2,gamma2,lambda2,theta2,g2,l2,omega2,tau2,t2):E2
 ) = int:
  if   ic1!=ic2 then prints("inner classes are not equal");0
  elif delta1!=delta2 then prints("involutions delta are not equal");0
  elif gamma1!=gamma2 then prints("infinitesimal characters are not equal");0
  elif g1!=g2 then prints("infinitesimal cocharacters are not equal");0
  elif theta1!=theta2 then prints("involutions theta_1,theta_2 are not equal");0
  elif x(E1)!=x(E2) then prints("KGB elements x_1,x_2 are not equal");0
  elif y(E1)!=y(E2) then prints("dual KGB elements y_1,y_2 are not equal");0
  else
    let exp=rat_as_int(
       (-t2*(1-delta1)*lambda2
        +t1*((1-delta1)*lambda1)
       )/2 + t1*(lambda2-lambda1) + (l2-l1)*tau2
    ) in (-1)^exp
fi

{ default(F)=\pm F is the extended parameter constructed by atlas (by the
  function E) with the same image as F. So
  default(F)=E(delta,parameter(F),g(F))
}
set default(extended_param F) = extended_param:
  E(delta(F),parameter(F),g(F))

set      sign (extended_param Ep) =int:      sign(Ep,default(Ep))
set dual_sign (extended_param Ep) =int: dual_sign(Ep,default(Ep))

set = (extended_param xp1, extended_param xp2) = bool: sign(xp1,xp2)=1

{ print information about an extended block }
set ext_print_block(mat delta, [Param] B) = void:
  let G=real_form(B[0]) in
  for p@i in B do
    if is_fixed(delta,p)
    then let types="" in
      for s:ss_rank(G) do types+:=" "+ext_type(delta,s,p) od
    ; prints(i, " ", types, ": ", p)
    fi
  od

set ext_print_trivial_block (RealForm G) = void:
  let (B,)=block(trivial(G))
  in ext_print_block(distinguished_involution(G),B)

{ for convenience
 usage: set (delta,B,g) = ext_basic(G)
 then you can run, for example test_hecke(0,1,delta,B,g)
}
set ext_basic (RealForm G) = (mat,[Param],ratvec):
  (distinguished_involution(G),trivial_block(G), rho_check(G))

{ is_default(E)=1 if E is equivalent to the extended parameter constructed
  by the software, lying over p=p(E)
}
set is_default (extended_param(,delta,gamma,,,g,,,,):xp) = bool:
  xp=E(delta,gamma,x(xp),g,y(xp))


