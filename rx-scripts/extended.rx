<basic
<representations
<lattice  
<Weylgroup
<synthetic  {for is_conjugate}
<parameters.rx { for square(x) }
<extended_misc  { basis for extended parameters }
<extended_types  { types of extended parameters }
<extended_cross  {cross action of extended parameters}
<extended_cayley  {Cayley transforms of extended parameters, also loads nonintegral.rx}

{       references:
  Parameters for Twisted Representations (Adams/Vogan)
  Extended Parameters in Atlas (Adams)
  Computing Twisted KLV Polynomials (Adams)
  More on the 2i12, 2Ci, 1i cases (Adams)
  Examples of extended paramters/braid relations (Adams)
  all found at www.liegroups.org/papers/extended (no public link)
}

{ extended parameter:
  the type abbreviation extended_param is defined in extended_misc.rx

  extended_param:(ic,delta,gamma,lambda,theta,g,l,omega,tau,t), is:

(InnerClass ic, {inner class}
 mat delta,     {twist}
 ratvec gamma,  {infinitesimal character, in X^*(H)\otimes Q}
 vec lambda,    {in X^*}
 mat theta,     {^theta_x = -theta_y}
 ratvec g,      {infinitesimal co-character, in X_*(H)\otimes Q}
 vec l,         {in X_*}
 mat omega,     {-^theta = ^theta_y = -theta_x}
 vec tau,       {in X^*}
 vec t          {in X_*}
)

 X^* = X^*(H) = X_*(H^v)
 X_* = X_*(H) = X^*(H^v)
 xi_0: distinguished involution of the inner class
 xi_0^v: distinguished involution of dual inner class
         (=-w_0\xi_0^t on level of root data)
 e(v)=exp(2i\pi v) (in \h=Lie(H) or \h^v=\h^*)

}

{ Reminders about what acts where
  delta, xi_0, theta, ^omega act on X^*,
                             which contains gamma,lambda,tau,rho,alpha
  ^delta, ^xi_0, omega, ^theta act on X_*,
                             which contains g,l,t,rho_check,alpha_check

 Warning: lambda is in X^*, NOT the same as lambda in (x,lambda,nu) in atlas,
 (which is in X^*+\rho) rather it is the weight vector atlas call lambda-rho

 (g,l,theta) -> xi:
 g = infinitesimal co-character, in X_*\otimes Q, delta-fixed
 precondition: (1-^theta)g=(1-^theta)(l+rho^v)
 l in X_*
    -> torus element e((g-l)/2) in H
 theta: involution of X^*(H), theta=^theta_x, acting on X^*
    -> w such that theta=w*\xi_0
 (g,l,theta)
    -> xi=e((g-l)/2)\sigma_w\xi_0
    -> x=image of xi in KGB space X of G

 (gamma,lambda,omega) -> eta
 entirely dual to construction of xi
 precondition: gamma*(1-omega)=(lambda+rho)*(1-omega)
 also: omega=-^theta
   -> e((gamma-lambda)/2)\in H^v
   -> eta=e((gamma-lambda)/2)\sigma_{ww_0}\xi^v_0
   -> y=image of eta in KGB space X^v of G^v

 t: solution in X_* to (1-^delta)l=(1+^theta)t
   -> h=e(t/2)\in H(w)
   -> h\delta in the extended Cartan, i.e. \xi(h\delta)\xi^{-1}=h\delta
 tau: solution to (1-delta)lambda=(1+^omega)tau
   -> e(tau/2)\in H^v(2)
   -> element of extended Cartan on dual side (don't give this element a name)
}

{ main construction of extended parameters
  E: (ic,delta,gamma,x,g,y) -> (ic,delta,gamma,lambda,theta,g,l,omega,tau,t)
  (ic inner class,
   delta involution of based root datum,
   gamma a logarithm of square(y),
   lambda=gamma-(torus_factor(y)+rho(ic))
   theta=involution(x) (!!!)
   g a logarithm of square(x),
   l=g-(torus_factor(x)+rho_check(ic))
   omega=involution(y) = -^theta
   tau: solve (1-delta)*lambda = (1+^omega)tau
   t:   solve l*(1-delta)      = t*(1+theta)
}

{primary definition of E: E(delta,x,gamma,g,lambda)
lambda\in X^*+\rho
}
set E(mat delta, KGBElt x, ratvec gamma, ratvec g, ratvec lambda)=extended_param:
  let () =
    if not is_fixed(delta,x) then error("x is not fixed by delta")
    elif not is_integer(square(x)-g)
    then error("x is not compatible with infinitesimal cocharacter g")
    fi
    then theta=involution(x) 
{    then l=ratvec_as_vec( (g-(1+^theta)*torus_factor(x)/2-rho_check(real_form(x))))}
{torus_factor(x) is ^theta fixed}
    then l=ratvec_as_vec(g-torus_factor(x)-rho_check(inner_class(x)))
    { g-(1+^theta)(tf(x))=l+rho^v =>
     (1-^theta)g = (1-^theta)(l+rho^v) as required above}
    then omega=-^theta
    then lambda_E=ratvec_as_vec(lambda-rho(real_form(x)))  {lambda_E in X^*}
    then (t,result1)  =solve((1-omega),ratvec_as_vec(-(1-^delta)*l)),
         (tau,result2)=solve((1-theta),ratvec_as_vec(-(1-delta)*lambda_E))
  in
  if result1=false
  then error("(1-^delta)l=(1+^theta)t has no integral solution")
  elif result2=false
  then error("(1-delta)lambda=(1+theta)tau has no integral solution")
  else (inner_class(real_form(x)),delta,gamma,lambda_E,theta,g,l,omega,tau,t)
  fi  

{in the nonintegral case the next definition uses KGBElt_gen for y, see synthetic.rx}

set E(mat delta, ratvec gamma, KGBElt x, ratvec g, KGBElt_gen y) = extended_param:
if dual(inner_class(x))!=inner_class(y)
 then error("inner classes are not dual")
 elif not is_fixed(delta,x) then error("x is not fixed by delta")
 elif not is_fixed(^delta,y) then error("y is not fixed by ^delta")
 elif square(y)%1 != gamma%1  {%1: mod(Z^n)}
 then prints("square y:", square(y), "gamma:", gamma); error("y is not compatible with infinitesimal character gamma")
 elif square(x)%1 != g%1
  then error("x is not compatible with infinitesimal cocharacter g")
else
{torus_factor(x) is ^theta fixed}
let l=ratvec_as_vec(g-torus_factor(x)-rho_check(inner_class(x)))
  , theta=involution(x), omega=involution(y) { NOTE ^theta=-omega }
  , lambda = ratvec_as_vec(gamma-torus_factor(y)-rho(inner_class(x)))
  then (t,result1)=solve(1-omega,ratvec_as_vec(l*(delta-1)))
  ,  (tau,result2)=solve(1-theta,ratvec_as_vec((delta-1)*lambda))
  in
  if result1=false    then error("(1-^delta)l=(1+^theta)t has no integral solution")
   elif result2=false then error("(1-delta)lambda=(1+theta)tau has no integral solution")
  else 
   (inner_class(real_form(x)),delta,gamma,lambda,theta,g,l,omega,tau,t)
  fi
fi

{ in case of an integral parameter, we can deduce gamma, lambda from it }
set E(mat delta, Param p, ratvec g) = extended_param:E(delta,x(p), infinitesimal_character(p), g, lambda(p))

set E(mat delta, Param p) = extended_param:E(delta,p,canonical_g(p))

{g must satisfy: e(g)=x^2 and is ^delta-invariant}
set E(mat delta, Param p, ratvec g) = extended_param:E(delta,p,g)

{assume delta=distinguished_involution(G)}
set E(Param p, ratvec g) = extended_param:E(distinguished_involution(real_form(p)),p,g)

{assume delta=distinguished_involution(G), use canonical cocharacter}
set E(Param p) = extended_param:let delta=distinguished_involution(real_form(p)) in E(delta,p)

set torus_factor(extended_param(,,,,,g,l,,,)) = ratvec: (g-l)/2
set dual_torus_factor(extended_param(,,gamma,lambda,,,,,,)) = ratvec:
  (gamma-lambda)/2
set nu(extended_param e) = ratvec: nu(gamma(e),x(e))

{ sign(E,F)=\pm 1 (or 0): nonzero tells whether the parameters for G are
  equivalent up to sign, and gives that sign.
  If E,F lie over the same ordinary parameter then sign(E,F)=\pm 1.
  The formula is the last line of Proposition 6.12 of PFTR.
  The i term of this formula is not symmetric in G and G^\vee, hence
  we also have dual_sign(E,F)
}

set sign(
  extended_param(ic1,delta1,gamma1,lambda1,theta1,g1,l1,omega1,tau1,t1):E1,
  extended_param(ic2,delta2,gamma2,lambda2,theta2,g2,l2,omega2,tau2,t2):E2
 ) = int:
  if   ic1!=ic2 then  0
  elif delta1!=delta2 then 0
  elif gamma1!=gamma2 then 0
  elif g1!=g2 then 0
  elif theta1!=theta2 then 0
  elif omega1!=omega2 then 0  {redundant}
  elif x(E1)!=x(E2) then 0
  {elif not KGB_equal(y(E1),y(E2)) then 0}
  {to avoid trouble with construction of y, test conjugacy of e((gamma-lambda)/2)\ch\sigma_w\ch\xi_0 directly}
  {see synthetic.rx:is_conjugate}
  elif not is_conjugate((gamma1-lambda1)/2,(gamma2-lambda2)/2,-theta1) then 0
  else
  let exp=rat_as_int(
     (-l2*(1-delta1)*tau2
      +l1*(1-delta1)*tau1
     )/2 + (l2-l1)*tau1 + t2*(lambda2-lambda1)
   ) in (-1)^exp
fi

{for use in Cayley transforms: define sign(E,[F1,F2])=sign(E,F1)+sign(E,F2)=\pm 1
(assuming sign(F1,F2)=0)
This is mainly used when [F1,F2] is a double-valued Cayley}
set sign(extended_param E,[extended_param] F)=int:sign(E,F[1])+sign(E,F[2])
set sign([extended_param] E,extended_param F)=int:sign(E[1],F)+sign(E[2],F)

set sign_verbose(
  extended_param(ic1,delta1,gamma1,lambda1,theta1,g1,l1,omega1,tau1,t1):E1,
  extended_param(ic2,delta2,gamma2,lambda2,theta2,g2,l2,omega2,tau2,t2):E2
 ) = int:
  if   ic1!=ic2 then prints("inner classes are not equal"); 0
  elif delta1!=delta2 then prints("involutions delta are not equal");0
  elif gamma1!=gamma2 then prints("infinitesimal characters are not equal");0
  elif g1!=g2 then prints("infinitesimal cocharacters are not equal");0
  elif theta1!=theta2 then prints("involutions theta_1,theta_2 are not equal");0
  elif x(E1)!=x(E2) then prints("KGB elements x_1,x_2 are not equal");0
{  elif y(E1)!=y(E2) then prints("dual KGB elements y_1,y_2 are not equal");0}
  {to avoid trouble with construction of y, test conjugacy of e((gamma-lambda)/2)\ch\sigma_w\ch\xi_0 directly}
  {elif not KGB_equal(y(E1),y(E2)) then prints("dual KGB elements y_1,y_2 are not equal");0}
  elif not is_conjugate((gamma1-lambda1)/2,(gamma2-lambda2)/2,-theta1) then prints("gamma_i-lambda_i not conjugate");0
  else
  let exp=rat_as_int(
     (-l2*(1-delta1)*tau2
      +l1*(1-delta1)*tau1
     )/2 + (l2-l1)*tau1 + t2*(lambda2-lambda1)
   ) in (-1)^exp
fi

{ dual_sign(E,F) see sign(E,F); dual_sign(E,F) tells whether the extended
  parameters for G^\vee defined by E,F are equivalent or not
}
set dual_sign(
  extended_param(ic1,delta1,gamma1,lambda1,theta1,g1,l1,omega1,tau1,t1):E1,
  extended_param(ic2,delta2,gamma2,lambda2,theta2,g2,l2,omega2,tau2,t2):E2
 ) = int:
  if   ic1!=ic2 then 0
  elif delta1!=delta2 then 0
  elif gamma1!=gamma2 then 0
  elif g1!=g2 then 0
  elif theta1!=theta2 then 0
  elif x(E1)!=x(E2) then 0
  {elif y(E1)!=y(E2) then 0}
  {to avoid trouble with construction of y, test conjugacy of e((gamma-lambda)/2)\ch\sigma_w\ch\xi_0 directly}
  elif not is_conjugate((gamma1-lambda1)/2,(gamma2-lambda2)/2,-theta1) then 0
  else
    let exp=rat_as_int(
       (-t2*(1-delta1)*lambda2
        +t1*((1-delta1)*lambda1)
       )/2 + t1*(lambda2-lambda1) + (l2-l1)*tau2
    ) in (-1)^exp
fi

{ default(F)=\pm F is the extended parameter constructed by atlas (by the
  function E) with the same image as F. So
  default(F)=E(delta,parameter(F),g(F))
}

{default(F) is the extended parameter the software constructs above p=paramter(F)}
set default(extended_param F) = extended_param:E(delta(F),x(F),gamma(F),g(F),lambda(F)+rho(ic(F)))

set      sign (extended_param E) =int:      sign(E,default(E))
set dual_sign (extended_param E) =int: dual_sign(E,default(E))
set = (extended_param E, extended_param F) = bool: sign(E,F)=1
set is_default (extended_param E)=bool:E=default(E)

{ print information about an extended block }
set ext_print_block(mat delta, [Param] B) = void:
  let G=real_form(B[0]),
  gamma=infinitesimal_character(B[0]) 
  then id=integrality_datum(G,gamma)
  then ()=if  not is_integral(G,gamma) then 
   prints("Infinitesimal character ", gamma, " is not integral.");
   prints("integral root system: ", integrality_datum(G,gamma));
   prints("integral-simple roots in the set of positive roots: ", for alpha in simple_roots(id) do find(posroots(G),alpha) od) 
 fi in 
   for p@i in B do
    if is_fixed(delta,p)
    then let types="" in
      for s:ss_rank(id) do types+:=" "+ext_type(delta,s,p) od
    ; prints(i, " ", types, ": ", p)
    fi
  od

set ext_print_block(mat delta,Param p)=void:ext_print_block(delta,block_of(p))
set ext_print_block(Param p)=void:ext_print_block(distinguished_involution(real_form(p)),block_of(p))

{for dyslexics}
set print_ext_block(mat delta,[Param] B)=void:ext_print_block(delta,B)
set print_ext_block(mat delta,Param p)=void:ext_print_block(delta,p)
set print_ext_block(Param p)=void:ext_print_block(distinguished_involution(real_form(p)),p)

set ext_block_of(mat delta, Param p, ratvec g)=[extended_param]:for p in fixed_block_of(delta,p) do E(delta,p,g) od
set ext_block_of(mat delta, Param p)=[extended_param]:ext_block_of(delta,p,canonical_g(p))
set ext_block_of(Param p)=[extended_param]:ext_block_of(distinguished_involution(real_form(p)),p)

set find([extended_param] list,extended_param E)=(int,int):
let i=0 in 
let rv=(-1,-1) in
while i<#list do 
let s=sign(E,list[i])  in
if s=0 then i:=i+1 else rv:=(s,i);i:=#list fi od;rv

set find(extended_param E,[extended_param] list)=(int,int):find(list,E)

{ for convenience
 usage: set (delta,B,g) = ext_basic(G)
 then you can run, for example test_hecke(0,1,delta,B,g)
}
set ext_basic (RealForm G) = (mat,[Param],ratvec):
  (distinguished_involution(G),trivial_block(G), rho_check(G))

{alpha,beta simple, delta distinguished
 p(alpha), p(beta) images in folded root system
 p(alpha)=(1+delta)alpha or alpha restricted to H^delta
 <p(alpha),p(beta)^v>=2<(1+delta)alpha,beta^v>/<(1+delta)beta,beta^v>
}

{<alpha,beta^\vee> in the quotient root system}
set folded_bracket(RootDatum rd, mat delta, int i, int j)=int:
let alpha=simple_roots(rd)[i],
beta=simple_roots(rd)[j],
betav=simple_coroots(rd)[j] in
rat_as_int(2*((1+delta)*alpha*betav)/((1+delta)*beta*betav))

set folded_m(RootDatum rd, mat delta, int i, int j)=int:
folded_bracket(rd,delta,i,j)*folded_bracket(rd,delta,j,i)

set folded_order(RootDatum rd, mat delta, int i, int j)=int:
let m=folded_m(rd,delta,i,j) in 
if m=0 then 2
elif m=1 then 3
elif m=2 then 4 
elif m=3 then 6
elif m=4 then 1  {case delta(root_i)=root_j}
else error("fundamental error in mathematics (folder_order)") fi
