<lietypes.rx
<Weylgroup.rx
<coherent.rx
<thetastable.rx
<sort.rx
<all_Kparameters.rx
<complex_nilpotent_orbits.rx
set kn_verbose=false
set kn_very_verbose=false
{implementation of parts of Letter to Atlas II: nilpotent orbits}

{return index of alpha in list of roots}
set find([vec] roots,vec alpha)=int:
let done=false,rv=-1,i=0 in
while done=false and i<#roots do
 if roots[i]=alpha then done:=true;rv:=i else i:=i+1 fi od;rv

{given x a theta_x-stable set of roots R, return subset of R
consisting of each imaginary root alpha\in R, and one of each pair
alpha,theta(alpha)
if R isn't theta-stable this will fail}
set extract_roots(KGBElt x, [vec] roots)=[vec]:
let theta=involution(x) then
rv=[] in 
while #roots>0 do 
 let alpha=roots[0] in 
 rv#:=alpha;
 roots:=delete(roots,0);
  if theta*alpha != alpha then
   let  index=find(roots,theta*alpha) in if (index=-1) then error("set of roots is not theta-stable") else 
      roots:=delete(roots, find(roots,theta*alpha))  fi fi od;rv 

{roots of H in s[1]
 s = -1 eigenspace of theta_x
 s[1] = 1 H-eigenspace of H on s
}
set s_one_roots(KGBElt x, ratvec H)=
let theta=involution(x) in 
if ^theta*H != H then error("H is not ^theta-fixed") else
let roots=[] then
()=for alpha in posroots(real_form(x)) do
 if H*alpha=1 or H*alpha=-1 then roots#:=alpha fi od in roots fi

{restriction of s_one_roots to Lie(H)^{theta_x}
 each pair (alpha,theta(alpha)) contributes 
 a single root restriction(alpha)=restriction(theta(alpha)), 
 corresponding to the single vector X_\alpha-\theta(X_\alpha) in s[1]
}
set s_one_roots_restricted(KGBElt x,ratvec H)=[ratvec]:
let roots=s_one_roots(x,H) in
roots:=extract_roots(x,roots);
for alpha in roots do (1+involution(x))*alpha/2 od


{generate all subsets of [ratvec], modified from misc.rx}
set generate_all_subsets([ratvec] S) = [[ratvec]]:
  let len=#S
  , gen (int i) = [[ratvec]]: [] { recursive stub; genee subset of S[i:] }
  in
  ( gen :=
    ((int i):
      if i=len then [[]]
      else let r=gen(i+1) in r # for x in r do S[i]#x od
      fi)
  )(0)

{all subset of the restrictions of the roots of s[1] to Lie(H)^{\theta_x}
 see Knilpotent paper, Corollary 7.3(6)}
set subsets(KGBElt x,ratvec H)=[[ratvec]]:
let roots=s_one_roots_restricted(x,H) in delete(generate_all_subsets(roots),0) {don't want empty subset}

set sum([ratvec] list)=if #list=0 then null(0) else let v=ratvec:null(#list[0]) in for w in list do v+:=w od; v fi

set rho_shifts(KGBElt x,ratvec H)=[(ratvec,int)]:
let S=subsets(x,H) in [(ratvec:null(rank(real_form(x))),0)]#for v in S do (sum(v),#v) od

{this implements the algorithm of Proposition 7.3(6)
p_L must be a standard final limit parameter for L=L(x,H) (i.e. an L\cap K-type)
}
set mu(KGBElt x, ratvec H, KParam p_L)=KParamPol:
if not (is_standard(parameter(p_L))) then error("p_L is not standard") 
elif not (is_final(parameter(p_L))) then error("p_L is not final") 
elif  (is_zero(parameter(p_L))) then error("p_L is zero") 
else
let G=real_form(x) then
rv=null_module(G) then
rhoshifts=rho_shifts(x,H) then
P_L=K_type_formula(parameter(p_L)) then
()=if kn_verbose then
prints("p_L: ", p_L);
prints("K-type formula on L: ", P_L);
prints("terms in sum:") fi then 
 ()=for c@p_L in P_L do
   let fixed_shift=- ( 2*rho_s(x)-2*rho_s(x(p_L))) then
  ()=if kn_verbose then prints("computing term ", p_L) fi in
  for (shift,j) in rhoshifts do   
    let ()=if kn_very_verbose then prints("j=",j," shift=",shift);
   prints("c=",split_as_int(c));
   prints("parameter on L:", p_L) fi in 
   let q=parameter(x(p_L),lambda(p_L)-shift+fixed_shift,nu(p_L)) then
  ()=if kn_very_verbose then prints("shifted param on L:", q) fi then 
   r_1=theta_induce_standard(q,G) then
   ()=if kn_very_verbose then prints("theta_induced parameter on G before standardization:", r_1) fi then
   r_2=standardize(r_1) then
   ()=if kn_very_verbose then prints("theta_induced parameter on G standardized:", r_2) fi then
   r_3=standardize(r_2)*0 {set nu=0} in
  let ()=if kn_very_verbose then prints("theta_induced parameter on G at nu=0:", r_3) fi in 
   rv+:=(-1)^j*c*r_3 od od in rv fi

set mu(KGBElt x, vec H)=KParamPol:mu(x,H,Kparameter(trivial(L(x,H))))

{x_L must be a KGB element for L(x,H)
then p_L=parameter(x_L,lambda_L,0) -> mu(x,H,p_L)
}
set mu(KGBElt x,vec H,KGBElt x_L, ratvec lambda_L)=KParamPol:
let p_L=KParam:(x_L, lambda_L) in mu(x,H,p_L)

{assume ParamPol has integral (not split) coefficients}
set vector([Param] list,ParamPol P)=(bool,vec):
let v=null(#list) then
found=true in
for (c,p) in %P do let 
i=find(list,p) in if i=-1 then found:=false else v[i]+:=split_as_int(c) fi od;(found,v)

{assume ParamPol has integral (not split) coefficients}
set vector([KParam] list,KParamPol P)=(bool,vec):
vector(for q in list do parameter(q) od,P)

{given list=[P_1,...,P_n] of KParamPols
test if P=\sum a_i P_i
}

{list of ParamPols -> list of distinct parameters occuring
careful: don't let terms cancel!
}
set monomials([ParamPol] list)=[Param]:
let sum_list=null_module(real_form(list[0])) in
for P in list do 
 for c@p in P do sum_list+:=p od od;monomials(sum_list)


{given ParamPols Q_1,...,Q_n and P test if 
P=\sum a_i Q_i
Q_i and P are assumed to have integer coefficients
return true/false, and [ParamPol] R,[int] S so that 
P=sum S[i]*R[i]
}
set in_span([KParamPol] list,KParamPol P)=(bool,[KParamPol],[int],[int]):
{let ()=prints("in_span with:");for a in list do prints(a) od; prints("P=",P) in}
let ()=prints("in_span with list of length ",#list, " P=",P) in
if #list=0 then (false,[KParamPol]:[],[int]:[],[int]:[]) else
let G=real_form(list[0]) then
R=[KParamPol]:[] then
S=[int]:[] then
basis=monomials(list) then
{()=prints("basis:", basis) then}
pairs=for Q in list do  {prints("Q=",Q);} vector(basis,Q) od in
let M=mat:for (,w) in pairs do w od then
()=prints("Going to compute vector", #basis, " ", #monomials(P)) then
(valid,T)=vector(basis,P) then
()=prints("Computed vector", #basis, " ", #monomials(P)) in
{let ()=prints("valid:", valid, "T=",T) in}
{let ()=prints("vector is possibly valid:",valid) in}
if valid then 
 let ()=prints("Now solving:", #M, " ", #T) in
 let (v,success)=solve(M,T) then
 ()=prints("Done solving:", #M, " ", #T) in
 if (success) then 
  let ()=prints("success", v) in
  let ()=for i:#v do if v[i]!=0 then 
{    prints("column ",i,":", M[i]); }
    for j:#(M[i]) do if M[i][j]!=0 then prints(basis[j], " ", K_norm(Kparameter(basis[j]))) fi od fi od in
let  ()=for i:#v do 
    if v[i]!=0 then 
       S#:=v[i];
{       let ()=prints("nonzero column i ",v[i], " ", M[i]) in }
       let column=M[i] in 
       let pols=null_module(G) in
       let ()=for j:#column do if column[j]!=0 then (pols+:=column[j]*basis[j]) fi  od in
       R#:=pols fi
  od in 
  (true,[KParamPol]:R,[int]:S,[int]:v)   {if valid and success}
  else (false,[KParamPol]:[],[int]:[],[int]:[]) fi  {if valid and not success}
 else (false,[],[],[]) fi {if valid}
fi {if #list=0}

set in_span_alt([ParamPol] list,ParamPol P)=
let basis=monomials(list) then
{()=prints("basis:", basis) then}
pairs=for Q in list do  {prints("Q=",Q);} vector(basis,Q) od in
let M=mat:for (,w) in pairs do w od then
(valid,T)=vector(basis,P) in 
{let ()=prints("vector is possibly valid:",valid) in}
if valid then 
prints("M=",M);
prints("T=",T);
let inlattice=in_lattice(M,T) in prints("solved in_lattice:",inlattice);(basis,M,T,inlattice)
else prints("can't find vector at all");(basis,M,T,false) fi    

{convenient to define in_span([[ParamPol]] list,ParamPol P)=
in_span( flatten the list,P)
}
set in_span([[ParamPol]] list_of_lists,ParamPol P)=(bool,[ParamPol],[int],[int]):
let list=[ParamPol]:[] in 
let ()=for new_list in list_of_lists do list#:=new_list od in
in_span(list,P)


{given (x,H,n) compute span of all mu(x,H,p_L) for K_norm(p_L)<=n}
set all_mu(KGBElt x,ratvec H,int bound)=
let rv=[Param]:[] then
P=null_module(real_form(x)) then
params_L=all_K_parameters_norm_less_than(L(x,H),rho_check(real_form(x)),bound) in
for p_L in params_L do {prints("ADDING", mu(x,H,p_L));}P+:=mu(x,H,p_L) od;monomials(P)

set all_H_smaller(KGBElt x,ratvec H)=
let rd=root_datum(x) then
allH=all_H(real_form(x)) then
length_H=invariant_form(dual(rd),H,H) then
smaller_H=[] in for (X,) in allH do if invariant_form(dual(rd),X,X)<length_H 
 then smaller_H#:=X fi od;smaller_H

set all_mu_smaller(KGBElt x, ratvec H, int bound)=[ParamPol]:
let G=real_form(x) then
()=prints("in all_mu_smaller with ", x, " ", H, " ", bound) then
smallerH=all_H_smaller(x,H) then
rv=[ParamPol]:[] in
for h in smallerH do 
  let L=L(x,h) in 
  for p_L in all_K_parameters_norm_less_than(L,rho_check(real_form(x)),bound-rat_as_int(2*rho(G)*rho_check(G)) )
  do  let m=mu(x,h,p_L) in 
  if (K_norm(m)<=bound) then 
     prints("ADDING:",h, " ",  L, " ", p_L, " ", m, " ", K_norm(m));rv#:=mu(x,h,p_L) 
  else 
     prints("NOT ADDING:",h, " ",  L, " ", p_L, " ", m, " ", K_norm(m)) fi
 od od;rv

{term_contained(P,Q)=int:N if:
P=\sum a_i p_i
Q=N(\sum a_i p_i) + other terms for some integer N
In other words, let #P be the number of terms in P, 
return N <=>  #(Q-NP)=#Q-#P, otherwise returns 0
}
set term_contained(ParamPol P,ParamPol Q)=int:
let 
(c_p,p)=(%P)[0] then
params_Q=for (,q) in %Q do q od then
N=rat:0 then
k=find(params_Q,p) in
if k=-1 then 0 else
 let (c_q,)=(%Q)[k] in
 N:=split_as_int(c_q)/split_as_int(c_p);
 if not is_integer(N) then 0
 else let diff=Q-rat_as_int(N)*P in 
 if #(monomials(diff))=#monomials(Q)-#monomials(P) then rat_as_int(N) else 0 fi fi fi

set reduce_mu(KGBElt x,ratvec H,KParam p_L)=KParamPol:
let mu=mu(x,H,p_L) then
()=prints("mu=",mu) then
G=real_form(x) then
{bound=K_norm(mu)-rat_as_int(2*rho(G)*rho_check(G)) then}
bound=K_norm(mu) then
()=prints("bound=",bound) then
smaller=all_mu_smaller(x,H,bound) then
()=prints("all_mu_smaller:") then
()=for mu in smaller do print_K_parameter(mu);prints(K_norm(mu)) od in
let rec_fun f(ParamPol Q,[ParamPol] smaller_mu)=ParamPol:
{let ()=prints();prints("trying to reduce:");
print_K_parameter(Q) in}
if #smaller_mu=0 then
prints("Done reducing:");
{print_K_parameter(Q);prints();}Q else
let P={prints("using smaller_mu=");
print_K_parameter(smaller_mu[0]);}smaller_mu[0] then
N=term_contained(leading_terms(P),leading_terms(Q)) in
if N=0 then 
{prints("No reduction");}f(Q,delete(smaller_mu,0)) else
prints("REDUCTION FOUND");prints("after reduction:");
{print_K_parameter(Q-N*P);}f(Q-N*P,smaller)  fi fi in f(mu,smaller)

set reduce_mu(KGBElt x,ratvec H,KGBElt x_L,ratvec lambda_L)=KParamPol:
let p_L=KParam:(x_L,lambda_L) in reduce_mu(x,H,p_L)

set leading_reduce_mu(KGBElt x,ratvec H,KParam p_L)=KParamPol:leading_terms(reduce_mu(x,H,p_L))
set leading_reduce_mu(KGBElt x,ratvec H,KGBElt x_L,ratvec lambda_L)=ParamPol:leading_terms(reduce_mu(x,H,x_L,lambda_L))

