{this file replaces earlier induction_plus.rx}
{real and theta-stable parabolic induction from general parabolic}
set verbose=false
<basic.rx
<kl.rx { for character_formula }
<coherent.rx {for standardize}

{induction from a general real parabolic}
{L is a real Levi factor in G, having been constructed using real_Levi(x_G)}

{KGB(L) embeds in KGB(G): x_L -> embed_KGB(x_L,G)}
set embed_KGB(KGBElt x_L,RealForm G)=KGBElt:KGB_elt(G,involution(x_L), torus_factor(x_L))

{given KGB elemnt of G, find one for M which maps to it}
set inverse_embed_KGB(KGBElt x_G,RealForm M)=KGBElt:KGB_elt(M,involution(x_G), torus_factor(x_G))

{Given a KGB element x, construct a set S of complex roots containing one representative
of each pair (alpha,theta(alpha))}
set makeS (KGBElt x)=[([int],bool)]:
   let G=real_form(x) in let theta=involution(x) in
   let pr=posroots(G) in let list=[([int],bool)]: for al in pr do (al,true) od in
   for i:#list do let (al,b)=list[i] in if b then for j:#list do
      let (beta,c)=list[j] in if beta=theta*al  or beta=-theta*al then
      list[j]:=(beta,false) fi od fi od; list

{construct the complex rho shift rho_S:=(1-theta)rho(S)}
set rhoS (KGBElt x)=ratvec:
     let theta=involution(x) in	let list=makeS(x) in
     let (r,c)=#theta in let Q=null(r) in for (beta,b) in list do
    if b then Q:=Q+beta-theta*beta fi od; 1/2*Q

{construct the complex rho shift theta_rho_S:=(1+theta)rho(S)}
set theta_rhoS (KGBElt x)=ratvec:
     let theta=involution(x) in let list=makeS(x) in
     let (r,c)=#theta in let Q=null(r) in for (beta,b) in list do
    if b then Q:=Q+beta+theta*beta fi od; 1/2*Q

{parameters for real Levi L -> parameters for G:
p_L=(x_L,lambda,nu) -> p_G=(embed_KGB(x_L,G),lambda + appropriate rho-shift,nu)
rho-shift is: rho_r(G)-rho_r(L)+(1-theta)(rho_S(G)-rho_S(L))
Then Ind_L^G(I(p_L))=I(p_g)}
set induce_standard(Param p_L,RealForm G)=Param:
let L=real_form(x(p_L)) in let x_G=embed_KGB(x(p_L),G) in
parameter(x_G,lambda(p_L)+rho_r(x_G)+rhoS(x_G)-rho_r(x(p_L))-rhoS(x(p_L)), nu(p_L))

set induce_standard(ParamPol P,RealForm G)=ParamPol:
let rv=null_module(G) in for c@p in P do rv+:=c*induce_standard(p,G) od;rv

{given a standard module for G, find one for real Levi M which maps to it}
set inverse_induce_standard(Param p, RealForm M)=
let x_G=x(p) then
x_M=inverse_embed_KGB(x(p),M)  in
parameter(x_M,lambda(p)-rho_r(x_G)-rhoS(x_G)+rho_r(x_M)+rhoS(x_M),nu(p)) 

{default: M=Cent(A) where H=TA is the Cartan of p}
set inverse_induce_standard(Param p)=inverse_induce_standard(p,M(x(p)))

{coherent continuation just using the imaginary roots
 this is done by p -> p_M=inverse_induce_standard(p) 
                   -> induce_standard(w.p_M)
 used in standardize@Param
}
set coherent_std_imaginary(W_word w,Param p)=
let M=M(x(p)) then
p_M=inverse_induce_standard(p,M) in
induce_standard(coherent_std(w,p_M),real_form(p))

{convert a possibly non-standard parameter into a linear combination of standard ones} 
{algorithm:
p=(x,lambda,nu)
if <lambda,alpha^vee><0 for some imaginary root alpha (i.e. non-standard)
let i_root_system=imaginary roots for x(p)
find w so that w^{-1}lambda is dominant for imaginary roots
set p_dom=parameter(x,w^{-1}lambda,nu)
and return coherent continuation action (wrt imaginary roots) of w^{-1} on p_dom
this should be w on p_dom, need to fix definition of coherent continuation action
}
set standardize(Param p)=ParamPol:
if is_standard(p) then ParamPol:p else
let i_root_system=root_datum(simple_imaginary_subsystem(x(p))) then
lambda=lambda(p) then
(lambda_dom,w)=make_dominant(i_root_system,lambda) then
p_dom=parameter(x(p), act(inverse(w),lambda(p)), nu(p))
in coherent_std_imaginary(inverse(w),p_dom) fi

set standardize(ParamPol P)=ParamPol:
let rv=null_module(P) in for c@p in P do rv+:=c*standardize(p) od;rv

{parameters for theta stable Levi L -> parameters for G:
p_L=(x_L,lambda,nu) -> p_G=(embed_KGB(x_L,G),lambda + appropriate rho-shift,nu)
rho-shift is: rho_i(G)-rho_i(L)+(1+theta)(rho_S(G)-rho_S(L))
Then p_G=Ind_L^G(I(p_L))=I(p_g)
might not be standard for G (outside of good range), so apply standardize
}
set theta_induce_standard(Param p_L,RealForm G)=ParamPol:
let L=real_form(x(p_L)) in let x_G=embed_KGB(x(p_L),G) then
p_G=parameter(x_G,lambda(p_L)+rho_i(x_G)+theta_rhoS(x_G)-rho_i(x(p_L))-theta_rhoS(x(p_L)), nu(p_L)) then
p_G_standardized=standardize(p_G) then
()=if verbose then prints("p_L: ", p_L) fi in 
if (is_standard(p_G)) then 
 if verbose then prints("p_G is standard: ", p_G, standardize(p_G)) fi
else
 if verbose then
 prints("p_G standardized:", p_G_standardized) fi fi; p_G_standardized

{write Ind(J) as a sum of standards for G}
{write J(p_L)=sum_i a_i* I_L(p_i)
compute sum_i a_i*induce_standard(I_L(p_i))
probably won't use this function much, it is mainly used in induced_irreducible}
set induce_irreducible_as_sum_of_standards(Param p_L, RealForm G)=
let cf=character_formula(p_L) in
let rv=null_module(G) in
for coeff@p in cf do rv+:=coeff*induce_standard(p,G) od;rv

{write theta-stable-Ind(J) as a sum of standards for G}
{write J(p_L)=sum_i a_i* I_L(p_i)
compute sum_i a_i*theta_induce_standard(I_L(p_i))
probably won't use this function much, it is mainly used in theta_induce_irreducible}
set theta_induce_irreducible_as_sum_of_standards(Param p_L, RealForm G)=
let cf=character_formula(p_L) in
{let ()=prints("p_L:",p_L) in 
let ()=prints("Character formula for p_L:") in 
let ()=prints(cf) in }
let rv=null_module(G) in
for coeff@p in cf do 
let new=theta_induce_standard(p,G) in 
{prints("");prints("adding: ", new);prints("");}
rv+:=coeff*new od;
if verbose then prints("induced as sum of standards:", rv) fi;rv

{write Ind(J) as a sum of irreducibles for G
use composition series to convert induce_irreducible_as_sum_of_irreducibles
then convert to sum of irreducibles using composition_series()}
set induce_irreducible(Param p_L, RealForm G)=
let cf=induce_irreducible_as_sum_of_standards(p_L,G) in
let rv=null_module(G) in
for coeff@p in cf do rv+:=coeff*composition_series(p) od;rv

{write theta-induce_irreducible(p_L,G) as a sum of irreducibles}
set theta_induce_irreducible(Param p_L, RealForm G)=
let cf=theta_induce_irreducible_as_sum_of_standards(p_L,G) in
let rv=null_module(G) in
for coeff@p in cf do rv+:=coeff*composition_series(p) od;
if verbose then prints("induced as sum of irreducibles: ", rv) fi;rv



