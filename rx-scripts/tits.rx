<basic.rx
<Weylgroup.rx

{ this file is not needed for the extended groups algorithm }

{ an element of the (extended) Tits group is represented by
  (ratvec v,mat theta) -> \exp(2i\pi v)\sigma_w\delta where \theta=w\delta
  note that the inner class (defining delta) is implicit here
}
: Tits_elt = (ratvec,mat)

set simple_reflection (RootDatum rd, int s) = mat: { s indexes simple root }
  id_mat(rank(rd))- [root(rd,s)] * ^[coroot(rd,s)]

set get_simple_number (RootDatum rd,vec alpha)=
  let rv=-1, i=0 in
  while i<semisimple_rank(rd)
  do if alpha=root(rd,i) then rv:=i;i:=semisimple_rank(rd) else i:=i+1 fi od;rv

{ matrix of action of Weyl word }
set matrix (RootDatum rd,W_word w)=mat:
  let rv=id_mat(rank(rd)) in
  for i:#w downto 0 do rv:=simple_reflection(rd,w[i])*rv od; rv

{action of Weyl word on ratvec}
set action (RootDatum rd,W_word w,ratvec v) = ratvec: matrix(rd,w)*v

{ assuming M is in W }
set length (RootDatum rd, mat M) = int:
  let rv=0 in
  for r in posroots(rd)
  do if (not is_positive_root(rd,M*r)) then rv+:=1 fi od; rv

{ left multiplication by \sigma_k, where k must index a simple root }
set left (RootDatum rd,int k,Tits_elt(v,theta)) = Tits_elt:
  let r=simple_reflection(rd,k) in
  if (length(rd,r*theta)>length(rd,theta)) then (^r*v,r*theta) else
  let alpha_check=coroot(rd,k) in (^r*v+alpha_check/2,r*theta) fi

{ right multiplication by \sigma_k, where k must index a simple root }
set right (RootDatum rd,int k, Tits_elt(v,theta)) = Tits_elt:
  let r=simple_reflection(rd,k) in
  if (length(rd,theta*r)>length(rd,theta)) then (v,theta*r)
  else let alpha_check=coroot(rd,k) in
   (v+^theta*alpha_check/2,theta*r)  {CHECK the sign v-^r...}
  fi

set left (RootDatum rd, W_word ww,Tits_elt xi) = Tits_elt:
  for j:#ww downto 0 do xi:=left(rd,ww[j],xi) od; xi

set right (RootDatum rd, W_word ww,Tits_elt xi) = Tits_elt:
  for j:#ww downto 0 do xi:=right(rd,ww[j],xi) od; xi

{ left multiply by \exp(2i\pi w)\sigma_k }
set left(RootDatum rd, (ratvec,int)(w,k), Tits_elt(v,theta)) = Tits_elt:
  let (u,phi)=left(rd,k,(v,theta)) in (u+w,phi)

{ right multiply by \exp(2i\pi w)\sigma_k }
set right(RootDatum rd, (ratvec,int)(w,k), Tits_elt(v,theta)) = Tits_elt:
  let (u,phi)=right(rd,k,(v,theta)) in (u+^theta*w,phi)

set conjugate (RootDatum rd, int k, Tits_elt xi) = Tits_elt:
  let alpha_check=coroot(rd,k) in
  right(rd,(alpha_check/2,k),left(rd,k,xi))

set conjugate (RootDatum rd, W_word ww, Tits_elt xi) = Tits_elt:
  for j in reverse(ww)
  do prints("conj:", j); xi:=conjugate(rd,j,xi) od; xi

{ inverse uses the bicycle lemma:
  sigma_w*sigma_{w^{-1}}=exp(2\ pi i(rho^vee-wrho^vee)/2)
}
set inverse (RealForm G,Tits_elt(v,theta)) = Tits_elt:
  (-v*theta-rho_check(G)/2+rho_check(G)*theta/2,theta)

set = (Tits_elt(v,theta),Tits_elt(w,phi)) = bool: v=w and phi=theta

