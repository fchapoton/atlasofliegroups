{an element of the (extended) Tits group is represented by 
([ratvec] v,mat theta) -> \exp(2i\pi v)\sigma_w\delta where \theta=w\delta}

set simple_reflection (RootDatum rd, int s) = mat: { s indexes simple root }
  id_mat(rank(rd))- [simple_roots(rd)[s]] * ^[simple_coroots(rd)[s]]

set get_simple_number(RootDatum rd,vec alpha)=
let rv=-1 in 
let i=0 in 
while i<ss_rank(rd) do  if alpha=simple_roots(rd)[i] then rv:=i;i:=ss_rank(rd) else i:=i+1 fi od;rv

{matrix of action of Weyl word}
set matrix(RootDatum rd,[int] w)=mat:
let rv=id_mat(rank(rd)) in 
for i:#w downto 0 do rv:=simple_reflection(rd,w[i])*rv od;rv

{action of Weyl word on ratvec}
set action(RootDatum rd,[int] w,ratvec v)=ratvec:matrix(rd,w)*v

set is_positive_root(RootDatum rd,vec v)=v*rho_check(rd)>0

{assuming M is in W}
set length(RootDatum rd, mat M)=int:
let rv=0 in
for r in posroots(rd) do if (not is_positive_root(rd,M*r)) then rv+:=1 fi od;rv

set left(RootDatum rd,int k,(ratvec,mat)(v,theta))=
let r=simple_reflection(rd,k) in 
if (length(rd,r*theta)>length(rd,theta)) then (^r*v,r*theta) else 
let alpha_check=simple_coroots(rd)[k] in (^r*v+alpha_check/2,r*theta) fi

set right(RootDatum rd,int k, (ratvec,mat)( v, theta))=
let r=simple_reflection(rd,k) in 
if (length(rd,theta*r)>length(rd,theta)) then (v,theta*r) else 
let alpha_check=simple_coroots(rd)[k] in 
(v+^theta*alpha_check/2,theta*r) fi  {CHECK the sign v-^r...}

set left(RootDatum rd, [int] s,(ratvec,mat)(v,theta))=
let rv=(v,theta) in 
for j:#s downto 0 do rv:=left(rd,s[j],rv) od;rv

set right(RootDatum rd, [int] s,(ratvec,mat)(v,theta))=
let rv=(v,theta) in 
for j:#s downto 0 do rv:=right(rd,s[j],rv) od;rv

set left(RootDatum rd, (ratvec,int)(w,k),(ratvec,mat)(v,theta))=
let (u,phi)=left(rd,k,(v,theta)) in (u+w,phi)

set right(RootDatum rd, (ratvec,int)(w,k),(ratvec,mat)(v,theta))=
let (u,phi)=right(rd,k,(v,theta)) in (u+^theta*w,phi)

set conjugate(RootDatum rd, int k, (ratvec, mat)(v,theta))=
let alpha_check=simple_coroots(rd)[k] in 
right(rd,(alpha_check/2,k),left(rd,k,(v,theta)))

set conjugate(RootDatum rd, [int] s, (ratvec, mat)(v,theta))=
let xi=(v,theta) in 
for j in reverse(s) do let ()=prints("conj:", j) in xi:=conjugate(rd,j,xi) od;xi

{uses the bicycle lemma: sigma_w*sigma_{w^{-1}}=exp(2\ pi i(rho^vee-wrho^vee)/2)}
set inverse(RealForm G,(ratvec,mat)(v,theta))=(-^theta*v-rho_check(G)/2+^theta*rho_check(G)/2,theta)

set =((ratvec, mat)(v,theta),(ratvec,mat)(w,phi))=v=w and phi=theta

