<basic.rx
<Weylgroup.rx

{ An element in the delta-coset of the (extended) Tits group is represented by
  (ratvec v,mat theta) -> \exp(2i\pi v)\sigma_w\delta where \theta=w\delta.
  So v is a rational coweight taken modulo 1; theta need not be an invloution.
  Note that \delta is incorporated into \theta (like into involution@KGBElt)
  and that theta is defined as operating from left on X^*; for left action of
  theta on v, use the transpose inverse (right-multiply v by inverse(theta)).
}
: Tits_elt = (ratvec,mat)

set = (Tits_elt(v,theta),Tits_elt(u,eta)) = bool: =(v-u)%1 and theta=eta
set != ((Tits_elt,Tits_elt)p) = bool: not =p

{ left multiplication by sigma_s, where s must index a simple root }
set left (RootDatum rd,int s,Tits_elt(v,theta)) = Tits_elt:
  ( let v1 = coreflect(rd,v,s) { permute sigma_s e(v), so act by s on v } in
    if lengthens(rd,s,theta) { valid even if theta=w.delta is not in W }
    then v1
    else v1+coroot(rd,s)/2 { second term represents m_s = sigma_s^2 }
    fi % 1
  , left_reflect(rd,s,theta)
  )

{ right multiplication by sigma_s, where s must index a simple root }
set right (RootDatum rd, Tits_elt(v,theta), int s) = Tits_elt:
  ( if lengthens(rd,theta,s) { again valid even if theta=w.delta not in W }
    then v
    else v+coroot(rd,s)*inverse(theta)/2 { got theta' m_s; permute factors }
    fi % 1
  , right_reflect(rd,theta,s)
  )

set left (RootDatum rd, W_word ww,Tits_elt xi) = Tits_elt:
  for i:#ww downto 0 do xi:=left(rd,ww[i],xi) od; xi

set right (RootDatum rd, Tits_elt xi, W_word ww) = Tits_elt:
  for s in ww do xi:=right(rd,xi,s) od; xi

{ left multiply by \exp(2i\pi v)\sigma_s }
set left (RootDatum rd, (ratvec,int)(v,s), Tits_elt xi) = Tits_elt:
  let (u,phi) = left(rd,s,xi) in ((u+v)%1,phi)

{ right multiply by \exp(2i\pi v)\sigma_s }
set right (RootDatum rd, Tits_elt(,theta):xi, (ratvec,int)(v,s)) = Tits_elt:
  let (u,phi) = right(rd,xi,s) in ((v*inverse(theta)+u)%1,phi)

set conjugate (RootDatum rd, int s, Tits_elt xi) = Tits_elt:
  let sigma_s_inv = (ratvec,int): (coroot(rd,s)/2,s) in
  right(rd,left(rd,s,xi),sigma_s_inv)

set conjugate (RootDatum rd, W_word ww, Tits_elt xi) = Tits_elt:
  for i in reverse(ww) do xi:=conjugate(rd,i,xi) od; xi

{ in multiplication only one of the arguments should be in the delta-coset }
set multiply (RootDatum rd, Tits_elt(v,theta), Tits_elt(u,eta)) = Tits_elt:
  let tt1 = ^inverse(theta)
  , neg_crs = columns_with(is_negative_coroot(rd),^inverse(eta)*poscoroots(rd))
  in
  ( ( v + tt1*u + sum(columns_with(is_positive_coroot(rd),tt1*neg_crs))/2 ) % 1
  , theta*eta
  )

{ inverse uses the bicycle (note the (2\-/2) structure) lemma:
   sigma_w*sigma_{w^{-1}} = exp(2\pi i(rho^vee-rho^vee*w^{-1})/2)
  whence
   inverse(Tits_elt:(0,theta)) = Tits_elt:(rho_check*(theta-1)/2,inverse(theta))
  (this formula remains valid with delta included in theta)
}
set inverse (RealForm G,Tits_elt(v,theta)) = Tits_elt:
  let theta_inv = inverse(theta) in
  ( (-v*theta_inv - rho_check(G)*(theta_inv-1)/2) % 1, theta_inv)

