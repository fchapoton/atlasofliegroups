{ KL stuff, including character formulas and composition series }

<misc.rx

{ Basic object: column of KL matrix (P-matrix), of polynomials,
  without signs (in regular case all coefficients are non-negative);
  evaluated at 1 gives formula for irreducible as sum of standards

  main functions:

  KL(p): array of polynomials, giving column of P-matrix
  signedKL(p): previous, with (-1)^{ell(x)-\ell(y)}
  KL_matrix_at_one(p): P-matrix evaluated at 1 (integral matrix)
  KL_singular_inverse_matrix_at_one(p): Q-matrix evaluated at 1
  character_formula(p): irreducible(p) as sum of standards
  composition_series(p): standard(p) as sum of irreducibles

  also
    print_KL, print_signedKL, print_character_formula,print_composition_series

  some commands come with "regular" and "singular" versions
  for example KL(p) calls either KL_regular(p) or KL_singular(p)
  typically the user does not need to explicitly call the
  regular/singular versions, but can do so for debugging purposes
}

{ ------------------------------------------------------------------- }

{ basic definitions, not usually called by the user }
{
  length difference of block elements
  length(block element i)-length(block element j) from block containing p
  uses stops, as returned by KL_block(p)
  see functions.help
}

set length_diff (int i,int j,vec stops)=let
ld=0 in for k :#stops do if (stops[k]>i and stops[k]<=j) then ld:=ld+1 fi od;ld

set length_diff (int i,int j,Param p)=
let (,,,,stops,,)=KL_block(p) in length_diff(i,j,stops)

{addition of vectors of possibly different length, corresponding
to addition of polynomials. See basic.rx}
set +(vec v,vec w)=
let a=#v then b=#w in
if a<b then (v#null(b-a))+w else v+(w#null(a-b)) fi

{special matrix multiplication: cumulation matrix * KL matrix
returns i,j coordinate of product, as a polynomial}
set mat_mult_int_poly (mat cumulation,mat KL,[vec] polys,int i,int j)=
let (r,c)=#cumulation then
rv=vec:[] in
for k:c do rv:=rv+(cumulation[i,k]*polys[KL[k,j]]) od;rv

{make a printable string out of a polynomial, for use in
other print functions}
set stringPoly (vec v)=
if #v=0 then "0" else
let rv="" in
for k:#v do if (not v[k]=0) then
let pm=if v[k]<0 then "-" else "+" fi in
rv:=rv#pm#int_format(abs(v[k]))#"q^"#int_format(k) fi od;rv fi

{nice printing of polynomial}
set printPoly (vec v)=prints(stringPoly(v))


{-------------------------------------------------------------------}

{columns of KL matrix, as polynomials or at w}


{single column of KL matrix for parameter p at regular infinitesimal character
entries are polynomials with non-negative coefficients}
set KL_regular (Param p)=
let (block,init,KL,polys,stops,indices,cumulation)=KL_block(p) in
for i:n_columns(KL) do  polys[KL[i,init]] od

{preceding, modified by (-1)^{\ell(x)-\ell(y)}}
set signedKL_regular (Param p)=
if not is_regular(p) then error("Parameter is not regular") else
let (block,init,KL,polys,stops,indices,cumulation)=KL_block(p) in
for i:n_columns(KL) do  (-1)^(length_diff(i,init,stops))*polys[KL[i,init]] od
fi

{column of KL matrix at singular infinitesimal character,
single column of polyomials
these are the cumulated P polynomials
all coefficients in a given term have the same sign
but not necessarily positive}
set KL_singular (Param p)=
let (block,init,KL,polys,stops,indices,cumulation)=KL_block(p) in
for i:#indices do mat_mult_int_poly(cumulation,KL,polys,i,init) od

{same as preceding, modified by (-1)^{\ell(x)-\ell(y)}}
set signedKL_singular (Param p)=
let (block,init,KL,polys,stops,indices,cumulation)=KL_block(p) in
for i:#indices do (-1)^(length_diff(indices[i],init,stops))*mat_mult_int_poly(cumulation,KL,polys,i,init) od

{return either KL_regular or KL_singular
these can also be called directly
if p is regular KL_singular should return the same as KL_regular
if p is singular these matrices will be of different sizes}
set KL (Param p)=
if is_regular(p) then KL_regular(p) else KL_singular(p) fi

{return signedKL_regular or signedKL_singular}
set signedKL (Param p)=
if is_regular(p) then signedKL_regular(p) else signedKL_singular(p) fi

{nice printing of column of KL matrix of polynomials}
set print_KL(Param p)=
let (block,k,kl,polys,lengths,indices,cumulated)=KL_block(p) then
KL=KL(p) in
for i:#block do prints(block[i],": ", stringPoly(KL[i])) od;()

set print_signedKL(Param p)=
let (block,k,kl,polys,lengths,indices,cumulated)=KL_block(p) then
signedKL=signedKL(p) in
for i:#block do if not #signedKL[i]=0 then prints(i,", ",block[i],": ", stringPoly(signedKL[i])) fi od;()
{-------------------------------------------------------------------}
{KL matrix at 1 (integral matrix)}

{KL matrix for p, with regular infinitesimal character, evaluated at 1
all entries positive}
set KL_regular_matrix_at_one (Param p)= mat:
  let (block,init,KL,polys,stops,indices,cumulation)=KL_block(p)
  in for col in KL do for entry in col do eval(polys[entry],1) od od

{signed KL matrix, at one, regular case}
set signedKL_regular_matrix_at_one (Param p)= mat:
  let (block,init,KL,polys,stops,indices,cumulation)=KL_block(p) in
    for col@j in KL do for entry@i in col do
      (-1)^(length_diff(i,j,stops))*eval(polys[entry],1)
    od od

set KL_singular_matrix_at_one (Param p)= mat:
  let (block,init,KL,polys,stops,indices,cumulation)=KL_block(p)
  in
    for j:#indices do { must do by columns first for building a matrix }
      for i:#indices do
        { in matrix multiplication:
          i runs over #indices: rows of cumulation matrix
          indices[j] runs over a subset of the columns of the KL matrix }
        eval(mat_mult_int_poly(cumulation,KL,polys,i,indices[j]),1)
      od
    od

set signedKL_singular_matrix_at_one (Param p)=
  let (block,init,KL,polys,stops,indices,cumulation)=KL_block(p)
  in
    for j:#indices do { must do by columns first for building a matrix }
      for i:#indices do
        { in matrix multiplication:
          i runs over #indices: rows of cumulation matrix
          indices[j] runs over a subset of the columns of the KL matrix }
        (-1)^(length_diff(indices[i],indices[j],stops))
        *eval(mat_mult_int_poly(cumulation,KL,polys,i,indices[j]),1)
      od
    od

set KL_matrix_at_one (Param p)=
if is_regular(p) then KL_regular_matrix_at_one(p)
else KL_singular_matrix_at_one(p)
fi

set signedKL_matrix_at_one (Param p)=
if is_regular(p) then signedKL_regular_matrix_at_one(p)
else signedKL_singular_matrix_at_one(p)
fi

{-------------------------------------------------------------------}
{inverse KL matrix at 1 (integral matrix)}

{extract submatrix Msub of M with rows/columns given by v
also return column # of Msub corresponding to column # init of M}
set extract_submatrix (mat M,vec v, int init)=
let n=#v then
rv=null(n,n) then
k=-1 in
for i:n do
 if v[i]=init then k:=i fi;
 for j:n do
  rv[i,j]:=M[v[i],v[j]]
 od
od;(rv,k)

{indices=[a_1,...,a_m]=array of indices, 1\le a_i\le n
returns j such that a_j=init
used for: M is an nxn matrix, indices picks out a submatrix,
returns the column of submatrix corresponding to specified
column init of M}
set get_singular_index ([int] indices,int init)=
let k=-1 in for i:#indices do if indices[i]=init then k:=i fi od;k

set get_singular_index (Param p)=
let (,init,,,,indices,)=KL_block(p) in
get_singular_index(indices,init)

{inverse of P-matrix at one: this is the Q-matrix, with all positive
entries, giving multiplicities of irreducibles in standard (p)}

{regular case}
set KL_regular_inverse_matrix_at_one (Param p)=
let (M,d)=invert(signedKL_regular_matrix_at_one(p)) in M

{singular case, use get_singular_index(p) to get the number of the column
in the smaller matrix}
set KL_singular_inverse_matrix_at_one (Param p)=
let (rv,d)=invert(signedKL_singular_matrix_at_one(p)) in rv

{for testing: should give the same result}
set KL_singular_inverse_matrix_at_one_alt (Param p)=
  let (block,init,KL,polys,stops,indices,cumulation)=KL_block(p)
  then Pmatrix=null(n_rows(KL),n_rows(KL))
  then (bigQmatrix,k) =
    for i:n_rows(KL) do
      for j:n_columns(KL) do
        Pmatrix[i,j]:=(-1)^(length_diff(i,j,p))*eval(polys[KL[i,j]],1)
      od
    od; invert(Pmatrix)
  then (Q,)=extract_submatrix(bigQmatrix,indices,init) in Q

set KL_inverse_matrix_at_one (Param p)=
if is_regular(p) then KL_regular_inverse_matrix_at_one(p)
else KL_singular_inverse_matrix_at_one(p)
fi

{-------------------------------------------------------------------}
{character formulas}

set regular_character_formula (Param p)=
if not is_regular(p) then error("Parameter is not regular") else
 let G=real_form(p) then
 P=null_module(G) then
 (block,init,KL,polys,stops,indices,cumulation)=KL_block(p) then
 KL=KL_regular(p) in
 for i:#KL do
  let  q=block[i]
  then poly=KL[i]
  then poly_at_one =eval(poly,1) in
  if not poly_at_one=0 then
   P:=P+(-1)^(length_diff(i,init,stops))*poly_at_one*q
  fi
 od;P
fi

set print_regular_character_formula (Param p)=
let char=regular_character_formula(p) in
for (w,p) in %char do prints(prettyPrint(w),"*",p) od;()

set singular_character_formula (Param p)=
let P=null_module(real_form(p)) then
 (block,init,kl,polys,stops,indices,cumulation)=KL_block(p) then
 KL=KL_singular(p) in
 for i:#KL do
  let q=block[i] then
  poly=KL[i] then
    poly_at_one=eval(poly,1) in
  if poly_at_one!=0 then
   P:=P+(-1)^(length_diff(i,init,stops))*poly_at_one*q
  fi
 od;P

set print_singular_character_formula (Param p)=
let char=singular_character_formula(p) in
for (w,p) in %char do prints(prettyPrint(w),"*",p) od;()

set character_formula (Param p)=
if is_regular(p) then regular_character_formula(p) else singular_character_formula(p) fi

set print_character_formula (Param p)=
if is_regular(p) then print_regular_character_formula(p) else print_singular_character_formula(p) fi
{-------------------------------------------------------------------}
{composition series}

set regular_composition_series(Param p)=
if not is_regular(p) then error("Parameter is not regular") else
 let G=real_form(p) then
 Q=null_module(G) then
 (block,init,KL,polys,stops,indices,cumulation)=KL_block(p) then
 M=KL_regular_inverse_matrix_at_one(p) in
 for i:n_columns(M) do
  let q=block[i] then
  coeff=M[i,init] in
  if not coeff=0 then
   Q:=Q+coeff*q
  fi
 od;Q
fi

set print_regular_composition_series(Param p)=
let char=regular_composition_series(p) in
for (w,p) in %char do prints(prettyPrint(w),"*",p) od;()

set singular_composition_series(Param p)=
let Q=null_module(real_form(p)) then
(block,init,KL,polys,stops,indices,cumulation)=KL_block(p) then
M=KL_singular_inverse_matrix_at_one(p) then
k=get_singular_index(indices,init) in
for i:#indices do
 let q=block[indices[i]] then
 coeff=M[i,k] in
 if not coeff=0 then
  Q:=Q+coeff*q
 fi
od;Q

set print_singular_composition_series(Param p)=
let char=singular_composition_series(p) in
for (w,p) in %char do prints(prettyPrint(w),"*",p) od;()

set composition_series (Param p)=
if is_regular(p) then regular_composition_series(p) else singular_composition_series(p) fi

set print_composition_series (Param p)=
if is_regular(p) then print_regular_composition_series(p) else print_singular_composition_series(p) fi
