<basic.rx
<Weyl.rx

{ action of Weyl word }
set act (RootDatum rd, W_word w, vec v) = vec:
  let alpha = simple_roots(rd), alphav = simple_coroots(rd) in
  for i:#w downto 0 do let wi=w[i] in v -:= alpha[wi]*(alphav[wi]*v) od; v

set action (RootDatum rd,W_word w,ratvec rv) = ratvec:
  let (v,den)=%rv in act(rd,w,v)/den

{ action of Weyl word on X_*\otimes Q }
set co_action (RootDatum rd,ratvec rcv,W_word w) = ratvec:
  let alpha = simple_roots(rd), alphav = simple_coroots(rd) in
  for wi in w do rcv -:= (rcv*alpha[wi])*alphav[wi] od; rcv

set w_matrix(RootDatum rd, W_word w) = mat:
  let M=id_mat(rank(rd))
  , alpha = simple_roots(rd), alphav = simple_coroots(rd)
  in for s in w do M -:= M*column(alpha[s])*row(alphav[s]) od; M

{ move_towards_dominant(rd,v)=(s_i.v,i)
  where i is the last simple root negative on v, or (v,-1) if already dominant
}
set non_dominant_index (RootDatum rd, vec v) = int:
  let coords = v*simple_coroots(rd), i=semisimple_rank(rd)-1 in
  while i>=0 and coords[i]>=0 do i-:=1 od; i

set move_towards_dominant (RootDatum rd, vec v) = (vec,int):
  let i = non_dominant_index(rd,v) in
  (if i<0 then v else reflection(rd,i)*v fi, i)


{ make_dominant(rd,v)
  returns (v_dom,w) where v_dom dominant and v=act(rd,w,v_dom)
}
set make_dominant (RootDatum rd, vec v) = (vec,W_word):
  let i=0 then w =
    while let (new_v,k)=move_towards_dominant(rd,v) in v:=new_v; (i:=k)>=0
    do i od
  in (v,w)

set make_dominant (RootDatum rd, ratvec v) = (ratvec,W_word):
  let (v,denom)=%v then (v_dom,w)=make_dominant(rd,v) in (v_dom/denom,w)

{ make_simple_sequence and make_simple used to be in synthetic.rx }

{ find Weyl group element (W_word) making root simple & index of simple root
  with result (w,i) one has simple_roots(rd)[i] = act(rd,w,root)
  note that w in in inverse position with respect to what make_dominant does
}
set make_simple_sequence (RootDatum rd, vec root) = (W_word, int):
  let alpha = simple_roots(rd), alphav = simple_coroots(rd)
  , r = semisimple_rank(rd), busy = true, i=0, w=W_word:[]
  in
  while(busy)
  do let val=0 in i:=0; while i<r and (val:=alphav[i]*root)<=0 do i+:=1 od
  ; if i=r then error("not a positive root")
    elif root = alpha[i] then busy:=false
    else root -:= alpha[i]*val; w := i#w
    fi
  od; (w,i)

{ as  make_simple_sequence, but return Weyl group element in matrix form }
set make_simple (RootDatum rd, vec root) = (mat, int):
  let (w,i) = make_simple_sequence(rd,root) in (w_matrix(rd,w),i)

{ gamma is integrally dominant, need to add a sum of roots to it to make it
  dominant; this does not change the integral Weyl chamber of gamma,
  so when acting on parameters it is another parameter with the same types of
  roots, generating an isomorphic block
  this algorithm is crude: it adds a big enough multiple of 2*rho
}
set make_dominant_using_roots (RootDatum rd, ratvec v) = (ratvec,vec):
  let diff = (2*rho(rd))\1 * { minimal factor >= 0 making v+diff dominant }
    ( let k=0 in
      for alpha_check in simple_coroots(rd)
      do k:=max(k,ceil(-v*alpha_check/2)) od
    ; k)
  in (v+diff,diff)

set make_dominant_using_roots(RootDatum rd, vec v) = (vec,vec):
  let (w,shift) = make_dominant_using_roots(rd,v) in (w\1,shift)

{ assume infinitesimal character gamma of p is integrally dominant
  translate by sum of roots to make it dominant
  return (new parameter, sum of roots)
}
set translate_to_dominant (Param p) = (Param,vec):
  let (new_gamma,shift) =
    make_dominant_using_roots(root_datum(p),infinitesimal_character(p))
  , (x,lambda_rho,) = %p
  in (param(x,lambda_rho+shift,new_gamma),shift)

set inverse (W_word w) = W_word: for i:#w downto 0 do w[i] od

set w_long(RootDatum rd) = W_word: let (,w) = make_dominant(rd,-rho(rd)) in w

{      ---------- integrally dominant functions -------------		}

{ using integrality datum for given character makes it integrally dominant
  note that in the result W_word encoded for integrality datum, not rd
}
set make_integrally_dominant(RootDatum rd,ratvec v) = (ratvec,W_word):
  make_dominant(integrality_datum(rd,v),v)

{ act by Weyl group element w, then make result integrally dominant }
set int_dom_act (RootDatum rd,W_word w,ratvec v) = ratvec:
  let (new_v,) = make_integrally_dominant(rd,action(rd,w,v)) in new_v
