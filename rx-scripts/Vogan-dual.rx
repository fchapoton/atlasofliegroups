<basic.rx

{ to compute y values over a block of parameters, precompute dual inner class }
set dual_inner_class(Param p) = InnerClass:
  let id = integrality_datum(real_form(p),infinitesimal_character(p))
  in dual(inner_class(id,involution(x(p))))

set rho_i ((RootDatum, mat) rd_theta) = ratvec:
  sum(imaginary_poscoroots(rd_theta))/2

{ find integral coweight that will correct grading for rational coweight |v|
  on (simple-imaginary roots) columns of |simples|. This means finding w such
  that < w , alpha > = < v , alpha > + 1 (mod 2) for all such roots alpha
}
set integral_shift(ratvec v, mat simples) = vec:
  let vals = for x in ratvec_as_vec(v * simples) do 1-x%2 od { 1 for rho_im }
  then sol = vals*mod2_section(simples)
  in if (sol*simples)%2 = vals then sol
     else print(^simples,vals); error("no solution mod 2")
     fi

set y(Param p, InnerClass G_vee) = KGBElt:
  let x=x(p)
  then dual_theta = -^involution(x)
  , rho_corr = rho(real_form(x))-rho_check(G_vee)
  then (simple_reals,) = simple_from_positive(imaginary_sys(G_vee,dual_theta))
  , phi = infinitesimal_character(p) - lambda(p) + rho_corr
  in KGB_elt(G_vee,dual_theta
            ,phi+integral_shift(rho_corr-rho_r(x),simple_reals))

{ caution: these two functions build an inner class on the fly; if called
  mutliple times even with the same argument, the results will be incompatible
}
set y(Param p) = KGBElt: y(p,dual_inner_class(p))
set dual_real_form (Param p) = RealForm: real_form(y(p))

{ cocharacter for (dual) real_form of y(p); should be constant %1 across block }
set character (Param p) = ratvec:
  let G=real_form(p), x=x(p)
  then int_d = integrality_datum(G,infinitesimal_character(p))
  then rho_r_int = sum(real_posroots(int_d,involution(x)))/2
  in ( infinitesimal_character(p) - lambda(p) + rho_r(x) { grading weight(x) }
      -rho_r_int + rho(int_d) )%1   { convert to cocharacter g(real_form(y)) }

set central_cocharacter (RealForm G) = ratvec:
  (base_grading_vector(G) + rho_check(G))%1

{ amount added to central_cocharacter(G) to get dual infinitesimal character }
set dual_shift (RootDatum rd, ratvec gamma) = ratvec:
  rho_check(integrality_datum(rd,gamma))-rho_check(rd)

{ shift (up) a candidate dual infinitesimal character to strictly dominant }
set shift_g_regular (RootDatum rd, ratvec g) = ratvec:
  for alpha@i in simple_roots(rd)
  do let (v,d) = %fundamental_coweight(rd,i)
     in g +:= (1-ceil(g*alpha/d)) * v
  od; g

{ Finding the value lambda for the dual parameter to p is surprisingly simple.
  Since imaginary roots are automatically integral, there is no difference
  of rho_i values to compensate for. The dual infinitesimal character is
  central_cocharacter(G)+dual_shift(G,gamma), but here rho_check(G) cancels
  out, giving base_grading_vector(G) + rho_check(integrality_datum(p)).
}

 { integral coweight associated to KGB element: is lambda-rho on dual side }
set ell(KGBElt x) = vec:
  let (numer,denom) = %(base_grading_vector(real_form(x))-torus_factor(x))
  in if denom=1 then numer else error("non-integral ell(x)") fi

set dual_gamma (Param p) = ratvec: { we want this to be strictly dominant }
  let G = real_form(p), dual_rho = rho_check(integrality_datum(p))
  in shift_g_regular(G,base_grading_vector(G) + dual_rho)

set dual_lambda (Param p) = ratvec: { is mod 2: ell(p)+rho(dual_inner_class) }
  dual_gamma(p) - torus_factor(x(p))

set check_dual_lambda (Param p) = bool:
  dual_lambda(p)%1 = rho_check(integrality_datum(p))%1

set dual (Param p, InnerClass dual_integral_class) = Param:
  parameter( y(p,dual_integral_class), dual_lambda(p), dual_gamma(p) )

set test1 (Param p) = [bool]:
  let G_v=dual_inner_class(p) then drf = real_form(y(p,G_v))
  in for q in block_of(p) do drf=real_form(y(q,G_v)) od

set test2 (Param p) = [ratvec]:
  let G_v=dual_inner_class(p) then drf = real_form(y(p,G_v))
  in for q in block_of(p) do character(q) od { should be constant gamma%1 }
