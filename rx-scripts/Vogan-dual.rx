<basic.rx
<parameters.rx { for dual_inner_class }
<extended_misc.rx {for shift_g_regular }

set rho_i ((RootDatum, mat) rd_theta) = ratvec:
  sum(imaginary_poscoroots(rd_theta))/2

{ half sum of positive coroots for roots not integral on (torus element of) z }
set rho_diff_integral (RootDatum rd, ratvec z) = ratvec:
  rho_check(rd)-rho(integrality_datum(dual(rd),z))

{ |rho_diff_integral(z)|, but made $\theta$-stable by a sum-of-roots shift.
  Here |x| just serves to record |theta=involution(x)|; such |x| is easy to
  build from |theta|, and |cross| is more efficient than matrix conjugation
}
set theta_stable_diff ((KGBElt, ratvec)(x,z):xz) = ratvec:
  let rd = RootDatum: real_form(x)
  then ssr1 = semisimple_rank(rd)-1
  , tsd (KGBElt x,ratvec z) = ratvec:[] { recursive stub }
  in (assert(all(for alpha in real_posroots(x) do denom(alpha*z)=1 od))
     ; tsd :=
      ((KGBElt x,ratvec z) ratvec:
       let s=ssr1 { test simple reflections of being complex descents }
       in while s>=0 and status(s,x)>0 do s-:=1 od
       ; if s<0 then let res=rho_diff_integral(rd,z)
         in assert (res*involution(x)=res,"unstable"); res
         else let rs=reflection(rd,s) in tsd(cross(s,x),z*rs)*rs
         fi
      )
     )(xz)

{ given a $\theta$-fixed torus element, find a $\theta$-fixed logarithm }
set fixed_lift(mat theta,ratvec z) = ratvec:
  let t1=theta-1 then (image,denom)=%(z*t1), (d,L,R)=diagonalize(t1)
  then ()=assert(denom=1,"torus element is not fixed by involution")
  , corr = for e@i in image*R do if i<#d then e\d[i] else 0 fi od * L
  in assert(corr*t1=image,"no lift possible"); z - corr

{
  When restricting to a centraliser subgroup, we shall need to correct a
  potential torus factor |tf| with respect to the changed system of
  imaginary roots. The final correction is computed by the |integral_shift| as
  an integer vector, which moreover should be $\theta$-stable, so that
  whatever correction is made will not change the square class that has been
  fixed beforehand; the condition for which the correction is computed is to
  get the proper grading on the simple-imaginary roots of the subsystem, which
  are passed as |simples| argument. That grading undergoes two changes. Even
  if |tf| remains valid it grades imaginary roots indirectly through an offset
  $\rho_im$; this means we must compensate for the grading change implied for
  the difference of the offset between full system and subsystem. Apart from
  that, we may have (had to) to shift |tf| in order to get into the proper
  (square class for the subsystem) coset. In order to compute the correction
  we pass (not |tf| but) that shift made, minus to old $\rho_im$ as |v|; the
  new $\rho_im$ value is implicit in |simples| and is not included in the
  passed value of |v|. So we must find an (integral) vector |w| such that for
  all roots alpha in |simples|: < w , alpha > = < v , alpha > + 1 (mod 2).
  This condition being $\theta$-invariant, we hope the solution is as well.
}
set integral_shift(ratvec v, mat simples, mat theta) = vec:
  let (d,L,R)=diagonalize(theta-1) then k=#d { theta-fixed part starts at |k| }
  , vals = for x in ratvec_as_vec(v*simples) do 1-x%2 od { 1 for new rho_im }
  then L1 = rows_with((int i): i>=k,L) then L1s=L1*simples
  then sol = vals*mod2_section(L1s)
  in assert ((sol*L1s)%2 = vals,"no solution mod 2") ; sol * L1

set dual_KGB(Param p, InnerClass dual_int_ic) = KGBElt:
  let x=x(p), dual_tf=infinitesimal_character(p) - lambda(p)
  then dual_theta = -^involution(x)  { |dual_tf| is |dual_theta|-stable }
  then rho_corr { correct changing of rho_check implicit in dual_tf }
    = fixed_lift(dual_theta,rho(root_datum(p))-rho(integrality_datum(p)))
  , (simple_ims,)= simple_from_positive(imaginary_sys(dual_int_ic,dual_theta))
  then phi = dual_tf + rho_corr { dual_theta stable rep.ve of dual square }
  in KGB_elt(dual_int_ic,dual_theta
            ,phi+integral_shift(rho_corr-rho_r(x),simple_ims,dual_theta))


{ caution: these two functions build an inner class on the fly; if called
  mutliple times even with the same argument, the results will be incompatible
}
set y_alt(Param p) = KGBElt: dual_KGB(p,dual_inner_class(p))
set dual_real_form (Param p) = RealForm: real_form(y_alt(p))

set central_cocharacter (RealForm G) = ratvec:
  (base_grading_vector(G) + rho_check(G))%1

{ amount added to central_cocharacter(G) to get dual infinitesimal character }
set dual_shift (RootDatum rd, ratvec gamma) = ratvec:
  rho_check(integrality_datum(rd,gamma))-rho_check(rd)

{ Finding the value lambda for the dual parameter to p is surprisingly simple.
  Since imaginary roots are automatically integral, there is no difference
  of rho_i values to compensate for. The dual infinitesimal character is
  central_cocharacter(G)+dual_shift(G,gamma), but here rho_check(G) cancels
  out, giving base_grading_vector(G) + rho_check(integrality_datum(p)).
}

 { integral coweight associated to KGB element: is lambda-rho on dual side }
set ell(KGBElt x) = vec:
  let (numer,denom) = %(base_grading_vector(real_form(x))-torus_factor(x))
  in if denom=1 then numer else error("non-integral ell(x)") fi

set dual_gamma (Param p) = ratvec: { we want this to be strictly dominant }
  let G = real_form(p) in
  shift_g_regular(G,base_grading_vector(G) + rho_check(integrality_datum(p)))

set dual_lambda (Param p) = ratvec: { is mod 2: ell(p)+rho(dual_inner_class) }
  dual_gamma(p) - torus_factor(x(p))

set check_dual_lambda (Param p) = bool:
  dual_lambda(p)%1 = rho_check(integrality_datum(p))%1

set dual_alt (Param p, InnerClass dual_integral_class) = Param:
  parameter( dual_KGB(p,dual_integral_class), dual_lambda(p), dual_gamma(p) )

set dual_alt(Param p)=Param:dual_alt(p,dual_inner_class(p))

set test1 (Param p) = [bool]:
  let G_v=dual_inner_class(p) then drf = real_form(dual_KGB(p,G_v))
  in for q in block_of(p) do drf=real_form(dual_KGB(q,G_v)) od

set test2 (Param p) = [bool]: { should be constant gamma%1 }
  let G_v=dual_inner_class(p), gamma1=infinitesimal_character(p)%1
  in for q in block_of(p)
     do central_cocharacter(real_form(dual_KGB(q,G_v)))=gamma1 od
