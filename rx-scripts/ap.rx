{ap.rx}

<groups
<hermitian
<thetastable
<K
<K_types

set inverse_theta_induce_standard(Param p, RealForm L)=
let x_G=x(p) then
x_L=inverse_embed_KGB(x_G,L) in
parameter(x_L,lambda(p)-rho_i(x_G)-theta_rhoS(x_G)+rho_i(x_L)+theta_rhoS(x_L),nu(p))

set is_lambda_dominant(Param p)=bool:let rd=root_datum(p) then lam=lambda(p) in
prints("lambda+theta(lambda)=",lam+involution(x(p))*lam); is_dominant(rd,lam+involution(x(p))*lam)

set make_lambda_dominant(Param p)= let rd=root_datum(p) in
let lam_a=lambda(p)+involution(x(p))*lambda(p) in
let (lam_new,w)=make_dominant(rd,lam_a) in
let W=w_matrix(w) in let W_inv=w_matrix(inverse(w)) in 
let x=KGB_elt(real_form(p),W_inv*involution(x(p))*W,act((inverse(w)),torus_factor(x(p))))
in let lam_new=act((inverse(w)),lambda(p)) in let nu_new=act((inverse(w)),nu(p))
in let q=parameter(x,lam_new,nu_new) in prints("Now lambda=",lam_new," lambda+theta(lambda)=",lam_new+involution(x)*lam_new,"  q=p:",q=p);
(w,x,lam_new,nu_new,L(x,lam_new)) 

set theta_stable_data(Param p)=
if is_lambda_dominant(p) then
let p_L=inverse_theta_induce_standard(p,L(x(p),lambda(p))) 
in (real_form(p_L),p_L)
else
let (w,x,lam,nu,L)=make_lambda_dominant(p) in let x_L=inverse_embed_KGB(x,L) in
let p_L=parameter(x_L,lam-rho_i(x)-theta_rhoS(x)+rho_i(x_L)+theta_rhoS(x_L),nu)
in (L,p_L) 
fi