<ap.rx
<kgp.rx

{some stuff at the top of this file should be moved elsewhere}

{reduce [Param] by combining equivalent parameters; returns a list of inequivalent parameters}
set reduce(RealForm G,[Param] parameters)=monomials(virtual(G,parameters))

set sum(ratvec v)=rat:sum(numer(v))/denom(v)

{write v as a linear combination of columns of A}
set solve_in_lattice([vec] A, vec v)=vec:solve_vec(mat:A,v)

{A: nxm matrix, columns are a basis of a Z-module V of rank m
 M: nxr matrix, columns span a submodule of V
 returns mxr matrix C, column i gives column i of M as a sum of columns of A
 i.e. A*C=M
}
set submodule_basis(mat A,mat M)=mat:for v in M do solve_in_lattice(A,v) od

{rational matrix [ratvec]:[column_1,...,column_n]}

{convert rational matrix to (mat,[int]):(matrix of numerators,vector of denominators)}
set int_matrix([ratvec] S)=(mat,[int]):
(for i:#S do numer(S[i]) od,for i:#S do denom(S[i]) od)

{multiply integer matrix times rational matrix}
set *(mat M,[ratvec] S)=[ratvec]:
let (T,d)=int_matrix(S) then
A=M*T in for i:#S do numer(A[i])/d[i] od

{transpose of rational matrix}
set ^([ratvec] S)=[ratvec]:
if #S=0 or #S[0]=0 then [ratvec]:[] else for i:#S[0] do for j:#S do S[j][i] od od fi

{multiply rationl matrix times integer matrix}
set *([ratvec] S,mat M)=[ratvec]:^(^M*^S)

set is_integer_matrix([ratvec] S)=bool:all( for v in S do is_integer(v) od)

{all [a_0,...a_{n-1}] with 0\le a_i integral and \sum a_i\le Sum}
set parallelogram(int n, int Sum)=[[int]]:let
rec_fun f([[int]] partial, int n,int Sum)=[[int]]:
if #partial=0 then let start=[[int]]:[] in for i:Sum+1 do start#:=[i] od; f(start,n,Sum)
elif #partial[0]=n then partial else
let rv=[[int]]:[] in 
for i:#partial do
  for j:Sum-sum(partial[i])+1 do 
  rv#:=j#partial[i] od od;f(rv,n,Sum)  fi 
in f([[int]]:[],n,Sum)

{given integer n, [rat]:[c_1,...,c_{n-1}], int Sum
all [int]:a[a_0,...a_{n-1}] with 0\le a_i integral and
\sum_i a_i*c_i\le Sum
application: c_i=<i^th fundamental weight,rho^vee>
}
set parallelogram(int n, [rat] c,int Sum)=[[int]]:let
rec_fun f([[int]] partial, int n,[rat] c,int Sum)=[[int]]:
if #partial=0 then let start=[[int]]:[] in for i:floor(Sum/c[0])+1 do start#:=[i] od; f(start,n,c,Sum)
elif #partial[0]=n then partial else
let rv=[[int]]:[] in 
for i:#partial do  
  let max=1+floor((Sum- sum(for k:#partial[i] do partial[i][k]*c[k] od))/c[#partial[i]])
  in   for j:max do 
  rv#:=partial[i]#j od od;f(rv,n,c,Sum)  fi 
in f([[int]]:[],n,c,Sum)

set dlambda(KGBElt x,ratvec v)=ratvec:(1+involution(x))*v/2
set dlambda(Param p)=ratvec:dlambda(x(p),lambda(p))

{K_norm@Param
 p=(x,lambda,nu)
 K_norm(p)= <d\lambda,2rho^vee> 
          = <(1+theta_x)lambda/2,2rho^vee> 
          = <(1+theta_x)lambda,rho^vee> \in Z
 to see this is an integer: up to integer can replace theta_x with distinguished involution delta
 <(1+delta)lambda,rho^vee>=<lambda,2rho^vee> \in Z since lambda\in X^*+rho\subset weights,
and 2rho^vee is a sum of coroots
}
set K_norm(Param p)=int:let q=make_dlambda_dominant(p) in rat_as_int((1+involution(x(q)))*lambda(q)*rho_check(real_form(q)))

set is_in_one_plus_delta(mat delta,ratvec v)=bool:is_integer(v) and in_lattice(1+delta,ratvec_as_vec(v))

set solve_one_plus_delta(mat delta, ratvec v)=vec:
assert(is_in_one_plus_delta(delta,v),"Not solvable");solve_vec(1+delta,ratvec_as_vec(v))

{basis_lambda_differential_0@KGBElt
returns [v_0,...,v_k], v_i\in X^*, 
the characters of H^{theta_x} with differential 0
are \sum a_i v_i with a_i=0,1 (or [] -> [0,...,0])
}
set basis_lambda_differential_0(KGBElt x)=[vec]:
let theta=involution(x) then
zero_vector=vec:null(rank(real_form(x))) {default value} then
K=kernel(1+theta) then
(r,c)=#K in
if c=0 then [vec]:[]  else let
M=submodule_basis(K,1-theta) in
if #M=0 then [vec]:[] else let
(A,v)=adapted_basis(M) then
B=K*A in
{prints("K=",K);
prints("A=",A);
prints("v=",v);
prints ("B=",B);}
let rv=[vec]:[]
 in 
 for i:#v do if v[i]=2 then rv#:=B[i] fi od;
rv fi fi

{all 2^k vectors in X^* representing the characters of H^theta with differential 0
 k=# of R^* factors in H
 if H^theta is connected, returns [0,...,0]
}
set all_lambda_differential_0(KGBElt x)=[vec]:
let basis=basis_lambda_differential_0(x) in
if #basis=0 then [null(rank(real_form(x)))] else
let rv=[vec]:[] in
for a in generate_all_binary(#basis) do 
 let w=vec:null(rank(real_form(x))) in for i:#a do w+:=a[i]*basis[i] od;rv#:=w od;rv fi

{Given mu\in X^*, 
 solve mu=(1+theta_x)*lambda for lambda\in X^*+rho
 recall d\lambda=(1+theta)lambda/2, so mu will be 2*d\lambda
 algorithm:
 lambda=lambda_0+rho with lambda_0\in X^* 
 note: (1+theta)rho is in X^*
 mu=(1+theta)*lambda_0+(1+theta)*rho \in X^*
 first check mu is in X^*
 then check mu-(1+theta)rho is in (1+theta)X^*
 then solve mu-(1+theta)rho =(1+theta)lambda_0
 then return lambda=lambda_0+rho
}
set find_lambda(KGBElt x,ratvec mu)=ratvec:
let G=real_form(x) then
theta=involution(x) in
assert(is_integer(mu),"mu is not integral");
assert(in_lattice(1+theta, ratvec_as_vec(mu-(1+theta)*rho(G))),"mu-(1+theta)rho is not in (1+theta)X^*");
let lambda_0=solve_vec(1+theta,ratvec_as_vec(mu-(1+involution(x))*rho(G))) in lambda_0+rho(G)

set make_K_parameter(KGBElt x,ratvec mu)=Param:
parameter(x,find_lambda(x,mu),null(rank(real_form(x))))

set make_all_K_parameters(KGBElt x,ratvec mu)=[Param]:
let p=make_K_parameter(x,mu) in 
for v in all_lambda_differential_0(x) do 
parameter(x(p),lambda(p)+v,null(rank(real_form(p)))) od

{all K parameters with same dlambda as p}
set make_all_K_parameters(Param p)=[Param]:make_all_K_parameters(x(p), dlambda(p))

{all parameters with given infinitesimal character}
set all_parameters_gamma(RealForm G,ratvec gamma)=[Param]:
let params=[Param]:[] in 
for x in KGB(G) do 
 let theta=involution(x) in 
 let nu=(1-theta)*gamma/2 in 
 let mu=(1+theta)*gamma in
 let K_params=make_all_K_parameters(x,mu) in
 for p in K_params do params#:=parameter(x(p),lambda(p),nu) od od ;
 reduce(G,params)  {keep only 1 from each equivalence class}


{all actual parameters with same dlambda as p, same nu}
set all_parameters(Param p)=[Param]:
let p=make_K_parameter(x(p),dlambda(p)) in 
for v in all_lambda_differential_0(x(p)) do 
parameter(x(p),lambda(p)+v,nu(p)) od

{all_dominant_norm_less_than@(RootDatum,int):
 note: mu will be 2*d\lambda=(1+theta)lambda so 
 returns mu dominant such that
1) mu\in X^*
2) <d\lambda,2*rho^v>=<mu,rho^vee> = <=N
 set lambda_i=i^th fundamental weight
 set [rat]:c =[c_1,...,c_{n-1}] where c_i=<lambda_i,rho^vee>
 use parallelogram to find 
 all mu=\sum a_i lambda_i such that 
 <mu,rho^vee>=sum a_i*c_i<=N
3) d\mu restricted to the center is trivial
set all_dominant_norm_less_than(RootDatum rd, int N)=[[int]]:
let f=fundamental_weights(rd) then
n=#f then
r=rho_check(rd) then
c=[rat]:for i:#f do f[i]*r od in  
let v=parallelogram(n,c,N) in 
let rv=[[int]]:[] in 
for w in v do let u=ratvec:null(rank(rd)) in for i:#w do u+:=w[i]*f[i] od; 
if is_integer(u) then rv#:=ratvec_as_vec(u) fi od;rv

{mu will be d\lambda=(1+theta)lambda/2 => 2*mu\in X^*
return all mu dominant satisfying:
1) mu in X^* 
2) <mu,rho^vee> <= N 
3) mu-(1+theta)rho \in (1+delta)X^* (same as in (1+theta)X^*)
4) 
}
set all_dominant_in_image_oneplustheta_norm_less_than(RootDatum rd, mat theta,int N)=[[int]]:
let rv=[[int]]:[] in
for mu in all_dominant_norm_less_than(rd,N) do
 if in_lattice(1+theta,mu-(1+theta)*rho(rd)) then rv#:=mu fi od;rv

set all_K_parameters_norm_less_than(KGBElt x, int N)=[Param]:
let rd=root_datum(x),theta=involution(x) then
mus=all_dominant_in_image_oneplustheta_norm_less_than(rd,theta,N) then
rv=[Param]:[] in 
for mu in mus do rv#:=make_all_K_parameters(x,mu) od;rv

set all_rel_split_theta_stable_parabolics(RealForm G)=[RealForm]:
let parabolics=all_theta_stable_parabolics(G) then
rel_split_parabolics=[] in
for (P,v) in parabolics do for x in v do 
 let L=Levi(P,x) in if is_relatively_split(L) then rel_split_parabolics#:=L fi od od;rel_split_parabolics

set all_K_parameters_norm_less_than(RealForm G, int N)=
let parabolics=all_rel_split_theta_stable_parabolics(G) then
parameters=[Param]:[] in 
for L in parabolics do let x_L=KGB(L,KGB_size(L)-1) then
x=embed_KGB(x_L,G) in parameters#:=all_K_parameters_norm_less_than(x,N) od;
let rv=null_module(G) in for p in parameters do rv+:=p od;sort_by_K_norm(monomials(rv))

set print_all_K_parameters_norm_less_than(RealForm G, int N)=void:
for p in sort_by_K_norm(all_K_parameters_norm_less_than(G,N)) do prints(p, " ", K_norm(p)) od






