<basic {to enable some extra type conversion}
<sort  

{(complex) nilpotent orbits for simple groups,
and 1/2 h(O^\vee) for dual nilpotent orbits O^\vee
classical groups: SL(n), GL(n), Sp(2n), SO(n), 
orbits: partition-type parameterization
no attempt is made to handle I/II orbits in type D,
so these are really orbits for O(n,C) not SO(n,C)
lambda: standard coordinates
(in type A_n lambda has n+1 coordinates, i.e. for GL(n))
exceptional groups: simply connected (fundamental weight) coordinates, 
only the lambdas are given, from tables in Spaltenstein and Carter
}

{utility to extract type A-E of a simple root system, 
also GL(n)->"A.T"}
set get_type(RootDatum rd)=string:(
let type="" in
if (nr_factors(Lie_type(rd))=2) then
 if str(Lie_type(rd))="A"+ss_rank(rd)+".T1" then type:="A.T" 
 else error("Only for simple roots systems and GL(n)")
 fi
elif (nr_factors(Lie_type(rd))=1) then 
 let r=rank(rd) in
 let types=["A","B","C","D","E","F","G"] in
 let match=false in
 let i=0 in
 while match=false and i<#types do
  if str(Lie_type(rd))=types[i]+r then match:=true;type:=types[i] else  i:=i+1 fi 
 od 
else
error("Only for simple root systems or GL(n)")  fi ;type
)

{same as previous applied to a string such as E8, or a RealForm}
set get_type(string lietype)=string:get_type(simply_connected(lietype))
set get_type(RealForm G)=string:get_type(root_datum(G))

{generate all partitions of n,
each partition is written in decreasing order
partitions are generated smallest to largest}
set partitions = (int n):[[1]]
partitions:= ((int n):
let rv=[] in 
if n=1 then rv:=[[1]] else
 for p in partitions(n-1) do
  rv:=rv#(p#1);
  if #p=1 or p[#p-2]>p[#p-1] then rv:=rv#(p+id_mat(#p)[#p-1]) fi od fi; rv);

{write a partition as a sequence of multiplicities
including a leading 0 so that rv[i] is the multiplicity of i
e.g. [4,3,1,1]->[0,2,0,1,1]}
set partition_multiplicities ([int] p)=vec:
let p=reverse_sort(p) in
let rv=null(p[0]+1) in
for k in p do rv[k]:=rv[k]+1 od;rv

{partitions of n with all rows of parity "parity" having even multiplicity}
set partitions_parity (int n, int parity) =[[int]]:
let P=partitions(n)  
then rv=[] in
for p in P do 
 let valid=true
 then multiplicities=partition_multiplicities(p)
 then i=0 in 
 while valid and i<=#multiplicities-2 do
  i:=i+1; if i%2=parity and multiplicities[i]%2=1 then valid:=false fi
 od;
 if valid=true then rv:=rv#p fi
od;rv

{(complex) nilpotent orbits, partition-type classification,
for simple group of type A-D}
set nilpotent_orbits(string s,int n)=[[int]]:
if s="A" or s="A.T" then partitions(n+1) 
elif s="B" then partitions_parity(2*n+1,0) 
elif s="C" then partitions_parity(2*n,1) 
elif s="D" then partitions_parity(2*n,0)  
else [[]]
fi

{same as previous applied to RootDatum or RealForm (only depends on complexification)}
set nilpotent_orbits(RootDatum rd)=[[int]]:nilpotent_orbits(get_type(rd),ss_rank(rd)) 
set nilpotent_orbits(RealForm G)=[[int]]:nilpotent_orbits(root_datum(G))

{nilpotent orbits of dual group}
set dual_nilpotent_orbits(RootDatum rd)=[[int]]:nilpotent_orbits(dual(rd))
set dual_nilpotent_orbits(RealForm G)=[[int]]:nilpotent_orbits(dual(root_datum(G)))

{tools for computing h(O^\vee): apply to rows of Young diagram}
set rho (int n)=[rat]: for k:n do (n-1)/2-k od
set String (int n)=[rat]:for k:n\2 do (n-1)/2-k od 

{compute 1/2 h(O^\vee) for G of type "type",
O^\vee assumed to be an orbit of G^\vee, given by [int] P
only complexification (root_datum) of G plays a role}
set nilpotent_lambda(string type,[int] P)=ratvec:(
if type = "A" or type = "A.T" then 
let rv=[rat]:[] in let a=for p in P do rv:=rv#rho(p) od 
in let (w,d)=%rv in w/d
elif type="B" or type="C" or type="D" then 
let rv=[rat]:[] in 
let a=for k in P do rv:=rv#String(k) od in 
let tail=[rat]:ratvec:null((sum(P)\2-#rv)) in 
let (w,d)=%(rv#tail) in w/d
else [] fi)

{same as previous applied to (RootDatum,[int] P)}
set nilpotent_lambda(RootDatum rd,[int] p)=ratvec:nilpotent_lambda(get_type(rd),p)

{lists of 1/2 h(O^\vee)}

{exceptional groups first}
{nilpotent orbit given by labelled Dynkin diagram
label c={0,1,2} on node i -> (c/2)*i^th fundamental weight}

set nilpotent_lambdas_G2=[ratvec]:
[[0,0],[0/1,1/2],[1/2,0/1],[1,0],[1,1]]

{these are flipped 
from the table Carter due to the duality}

set nilpotent_lambdas_F4=[ratvec]:[
[0/1,0/1,0/1,0/1],
[0/2,0/1,0/1,1/2],
[1/1,0/1,0/1,0/2],
[0/1,0/1,1/2,0/1],
[1/1,0/1,0/1,0/1],
[0/1,0/1,0/1,1/1],
[0/1,1/2,0/1,0/1],
[1/2,0/1,0/1,1/1],
[0/1,1/2,0/1,1/2],
[1/2,0/1,1/2,0/1],
[0/1,0/1,1/1,0/1],
[1/1,1/2,0/1,1/2],
[0/1,0/1,1/1,1/1],
[1/1,0/1,1/1,0/1],
[1/1,0/1,1/1,1/1],
[1/1,1/1,1/1,1/1]]

set nilpotent_lambdas_E6=[ratvec]:[
[0/1,0/1,0/1,0/1,0/1,0/1],
[0/1,1/2,0/1,0/1,0/1,0/1],
[1/2,0/1,0/1,0/1,0/1,1/2],
[0/1,0/1,0/1,1/2,0/1,0/1],
[0/1,1/1,0/1,0/1,0/1,0/1],
[1/2,1/2,0/1,0/1,0/1,1/2],
[1/1,0/1,0/1,0/1,0/1,1/1],
[0/1,0/1,1/2,0/1,1/2,0/1],
[1/2,1/1,0/1,0/1,0/1,1/2],
[1/2,0/1,0/1,1/2,0/1,1/2],
[0/1,1/2,1/2,0/1,1/2,0/1],
[0/1,0/1,0/1,1/1,0/1,0/1],
[1/1,1/1,0/1,0/1,0/1,1/1],
[0/1,1/1,0/1,1/1,0/1,0/1],
[1/2,1/2,1/2,0/1,1/2,1/2],
[1/1,1/2,1/2,0/1,1/2,1/1],
[1/2,1/1,1/2,0/1,1/2,1/2],
[1/1,0/1,0/1,1/1,0/1,1/1],
[1/1,1/1,0/1,1/1,0/1,1/1],
[1/1,1/1,1/1,0/1,1/1,1/1],
[1/1,1/1,1/1,1/1,1/1,1/1]]

set nilpotent_lambdas_E7=[ratvec]:[
[0/1,0/1,0/1,0/1,0/1,0/1,0/1],
[1/2,0/1,0/1,0/1,0/1,0/1,0/1],
[0/1,0/1,0/1,0/1,0/1,1/2,0/1],
[0/1,0/1,0/1,0/1,0/1,0/1,1/1],
[0/1,0/1,1/2,0/1,0/1,0/1,0/1],
[1/1,0/1,0/1,0/1,0/1,0/1,0/1],
[0/1,1/2,0/1,0/1,0/1,0/1,1/2],
[1/2,0/1,0/1,0/1,0/1,1/2,0/1],
[0/1,0/1,0/1,1/2,0/1,0/1,0/1],
[1/1,0/1,0/1,0/1,0/1,1/2,0/1],
[0/1,0/1,0/1,0/1,0/1,1/1,0/1],
[0/1,1/1,0/1,0/1,0/1,0/1,0/1],
[1/1,0/1,0/1,0/1,0/1,0/1,1/1],
[0/1,0/1,1/2,0/1,0/1,1/2,0/1],
[1/2,0/1,0/1,1/2,0/1,0/1,0/1],
[0/1,0/1,1/1,0/1,0/1,0/1,0/1],
[1/2,0/1,0/1,0/1,1/2,0/1,1/2],
[1/1,0/1,1/1,0/1,0/1,0/1,0/1],
[0/1,1/2,1/2,0/1,0/1,0/1,1/2],
[0/1,0/1,0/1,1/2,0/1,1/2,0/1],
[1/1,0/1,0/1,0/1,0/1,1/1,0/1],
[0/1,0/1,0/1,0/1,1/1,0/1,0/1],
[1/1,0/1,0/1,0/1,0/1,1/1,1/1],
[1/1,1/2,1/2,0/1,0/1,0/1,1/2],
[1/2,0/1,0/1,1/2,0/1,1/2,0/1],
[1/1,0/1,0/1,1/2,0/1,1/2,0/1],
[0/1,0/1,0/1,1/1,0/1,0/1,0/1],
[1/2,0/1,0/1,1/2,0/1,1/1,0/1],
[1/2,0/1,0/1,1/2,0/1,1/2,1/1],
[1/1,0/1,0/1,0/1,1/1,0/1,0/1],
[0/1,1/2,1/2,0/1,1/2,0/1,1/1],
[0/1,0/1,1/1,0/1,0/1,1/1,0/1],
[1/1,0/1,1/1,0/1,0/1,1/1,0/1],
[0/1,0/1,0/1,1/1,0/1,0/1,1/1],
[0/1,0/1,0/1,1/1,0/1,1/1,0/1],
[1/1,1/2,1/2,0/1,1/2,1/2,0/1],
[1/1,1/2,1/2,0/1,1/2,0/1,1/1],
[1/1,0/1,0/1,1/1,0/1,0/1,1/1],
[1/1,1/2,1/2,0/1,1/2,1/1,1/1],
[1/1,0/1,0/1,1/1,0/1,1/1,0/1],
[1/1,0/1,1/1,1/1,0/1,1/1,0/1],
[1/1,0/1,0/1,1/1,0/1,1/1,1/1],
[1/1,1/1,1/1,0/1,1/1,0/1,1/1],
[1/1,1/1,1/1,0/1,1/1,1/1,1/1],
[1/1,1/1,1/1,1/1,1/1,1/1,1/1]]

set nilpotent_lambdas_E8=[ratvec]:
[[0/1,0/1,0/1,0/1,0/1,0/1,0/1,0/1],
[0/1,0/1,0/1,0/1,0/1,0/1,0/1,1/2],
[1/2,0/1,0/1,0/1,0/1,0/1,0/1,0/1],
[0/1,0/1,0/1,0/1,0/1,0/1,1/2,0/1],
[0/1,0/1,0/1,0/1,0/1,0/1,0/1,1/1],
[0/1,1/2,0/1,0/1,0/1,0/1,0/1,0/1],
[1/2,0/1,0/1,0/1,0/1,0/1,0/1,1/2],
[0/1,0/1,0/1,0/1,0/1,1/2,0/1,0/1],
[1/2,0/1,0/1,0/1,0/1,0/1,0/1,1/1],
[0/1,0/1,1/2,0/1,0/1,0/1,0/1,0/1],
[1/1,0/1,0/1,0/1,0/1,0/1,0/1,0/1],
[1/2,0/1,0/1,0/1,0/1,0/1,1/2,0/1],
[0/1,0/1,0/1,0/1,0/1,1/2,0/1,1/2],
[0/1,0/1,0/1,0/1,0/1,0/1,1/1,0/1],
[0/1,0/1,0/1,0/1,0/1,0/1,1/1,1/1],
[0/1,0/1,0/1,0/1,1/2,0/1,0/1,0/1],
[0/1,0/1,1/2,0/1,0/1,0/1,0/1,1/2],
[0/1,1/2,0/1,0/1,0/1,0/1,1/2,0/1],
[1/2,0/1,0/1,0/1,0/1,1/2,0/1,0/1],
[1/1,0/1,0/1,0/1,0/1,0/1,0/1,1/1],
[0/1,0/1,0/1,1/2,0/1,0/1,0/1,0/1],
[0/1,1/2,0/1,0/1,0/1,0/1,1/2,1/1],
[0/1,1/1,0/1,0/1,0/1,0/1,0/1,0/1],
[1/2,0/1,0/1,0/1,0/1,1/2,0/1,1/2],
[1/2,0/1,0/1,0/1,1/2,0/1,0/1,0/1],
[1/2,0/1,0/1,0/1,0/1,1/2,0/1,1/1],
[0/1,0/1,0/1,1/2,0/1,0/1,0/1,1/2],
[0/1,0/1,0/1,0/1,0/1,1/1,0/1,0/1],
[1/1,0/1,0/1,0/1,0/1,1/2,0/1,1/2],
[0/1,0/1,0/1,1/2,0/1,0/1,0/1,1/1],
[0/1,0/1,1/2,0/1,0/1,1/2,0/1,0/1],
[0/1,1/1,0/1,0/1,0/1,0/1,0/1,1/1],
[1/1,0/1,0/1,0/1,0/1,0/1,1/1,0/1],
[1/1,0/1,0/1,0/1,0/1,0/1,1/1,1/1],
[0/1,0/1,0/1,1/2,0/1,0/1,1/2,0/1],
[1/2,0/1,0/1,1/2,0/1,0/1,0/1,1/2],
[0/1,0/1,1/2,0/1,0/1,1/2,0/1,1/2],
[0/1,1/2,1/2,0/1,0/1,0/1,1/2,0/1],
[1/2,0/1,0/1,0/1,1/2,0/1,1/2,0/1],
[0/1,0/1,0/1,1/2,0/1,1/2,0/1,0/1],
[1/2,0/1,0/1,0/1,1/2,0/1,1/2,1/1],
[0/1,0/1,0/1,0/1,1/1,0/1,0/1,0/1],
[1/1,0/1,0/1,0/1,0/1,1/1,0/1,0/1],
[0/1,1/2,1/2,0/1,0/1,0/1,1/2,1/1],
[1/2,0/1,0/1,1/2,0/1,1/2,0/1,0/1],
[0/1,0/1,0/1,1/2,0/1,1/2,0/1,1/1],
[1/1,0/1,0/1,0/1,0/1,1/1,0/1,1/1],
[0/1,0/1,0/1,0/1,1/1,0/1,0/1,1/1],
[1/1,1/2,1/2,0/1,0/1,0/1,1/2,1/1],
[1/1,0/1,0/1,0/1,0/1,1/1,1/1,1/1],
[1/2,0/1,0/1,1/2,0/1,1/2,0/1,1/2],
[1/2,0/1,0/1,1/2,0/1,1/2,1/2,0/1],
[1/2,0/1,0/1,1/2,0/1,1/2,0/1,1/1],
[1/1,0/1,0/1,1/2,0/1,1/2,0/1,1/1],
[0/1,0/1,0/1,1/1,0/1,0/1,0/1,1/1],
[1/1,0/1,0/1,0/1,1/1,0/1,0/1,1/1],
[1/2,0/1,0/1,1/2,0/1,1/2,1/1,1/1],
[0/1,1/2,1/2,0/1,1/2,0/1,1/1,1/1],
[0/1,0/1,0/1,1/1,0/1,0/1,1/1,0/1],
[1/1,1/2,1/2,0/1,1/2,1/2,0/1,1/2],
[0/1,0/1,0/1,1/1,0/1,0/1,1/1,1/1],
[1/1,1/2,1/2,0/1,1/2,0/1,1/1,1/1],
[1/1,0/1,0/1,1/1,0/1,0/1,1/1,0/1],
[1/1,0/1,0/1,1/1,0/1,0/1,1/1,1/1],
[1/1,1/2,1/2,0/1,1/2,1/1,1/1,1/1],
[1/1,0/1,0/1,1/1,0/1,1/1,0/1,1/1],
[1/1,0/1,0/1,1/1,0/1,1/1,1/1,1/1],
[1/1,1/1,1/1,0/1,1/1,0/1,1/1,1/1],
[1/1,1/1,1/1,0/1,1/1,1/1,1/1,1/1],
[1/1,1/1,1/1,1/1,1/1,1/1,1/1,1/1]]

set nilpotent_lambdas_E(int n)=
if n=6 then nilpotent_lambdas_E6 
elif n=7 then nilpotent_lambdas_E7 
elif n=8 then nilpotent_lambdas_E8
else [] fi

{list of 1/2 h(O^\vee), for G with root datum rd
coordinaes are: 
G: GL(n), SP(2n), SO(n), standard coordinates
or simple, exceptional, fundamental weight coordinates}

set nilpotent_lambdas(RootDatum rd)=[ratvec]:(
let type=get_type(rd) in
let r=rank(rd) in
if type="A.T" or type = "A" or type="B" or type="C" or type="D" then
 for p in dual_nilpotent_orbits(rd)  do nilpotent_lambda(get_type(rd),p) od
elif type="G" and r=2 then nilpotent_lambdas_G2 
elif type="F" and r=4 then nilpotent_lambdas_F4
elif type="E" then nilpotent_lambdas_E(r) 
else []
fi
)

{same as previous for RealForm or, for example, "E8"}
set nilpotent_lambdas(RealForm G)=[ratvec]:nilpotent_lambdas(root_datum(G))
set nilpotent_lambdas(string s)=[ratvec]:nilpotent_lambdas(simply_connected(s))
