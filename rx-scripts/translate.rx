{the functions in this file have not been carefully checked}

{<hermitian if not done already}
set translate_debug=false

{translate Param p, at infinitesimal character gamma,
to new infinitesimal character gamma_new
assumes gamma,gamma_new are dominant, gamma_new-gamma is integral
replaces (x,lambda,nu) with (x,lambda+delta,nu+delta)
if gamma,gamma_new are regular, p and T(p,gamma_new) will have identical block structure
if gamma is regular, gamma_new is singular, block of T(p,gamma_new) will be a quotient
if gamma or gamma_new is not dominant, no guarantees}

set T(Param p, ratvec gamma_new)=
let G=real_form(p) then
rho=rho(G) then
gamma=infinitesimal_character(p) then
delta=gamma_new-gamma then
lambdaminusrho_new=ratvectovec(lambdaminusrho(p)/1+delta) in
param(x(p),lambdaminusrho_new,nu(p)+delta) 

{translate a ParamPol by translating each term}
set T(ParamPol P, ratvec gamma_new)=
let Q=null_module(real_form(P)) in
for (w,q) in %P do Q:=Q+(w,T(q,gamma_new)) od;Q

set T(Param p, vec gamma_new)=T(p,gamma_new/1)
set T(ParamPol P, vec gamma_new)=T(P,gamma_new/1)

{translate parameter p to simple root wall #k of the integral root system}
set Psi(Param p,int k)=
let G=real_form(p) then
rd=integrality_datum(p) then
coroot=positive_coroots(rd)[k] then 
gamma=infinitesimal_character(p) then
c=coroot*gamma in
if not is_integer(c) then error("root is not integral") else
 let weight=c*fundamental_weight(rd,k) in
 if not is_integer(weight) then error("cannot translate to this wall") else
  T(p,gamma-rattoint(coroot*gamma)* fundamental_weight(rd,k))
 fi
fi

{translate ParamPol to simple root wall #k of the integral root system}
set Psi(ParamPol P,int k)=
let Q=null_module(real_form(P)) in
for (w,q) in %P do Q:=Q+(w,Psi(q,k)) od;Q

{translate Param p to set of simple root walls}
set Psi(Param p,[int] v)=
for k in v do p:=Psi(p,k) od;p

{translate ParamPol to set of simple root walls of the integral root system}
set Psi(ParamPol P,[int] v)=
let Q=null_module(real_form(P)) in
for (w,q) in %P do Q:=Q+(w,Psi(q,v)) od;Q

{the "pseudo-tau" invariant}
{subset of simple integral roots such that:
1) can translate to this wall (i.e. the requisite translation is in X^*)
2) this translation is 0
If G is simply connected this should be the usual tau_invariant
Example: the trivial representation of SO(3), the root 
is in the pseudo-tau invariant, but you can't translate to the wall, since
rho is not in the root lattice}

{root k of the integral roots is in pseudo-tau(p) if 
<gamma,alpha_k^v>*fund_weight is integral, and 
Psi(p,k)=0 (translation of standard module), 
or its x gets changed by make_final}
set root_in_pseudo_tau (Param p,int k)=
let rd=integrality_datum(p) in
let weight=(simple_coroots(rd)[k]*infinitesimal_character(p))*fundamental_weight(rd,k) in 
if is_integer(weight) and is_zero(Psi(p,k)) or not x(Psi(p,k))=x(make_final(Psi(p,k))[0]) then true else false fi

{set of integers, defining a subset of the simple integral roots}
set pseudo_tau (Param p)=
let rd=integrality_datum(p) then
rv=[] in
for i:ss_rank(rd) do if root_in_pseudo_tau(p,i) then rv:=rv#i fi od;rv

{set of integers, defining a subset of the simple integral roots}
set pseudo_tau_complement (Param p)=
let rd=integrality_datum(p) then
rv=[] in
for i:ss_rank(rd) do if not root_in_pseudo_tau(p,i) then rv:=rv#i fi od;rv

{push Param p to the most singular place where the irreducible
is non-zero, i.e. to all of the root walls not
in the pseudo_tau_invariant}
set make_maximally_singular (Param p)=Psi(p,pseudo_tau_complement(p))

{translate each term in a list of parameters to all the simple root
walls not in its tau_invariant, and test if it is unitary The even
special unipotents of G should (all?) show up this way, varying over
all blocks at rho}

set test_even_unipotent (Param p)=
 let q=make_maximally_singular(p) then
 Q=hermitian_form_irreducible(q) then
 unitary=is_unitary(Q) in
 (prints(""); prints("original parameter: ",p);
 prints("translated parameter: ",q,", ", infinitesimal_character(q));
 prints("translated irreducible is unitary: ",unitary);
 (if translate_debug then prettyPrint(Q) fi))

{test_even_unipotent of a list of parameters}
set test_even_unipotent ([Param] params)=
for p in params do  test_even_unipotent(p) od;()


