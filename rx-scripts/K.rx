{ embedding of the complex group K defined by compact imaginary root system }

<basic.rx
<matrix.rx { for left_inverse }

{---------------- tests for any root, not just simple  --------------}

{ this is mostly already done in basic.rx, just add imaginary test }
set is_imaginary_compact(KGBElt x) = (vec->bool):
  let p=is_imaginary(x), q=is_compact(x) { allow pre-computation for x }
  in (vec alpha) bool: p(alpha) and q(alpha)

set is_imaginary_noncompact(KGBElt x) = (vec->bool):
  let p=is_imaginary(x), q=is_noncompact(x)
  in (vec alpha) bool: p(alpha) and q(alpha)


set rho_ic(KGBElt x) = ratvec: sum(compact_posroots(x))/2

set rho_in(KGBElt x) = ratvec:
  sum(columns_with(is_noncompact(x),imaginary_posroots(x)))/2


{ ------------------    matrices related to T_K\subset T  ------------------ }

{ bases of cocharacter lattice of K_0 (as rows), and reps of generators X^*(K)
  returns a pair of matrices (B,M), sizes r*n and n*r where r is the rank
  of K (and that of the +1 eigenspace of delta), such that M*B=1+delta, B*M=2I

  One has B*delta=B; the matrix B can be viewed as a projection X^*->X^*(K),
  and right-multiplication by it (its transpose) as injection X_*(K)->X_*.

  The matrix M is 2 times a section of B, mapping X^*(K)->(1+delta)X^*
}
set cocharacter_lattice_K_info (InnerClass ic) = (mat,mat):
  let A=1+distinguished_involution(ic) then (coefs,,R) = diagonalize(A)
  then initial = let rank_K = #coefs in (int j)bool: j<rank_K
  in
  ( rows_with(initial,inverse(R)) { rows: basis of +1 left-eigenspace delta }
  , A * columns_with(initial,R) { columns span weights in image of 1+delta }
  )

{ matrix of projection X^*(T)-> X^*(T_K) where T is fundamental Cartan of G,
  and T_K is identity component of fundamental Cartan of K

  project modulo the -1 eigenspace of the distinguished involution
}
set projection_to_K_matrix (InnerClass ic) = mat:
  let (proj,)=cocharacter_lattice_K_info(ic) in proj

{ projection function that accepts rational vectors whose image is integral }
set project_K (InnerClass ic,ratvec v)= vec:
  ratvec_as_vec(projection_to_K_matrix(ic)*v)

{ matrix of injection X_*(T_K)->X_*(T); image is a saturated sublattice }
set injection_from_K_matrix(InnerClass ic) = mat:
  let (proj,)=cocharacter_lattice_K_info(ic) in ^proj

set rank_K (InnerClass ic) = int:
  let (ds,,) = diagonalize(1+distinguished_involution(ic)) in #ds

{ G_K_roots_and_coroots
  Input: x in fundamental fiber, so theta permutes positive complex roots
  Output:
  ((G_K_roots: posroots of K as elements of X^*(T_K) (proj is applied)
     (from all compact imaginary posroots, and one of each complex theta-orbit)
   ,G_K_coroots: poscoroots of K as elements of X_*(T_K) (i.e., pulled back)
     (from compact imaginary poscoroots, and for each complex theta-orbit
      the coweight c.(alpha^v)(1+theta) where c= 2\(2+alpha^v*delta*alpha) =
      if <delta(alpha),alpha^v>=0 then 1 else 2 fi )
   )
  ,( injection(X_*(T_K)->X_*(T)^\theta), pull-back (X_*(T)^\theta->X_*(T_K)) )
  )
}
set G_K_roots_and_coroots (KGBElt x) = ((mat,mat),(mat,mat)):
  let ic = inner_class(real_form(x))
  then (proj { cols: weights },M) = cocharacter_lattice_K_info(ic)
  , delta = distinguished_involution(ic), rd = root_datum(ic)
  then inj = ^proj  { injection (X_*(T_K)->X_*(T)^\theta) }
  then pull_back = left_inverse(inj) { columns are coweights in X_*(K) }
  , proots = posroots(rd), pcroots = poscoroots(rd), r = rank(rd)
  , is_cpt  = is_compact(x) { predicate on imaginary roots }
  , ic_inx = [int]:[], C_inx = [int]:[] { list indices into proots/pcroots }
  in begin
    assert(involution(x)=delta,"x is not in fundamental fiber")
  ; for alpha@j in proots
    do let k = root_index(rd,delta*alpha) in
       if k=j then if is_cpt(alpha) then ic_inx #:= j fi
       elif k>j { first of a pair of complex posroots } then C_inx #:= j
       fi
    od
  ; (( proj * r#for i in ic_inx#C_inx do proots[i] od
     , (pull_back * r#for i in ic_inx do pcroots[i] od)
       # { for complex coroots apply 1+delta implicitly to recover the pair }
       ( ^M * { maps v\in X_* to elt in X_*(K) with inj image v*(1+delta) }
         r#for i in C_inx do pcroots[i]*(int: 1-pcroots[i]*delta*proots[i]) od
         { the factor after int: is yet another way of expressing c above }
       )
     )
    ,(inj,pull_back) { in case somebody needs them; not actually used below }
    )
  end


{ extract simple roots, coroots by computing pairing with rho,rho^v }
set G_K_simple_roots_and_coroots(KGBElt x) = (mat,mat):
  let (pos_sys,)=G_K_roots_and_coroots(x) in simple_from_positive(pos_sys)

set K_root_datum (KGBElt x) = RootDatum:
  root_datum(G_K_simple_roots_and_coroots(x))

set K_0 (KGBElt x) = RealForm:
  let rd = K_root_datum(x)
  in quasicompact_form(inner_class(rd,id_mat(rank(rd))))

set K_0 (RealForm G) = RealForm: K_0(KGB(G,0))

set rho_K (KGBElt x) =   ratvec:rho(K_0(x))
set rho_K (RealForm G) = ratvec:rho(K_0(G))



{	  conversion from restriction to K format to Param		}

{ atlas outputs a K-type as two_lambada@torus_bits#cartan_class
  this defines a final standard limit parameter p=(x,lambda) where
  torus_factor(x)=base_grading(G)+torus_bits, and involution(x) is the
  canonical involution of the Cartan_class
  currently atlas commands Ktype_mat, branch and Ktypeform print K-types in
  format [ 2, 2,-2, 2 ]@(0,0,1,1)#4; this can be made into a Param value by
  calling the function below as convert_K_type(G,[2,2,-2,2],[0,0,1,1],4)
}
set convert_K_type (RealForm G,vec two_lambda, vec torus_bits, int cartan) =
  Param:
  let torus_factor = base_grading_vector(G)+torus_bits
  , theta=involution(Cartan_class(G,cartan))
  in parameter(KGB_elt(G,theta,torus_factor),two_lambda/2,null(rank(G)))

set convert_K_type (RealForm G,(vec two_lambda, vec torus_bits, int cartan)) =
  Param:
  convert_K_type(G,two_lambda,torus_bits,cartan)


