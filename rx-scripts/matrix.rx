<basic.rx

set block_matrix(mat A,mat B) = mat:
  let (ra,ca)=#A, (rb,cb)=#B in
  if ca+cb=0 then null(ra+rb,0) { retain vertical size in absence of columns }
  else for i:ca do A[i]#null(rb) od # for i:cb do null(ra)#B[i] od
  fi

set minor(mat M, int size, int start) = mat: { principal minor, offset start }
  let rv=null(size,size) in
  for i:size do for j:size  do rv[i,j]:=M[i+start,j+start] od od; rv

set minor(mat M,int size) = mat: minor(M,size,0)

set right_inverse(mat A) = mat:
  let (diag,L,R) = diagonalize(A)
  then ()=
    if #diag<n_rows(A) then error("image does not have full rank")
    elif abs(product(diag))!=1 then error("image is a proper sublattice")
    fi
  { now since every element of diag is $\pm1$, division is almost trivial }
  in (mat: for d@j in diag do if d>0 then R[j] else -R[j] fi od)*L

set left_inverse(mat A) = mat: ^right_inverse(^A)

set weak_left_inverse(mat A) = (int,mat): { left inverse after saturation }
  let (diag,L,R) = diagonalize(A) then r = #diag then less_r = (int j):j<r
  in ( product(diag), columns_with(less_r,R) * rows_with(less_r,L) )

set reduce (mat M) = { factor out common divisor } mat: M\inv_fact(M)[0]
