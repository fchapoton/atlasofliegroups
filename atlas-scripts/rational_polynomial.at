<basic.at
<polynomial.at

: ratpoly = ratvec { in this file vectors will represent polynomials }
{ poly: [a_0,...,a_n] represents the polynomial a_0+a_1q+...+a_nq^n }

{ addition of vectors (overrides definition in basic.at) to allow vectors of
  possibly different lengths, implicitly extending on the right by zeros as
  needed. This gives the right thing for coefficient vectors of polynomials.
}

set fix_add = +@(ratvec,ratvec)
set fix_sub = -@(ratvec,ratvec) { save fixed-length vector additive operations }
set dot_product = *@(ratvec,ratvec) { and scalar product }

{ prepare for binding arithmetic on |poly| values differently inside this file }
forget +@(ratvec,ratvec)
forget -@(ratvec,ratvec)
forget *@(ratvec,ratvec)

{ for convenience declare some constants, the ! makes changes to these illegal }
set !ratpoly_0 = ratpoly:[], !ratpoly_1 = ratpoly:[1], !ratpoly_2 = ratpoly: [2]
set !ratpoly_q = ratpoly: [0,1], !ratpoly_q2 = ratpoly: [0,0,1]

set common(int a,int b)=lcm([a,b])

set flex_add (ratpoly f,ratpoly g) = ratpoly:
   let (fn,fd)=%f, (gn,gd)=%g in flex_add(gd*fn,fd*gn)/(fd*gd)
set flex_sub(ratpoly f,ratpoly g) = ratpoly:
   let (fn,fd)=%f, (gn,gd)=%g in flex_sub(gd*fn,fd*gn)/(fd*gd)
set convolve (ratpoly f,ratpoly g) = ratpoly:
   let (fn,fd)=%f, (gn,gd)=%g in convolve(fn,gn)/(fd*gd)

set + = flex_add@(ratpoly,ratpoly)
set - = flex_sub@(ratpoly,ratpoly)
set * = convolve@(ratvec,ratvec)

set ratpoly_product = *@(ratpoly,ratpoly) { this binding will remain exported }
set ratpoly_plus = +@(ratpoly,ratpoly) { this binding will remain exported }
set ratpoly_sub = -@(ratpoly,ratpoly) { this binding will remain exported }

{ reduce polynomial by dropping trailing zeros; shouldn't really be needed }
set strip (ratpoly v) = ratpoly: v + ratpoly_0 { operator + does actual work }
set degree (ratpoly P) = int: #P.strip-1 { degree, or -1 for the zero ratpoly }

{ evaluate polynomial at integer }
set evaluate_at_1 = sum@ratpoly { from basic.at; often we need this easy case }

{. returns polynomials (q,r) where p=q*d+r and r=0 or deg(r)<deg(d) .}
set divide(poly p,poly d) = (poly,poly):
   let rec_fun f(poly q, poly r) = (poly,poly):
      if #r<#d then (q,r)
      else let t=poly: null(#r-#d) # rat_as_int(r~[0]/d~[0]) in
         f(poly_plus(q,t),poly_plus(r,-poly_product(t,d)))
      fi
   in f(poly_0,p)

set ^ = (ratpoly,int->ratpoly): { power of a rational polynomial }
  let one=ratpoly:[1] { use local constant for efficiency } in
  (ratpoly p,int n) ratpoly: { the actual powering function }
    if n=0 then [1]
    else { no point in trying to do this by repeated squaring: is not faster }
      let f=p in while (n-:=1)>0 do f *:= p od; f
    fi

{. returns rational polynomials (q,r) where p=q*d+r and r=0 or deg(r)<deg(d) .}
set divide(ratpoly p,ratpoly d) = (ratpoly,ratpoly):
   let rec_fun f(ratpoly q, ratpoly r) = (ratpoly,ratpoly):
      if #r<#d
      then assert(strip(d*q+r)=strip(p),"bug in divide") { check success }
      ; (q,r) { return accuulated quotient and remainder }
      else let c=r~[0]/d~[0] then t=ratpoly: for :#r-#d do rat:0 od # c  in
        f(q+t,r-d*t)
      fi
   in f(ratpoly_0,p)

{ Euclidean division by a monic polynomial, using [rat] values at interface.
  This is promted by implementation which handles individual rat values, but
  also has the advantage of avoiding overflow problems. The remainder is
  defined to have exactly |d.degree| entries, which may include trialing zeros.
}
{.Euclidean division of rational polynomial by a monic rational polynomial.}
set monic_divide ([rat] P, [rat] D) = ([rat],[rat]): { quotient, remainder }
   assert(#D>0 and D~[0]=1,"Not a monic divisor");
   let deg_D = D.degree, l_P=#P in
   if l_P<=deg_D then (ratpoly_0,P ## for :deg_D-l_P do rat:0 od)
   else
      for i: l_P-deg_D { quotient has $\deg P+1-\deg D$ terms }
      do let c=P~[i] in for j:deg_D from 1 do P~[i+j] -:= c*D~[j] od
      od
   ;  (P[deg_D:] {quotient from upper part}, P[:deg_D] {remainder} )
   fi

{ restore normal vector arithmetic }
forget +@(ratvec,ratvec)
forget -@(ratvec,ratvec)
forget *@(ratvec,ratvec)
set + = fix_add@(ratvec,ratvec)
set - = fix_sub@(ratvec,ratvec)
set * = dot_product@(ratvec,ratvec)

{ make a printable string out of a ratpol and name of indeterminate,
  for use in other print functions, see polynomial.at:stringPoly }
set stringPoly (ratpoly v, string q)= string:
  if =v then "0" else "("+stringPoly(numer(v),q)+")/"+int_format(denom(v)) fi
