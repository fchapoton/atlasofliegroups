<basic.at
<springer_tables.at
<simple_character_table.at

<springer_table_A.at
<springer_table_BC.at
<springer_table_D.at
<springer_table_F.at
<springer_table_G.at
<springer_table_E6.at
<springer_table_E7.at
<springer_table_E8.at
<springer_table_torus.at

{previously the character tables were constructed from a possibly
different root datum from the given one (same up to isogeny)
now use the given root datum exactly}
set springer_table_simple(RootDatum rd) = SpringerTable:
let (letter,n)=simple_type(rd.derived) in
if letter="A" then springer_table_A(character_table_A(rd))
elif letter="B" then springer_table_B(character_table_B(rd))
elif letter="C" then springer_table_C(character_table_C(rd))
elif letter="D" then  springer_table_D(character_table_D(rd))
elif letter="F" then  springer_table_F4(character_table(rd))
elif letter="G" then  springer_table_G2(character_table(rd))
{don't need to construct chartacter_table first in type E}
elif letter="E" and n=6 then springer_table_E6(character_table(rd))
elif letter="E" and n=7 then springer_table_E7(character_table(rd))
elif letter="E" and n=8 then springer_table_E8(character_table(rd))
elif is_abelian(rd) then springer_table_torus(rd)
else error("case not covered")
fi


set springer_table_old(RootDatum rd)=
if rd.is_abelian then springer_table_torus(rd) else
let factors=simple_factors(rd) then
st=springer_table_simple(factors[0].derived) in
for i:#factors-1 from 1 do
 st:=tensor(st,springer_table_simple(factors[i].derived)) od;st fi


{under construction: combining springer tables not yet functional}
set split(RootDatum rd,ComplexNilpotent orbit)=[ComplexNilpotent]:
let (factors,simple_roots_of_factors)=simple_factors_info(rd) in
for i:#factors do
 let factor=factors[i],
 simple_roots=simple_roots_of_factors[i] in
 complex_nilpotent(factor,
    ratvec_as_vec(sum(rd.rank,for j:#simple_roots do orbit.H*rd.simple_roots[simple_roots[j]]*factor.fundamental_coweights[j] od)))
 od

{don't need rd: this will always be orbit.root_datum?}
set split(ComplexNilpotent orbit)=[ComplexNilpotent]:split(orbit.root_datum,orbit)

{factors: one orbit for each simple factor}
set combine_orbit(RootDatum rd,[ComplexNilpotent] factors)=ComplexNilpotent:
{let ()=prints("combine_orbit:  rd=", rd, new_line,"factors=", factors) in }
complex_nilpotent(rd,sum(for f in factors do f.H od))   {n#for f in factors do f.H od where n is the rank}

set combine_orbits(RootDatum rd,[[ComplexNilpotent]] factors)=[ComplexNilpotent]:
let radix=for f in factors do #f od in
 for v in all_words(radix) do
  combine_orbit(rd,for i:#v do factors[i][v[i]] od) od

{maps is a collection of functions for each simple factor of rd; combine them into a single function for rd}
{each entry maps is a function from orbit.root_datum to rd.orbits}
{assumption: rd_out.simple_factors [i] is isogenous to maps[i](orbit_factors).root_datum}

set combine_orbit_functions(RootDatum rd_out, [(ComplexNilpotent->ComplexNilpotent)] maps)=(ComplexNilpotent->ComplexNilpotent):
{can put in something here only depending on rd and maps, e.g. projection matrices, the factorization of rd}
{reference: "currying" from Haskell Curry haskell programming language}
(ComplexNilpotent orbit):
let orbit_factors=split(orbit) then
rd_out_factors=rd_out.simple_factors in
{let ()=prints("combine_orbit: ", new_line,
"orbitfactors=", orbit_factors, new_line,
"maps=", maps) in}
combine_orbit(rd_out,for i:#orbit_factors do  orbit_isogeny({maps[i]}(orbit_factors[i]),rd_out_factors[i]) od)



set combine_springer_tables(RootDatum rd,[SpringerTable] springer_tables)=SpringerTable:
let radix = for table in springer_tables do #table.orbits od then
words = all_words(radix), { mixed radix representations of number of orbits}
index= mixed_radix_nr(radix) { map from |word| to its index in |words| }
in
(   combine(rd,for table in springer_tables do table.ct od), {character table}
    combine_orbits(rd,for table in springer_tables do table.orbits od),  {orbit}
    combine_orbit_functions(rd.dual,for table in springer_tables do table.dual_map od),  {dual_map}
    combine_orbit_functions(rd,for table in springer_tables do table.dual_map_i od),     {dual_map_i}
    (ComplexNilpotent orbit) int:           {Springer correspondence}
     for proj@i in split(rd,orbit) do
      springer_tables[i].springer(proj) od.index
     )

set springer_table(RootDatum rd) = SpringerTable:
 if is_abelian(rd) then springer_table_torus(rd) else
 combine_springer_tables(rd,for factor in rd.simple_factors do  factor.springer_table_simple od) fi

{
set character_table(RootDatum rd) = CharacterTable:
   let (Lie_type,map) = Cartan_matrix_type(rd.Cartan_matrix)
   then simples = simple_factors(Lie_type)
   then root_data = [RootDatum]: { subdata with a single simple factor + torus }
      let offset=0 in
      for (,rank) in simples
      do sub_datum(rd,for i:rank do map[offset+i] od)  next offset+:=rank
      od
   then simple_tables = [CharacterTable]: { tables for each of |root_data| }
      for rdi@i in root_data
      do let (letter,n)=simples[i] in character_table_simple(rdi,letter,n)
      od
in combine(rd,simple_tables)}