<basic.at
<springer_tables.at
<classical_character_tables.at

<springer_table_A.at
<springer_table_BC.at
<springer_table_D.at
<springer_table_F.at
<springer_table_G.at
<springer_table_E6.at
<springer_table_E7.at
<springer_table_E8.at
<springer_table_torus.at

set springer_table_simple(RootDatum rd,string letter,int n) = SpringerTable:
   let ct = character_table_simple(rd,letter,n) { should become unused }
in case ascii(letter)-ascii("A")
   in springer_table_A(rd)
   ,  springer_table_B(ct)
   ,  springer_table_C(ct)
   ,  springer_table_D(ct)
   ,  case n-6
      in springer_table_E6(ct), springer_table_E7(ct), springer_table_E8(ct)
      else error("wrong rank for type E")
      esac
   ,  assert(n=4,"wrong rank for type F"); springer_table_F4(ct)
   ,  assert(n=2,"wrong rank for type G"); springer_table_G2()
   else error("invalid type letter")
   esac

{ this is broken, but should parse }
set springer_table(RootDatum rd)=
   let (Lie_type,map) = Cartan_matrix_type(rd.Cartan_matrix)
   then simples = simple_factors(Lie_type)
   then  simple_tables = [SpringerTable]:
      let offset=0 in
      for (letter,rank) in simples
      do let simple_rd = sub_datum(rd,for i:rank do map[offset+i] od)
      next offset+:=rank
      in springer_table_simple(derived(simple_rd),letter,rank)
      od
in if rd.is_abelian then springer_table_torus(rd)
   else let st = simple_tables[0] in
      for i:#simples from 1 do st:=tensor(st,simple_tables[i]) od
   ;  st
   fi


