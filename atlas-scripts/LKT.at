<cross_W_orbit.at { find_W_cross }
<induction.at { rho_S@KGBElt }
<finite_dimensional.at { highest_weight@Param }
<W_K.at { make_strongly_dominant@(KGBElt,ratvec) }
<thetastable.at { two_rho_u_cap_s@Parabolic }
<Weylgroup.at {make_no_Cminus}

{ ---------------- LKT(p): list of K_types ---------------- }

{ this is simply a list [K_type] of K_types, i.e.
  final standard limit tempered parameters
  LKTs(Param p) has value [K_type]
  simply set nu=0, apply finalize, and discard nu=0 terms
  define LKT(Param p) of type K_Type, provided it is unique
}
set LKTs (Param p) = [K_Type]: for q in finalize(p*0) do K_type(q) od
set LKT (Param p) = K_Type:
  let lkts=LKTs(p) in assert(#lkts=1,"More than one LKT; use LKTs"); lkts[0]

{ given (x,lambda): x in distinguished fiber, lambda in  X^*
  lambda restricted to H^\delta is the highest weight of a representation of K_x
  replace (x,lambda) with (y,mu) where mu is highest weight for K_y
  algorithm: find w\in W_G taking rho(K_x) to rho(K_y) using cross_W_orbit
  (x,lambda)->(y,w\lambda)
}

{ shouldn't be used:
set move_weight (KGBElt x,KGBElt y,ratvec lambda) = (KGBElt,ratvec):
  let G=real_form(x) in assert(real_form(y)=G,"Real form mismatch");
  let w=find_W_cross(x,y) in (y,act(w,lambda))
}

set move_finite_dimensional (KGBElt x,KGBElt y,Param p) = Param:
  let (,hw)=move_weight((x,highest_weight_finite_dimensional(p)),y)
  in finite_dimensional(K_0(real_form(y)),hw)

{ sum of the roots of K as an element of X^*(H^delta)
  x is assumed to be in the distinguished fiber, defining K
  in particular alpha complex posroot implies delta(alpha) is a posroot also
  return value is an element of X^*
  which restricts to give an element of X^*(H^delta)=X^*/(1-delta)X^*
  mu is not unique (of course), and mu is not necessarily fixed by delta
  to get an element fixed by delta we need to allow 1/2X^*,
  see tworho_K_fixed(x) below
  if {alpha,delta(alpha)} is a pair of positive roots, these contribute
  alpha (which is in X^*) or (1+delta)alpha/2 (which is delta-fixed)
  in order to get in X^* (not 1/2X^*), contribution of a positive complex pair
  {alpha,theta(alpha)} is alpha, rather than (1+theta)\alpha/2
  see rho_S(x) in induction.at
}

set tworho_K (KGBElt x) = vec:
( if not in_distinguished_fiber(x)
  then prints("Warning: x is not in distinguished fiber")
  fi
; let G=real_form(x) in sum(compact_posroots(x)) + ratvec_as_vec(2*rho_S(x))
)

{ sum of the roots of K as an element of (X^*)^delta\otimes Q
  (it can be half-integral)
  x is assumed to be in the distinguished fiber, defining K
  in particular alpha complex posroot implies theta(alpha) is a posroot too
  tworho_K(x)\in X^* and tworho_K_fixed(x)\in 1/2(X^*)^delta map
  to same element 2*rho_K(x) in X^*(T_{K_0})
}
set tworho_K_fixed (KGBElt x) = ratvec:
( if not in_distinguished_fiber(x)
  then prints("Warning: x is not in distinguished fiber") fi
; let G=real_form(x) in sum(compact_posroots(x)) + sum(complex_posroots(x))/2
)

{ x is assumed to be in the distinguished fiber, defining K; y on any Cartan
  all complex roots of type C+ (alpha>0 => theta(alpha)>0)
  returns sum of compact roots of centralizer of H^{\theta_y},
  as an element of X^*
}
{set tworho_Kr (KGBElt x, KGBElt y) = ratvec:
( if not in_distinguished_fiber(x)
  then prints("Warning: x is not in distinguished fiber")
  elif not no_Cminus_roots(y)
  then prints("Warning: not all complex roots for y are type C+")
  fi
; let rpry = real_posroots(y), imx=is_imaginary(x), cpx=is_compact(x) in
  sum(columns_with((vec alpha): imx(alpha) and cpx(alpha),rpry)) +
  sum(columns_with(is_complex(x),rpry))/2
)}

set tworho_Kr (KGBElt x, KGBElt y) = vec:
  if not in_distinguished_fiber(x)
  then prints("Warning: x is not in distinguished fiber")
  elif not no_Cminus_roots(y)
  then prints("Warning: not all complex roots for y are type C+")
  fi;
  let cix_ry_sum = sum(columns_with(is_compact_imaginary(x),real_posroots(y)))
  , real_datum_y=root_datum(simple_from_positive(real_sys(y)))
  in cix_ry_sum + ratvec_as_vec(2*rho_S(involution(x),real_datum_y))

{ lowest K-type of (limit of) discrete series on M }
set M_LKT  (Param p) = ratvec:
  let x=x(p)
  then lambda = involution(x)* { why? what follows is already fixed by theta }
      (infinitesimal_character(p)-nu(p))
  , delta = distinguished_involution(real_form(p))
  in projection_mod_image(1-delta)*ratvec_as_vec(lambda+rho_i(x)-2*rho_ci(x))


{ ---------------- convert K_type to highest weights for K_# ---------------- }

{algorithm:
1) if G is relatively split, Cartan is (relatively) split, all roots in the
   tau-invariant,
   this is the "G-spherical" case of KHatHowe, section 8
2) if p is final standard limit tempered, it has a unique LKT,
   use theta_stable_data to write p as cohomologically induced from a
   relatively split L
3) apply 2) to all terms of finalize(p*0)
}
set is_split_spherical(Param p)=bool:
  assert(is_final(p), "parameter is not final");
  is_relatively_split(real_form(p)) and
  #x(p) = KGB_size(real_form(p))-1 and
  all(for alpha_check in simple_coroots(root_datum(p))
      do is_even(rat_as_int( (lambda(p)-rho(root_datum(p))) *alpha_check))
      od)

set is_split_spherical(K_Type p)=bool:
   is_split_spherical(parameter(p))

{highest weight in split spherical case is unique}
set highest_weight_split_spherical(K_Type p)=KHighestWeight:
  assert(is_split_spherical(p), "p is not a spherical rep of a split group");
  let x=x(p) then x_K=canonical_x_K(x)
  then i_rd=root_datum(simple_from_positive(imaginary_sys(x_K)))
  , lambda=lambda(p)
  then rd=i_rd
  then fw=fundamental_weights(rd), mu=ratvec:lambda(p)-rho(rd)
  in { prints("mu=", mu); }
  for alpha_check@i in simple_coroots(rd) do mu-:=mu*alpha_check*fw[i] od;
{ prints("mu modified=", mu); }
  assert(all(for alpha_check in simple_coroots(rd) do mu*alpha_check=0 od)
        ,"error, mu isn't orthogonal to all roots");
  (KGB(real_form(x),0),ratvec_as_vec(mu))

set highest_weight_split_spherical (Param p) = KHighestWeight:
  highest_weight_split_spherical(K_type(p*0))
set highest_weight_split_spherical (K_Type p,KGBElt x_K) = KHighestWeight:
  let (x,mu)=highest_weight_split_spherical(p) in move_weight((x,mu),x_K)
set highest_weight_split_spherical (Param p,KGBElt x_K) = KHighestWeight:
  let (x,mu)=highest_weight_split_spherical(p) in move_weight((x,mu),x_K)

set highest_weight (K_Type p) = KHighestWeight:
  assert(is_final(parameter(p)),"parameter is not final");
  let p=make_no_Cminus(p)
  then (Q,pL)=theta_stable_data(parameter(p))
  then (x_L,mu_L)=highest_weight_split_spherical(pL)
  then x_G=canonical_x_K(x(p))
{ need version of 2*rho_u_cap_s(Q) which is integral, see thetastable.at}
  , mu_G=mu_L+two_rho_u_cap_s(Q)
  in
{ x_G=x_min(Q); }
{ prints("x_G=",x_G); }
{ prints("mu_L:",mu_L,new_line, " mu_G", mu_G, new_line,"2*rho_u_cap_s(Q)"
        , 2*rho_u_cap_s(Q), new_line, "two_rho_u_cap_s", two_rho_u_cap_s(Q)); }
{ this might be a ratvec, denominator 1/2, by restriction it defines a
  character  of T_{K_0}
  need to replace mu_G\in 1/2X^*theta with mu_G_integral\in X^*
  so that restriction takes mu_G_integral to mu_G restricted to T_{K_0}
}
{ don't understand this issue, it looks like mu_G is integral }
{ also, can't project to character of T_{K_0}, lose information on
  disconnected part, having to do with K_# }
  (x_G,mu_G)
{ original rest now commented out...
  let mu_K=project_K(x_G,mu_G)
  then ()=prints("mu_K=", mu_K)
  then mu_G_integral=mu_K*left_inverse(injection_from_K_matrix(x_G))
  then ()=prints("mu_G_integral:", mu_G_integral)
  in
  prints("L=", Levi(Q));
  prints("pL=", pL);
  prints("mu_K=", mu_K);
  prints("mu_L=", mu_L);
  prints("rho_u_cap_s:=", rho_u_cap_s(Q));
  prints("rho_u_cap_k:=", rho_u_cap_k(Q));
  prints("mu_G=", mu_G);
  (x_G,mu_G_integral)
}

{ highest weight of K_Type is unique }
set highest_weight (K_Type p,KGBElt x_K) = KHighestWeight:
  let (x,mu)=highest_weight(p) in move_weight((x,mu),x_K)

{ highest weight of Param is not neccessarily unique }
set highest_weights (Param p) = [KHighestWeight]:
  for q in finalize(p*0) do highest_weight(K_type(q)) od

{ return single highest weight of Param if it is unique }
set highest_weight (Param p) = KHighestWeight:
  let hwts=highest_weights(p) in
  assert(#hwts=1,"LKT is not unique, use highest_weights"); hwts[0]

set highest_weights (Param p,KGBElt x_K) = [KHighestWeight]:
  for (x,mu) in highest_weights(p) do move_weight((x,mu),x_K) od


{ although highest weight is unique, allow call using plural weights }
set highest_weights(K_Type p)=KHighestWeight:
  highest_weight(p)

{ just list the highest weights of lowest K-types, with respect to given x_K }
{ set highest_weights (Param p,KGBElt x_K) = [vec]:
  for (x,mu) in highest_weights(p)
  do let (,mu_1)= move_weight((x,mu),x_K) in mu_1 od
}

{ -------- K-type as parameter for the identity component of K ------------ }

{ given mu in X^*(T_K)=X^*(H)/(1-delta)X^*(H), choose representative in X^*(H)
  giving a KHighestWeight (x,mu) cannot necessarily take mu to be \delta-fixed
}

set H_weight (KGBElt x,vec mu_K) = KHighestWeight:
  (x, { vec: } mu_K*left_inverse(injection_from_K_matrix(x)) )

{ this may be a ratvec, not vec }
set fundamental_weights_K_H (KGBElt x) = [ratvec]:
  let M=left_inverse(injection_from_K_matrix(x)) in
  for v in fundamental_weights(K_0(x)) do v*M od

{
set K0_param (K_Type p,KGBElt x_K) = Param:
let (,tau)=highest_weight(p,x_K) in finite_dimensional(K_0(x_K),tau)
}

set K0_param (K_Type p,KGBElt x_K) = Param:
  let (,tau)=highest_weight(p,x_K) in
  finite_dimensional(K_0(x_K),project_K(x_K,tau))

set K0_param (K_Type p) = Param:
  K0_param(p,KGB(real_form(x(p)),0))

{
set LKTs_K0 (Param p,KGBElt x_K) = [Param]:
  for (,tau) in highest_weights(p,x_K) do finite_dimensional(K_0(x_K),tau) od
}
set K0_params (Param p,KGBElt x_K) = [Param]:
  for (,tau) in highest_weights(p,x_K)
  do finite_dimensional(K_0(x_K),project_K(x_K,tau)) od
set K0_params (Param p) = [Param]:
  K0_params(p,KGB(real_form(x(p)),0))

set K0_param (Param p,KGBElt x_K) = Param:
  let K0_prms=K0_params(p,x_K) in
  assert(#K0_prms=1,"Parameter has more than one K0 parameter, use K0_param");
  K0_prms[0]

set K0_param (Param p) = Param:
  K0_param(p,KGB(real_form(x(p)),0))

{ mu is a highest weight for K_0=identity component of K_x
  returns fundamental weight coordinates
}
set fundamental_weight_coordinates (KHighestWeight (x,mu)) = vec:
  mu*simple_coroots(K_0(x))

{ if possible, take weight of K_0, in fundamental weight coordinates, to
  KHighestWeight (x,mu) }
set K_highest_weight_from_fundamental_weights(KGBElt x,vec tau) =
    KHighestWeight:
  let K_0=K_0(x), fw=fundamental_weights_K_H(x)
  , weight=ratvec:null(ss_rank(real_form(x)))
  in for i:#tau do weight+:=tau[i]*fw[i] od;
  assert(is_integer(weight),"Weight is not integral");
  (x,ratvec_as_vec(weight))

set dimensions (Param p, KGBElt x_K) = [int]:
  for pi in K0_params(p,x_K) do dimension(pi) od
set dimensions (Param p) = [int]:   dimensions(p,KGB(real_form(p),0))
set dimensions ([Param] B)= [[int]]: for p in B do dimensions(p) od


{ --------------- printing and other auxiliary routines ------------- }

set print_LKTs (Param p) = void:
  let lkts=LKTs(p) in
  for q in lkts
  do let mu=K0_param(q) then (x,v)=highest_weight(mu) in
    prints("highest weight=", v, new_line
          , "fund. wt. coords:", fundamental_weight_coordinates(x,v),new_line
          ,"length=", length(x,v),new_line,"dim= ", dimension(mu))
  od
