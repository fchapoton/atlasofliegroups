<nilpotent_orbits.at

{compute induction of nilpotent orbits in easy case:
when determined by the dimension}
set_type [
maybe_induce = (void no_orbit| ComplexNilpotent orbit)
]

set any(maybe_induce orbit)=bool: case orbit| orbit: true | no_orbit: false esac
set req(maybe_induce orbit)=ComplexNilpotent: case orbit | orbit(orbit):orbit  | else error("error in easy induce") esac

{assume O_L is for a Levi}
set induce_multiple(ComplexNilpotent O_L,RootDatum rd)=
let target_dimension=O_L.dim_nilpotent + rd.dimension -O_L.root_datum.dimension in
##for orbit in rd.complex_nilpotent_orbits do
 if orbit.dim_nilpotent=target_dimension  then [orbit] else [] fi od

{assume O_L is for a Levi}
set simple_induce(ComplexNilpotent O_L,RootDatum rd)=maybe_induce:
let ind=induce_multiple(O_L,rd) in if #ind=1 then ind[0].orbit else ().no_orbit fi






