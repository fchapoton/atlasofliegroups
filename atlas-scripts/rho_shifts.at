<misc.at
{---------------- various rho-shifts -----------------}

{ Given an involution theta, return the set S of complex roots containing the
  first positive representative of each quadruple (\pm alpha,\pm theta(alpha))
}
set makeS (mat theta,RootDatum rd) = mat:
  columns_with((int j,vec alpha):posroot_index(rd,theta*alpha)>j,posroots(rd))
set makeS (KGBElt x) = mat: makeS(involution(x),root_datum(x))

{ rho_S = half sum of roots in chosen set S of complex roots, described above }
set rho_S ((mat,RootDatum)pair) = ratvec: sum(makeS(pair))/2
set rho_S (KGBElt x)            = ratvec: sum(makeS(x))/2

{ subset of makeS, those alpha>0 such that theta*alpha>0 }
set makeS_typeCplus ((mat,RootDatum)(theta,rd):pair) = mat:
  columns_with((vec alpha):is_posroot(rd,theta*alpha),makeS(pair))
set makeS_typeCplus (KGBElt x) = mat:
  makeS_typeCplus(involution(x),root_datum(x))

set rho_S_typeCplus ((mat,RootDatum)pair) = ratvec: sum(makeS_typeCplus(pair))/2
set rho_S_typeCplus (KGBElt x) = ratvec:
  rho_S_typeCplus(involution(x),root_datum(x))

{ rho_k(x)=one-half the sum of the positive roots of h in k,
  2rho_k(x) is in X^*(H), but is really only well defined modulo (1-theta)X^*
  complex root contribution: only type C+
}
set rho_k(KGBElt x)=ratvec: rho_ci(x)+rho_S_typeCplus(x)
set rho_s(KGBElt x)=ratvec: rho_nci(x)+rho_r(x)+rho_S_typeCplus(x)

{these rho-shift commands could use some cleaning up}

{ sum of the roots of K as an element of X^*(H^delta)
  x is assumed to be in the distinguished fiber, defining K
  in particular alpha complex posroot implies delta(alpha) is a posroot also
  return value is an element of X^*
  which restricts to give an element of X^*(H^delta)=X^*/(1-delta)X^*
  mu is not unique (of course), and mu is not necessarily fixed by delta
  to get an element fixed by delta we need to allow 1/2X^*,
  see tworho_K_fixed(x) below
  if {alpha,delta(alpha)} is a pair of positive roots, these contribute
  alpha (which is in X^*) or (1+delta)alpha/2 (which is delta-fixed)
  in order to get in X^* (not 1/2X^*), contribution of a positive complex pair
  {alpha,theta(alpha)} is alpha, rather than (1+theta)\alpha/2
  see rho_S(x) in induction.at
}

set tworho_K (KGBElt x) = vec:
( if not in_distinguished_fiber(x)
  then prints("Warning: x is not in distinguished fiber")
  fi
; let G=real_form(x) in sum(compact_posroots(x)) + ratvec_as_vec(2*rho_S(x))
)

{ sum of the roots of K as an element of (X^*)^delta\otimes Q
  (it can be half-integral)
  x is assumed to be in the distinguished fiber, defining K
  in particular alpha complex posroot implies theta(alpha) is a posroot too
  tworho_K(x)\in X^* and tworho_K_fixed(x)\in 1/2(X^*)^delta map
  to same element 2*rho_K(x) in X^*(T_{K_0})
}
set tworho_K_fixed (KGBElt x) = ratvec:
( if not in_distinguished_fiber(x)
  then prints("Warning: x is not in distinguished fiber") fi
; let G=real_form(x) in sum(compact_posroots(x)) + sum(complex_posroots(x))/2
)

{ x is assumed to be in the distinguished fiber, defining K; y on any Cartan
  all complex roots of type C+ (alpha>0 => theta(alpha)>0)
  returns sum of compact roots of centralizer of H^{\theta_y},
  as an element of X^*
}
{set tworho_Kr (KGBElt x, KGBElt y) = ratvec:
( if not in_distinguished_fiber(x)
  then prints("Warning: x is not in distinguished fiber")
  elif not no_Cminus_roots(y)
  then prints("Warning: not all complex roots for y are type C+")
  fi
; let rpry = real_posroots(y), imx=is_imaginary(x), cpx=is_compact(x) in
  sum(columns_with((vec alpha): imx(alpha) and cpx(alpha),rpry)) +
  sum(columns_with(is_complex(x),rpry))/2
)}

set tworho_Kr (KGBElt x, KGBElt y) = vec:
  if not in_distinguished_fiber(x)
  then prints("Warning: x is not in distinguished fiber")
  elif not no_Cminus_roots(y)
  then prints("Warning: not all complex roots for y are type C+")
  fi;
  let cix_ry_sum = sum(columns_with(is_compact_imaginary(x),real_posroots(y)))
  , real_datum_y=root_datum(simple_from_positive(real_sys(y)))
  in cix_ry_sum + ratvec_as_vec(2*rho_S(involution(x),real_datum_y))
