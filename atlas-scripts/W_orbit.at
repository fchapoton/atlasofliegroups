<basic.at  { for |assert|, |all_simples|,... }

{
  An optimised orbit generation procedure, which assumes that generators can
  detect and eliminate (by returning |no_vec|) backwards or stationary steps
  (in the main application we generate the orbit of a dominant weight, whence
  the function name, and "forward" will then mean subtracting posroots) and that
  the poset structure on the orbit is graded (as is true for the weak order on
  $W$ or on $W/P$ for a parabolic subgroup $P$). This allows the orbit to be
  partitioned into levels, with equality testing only within current level.

  Arguments are a row |S| of generating maps and a starting dominant weight |v|.
  it returns a list of pairs of a weight |b| and a representative word in the
  generators, which when applied right-to-left transforms |v| into |b|.

  The algorithm is to generate an array of such pairs, with a counter |done|
  saying how many have been considered for successors, and a marker |stop|
  saying where the newest level (where duplicates must be avoided) starts.
}
set generate_from_dom ([(vec->maybe_a_vec)] S,vec v) = [vec,[int]]:
(  let result = [vec,[int]]: [(v,[])], done=0, stop=1
   then absent (vec y) = bool: { check down to last level marker }
          none(#result-stop,(int i)bool: let(x,)=result~[i] in x=y)
   in
   while done<#result
   do if done=stop then stop:=#result fi { hit end of level, define new level }
   ;  let (a,w) = result[done] next done+:=1
   in for f@i in S
      do case f(a) | else () { skip when no new vector is returned }
	 | solution(b): if absent(b) then result #:= (b,i#w) fi
	 esac
      od
   od
;  result
)

{ same as above, but also compose |gens_rep| matrices for applied generators }
set generate_action_from_dom \
   ([(vec->maybe_a_vec)] S,vec v,int dim,[mat] gens_rep) = [vec,[int],mat]:
(  let result = [vec,[int],mat]: [(v,[],id_mat(dim))], done=0, stop=1
   then absent (vec y) = bool: { check down to last level marker }
          none(#result-stop,(int i)bool: let(x,,)=result~[i] in x=y)
   in
   while done<#result
   do if done=stop then stop:=#result fi { hit end of level, define new level }
   ;  let (a,w,act) = result[done] next done+:=1
   in for f@i in S
      do case f(a) | else () { skip when no new vector is returned }
	 | solution(b): if absent(b) then result #:= (b,i#w,gens_rep[i]*act) fi
	 esac
      od
   od
;  result
)

set simple_actor (RootDatum rd, int i) = (vec->maybe_a_vec):
  let s=W_gen(rd,i), av=coroot(rd,i) in
  (vec x)maybe_a_vec: if (av*x).> then solution(s*x) else no_vec() fi

{ get orbit of |v| under parabolic subgroup of Weyl group with generators |S|,
  and witnessing (minimal) Weyl group elements |w|: |x=w*v| for |x| in orbit }
set generate_from (RootDatum rd,[int] S,vec v) = [vec,WeylElt]:
   let (chamber,dom_wt)=from_dominant(rd,v) { dominant for |S| would suffice }
   then orbit = generate_from_dom(for s in S do simple_actor(rd,s) od,dom_wt)
   , to_dom= WeylElt: inverse(chamber)
in for (x,word) in orbit do (x,W_elt(rd,for i in word do S[i] od)*to_dom) od

{ like previous, but assuming |v| is dominant, and incorporating action }
set generate_action_from_dom \
   ( RootDatum rd, [int] S, vec v, int dim, [mat] gens_rep) =
      [vec,WeylElt,mat]:
   let orbit= generate_action_from_dom
       (for s in S do simple_actor(rd,s) od,v, dim,for s in S do gens_rep[s] od)
in for (x,word,act) in orbit do (x,W_elt(rd,for s in word do S[s] od),act) od

{ when no |WeylElt| elements are needed in the end, we can simplify a bit }
set W_orbit (RootDatum rd,[int] S, vec v) = [vec]:
   for (x,) in generate_from_dom(for i in S do simple_actor(rd,i) od,v) do x od

{ just the coset representatives for the stabilizer of |v| }
set W_orbit_W_elements((RootDatum,[int],vec) triple) = [WeylElt]:
  for (,w) in generate_from(triple) do w od

{ default S to full set of simple roots }
set generate_from (RootDatum rd,vec v) = [vec,WeylElt]:
  generate_from(rd,all_simples(rd),v)
set W_orbit (RootDatum rd, vec v) = [vec]:
  W_orbit(rd,all_simples(rd),v)
set W_orbit_W_elements(RootDatum rd,vec v) = [WeylElt]:
  W_orbit_W_elements(rd,all_simples(rd),v)

{ enumerate parabolic subgroup of W }
set W_parabolic (RootDatum rd, [int] gens) = [WeylElt]:
(  let result=[id_W(rd)]
in for s@i in gens
   do let coset =
     W_orbit_W_elements(rd,gens[:i+1],fundamental_weight(rd,s).numer)
   in result := for x in coset do for y in result do x*y od od.##
   od
;  result
)

{ enumerate parabolic subgroup of W, with their action defined by |gens_rep| }
set W_parabolic_act (RootDatum rd, [int] gens, int dim, [mat] gens_rep) =
      [WeylElt,mat]:
(  let result=[(id_W(rd),id_mat(dim))] in
   for s@i in gens
   do result := { expand previous |result| to a new version }
      for (,x,M) in generate_action_from_dom
      	  (rd,gens[:i+1],fundamental_weight(rd,s).numer,dim,gens_rep)
      do for (y,act) in result do (x*y,M*act) od
      od.##
   od
;  result
)

{ all elements of Weyl group of RootDatum, in parabolic	quotient lex order }
set W (RootDatum rd) = [WeylElt]: W_parabolic(rd,all_simples(rd))

{ variants of the above for |vec| instead of |vec|; reduce to |vec| case }
set generate_from (RootDatum rd,[int] S,ratvec rv) = [ratvec,WeylElt]:
   let (v,d) = %rv in for (x,w) in generate_from(rd,S,v) do (x/d,w) od
set W_orbit (RootDatum rd,[int] S, ratvec rv) = [ratvec]:
   let (v,d) = %rv in for x in W_orbit(rd,S,v) do x/d od
set generate_from (RootDatum rd,ratvec rv) = [ratvec,WeylElt]:
   generate_from(rd,all_simples(rd),rv)
set W_orbit (RootDatum rd, ratvec rv) = [ratvec]: W_orbit(rd,all_simples(rd),rv)

{ orbit of <w_1,..,w_n> acting on v where w_i is an element of W (WeylElt),
  (not always a simple reflection). Example use: for $W^\delta$-orbit of a root

  Here we must use instead of |generate_from_dom| a simplified but less
  efficient method, using linear search over the full orbit generated so for,
  because nothing is known about how generators relate to dominance, or even
  that the generated directed acyclic graph is graded
}
set generate ([(ratvec->ratvec)] S,ratvec v) = [ratvec,[int]]:
   let result = [ratvec,[int]]: [(v,[])], done=0
   then absent (ratvec y) = bool: { check whole orbit }
          none(#result,(int i)bool: let(x,)=result[i] in x=y)
   in
   while done<#result
   do let (a,w) = result[done] next done+:=1
   in for f@i in S
      do let b=f(a) in if absent(b) then result #:= (b,i#w) fi
      od
   od; result

{
  The function |generate| builds an orbit for the action of the elements of |S|.
  No assumtions are made about |S|; its elemtns need not be simple generators
  for any Weyl subgroup. All |WeylElt| values here are (assumed to be) for |rd|.
}
set generate (RootDatum rd,[WeylElt] S,ratvec v) = [ratvec,WeylElt]:
   for (x,word) in generate(for s in S do (ratvec x) ratvec: s*x od, v)
   do (x,product(rd,for s in word do S[s] od))
   od

{ find a |WeylElt| in the generated group <S> whose action sends |v| to |w|
  returns either (true,w) or (false,id)
}
set conjugate_to (RootDatum rd, [WeylElt] S, ratvec a,ratvec b) =
     (bool,WeylElt):
(  for (x,w) in generate(rd,S,a)
   do if x=b then return (true,w) fi
   od
;  return (false,id_W(rd))
)

{ find WeylElt |w| satisfying |w*v=u| }
set conjugate_to (RootDatum rd, ratvec u, ratvec v) = (bool,WeylElt):
  let (wu,u_dom)=from_dominant(rd,u), (wv,v_dom)=from_dominant(rd,v) in
  (u_dom=v_dom, wu*/wv)


{     orbit generation routines which terminate early based on length bound  }

set generate_from_dom_terminate \
  ([(vec->maybe_a_vec)] S,vec v, int length_bound) = [vec,[int]]:
(  let result = [vec,[int]]: [(v,[])], done=0, stop=1, length=0
   then absent (vec y) = bool: { check down to last level marker }
          none(#result-stop,(int i)bool: let(x,)=result~[i] in x=y)
   in
   while length<length_bound and done<#result
   do if done=stop then stop:=#result fi { hit end of level, define new level }
   ;  length+:=1 { now |length| equals length of elements generated }
   ;  let (a,w) = result[done] next done+:=1
   in for f@i in S
      do case f(a) | else () { skip when no new vector is returned }
	 | solution(b): if absent(b) then result #:= (b,i#w) fi
	 esac
      od
   od
;  result
)

{ same as above, but also compose |gens_rep| matrices for applied generators }
set generate_action_from_dom_terminate \
   ([(vec->maybe_a_vec)] S, vec v, int dim, [mat] gens_rep, int length_bound) =
      [vec,[int],mat]:
(  let result = [vec,[int],mat]: [(v,[],id_mat(dim))], done=0, stop=1, length=0
   then absent (vec y) = bool: { check down to last level marker }
          none(#result-stop,(int i)bool: let(x,,)=result~[i] in x=y)
   in
   while length<length_bound and done<#result
   do if done=stop then stop:=#result fi { hit end of level, define new level }
   ;  length+:=1 { now |length| equals length of elements generated }
   ;  let (a,w,act) = result[done] next done+:=1
   in for f@i in S
      do case f(a) | else () { skip when no new vector is returned }
	 | solution(b): if absent(b) then result #:= (b,i#w,gens_rep[i]*act) fi
	 esac
      od
   od
;  result
)

{ get orbit of |v| under parabolic subgroup of Weyl group with generators |S|,
  and witnessing (minimal) Weyl group elements |w|: |x=w*v| for |x| in orbit }
set generate_from_terminate (RootDatum rd,[int] S,vec v,int bound) =
      [vec,WeylElt]:
   let (chamber,dom_wt)=from_dominant(rd,v) { dominant for |S| would suffice }
   then orbit = generate_from_dom_terminate
      (for s in S do simple_actor(rd,s) od,dom_wt,bound)
   ,  to_dom= inverse(chamber)
in for (x,word) in orbit do (x,W_elt(rd,for i in word do S[i] od)*to_dom) od

{ like previous, but assuming |v| is dominant, and incorporating action }
set generate_action_from_dom \
   ( RootDatum rd,[int] S, vec v, int dim, [mat] gens_rep) = [vec,WeylElt,mat]:
   let orbit = generate_action_from_dom
      (for s in S do simple_actor(rd,s) od,v, dim,for s in S do gens_rep[s] od)
in for (x,word,act) in orbit do (x, W_elt(rd,for i in word do S[i] od),act) od

{ when no |WeylElt| elements are needed we dispose of them }
set W_orbit (RootDatum rd,[int] S, vec v) = [vec]:
   for (x,) in generate_from_dom(for i in S do simple_actor(rd,i) od,v)
   do x
   od

{ just the coset(for the stabilizer of |v|) representatives  }
set W_orbit_W_elements(RootDatum rd, [int] S, vec v) = [WeylElt]:
   for (,w) in generate_from_dom(for i in S do simple_actor(rd,i) od,v)
   do W_elt(rd,for s in w do S[s] od)
   od

{ default S to full set of simple roots }
set generate_from_terminate (RootDatum rd,vec v,int bound) = [vec,WeylElt]:
   generate_from_terminate(rd,all_simples(rd),v,bound)

set W_orbit (RootDatum rd, vec v) = [vec]:
   W_orbit(rd,all_simples(rd),v)
set W_orbit_W_elements(RootDatum rd,vec v) = [WeylElt]:
   W_orbit_W_elements(rd,all_simples(rd),v)
