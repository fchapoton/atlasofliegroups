{jda@ThinkPad:~/jc/atlas-scripts$ git branch
* (HEAD detached at acfd25f9)
}


{looking at question raised by David in atlas seminar 5/25/21

take a classical group, so A-bar(O) is abelian.

given a cell, look at the set of x such at sigma(x,trivial)
is in the cell. This contains 1 (since the special is in the
cell). This gives a subset of A-bar(O): is it a subgroup?
What subgroups arise?

Presumably this question can be modified to make sense
for non-abelian A(O)
}

{n=2}
set vectors_sets_two=[[vec]]:
[
[[0,0]],
[[1,0]],
[[1,1]],
[[1,0],[0,1]]]
{n=3}
set vectors_sets_three=[[vec]]:
[
[[0,0,0]],
[[1,0,0]],
[[1,1,0]],
[[1,0,1]],
[[1,1,1]],
[[0,1,0]],
[[0,1,1]],
[[0,0,1]],
[[1,0,0],[0,1,0]],
[[1,0,1],[0,1,0]],
[[1,0,0],[0,1,1]],
[[1,0,1],[0,1,1]],
[[1,0,0],[0,0,1]],
[[1,1,0],[0,0,1]],
[[0,1,0],[0,0,1]],
[[1,0,0],[0,1,0],[0,0,1]]]

set root_datum(RootDatum G,[ratvec] gens) = RootDatum:
root_datum(G.Lie_type,gens)

set sp_product(int n)=RootDatum:let G=Sp(4) in for i:n-1 do G:=G*Sp(4) od;G

set sp_product(int n,[ratvec] gens)=RootDatum:root_datum(sp_product(n),gens)

set sp_product(int n,[vec] vecs)=RootDatum:sp_product(n,for v in vecs do v/2 od)

set all_vectors(int n)=[vec]:box(2,n)

set sp_products(int n)=[RealForm]:
if n=3 then 
let vecs=vectors_sets_three then
Sp=(sp_product(n,[vec]:[])).split_form in
for list in vecs do sp_product(n,list).split_form od
elif n=2 then 
let vecs=vectors_sets_two then
Sp=(sp_product(n,[vec]:[])).split_form in
for list in vecs do sp_product(n,list).split_form od else
[] fi

set sp_products_long(int n)=[([vec],RealForm)]:
assert(n=3,"only n=3");
let vecs=vectors_sets_three then
Sp=(sp_product(n,[vec]:[])).split_form in
for list in vecs do (list,sp_product(n,list).split_form) od 

set my_orbit(RootDatum G)=
assert(G.rank=4 or G.rank=6, "only rank 2,3");
let cwts=G.fundamental_coweights in
if G.rank=3 then 
complex_nilpotent(G,ratvec_as_vec(2*(cwts[1]+cwts[3]+cwts[5])))
else
complex_nilpotent(G,ratvec_as_vec(2*(cwts[0]+cwts[2]))) fi






{subregular orbit in each group}
set sp_orbits(int n)=[(RealForm,ComplexNilpotent)]:
for G in sp_products(n) do
 let Gd=G.dual_quasisplit_form in 
 (G,my_orbit(Gd)) od

set sp_character_table(int n)=character_table(sp_product(n))
set sp_springer_table_dual(int n)=sp_product(n).dual.springer_table

set sp_test(int n)=
let groups_and_orbits=sp_orbits(n) then
()=prints("defined ", #groups_and_orbits, " groups") then
ct_0=sp_character_table(n) then
(G,)=groups_and_orbits[0] then
()=prints("computed character table") then
fd=
 if n=3 then [0,1,1,-1,4,1,2,2,-1,5,1,2,2,-1,5,-1,-1,-1,-1,-1,4,5,5,-1,8,1,2,2,-1,5,2,\
3,3,-1,6,2,3,3,-1,6,-1,-1,-1,-1,-1,5,6,6,-1,9,1,2,2,-1,5,2,3,3,-1,6,2,3,3,-1,6,-1,-1,-1,-1,-1,\
5,6,6,-1,9,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,5,5,\
-1,8,5,6,6,-1,9,5,6,6,-1,9,-1,-1,-1,-1,-1,8,9,9,-1,12] else
fake_degrees(ct_0,all_parameters_gamma(G,G.rho)) fi then
()=ct_0.fake_degrees:=fd then
{ct=update_fake_degrees(G,ct_0) then}
()=prints("updated fake degrees:") then
()=prints(ct_0.fake_degrees) then
ct=ct_0 then
st_v=sp_springer_table_dual(n) then
()=prints("computed (dual) springer table") in
for (G,orbit) in groups_and_orbits do
 prints("-------------------------------------------------------------");
 prints("G=", G, new_line);
 prints("Orbit: ", orbit, " ", orbit.diagram);
 print_Z(G);
 for v in G.center do prints(v) od;
 show_lusztig_cell(G,ct,st_v,orbit) od






set show_groups([([vec],RealForm)] groups)=
 for (x,a)@i in groups do prints(new_line,i);prints("vecs=",x);print_Z(a);prints("center:",a.elements_of_center) od

 set show_groups(int n)=show_groups(sp_products_long(n)) 