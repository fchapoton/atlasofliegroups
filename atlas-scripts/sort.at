<basic.at

set merge ([int] a, [int] b) = [int]: { merge weakly increasing lists }
  let na=#a in
  if na=0 then b
  else let i=0, j=0, nb=#b { original length of b }
  in b #:= a~[0] { sentinel; when this elt becomes b[j], then a is emptied }
  ; while i<na or j<nb { run until i=na and j=nb=#b-1 }
    do if i<na and a[i]<=b[j] then a[i] next i+:=1 else b[j] next j+:=1 fi
    od
  fi

set sort = ([int]->[int]): { merge sort }
  let rec_fun ms ([int] v, int l) = [int]: { invariant includes l=#v }
    if l<3 then if l=2 and v[0]>v[1] then v~[:] { swap } else v fi
    else let half=l\2 in merge( ms(v[:half],half), ms(v[half:],l-half) )
    fi
  in { sort = } ([int] v) [int]: ms(v,#v)

set reverse_sort ([int] v) = [int]: sort(v)~[:]

{sort unique}
set sort_u ([int] v) = [int]:
  let result = [int]:[] in
  for a@i in sort(v) do if =i or a!=result~[0] then result #:= a fi od; result

{ the following helps stable-sorting of anything according to a statistic }

{ Inverse (since used for permuting) of the permutation that stable-sorts a list
  $v$ of (integer) values into increasing order: at $i$, it has the index of the
  value ranked $i$ in $v$, where equal values are ranked from left to right.
  That permutation itself is just the standardisation (stable ranking) of $v$.
}
set inv_standardisation = ([int]->[int]):
  let merge([(int,int)] a, [(int,int)] b) = { merge based on first component }
      let na=#a in
      if na=0 then b
      else let i=0, j=0, nb=#b { original length of b }
      in b #:= a~[0] { sentinel; when this becomes b[j], then $a$ is emptied }
      ; while i<na or j<nb { run until i=na and j=nb=#b-1 }
	do
	  if i=na then b[j] next j+:=1
	  else { compare only first components, as second one always increase }
	    let (x,):ai=a[i], (y,):bj=b[j] { x,y are sort keys, ai,bj elements }
	    in if x<=y then ai next i+:=1 else bj next j+:=1 fi
	  fi
	od
      fi
  then
    rec_fun ms ([(int,int)] v, int l) = [(int,int)]:
      if l>=3 then let h=l\2 in merge(ms(v[:h],h),ms(v[h:],l-h))
      elif l=2 and (let (x,)=v[0], (y,)=v[1] in x>y) then v~[:] { swap }
      else v { either l=1 or v sorted }
      fi
  in ([int] v) [int]: { actual body of inv_standardisation }
    for (,org_i) in ms(for a@i in v do (a,i) od,#v) { attach index to entries }
    do org_i od { afterward just recover the permuted original indices }

{ inv_standardisation -> order of indices to select from original for sorting }
set sort_by ((KGBElt -> int) f)= ([KGBElt] v) [KGBElt]:
  for index in inv_standardisation(for x in v do f(x) od) do v[index] od
set sort_by ((Param->int) f) = ([Param] v) [Param]:
  for index in inv_standardisation(for x in v do f(x) od) do v[index] od

{for use in K_norm.at: sorting of KParams}
set sort_by ( ( (KGBElt,ratvec) -> int) f ) =
  ([(KGBElt,ratvec)] v) [(KGBElt,ratvec)]:
    for index in inv_standardisation(for x in v do f(x) od) do v[index] od

set sort_by (((Param,bool)->int) f) = ([(Param,bool)] v) [(Param,bool)]:
  for index in inv_standardisation(for x in v do f(x) od) do v[index] od

set sort_by ( (Split,Param->int) f) = ([(Split,Param)] v) [(Split,Param)]:
  for index in inv_standardisation(for x in v do f(x) od) do v[index] od

{ for use in K_norm.at, sorting of KParamPol }
set sort_by ( (Split,(KGBElt,ratvec)->int) f) =
  ([(Split,(KGBElt,ratvec))] v) [(Split,(KGBElt,ratvec))]:
    for index in inv_standardisation(for x in v do f(x) od) do v[index] od

{ also need sorting by rationals; this uses conversion to/from ratvec }
set sort ([rat] v) = [rat]: let (num,denom)=%v in sort(num)/denom
set inv_standardisation ([rat] v) = let (num,)=%v in inv_standardisation(num)

{ and so forth for any type; this really should be second-order typed }

{ Here are example calls of the model functions above. They can be defined
  here because reducibility_points and height are built-in functions (those
  defined in basic.at could also be used). If however you need to sort on a
  custom attribute defined elsewhere, DON'T do so here (and don't include
  modules to make that possible); rather call sort_by in the script where that
  custom attribut is defined. (You might need to extend the above list of
  models if a new value type is involved; that is OK and in fact recommended.)

  For instance LKT.at defines the attribute LKT_dimensions, and then defines
  sort_by_dimension in a call of sort_by, whose argument uses that attribute.
}

{ sort list of pairs [(Param,bool)] by #reducibility_points of Param }
set sort_by_reducibility_points = ([(Param,bool)]->[(Param,bool)]):
  sort_by((Param p,bool x) int: #reducibility_points(p) )

{ sort list [Param] by #reducibility_points of Param }
set sort_by_reducibility = ([Param]->[Param]):
  sort_by((Param p) int: #reducibility_points(p) )

{ Sort list of parameters by height }
set sort_by_height = ([Param] -> [Param]): sort_by( height@Param )

{ Same for a list of parameters with a Split attached (ignored for sorting) }
set sort_by_height = ([(Split,Param)] -> [(Split,Param)]):
 sort_by( (Split s,Param p) int: height(p) )
