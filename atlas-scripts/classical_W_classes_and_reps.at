<basic.at
<combinatorics.at { for types |Partition|, |Signed_cycles|, and many functions }
<W_characters.at
<simple_factors.at

{conjugacy classes and representations of classical Weyl groups
this file consists mainly of some union types to
aggregate A/BC/D constructions into a uniform type
see character_tables.at
springer_tables.at
see character_table_*.at (A,B,C,D,E,F,G)
springer_table_*.at (A,BC,D,E,F,G)
}


set_type A_class = Partition { parametrise W conjugacy classes in type A }
set_type A_irrep = Partition

{ for types B and C, there is the type |Signed_cycles| from combinatorics.at
  Here we group cycles with |true| negative sign), then cycles with |false|
  (positive sign), each decreasingly sorted, to a order pair of |Paritition|s }
set_type BC_class = (Partition,Partition)
set_type BC_irrep = (Partition,Partition)

set_type
[ D_class = { cycle types restricted to Dn subgroup }
   ( Signed_cycles unsplit_class { the product of all signs is positive }
   | (Partition,bool) split_class { "all false" even cycles, and a single sign }
   )
,  D_irrep = { from folding pairs of partitions under swapping }
   ( (Partition,Partition) unsplit_irr { unequal partitions, larger first }
   | (Partition,bool) split_irr { for pair of equal partitions, with sign }
   )
]

{ A type that allows grouping any of the above or none into a single value }
set_type
[ classical_class =
    ( A_class class_A
    | BC_class class_BC
    | D_class  class_D
    | void null_class { for an exceptional group }
    )
, classical_irrep =
    ( A_irrep irrep_A
    | BC_irrep irrep_BC
    | D_irrep irrep_D
    | void null_irrep{for an exceptional group}
    )
]

{ functions to extract form the union; for user convenience only, for
  programming purpusos always use discrimination clauses (case..esac as below) }

set split_class (D_class c) = (Partition,bool):
   case c | split_class(pair): pair | else error("class is not split") esac

set unsplit_class(D_class c) = Signed_cycles:
   case c | unsplit_class(pair): pair | else error("class is split") esac



set get_class_A(classical_class cl) = Partition:
case cl
| class_A(P): P
| class_BC(x): error("wrong type")
| class_D(x):  error("wrong type")
| else []
esac

set get_class_BC(classical_class cl) = (Partition,Partition):
case cl
| class_A(x):   error("wrong type")
| class_BC(PQ): PQ
| class_D(x):   error("wrong type")
| else          ([],[])
esac

set get_class_D(classical_class cl) = D_class:
case cl
| class_D(val): val
| else          error("wrong type")
esac

set to_partition_pair(Signed_cycles cy) = BC_class:
( for (part,b) in cy do if b then [part] else [] fi od.##.reverse_sort
, for (part,b) in cy do if b then [] else [part] fi od.##.reverse_sort
)



{-------------------------------------------------------------------}
set get_irrep_A(classical_irrep rep) = [int]:
   case rep | P.irrep_A: P | else error("wrong type") esac

set get_irrep_BC(classical_irrep rep) = ([int],[int]):
   case rep | PQ.irrep_BC: PQ | else error("wrong type") esac

set get_irrep_D(classical_irrep rep) = D_irrep:
   case rep | val.irrep_D: val | else error("wrong type") esac

{-------------------------------------------------------------------}

{some cases special to type D:}
{ recover the value of |n| }
set rank (D_irrep chi) = int:
   case chi
   | pair.unsplit_irr: pair.rank { rank@(Partition,Partition); combinatorics.at }
   | (lambda,).split_irr: 2*lambda.sum { |lambda| stands for (lambda,lambda) }
   esac

set rank (D_class c) = int:
   case c
   | cycles.unsplit_class: cycles.rank { rank@Signed_cycles; combinatorics.at }
   | (lambda,).split_class: lambda.sum { |lambda| has all cycles (even,false) }
   esac

set cycle_type_order (D_class c) = int:
   case c
   | cycles.unsplit_class: cycles.cycle_type_order { as in types B, C }
   | (lambda,).split_class: lambda.cycle_type_order { as in type A }
   esac

{ compute cycle type of power of a signed permutation, given its cycle type }
set cycle_power (D_class c, int k) = D_class:
   case c
   | cycles.unsplit_class: cycle_power(cycles,k).unsplit_class
   | (alpha,sign).split_class: let beta=cycle_power(alpha,k) in
     if =beta%2 { whether class remains split (could fail if |k| is even) }
     then (beta,sign).split_class { keep sign when class remains split }
     { an easy way to see that this is right: certainly when |sign=false|, the
       power gets no sign, but since an outer automorphisme interchanges the
       halves of every split class, |sign=true| should give the opposite half }
     else for part in beta do (part,false) od.unsplit_class
     fi
   esac

set centralizer_order (D_class c) = int:
   case c
   | cycles.unsplit_class: { unsplit means half of BC centralizer is not in Dn }
       cycles.cycle_centralizer_order\2
   | (alpha,).split_class: { split means full BC centralizer is in Dn subgroup }
       { simulate |cycle_centralizer_order@Signed_cycles|, using ..@Partition }
       alpha.cycle_centralizer_order*2^#alpha { add a factor 2 for each cycle }
   esac

set D_irreducibles (int n) = [D_irrep]:
 ##for (lambda,mu) in partition_pairs(n)
   do if leq_partitions(lambda,mu) then [] else [(lambda,mu).unsplit_irr] fi
   od ##
  (let (s,r)=n\%2 in
   if =r else []
   then
    ##for lambda in partitions(s)
      do [(lambda,false).split_irr,(lambda,true).split_irr]
      od
   fi
  )

set D_classes (int n) = [D_class]:
   for (alpha,beta):pair in partition_pairs(n)
   do if (#alpha).is_odd then [] { must have even number of cycles in alpha }
      elif != alpha or !=beta%2 { whether unsplit: some negative or odd length }
      then [pair.cycles.unsplit_class]
      else { alpha is empty, beta has all even parts }
         [ (beta,false).split_class, (beta,true).split_class ]
      fi
   od.##

set character (D_irrep chi, D_class c) = int:
   assert(chi.rank = c.rank,"Size mismatch");
   let pos_cycles(Partition mu)=Signed_cycles: for l in mu do (l,false) od in
   case chi
   | pair.unsplit_irr:
     case c
     | cycles.unsplit_class: hyperoctahedral_character(pair,cycles)
     | (alpha,).split_class: { both halves behave as their BC class }
        hyperoctahedral_character(pair,pos_cycles(alpha))
     esac
   | (lambda,epsilon).split_irr:
     case c
     | cycles.unsplit_class:
       let (q,r) = hyperoctahedral_character((lambda,lambda),cycles)\%2 in
       assert(=r,"Odd character value at unsplit class"); q
     | (alpha,delta).split_class:
       let Hn_char = int:
           hyperoctahedral_character((lambda,lambda),pos_cycles(alpha))
       ,   Sn_char = int:
           assert(=alpha%2,"Split class with odd cycle(s)");
           Murnaghan_Nakayama(lambda, alpha\2)
       then (q,r) = (Hn_char+sign(epsilon!=delta)*2^#alpha*Sn_char)\%2
       in assert(=r,"Parity problem for split-split character value"); q
     esac
   esac

set is_split(D_class c) = bool:
   case c | (,).split_class: true | else false esac

set split_and_unsplit_classes([D_class] list) =
      (([Partition,bool],[int]),([Signed_cycles],[int])):
let split=[Partition,bool]:[], map_split=[int]:[]
,   unsplit=[Signed_cycles]:[], map_unsplit=[int]:[]
in for x@i in list
   do case x
      | split_class(s):    split  #:= s;  map_split#:=i
      | unsplit_class(us): unsplit #:=us; map_unsplit#:=i
      esac
   od; ((split,map_split),(unsplit,map_unsplit))

set is_split(D_irrep pi) = bool:
   case pi | (,).split_irr: true | else false esac

set split_irrep (D_irrep pi) = (Partition,bool):
   case pi | pair.split_irr: pair | else error("rep is unsplit") esac

set unsplit_irrep (D_irrep pi) = (Partition,Partition):
   case pi | pair.unsplit_irr: pair | else error("rep is split") esac

{ curried version could be more efficient here }
set index_D_classes([D_class] L) = (D_class->int):
   let ((split,map_split),(unsplit,map_unsplit)) = split_and_unsplit_classes(L)
in (D_class class) int:
   case class
   | split_class(P,boolean):
       let ix=first(#split,(int i)bool: let (a,b)=split[i] in a=P and b=boolean)
       in map_split[ix]
   | unsplit_class(cycles): index_signed_cycles(unsplit,map_unsplit)(cycles)
   esac

{ uncurried vesion used curried one (without efficieny gain) }
set index_D_classes([D_class] L, D_class c) = int: index_D_classes(L)(c)


set split_and_unsplit_reps([D_irrep] list) =
      (([Partition,bool],[int]), ([Partition,Partition],[int])):
let  split=[Partition,bool]:[], map_split=[int]:[]
,  unsplit=[Partition,Partition]:[], map_unsplit=[int]:[]
in for x@i in list
   do case x
      | split_irr(r):    split  #:= r;  map_split#:=i
      | unsplit_irr(ur): unsplit #:=ur; map_unsplit#:=i
      esac
   od; ((split,map_split),(unsplit,map_unsplit))

{ curried first }
set index_D_reps([D_irrep] L) = (D_irrep->int):
   let ((split,map_split),(unsplit,map_unsplit)) = split_and_unsplit_reps(L)
in (D_irrep rep) int:
   case rep
   | split_irr(P,boolean):
      let ix=first(#split,(int i)bool: let (a,b)=split[i] in a=P and b=boolean)
      in map_split[ix]
   | unsplit_irr(lambda,mu):
     let ix=first(#unsplit
                 ,(int i)bool: let (a,b)=unsplit[i] in a=lambda and b=mu
		 )
     in map_unsplit[ix]
   esac

set index_D_reps ([D_irrep] L,D_irrep rep) = int: index_D_reps(L)(rep)

set string_rep(D_class c) = string:
   case c
   | (list).unsplit_class: list.to_partition_pair.to_string
   | (P,b).split_class: P.to_string + ";" + sign(b).to_string
   esac

set class_string(classical_class cl)=
  case cl
  | cl.class_A: cl.to_string
  | cl.class_BC: cl.to_string
  | cl.class_D: cl.string_rep
  | else ""
  esac

set string_rep(D_irrep rep) = string:
   case rep
   | pair.unsplit_irr: pair.to_string
   | (P,b).split_irr: P.to_string + ";" + sign(b).to_string
   esac

set irrep_string(classical_irrep rep)=
  case rep
  | lambda.irrep_A: lambda.to_string
  | pair.irrep_BC: pair.to_string
  | r.irrep_D: r.string_rep
  | else ""
  esac
