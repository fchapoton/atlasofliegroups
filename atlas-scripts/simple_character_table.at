<basic.at
<combinatorics.at { for partitions@int }
<character_tables.at
<character_table_B.at  {loads type C also}
<character_table_F.at
<character_table_G.at

{now for the individual types}

{  type A }

{ get an actual WeylElt from a partition <-> conjugacy class in W}
{ sum(P)=n -> S_n -> root datum A_{n-1} -> SL(n)}
set conjugacy_class_S(Partition P) = WeylElt:  {for SL(n)}
(  assert(is_positive(P), "P is not a partition (has non-positive entries)")
;  let n=sum(P)
   , bars= let sum=-1 in for p in P do sum+:=p od { W generators to suppress }
in W_elt(if =n then trivial_group else SL(n) fi,complement(n,bars))
)

set character_table_S(int n) = CharacterTable:
  let partitions_n = partitions(n)
  then classes = [WeylElt,classical_class,string]:
    for lambda in partitions_n
    do (conjugacy_class_S(lambda),lambda.class_A,lambda.to_string)
    od
  , irreps = [classical_irrep,string,[int]]:
    for lambda in partitions_n
    do (irrep_A(lambda),lambda.to_string
       ,for cyc_type in partitions_n do Murnaghan_Nakayama(lambda,cyc_type) od
       )
    od
  in character_table(SL(n),classes,irreps)

set character_table_A(int n) = CharacterTable: character_table_S(n+1)



{
set character_table_D(int n) = CharacterTable:
( let order=n.fac*2^(n-1)
  , irred = Dn_irreducibles(n)
  , class = Dn_classes(n)
  , unsplits = [[int,bool]]:[], splits = [Partition]: []
  then unsplit_indices =
   ##for c@i in class
     do case c | cycles.unsplit_class: unsplits #:= cycles; [i] | else [] esac
     od
  , split_indices =
   ##for c@i in class
     do case c
        | (alpha,neg).split_class: if neg then [] else splits #:= alpha; [i] fi
        | else []
        esac
     od
  then index_unsplit = index_signed_cycles(unsplits,unsplit_indices)
  , index_split = index_partition(splits) { |splits| is born in sorted order }
  then index(Dn_class C) = int:
     case C
     | cycles.unsplit_class: cycles.index_unsplit
     | (alpha,neg).split_class: split_indices[alpha.index_split]+#neg
     esac
  , centralizer_orders = for C in class do C.centralizer_order od
  , sign(bool s) = string: if s then "-" else "+" fi
in
  ( Lie_type(SO(2*n))
  , order
  , (int j) [(Partition,vec)]: [([],[])] {do this later}
  , (int j) string: { class_label }
    case class[j]
    | cycles.unsplit_class: cycles.cycles_string
    | (alpha,s).split_class: alpha.to_string ## sign(s)
    esac
  , (int j) int: class[j].cycle_type_order
  , (int j, int p) int: cycle_power(class[j],p).index
  , centralizer_orders
  , for co in centralizer_orders do order\co od
  , (int i) string: { irreducible representation label }
    case irred[i]
    | (lambda,mu).unsplit_irr: { here we keep the stored order of partitions }
      "{" ## lambda.parts_string ## " | " ## mu.parts_string ## "}"
    | (mu,s).split_irr:
      "{" ## mu.parts_string ## " | " ## mu.parts_string ## "}" ## s.sign_string
    esac
  , [int]:[] {reflection character, do this later}
  ,[WeylElt]:[]
  , #class ^ { gather rows of this size: }
    for chi in irred do for C in class do Dn_character(chi,C) od od
  )
)
}

set simple_character_table(LieType lt)=
assert(lt.is_simple, "Lie Type is not simple");
let (letter,rank)=lt.simple_type in
assert(letter="A" or letter="C" or letter="F","only types ACF currently implemented");
if letter="A" then character_table_A(rank+1)
elif letter="C" then character_table_C(rank)
elif letter="F" then character_table_F4()
elif letter="G" then character_table_G2()
else error("missing case") fi

set simple_character_table(RootDatum rd)=simple_character_table(rd.Lie_type)