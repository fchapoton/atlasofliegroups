<subalgebra.at
<simple_factors.at
<conjugate.at

{a few display commands}
set show([RootDatum] rds)=void:
for rd in rds do prints(rd.Lie_type.str) od

set show([[RootDatum]] rds)=void:
for list@i in rds do prints(new_line, i);show(list) od

{find a conjugate of sub_rd in rds, everything going
on in rd_ambient}
set find(RootDatum rd_ambient, [RootDatum] rds,RootDatum sub_rd)=bool:
first(for rd in rds do is_conjugate(rd_ambient,rd,sub_rd) od) !=-1

{sorting by dimension, semisimple rank, #simple factors}
set sort_by((RootDatum->int) f) =
   ([RootDatum] v) [RootDatum]:
      for index in inv_standardisation(for x in v do f(x) od) do v[index] od

set sort_by_dimension = ([RootDatum] -> [RootDatum]):
   sort_by(dimension@RootDatum)

set sort_by_ss_rank = ([RootDatum]->[RootDatum]):
   sort_by(ss_rank@RootDatum)

set group_by_ss_rank([RootDatum] rds)=[[RootDatum]]:
if =#rds then [rds] else
let n=max(for rd in rds do ss_rank(rd) od) then
rv=[[RootDatum]]:for i:n+1 do [RootDatum]:[] od in
for rd in rds do rv[ss_rank(rd)]#:=rd od ;rv fi

set group_by_number_simple_factors([RootDatum] rds)=[[RootDatum]]:
if =#rds then [rds] else
let n=max(for rd in rds do number_simple_factors(rd) od) then
rv=[[RootDatum]]:for i:n+1 do [RootDatum]:[] od in
for rd in rds do rv[number_simple_factors(rd)]#:=rd od ;rv fi

set group_by_ss_rank_and_number_simple_factors([RootDatum] rds)=
for x in group_by_ss_rank(rds) do group_by_number_simple_factors(x) od 

{all maximal pseudo Levis of rd
(including rd itself for induction reasons)
assumption: rd has one simple factor, i.e. derived(rd) is simple
run over all subsets obtained by deleting one
non-special (i.e. label \ne 1) node from
the extended Dynkin diagram
this does NOT include actual Levi subgroups
}
set maximal_pseudo_Levis_simple(RootDatum rd)=[RootDatum]:
assert(derived_is_simple(rd),"Root Datum has more than one simple factor");
if is_abelian(rd) then [rd] else
let sr=simple_roots(rd) then
labels=labels(derived(rd)) then
alpha=-highest_root(rd) in
rd#(##for i:ss_rank(rd) do
 if labels[i] !=1 then [subalgebra_by_simple(rd, delete(sr,i)#alpha)] else [] fi od) fi

{each RootDatum in rds is made from roots in rd_ambient
 construct Cartesian products (in rd_ambient) of simple factors
 see maximal_pseudo_Levis below for the main application
 and and example
}
set all_products([[RootDatum]] rds,RootDatum rd_ambient)=[RootDatum]:
if #rds=0 then [] elif
#rds=1 then rds[0] else
let rec_fun f([[RootDatum]] to_do,[RootDatum] done)=[RootDatum]:
 if =#to_do then done else
 let new=##
  for rd in done do
   for rd0 in to_do[0] do
    let new_simple_roots=simple_roots(rd0)##simple_roots(rd) in
    subalgebra_by_simple(rd_ambient,new_simple_roots) 
   od
  od
  in f(for i:#to_do-1 from 1 do to_do[i] od,new)
 fi
in f(for i:#rds-1 from 1 do rds[i] od,rds[0])  fi

{construct all maximal pseudo Levis of rd, not necessarily simple
no attempt to mod out by conjugacy
for example:
atlas> rd
Value: simply connected root datum of Lie type 'C2.C2'
atlas> for sub in maximal_pseudo_Levis(rd) do prints(sub) od
simply connected root datum of Lie type 'A1.A1.A1.A1'
simply connected root datum of Lie type 'C2.A1.A1'
simply connected root datum of Lie type 'A1.A1.C2'
simply connected root datum of Lie type 'C2.C2'
}
set maximal_pseudo_Levis(RootDatum rd)=[RootDatum]:
all_products(for subrd in simple_factors(rd) do maximal_pseudo_Levis_simple(subrd) od,rd)

{for the inductive step need to keep only proper ones}
set proper_maximal_pseudo_Levis(RootDatum rd)=[RootDatum]:
##for pl in maximal_pseudo_Levis(rd) do if dimension(pl)=dimension(rd) then [] else [pl] fi od

{iteratively compute all subalgebras by repeatedly computing maximal pseudo Levis
 ignore conjugacy
}
set iterate_maximal_pseudo_Levis(RootDatum rd)=[RootDatum]:
let rec_fun f([RootDatum] done,[RootDatum] to_do)=[RootDatum]:
 if =#to_do then done else
 f(done#(to_do[0]),(for i:#to_do-1 from 1 do to_do[i] od)##proper_maximal_pseudo_Levis(to_do[0])) fi in
 f([],[rd]) 

{all equal rank reductive subalgebras, ignoring conjugacy
algorithm:
1) iteratively compute all maximal pseudo Levis
2) for each sub sub_rd list representatives of all conjugacy classes of Levis
}
set all_subs_raw(RootDatum rd)=[RootDatum]:
##for sub in iterate_maximal_pseudo_Levis(rd) do
 for S in standard_Levi_conjugacy_representatives(sub)  do complex_Levi(sub,S) od  od

{keep one representative from each conjugacy class of subalgebras}
set filter(RootDatum rd_ambient, [RootDatum] subs)=[RootDatum]:
if #subs=0 then [] else
let rv=[subs[0]] in
 for i:#subs-1 from 1 do
  if not find(rd_ambient,rv,subs[i]) then rv#:=subs[i] fi od;
rv fi

{cut down all_subs_raw to one representative of each conjugacy class
for efficiency group by ss_rank and number of simple factors before 
testing for conjugacy
return two lists
first: [[RootDatum]] grouped by ss_rank
second:[RootDatum] ordered by dimension
}
set all_subs(RootDatum rd)=([[RootDatum]],[RootDatum]):
let all=group_by_ss_rank_and_number_simple_factors(all_subs_raw(rd)) in
let rv=
for i:#all do
 for j:#all[i] do
{  let ()=prints("ss_rank: ", i, new_line, "# simple factors: ",j) in }
  let f=filter(rd,all[i][j])  in
{let ()=prints("#reduced subs=",#f) in}
f od od in
{regroup answer by ss_rank}
let grouped_by_ss_rank=for i:#rv do ##rv[i] od in
(grouped_by_ss_rank,sort_by_dimension(##grouped_by_ss_rank))

{weak testing: only using rho and rho_check}
set find_weak(RootDatum rd_ambient, [RootDatum] rds,RootDatum sub_rd)=bool:
(first(for rd in rds do is_conjugate(rd_ambient,rho(rd),rho(sub_rd)) od) !=-1) and
(first(for rd in rds do is_conjugate(rho_check(rd),rho_check(sub_rd),rd_ambient) od) !=-1)

{keep one representative from each conjugacy class of subalgebras}
set filter_weak(RootDatum rd_ambient, [RootDatum] subs)=[RootDatum]:
if #subs=0 then [] else
let rv=[subs[0]] in
 for i:#subs-1 from 1 do
  if not find_weak(rd_ambient,rv,subs[i]) then rv#:=subs[i] fi od;
rv fi

{cut down all_subs_raw to one representative of each conjugacy class
for efficiency group by ss_rank and number of simple factors before 
testing for conjugacy}
set all_subs_weak(RootDatum rd)=
let all=group_by_ss_rank_and_number_simple_factors(all_subs_raw(rd)) in
let rv=
for i:#all do
 for j:#all[i] do
  let ()=prints("ss_rank: ", i, new_line, "# simple factors: ",j) in 
  let f=filter_weak(rd,all[i][j])  then
()=prints("#reduced subs=",#f) in
f od od in
{rearrange answer}
for i:#rv do ##rv[i] od


set group_by_rho(RootDatum rd_ambient, [RootDatum] rds)=[[RootDatum]]:
let rv=[[RootDatum]]:[] in
 for rd in rds do let
  match=first(for subs in rv do find_weak(rd_ambient,subs,rd) od) in
   if match=-1 then rv#:=[rd] else rv[match]#:=rd fi od ;rv



{this should really be in W_characters.at}
set find_conjugate([WeylElt] S,WeylElt w)=int:
first(for y in S do is_conjugate(y,w) od)

set find_all_conjugate([WeylElt] S,WeylElt w)=[int]:
##for y@i in S do if is_conjugate(y,w) then [i] else [] fi od

set group_by_conjugacy([WeylElt] S)=[[WeylElt]]:
let rv=[[WeylElt]]:[] in
for w in S do
 let match=find_conjugate(for list in rv do list[0] od,w) in 
 if match =-1 then rv#:=[w] else rv[match]#:=w fi od;
 rv


set iterate_maximal_pseudo_Levis(RootDatum rd)=[RootDatum]:
let rec_fun f([RootDatum] done,[RootDatum] to_do)=[RootDatum]:
 if =#to_do then done else
 f(done#(to_do[0]),(for i:#to_do-1 from 1 do to_do[i] od)##proper_maximal_pseudo_Levis(to_do[0])) fi in
 f([],[rd]) 

set conjugacy_classes_from_subs(RootDatum rd,[RootDatum] subs)=[(RootDatum,WeylElt)]:
for L in subs do (L,W_elt(rd,matrix(coxeter_element(L)))) od

set group_by_conjugacy([(RootDatum,WeylElt)] pairs)=[[(RootDatum,WeylElt)]]:
let rv=[[(RootDatum,WeylElt)]]:[] in
for (L,w) in pairs do
 let match=find_conjugate(for list in rv do let (,y)=list[0]  in y od,w) in 
 if match =-1 then rv#:=[(L,w)] else rv[match]#:=(L,w) fi od;
 rv


{iteratively compute all subalgebras by repeatedly computing maximal pseudo Levis
 ignore conjugacy
 keep extra information: nested sequence of subgroups
}
{NOT WORKING}
set iterate_maximal_pseudo_Levis_long(RootDatum rd)=
let stop=0 in 
let rec_fun f([[RootDatum]] done,[[RootDatum]] to_do)=[[RootDatum]]:
 assert(stop<5,"Stopping");
 prints("stop=",stop);
 if =#to_do then done else
 let ()=prints(new_line,"done:", #done, new_line, "to_do:", #to_do, " ", to_do) in
 let first_list=to_do[0] then
  first_sub=first_list[0] then
  done_new=done#(first_list) then
  to_do_new=
   let subs=proper_maximal_pseudo_Levis(first_sub) in
   (for i:#to_do-1 from 1 do to_do[i] od)##
    for L in subs do first_list#L od in
  stop+:=1;
  f(done_new,to_do_new) fi in
  f([[]],[[rd]])

{test sub_rd_1 is rd-conjugate to a subalgebra of sub_rd_2}
set is_contained(RootDatum rd,RootDatum sub_rd_1,RootDatum sub_rd_2)=bool:
if dimension(sub_rd_1)>dimension(sub_rd_2) or
   ss_rank(sub_rd_1)>ss_rank(sub_rd_2) then false else
find(rd,let (,all_subs_2)=all_subs(sub_rd_2) in all_subs_2,sub_rd_1) fi

{test sub_rd_1 is rd-conjugate to a subalgebra of sub_rd_2}
{in which all subs of rd_2 is precomputed}
set is_contained(RootDatum rd,RootDatum sub_rd_1,RootDatum sub_rd_2,[RootDatum]  all_subs_rd_2)=bool:
if dimension(sub_rd_1)>dimension(sub_rd_2) or
   ss_rank(sub_rd_1)>ss_rank(sub_rd_2) then false else
find(rd,all_subs_rd_2,sub_rd_1) fi

{transitivity: looking for n in done[j] for all j in new}
set easy([[int]] done,[int] new, int n)=bool:
 any(for j in new do if j<=#done-1 then find(done[j],n) !=-1 else false fi od)

{assume sorted by dimension}
set hasse(RootDatum rd,[RootDatum] subs)=[[int]]:
let rv=[[int]]:[] in
for i:#subs do
let (,all_subs_rd_i)=all_subs(subs[i]) in
{ let ()=prints("rv is now:"); for a@i in rv do prints(i, " ", a) od in}
 let new=prints(new_line,"-----",new_line,"i=",i);[int]:[] in  {list of subalgebras of subs[i]} 
  for j:i downto 0  do {see if subs[j] \subset subs[i]}
   let ()=prints("j=",j) in
{   let ()=prints("new:",new) in}
   {see if already done by transitivity}
   if easy(rv,new,j) then prints("easy:",i, " ", j); new#:=j 
    elif is_contained(rd,subs[j],subs[i],all_subs_rd_i) then {prints("added: ", j);}new#:=j fi
  od;
 rv#:=new
od;
rv

set export_graph([[int]] data,[RootDatum] subs)=string:
let text=
"strict digraph  { " + 
new_line + "size=""30.0,30.0!""; " + 
new_line + "center=true;  " + 
new_line + "node [color=black,fontcolor=black] " + 
new_line + " edge [arrowhead=none,color=red]; "
in
for i:#data do
{ let str=new_line+i.to_string + "[label=""" + subs[i].derived.Lie_type.standardize_Lie_type.str + """];" in }
 let str=new_line+i.to_string + "[label=""" + subs[i].derived.Lie_type.nice_format + """];" in 
  for j in data[i] do str+:=i.to_string + "->" + j.to_string + ";" od;
 text+:=str od;text+new_line+"}"

set make_graph(RootDatum rd)=string:
let (,subs)=all_subs(rd) then
()=prints("Got subalgebras: ", #subs,new_line,"computing Hasse diagram") then
h=hasse(rd,subs) in
prints("Computed Hasse diagram");
export_graph(h,subs)