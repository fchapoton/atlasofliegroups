<basic.at
<sort.at { for inv_standardisation }
<Weylgroup.at { for make_dominant }

{also see parabolics.at}

{
  see "K_types in atlas", in dropbox, ultimately on atlas web site

  Fix a subset S of the simple roots, defining the complex standard
  parabolic P_S (see parabolic.at) of type S. We define a set KGP(S) (a
  quotient of KGB) such that (roughly) KGP(S) <-> K\G/P_S

  More precisely for any x\in KGB and p(\xi)=x then
  KGP(S) is canonically in bijection with K_\xi\G/P_S, i.e.
  K_\xi conjugacy classes of parabolics of type S.

  K orbits on G/P_S, equivalently K-conjugacy classes of parabolics of type S
  Given a RealForm and a subset S of the simple roots
  S -> partial order on KGB, generated by ascents not in S
    -> equivalence relation generated by this
  KGB/equivalence <-> K\G/P_S
  Define KGP to be KGB modulo this equivalence

  Data: ([int],KGBElt)=(S,x) where S lists the indices of a subset of the
  simple roots of root_datum(x)
  Equivalence: (S,x)=(S',y) if these correspond to the same K orbit on G/P_S,
  which means:
   real_form(x)=real_form(y), S=S'  (i.e. same complex parabolic), and
   x=y in the equivalence defined by S
  In particular, given (S,x), taking x itself for the strong real form,
  (S,x) goes to K_x-conjugacy class of the standard parabolic P_S

  Given (S,x),
  write [x_1,...,x_n] for the S-equivalence class of x\subset KGB

  The last element x_n is maximal, and is uniquely determined
  This orbit of K on G/P_S is closed <=>x_1 is closed in KGB
}

{ data type for a K-orbit on G/P_S, equivalently a K-conjugacy class of
  parabolics of type S
  ([int] S,KGBElt x)
  S lists indices of a subset of the simple roots
  (S,x)=(S,y) if x is S-equivalent to y, see below
  Associated to (S,x) is a canonical K-conjugacy class of parabolics of type S
  More precisely, for each \xi, a K_\xi-conjugacy class of parabolics of type S
}
: KGPElt    = ([int], KGBElt)
: Parabolic = ([int], KGBElt)  { synonym }

{ some auxiliary routines needed for defining equivalence of data }
set sort_by((KGBElt -> int) f)= ([KGBElt] v) [KGBElt]:
  for index in inv_standardisation(for x in v do f(x) od) do v[index] od
set sort = ([KGBElt] -> [KGBElt]): sort_by((KGBElt x) int: #x)

set min ([KGBElt] list)=sort(list)[0]
set max ([KGBElt] list)=sort(list)~[0]


set KGP_elt (KGPElt pair) = KGPElt: pair { identity; prefer cast KGPElt:(S,x) }

set S (KGPElt(S,)) = [int]: S
set root_datum (KGPElt(,x)) = RootDatum: root_datum(x)
set real_form  (KGPElt(,x)) = RealForm:  real_form(x)

{ complement of subset of simple roots in rank n }
set complement(int n,[int] S) = [int]:
  list((int i)bool: none(for m in S do i=m od),n)

{ an ascent of x by a generator in S, if any exist }
set find_ascent ([int] S, KGBElt x) = [KGBElt]:
  let f = first(#S,(int i)bool: is_ascent(S[i],x)) in
  if <f then []
  else let s=S[f] in
    [if is_noncompact(s,x) then Cayley(s,x) else cross(s,x) fi]
  fi

{ all descents of x by generators in S, there may be duplicates }
  set down_neighbors ([int] S,KGBElt x) = [int]:
  let result=[int]:[] in
  for i in list((int i): is_strict_descent(S[i],x),#S)
  do let s=S[i] in
    if is_real(s,x)
    then let y=Cayley(s,x) in result #:= [#y,#cross(s,y)]
    else result #:= #cross(s,x)
    fi
  od; result

set is_maximal_in_partial_order ([int] S,KGBElt x) = bool: #find_ascent(S,x)=0

{ maximal elements in the partial order }
set maxima_in_partial_order (RealForm G,[int] S) = [KGBElt]:
  let result=[KGBElt]:[] in
  for x in KGB(G)
  do if is_maximal_in_partial_order(S,x) then result #:= x fi od; result

{ (unique) maximal element in equivalence class of x }
set maximal ([int] S, KGBElt x) = KGBElt:
  let r=[KGBElt]: [] in { variable needed to cross 'do' boundary }
  while r:=find_ascent(S,x); #r>0 do x:=r[0] od; x

set canonical_representative (KGPElt y) = KGPElt: (S(y),maximal(y))
set x = (KGPElt->KGBElt): maximal@KGPElt

{ (S,x)=(T,y) if these give the same K-orbit of parabolics }
set = (KGPElt (S,x),KGPElt (T,y))=bool:
  real_form(x)=real_form(y) and S=T and maximal(S,x)=maximal(S,y)


{equivalence class of KGB element in partial order defined by S}
set equivalence_class_of (KGPElt(S,x):y) = [KGBElt]:
  let x_max=maximal(S,x)
  then G=real_form(x_max), !last=#x_max
  then result=[last], done=0, present = for :last do false od
  in
  while done < #result
  do
    for i in down_neighbors(S,KGB(G,result[done])) next done +:= 1
    do if not present[i] then result #:= i; present[i] := true fi od
  od;
  for i in sort(result) do KGB(G,i) od


{ a minimal element from equivalence class (unlike x_max, it is not unique) }
set x_min (KGPElt P) = KGBElt:
  equivalence_class_of(P)[0] { inefficent, but at least avoid soring twice }

{ set of KGP elements (P,S), S=[KGBElt] is an equivalence class
  KGP(G,P) is in bijection with K\G/P }
set KGP (RealForm G,[int] S) = [KGPElt]:
  for x in maxima_in_partial_order(G,S) do KGPElt:(S,x) od

{ sometimes it is convenient to just keep the numbers, although this loses the
  information of what G is }
set KGP_numbers (RealForm G,[int] S) =[int]: for (,x) in KGP(G,S) do #x od


{ test y in K\G/P_S is open: <=> last element of y is last element of KGB }
set is_open (KGPElt y) = bool: #maximal(y) = KGB_size(real_form(y))-1

{ test y in K\G/P_S is closed: <=> length(first element)=0 }
set is_closed (KGPElt P) = bool: length(x_min(P))=0

{ parabolic determined by (stabilizer in W of) weight lambda }
set KGP_elt (ratvec lambda,KGBElt x) = KGPElt:
  let rd=root_datum(x)
  then (lambda_dom,w)=make_dominant(rd,lambda), P=[int]:[]
  in for a@i in simple_coroots(rd) do if a*lambda_dom=0 then P#:=i fi od;
  KGPElt:(P,cross(inverse(w),x))

{ unnecessary function: instead of parabolic(P,x) do  Parabolic:(p,x)
    set parabolic([int] P,KGBElt x) = Parabolic:(P,x)
  also the next just reuses a function defined to return KGPElt
}
set parabolic = (ratvec,KGBElt->Parabolic): { first argument lambda in \h^* }
  KGP_elt@(ratvec,KGBElt)





