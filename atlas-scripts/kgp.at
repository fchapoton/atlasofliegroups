{! also see parabolics.at;
  see "Parabolic Subgroups and Induction", in dropbox, ultimately on atlas web site.

  Fix a subset S of the simple roots, defining the complex standard
  parabolic $P_S$ (see parabolics.at) of type S. We define a set KGP(S) (a
  quotient of KGB) such that (roughly) KGP(S) <-> $K\G/P_S$.

  More precisely, for any $x\in$ KGB and $p(\xi)=x$,
  KGP(S) is canonically in bijection with $K_\xi\G/P_S$; i.e.,
  $K_\xi$ conjugacy classes of parabolics of type S.

  K orbits on $G/P_S$, equivalently K-conjugacy classes of parabolics of type S:
  Given a RealForm and a subset S of the simple roots,
  S -> partial order on KGB, generated by ascents in S
    -> equivalence relation generated by this
  KGB/equivalence <-> $K\G/P_S$
  Define KGP to be KGB modulo this equivalence.

  Data: ([int],KGBElt)=(S,x) where S lists the indices of a subset of the
  simple roots of root_datum(x)
  Equivalence: (S,x)=(S',y) if these correspond to the same K orbit on $G/P_S$,
  which means:
   real_form(x)=real_form(y), S=S'  (i.e. same complex parabolic), and
   x=y in the equivalence defined by S.
  In particular, given (S,x), taking x itself for the strong real form,
  (S,x) goes to the $K_x$-conjugacy class of the standard parabolic $P_S$.

  Given (S,x),
  write $[x_1,...,x_n]$ for the S-equivalence class of $x\subset$ KGB.

  The last element $x_n$ is maximal, and is uniquely determined.
  This orbit of K on $G/P_S$ is closed <=> $x_1$ is closed in KGB.
!}
<basic.at
<sort.at { for inv_standardisation }
<Weylgroup.at { for make_dominant }

{ data type for a K-orbit on G/P_S, equivalently a K-conjugacy class of
  parabolics of type S
  ([int] S,KGBElt x)
  S lists indices of a subset of the simple roots
  (S,x)=(S,y) if x is S-equivalent to y, see below
  Associated to (S,x) is a canonical K-conjugacy class of parabolics of type S
  More precisely, for each \xi, a K_\xi-conjugacy class of parabolics of type S
}
: KGPElt    = ([int], KGBElt)
: Parabolic = ([int], KGBElt)  { synonym }

{. given a list of KGB elements and a function f assigning integers to them,
sort the list by weakly increasing value of f  .}
set sort_by((KGBElt -> int) f)= ([KGBElt] v) [KGBElt]:
  for index in inv_standardisation(for x in v do f(x) od) do v[index] od

{. sort a list of KGB elements by their index numbers, in increasing order  .}
set sort = ([KGBElt] -> [KGBElt]): sort_by((KGBElt x) int: #x)

{. choose from a list of KGB elements the one (only unique if all associated
to the same RealForm) with the smallest index number .}
set min ([KGBElt] list)=sort(list)[0]

{. choose from a list of KGB elements one with greatest index number  .}
set max ([KGBElt] list)=sort(list)~[0]


set KGP_elt (KGPElt pair) = KGPElt: pair { identity; prefer cast KGPElt:(S,x) }

{. the list S of simple roots of a KGP element .}
set S (KGPElt(S,)) = [int]: S

{. the root datum of the RealForm G of a KGP element .}
set root_datum (KGPElt(,x)) = RootDatum: root_datum(x)

{. the RealForm G of a KGP element .}
set real_form  (KGPElt(,x)) = RealForm:  real_form(x)

{. complement of subset of simple roots in rank n .}
set complement(int n,[int] S) = [int]:
  list((int i)bool: none(for m in S do i=m od),n)

{. an ascent of x by a generator in S, if any exist .}
set find_ascent ([int] S, KGBElt x) = [KGBElt]:
  let f = first(#S,(int i)bool: is_ascent(S[i],x)) in
  if <f then []
  else let s=S[f] in
    [if is_noncompact(s,x) then Cayley(s,x) else cross(s,x) fi]
  fi

{. all descents of x by generators in S, there may be duplicates .}
set down_neighbors ([int] S,KGBElt x) = [int]:
  ##
  for i in list((int i): is_strict_descent(S[i],x),#S)
  do let s=S[i] in
    if is_real(s,x)
    then let y=Cayley(s,x) in [#y,#cross(s,y)]
    else [#cross(s,x)]
    fi
  od

{. decide whether x is maximal in the partial order defined by S .}
set is_maximal_in_partial_order ([int] S,KGBElt x) = bool: #find_ascent(S,x)=0

{. list maximal KGB elements in the partial order defined by S .}
set maxima_in_partial_order (RealForm G,[int] S) = [KGBElt]:
  let result=[KGBElt]:[] in
  for x in KGB(G)
  do if is_maximal_in_partial_order(S,x) then result #:= x fi od; result

{. (unique) maximal element in equivalence class of x .}
set maximal ([int] S, KGBElt x) = KGBElt:
  let r=[KGBElt]: [] in { variable needed to cross 'do' boundary }
  while r:=find_ascent(S,x); #r>0 do x:=r[0] od; x

{. the representative of a KGP element with maximal x .}
set canonical_representative (KGPElt y) = KGPElt: (S(y),maximal(y))

{. (unique) maximal KGB element representing a KGP element .}
set x = (KGPElt->KGBElt): maximal@KGPElt

{. equality of KGP elements: (S,x)=(T,y) if these give the same 
K-orbit of parabolics .}
set = (KGPElt (S,x),KGPElt (T,y))=bool:
  real_form(x)=real_form(y) and S=T and maximal(S,x)=maximal(S,y)


{. the equivalence class of a KGB element in partial order defined by S .}
set equivalence_class_of (KGPElt(S,x):y) = [KGBElt]:
  let x_max=maximal(S,x)
  then G=real_form(x_max), !last=#x_max
  then result=[last], done=0, present = for :last do false od
  in
  while done < #result
  do
    for i in down_neighbors(S,KGB(G,result[done])) next done +:= 1
    do if not present[i] then result #:= i; present[i] := true fi od
  od;
  for i in sort(result) do KGB(G,i) od


{. a minimal KGB element from an equivalence class defined by S 
(unlike x_max, it is not unique) .}
set x_min (KGPElt P) = KGBElt:
  equivalence_class_of(P)[0] { inefficent, but at least avoid soring twice }

{. the set of KGP elements associated to a RealForm and a set of 
simple roots S; KGP(G,S) is in bijection with $K\G/P_S$ .}
set KGP (RealForm G,[int] S) = [KGPElt]:
  for x in maxima_in_partial_order(G,S) do KGPElt:(S,x) od

{. just the index numbers (maximal x) of KGP(G,S) .}
set KGP_numbers (RealForm G,[int] S) =[int]: for (,x) in KGP(G,S) do #x od


{. test whether y in $K\G/P_S$ is open: <=> last element of y is last element 
of KGB .}
set is_open (KGPElt y) = bool: #maximal(y) = KGB_size(real_form(y))-1

{. test whether y in $K\G/P_S$ is closed: <=> length(first element)=0 .}
set is_closed (KGPElt P) = bool: length(x_min(P))=0

{. parabolic determined by (the stabilizer in W of) a weight lambda .}
set KGP_elt (ratvec lambda,KGBElt x) = KGPElt:
  let rd=root_datum(x)
  then (lambda_dom,w)=make_dominant(rd,lambda), P=[int]:[]
  in for a@i in simple_coroots(rd) do if a*lambda_dom=0 then P#:=i fi od;
  KGPElt:(P,cross(inverse(w),x))
