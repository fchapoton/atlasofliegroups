<basic.at

{ generalise adjustment functions from basic.at to handle non-space padding }
set l_adjust (int w, string s, string pad_char) = string:
  let d=w-#s in if <=d then s else s##(pad_char*d) fi
set r_adjust (int w, string s, string pad_char) = string:
  let d=w-#s in if <=d then s else (pad_char*d)##s fi
set c_adjust (int w, string s,string pad_char) = string:
  let d=w-#s in
  if d.<= then s { no room for padding, so don't try }
  else let h=d\2 in (pad_char*h) ## s ## (pad_char*(d-h))
  fi

{ pad string with copies of |pad_char| (for lining up columns in tables) }
set pad (string s,string alignment,int padding,string pad_char) = string:
  case char_index(alignment,"lr")
  in l_adjust(padding,s,pad_char), r_adjust(padding,s,pad_char)
  else c_adjust(padding,s,pad_char)
  esac

{ print string matrix (by rows) |data|, aligining each column to largest width
  plus |cell_padding|, while padding uniformly with |pad_char| (of size 1)
}
set tabulate ([[string]] data,
    string alignment, int cell_padding, string pad_char) = void:
  let max_per_column = for j:#data[0] do max(for d in data do #d[j] od) od in
  for d in data
  do
    for x@j in d
    do pad(x,alignment,max_per_column[j]+cell_padding,pad_char)
    od.##.prints
  od

set test=[
["A","bb","ttt","uuu"],
["AAAAAA","b","Z","xyzzzzzzzzz"],
["A","bbbbbbbbb","W","x"]]
