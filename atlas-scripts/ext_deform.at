<basic.at
<extended.at
<extended_misc.at { for |fixed_block| }
<polynomial.at

set survives (Param p) = bool: { whether no singular coroot is a descent }
( p.x=dominant(p).x { this fails when there is a complex singular descent }
  and not p.is_zero and p.is_final { test absence of other singluar descents }
)

set KL_block (Param p, mat delta) = { emulate built-in |KL_block| }
    ([Param],int,mat,[vec],vec,vec,mat):
  let (regular_extblock,,,) = extended_block(p,delta)
  , (KL_mat,polys,stops) = raw_ext_KL(p,delta)
  then survivors =
    ## for q@j in regular_extblock do if q.survives then [j] else [] fi od
  , length = from_stops(stops)
  in ( regular_extblock,  first(for q in regular_extblock do q=p od)
     , KL_mat, polys, stops
     , vec: survivors
     , for q@j in regular_extblock { run through columns }
       do let lq=length(j), Q = finalize_extended(q,delta) in
         for si in survivors
         do minus_1^(lq-length(si))*Q[regular_extblock[si]].s_to_minus_1
         od
       od
     )

{ use output of |KL_block| to prepare block, signed KL matrix, and stops }
set cook_KL_block([Param] B,int entry_elem
                  ,mat KL,[poly] polys,vec stops
                  ,vec surv, mat contrib) =
  ([Param],int,poly_mat,vec): { singular block, z0, signed P matrix, lengths }
  let nB=#B, n_surv=#surv
  then inter_mat = poly_mat: { survivor columns extracted, and transposed }
    for j in surv do for ind in KL[j] do
      if ind<0 then -polys[-ind] else polys[ind] fi { entries are |poly| now }
    od od
  , len = from_stops(stops) { compute length from index into |B| }
  then cooked_P_mat = poly_mat:
     for si@i in surv do let lsi=len(si) in for sj@j in surv do
       let sum=poly_0 in
       for Pkj@k in inter_mat[j] do sum:=flex_add(sum,contrib[i,k]*Pkj) od
     ; sum{ * minus_1^(len(sj)-lsi)}
     od od
  , get_index (int z) = int: binary_search_first((int i):surv[i]>=z,0,n_surv)
  in ( for i in surv do B[i] od { condensed block }
     , get_index(entry_elem) { convert index of seeding element }
     , cooked_P_mat
     , for s in stops do get_index(s) od { convert stops to condensed block }
     )

set ed_verbose=false
set ed_verbose2=false

set null_wt(int r) = ratvec: null(r)
set has_nu0 (Param p) = bool: =nu(p)

{ Compute the direct (P) extended Kazhdan-Lusztig-Vogan polynomials
  |B_fixed| should be the delta-fixed parameters in a block
  The result is a row-gathered matrix of (univariate) polynomials
}

set KL_P_polynomials_1 ([Param] B_fixed,mat delta) = [[poly]]:
  assert( all(for p in B_fixed do is_fixed(delta,p) od)
  	, "Not every parameter is delta-fixed" );
  let (P,polys,)=raw_ext_KL(B_fixed[0],delta) in
  for row@i in ^P
  do
    for entry@j in row
    do if >=entry then polys[entry] else -polys[-entry] fi
    od
  od

set KL_P_signed_polynomials_1 ([Param] B_fixed,mat delta) = [[poly]]:
  assert( all(for p in B_fixed do is_fixed(delta,p) od)
	, "Not every parameter is delta-fixed" );
  let (P,polys,jumps)=raw_ext_KL(B_fixed[0],delta)
  then length = from_stops(jumps)
  in
  for row@i in ^P
  do
    for entry@j in row
    do minus_1^(length(j)-length(i))
     * if >=entry then polys[entry] else -polys[-entry] fi
    od
  od

set KL_Q_polynomials ([Param] B_fixed, mat delta) = [[poly]]:
  upper_unitriangular_inverse (KL_P_signed_polynomials_1(B_fixed,delta))

set deform (Param p, mat delta) = ParamPol:
( assert(is_fixed(delta,p),"parameter is not delta-fixed");
  let (B_f,index) = fixed_block(delta,p) { hopefully the same block as KL_P }
  , l_index=length(p) { use built-in function |length| for Param |p| }
  then P_signed_polys=KL_P_signed_polynomials_1(B_f,delta)
  then Q_polys=upper_unitriangular_inverse(P_signed_polys)
  in
  if ed_verbose then prints("index=",index) fi;
  let outer_sum = null_module(real_form(p))
  + for p_i@i in B_f[:index] { traverse |B_f| up to the index of |p| }
    do
      if ed_verbose then prints("outer loop i=",i) fi;
      let l_i=length(p_i), P_signed_i=P_signed_polys[i]
      , onr=(-1)^rat_as_int((orientation_nr(p)-orientation_nr(p_i))/2)
      , inner_sum=0 in
      if ed_verbose then prints("onr=", onr)  fi;
      for p_j@j_minus_i in B_f[i:index]
      do
        let j=j_minus_i+i, l_j=length(p_j) in
        if ed_verbose
        then prints("  inner loop j=",j)
        ;    prints("  length_diff:", l_index-l_j)
        fi;
        if is_odd(l_index-l_j)
        then
          let P_ij= poly: P_signed_i[j]
          , Q_jindex= poly: Q_polys[j][index]
	  then term= eval(P_ij,-1) * eval(Q_jindex,-1)
          in
          if ed_verbose then prints("   inner term: ", term) fi
	; inner_sum+:=term
        ; if ed_verbose then prints(" inner_sum is now:", inner_sum) fi
        fi
      od
    ; let contrib = (Split,Param):
        (onr*inner_sum {coefficient}, B_f[i] {monomial})
      in
      if ed_verbose
      then prints("onr=",onr,new_line
		 ,"inner_sum=",inner_sum,new_line
		 ,"contribution with i=", i, ":", contrib)
      fi
    ; contrib
    od
    in (1-s)*outer_sum
)

set rec_def (Param p,mat delta) = (Param,ParamPol):
  if ed_verbose2 then prints("rec_def with:", p) fi;
  if is_zero(p) or not is_final(p) or not is_fixed(delta,p)
  then error("improper parameter")
  fi;
  let !empty=null_module(real_form(p))
  then rec_fun recd (Split coef,Param p) = (Param,ParamPol):
     { |coef| to be multiplied to deformation terms }
    begin
    if ed_verbose2 then prints("recd with:", p) fi;
    if has_nu0(p) then (p,empty) { but deformed |p| has |coef| implicitly }
    elif not is_standard(p) then prints(p,%p); error("halt")
    else
      let (x,lambda,gamma)=%p, rp=reducibility_points(p)
      then inx=#rp, at_nu0=empty, acc=empty
      in
      while inx>0
      do
        let p_def=param(x,lambda,gamma*rp[inx-:=1]) in
{	let ()=prints("working on p_def",p_def) in}
        let def=deform(p_def,delta) in
	if ed_verbose2
        then prints("adding deformation term: p=", p_def, new_line
	           , "adding:", def)
	fi;
	acc+:=def
      od
    ; for k@q in acc
      do
        let c=coef*k then (q0,nu0_terms) = recd(c,q)
	in at_nu0 +:= nu0_terms+(c,q0)
      od
    ; { return deformed p and accumulated deformation terms }
      (param(x,lambda,null_wt(#gamma)), at_nu0)
    fi
    end
  in recd(1,p)

{ alternative, use the new built-in |extended_KL_block| }
set deformation_terms (Param p, mat delta) = ParamPol:
  assert(is_fixed(delta,p),"parameter is not delta-fixed");
  let (B,P_mat,length) = extended_KL_block(p,delta) then nB=#B in
  if =nB or B~[0]!=p
  then null_module(p) { if |p| itself is not among survivors, return 0 }
  else { compute final column |acc| of |Q| matrix by solving linear system
         $P'*acc=e_p$ with $P'$ a matrix of Split, columns from |KL_sum_at_s| }
    let remainder = null(nB-1)#1 { start with standard basis vector for |p| }
    , solution=null(nB)
    , !opposite_parity=1-length~[0]%2 { opposite to that of |length(p)| }
    , !on_p = orientation_nr(p)
    in
    for q_ind : nB
    ~do let contrib=remainder[q_ind]*P_mat[q_ind] in
      remainder -:= contrib
    ; if length[q_ind]%2=opposite_parity
      then solution +:= contrib
{;      prints(new_line,"contrib=",contrib);
     prints("remainder=",remainder);
      prints("solution=",solution)}
      fi
    od
  ; null_module(p)+
    for c@i in solution
    do { twist (1-s)*solution according to orientation numbers of its terms }
      let x=B[i] then (q,r)=(on_p-orientation_nr(x))\%2 in
      assert(=r,"odd orientation");
      (minus_1^q*c*one_minus_s,x) { we have |s^q*c*(1-s) = (-1)^q*c(1-s)| }
      { for the same reason we replaced |s| by |-1| in computations giving |c| }
    od
  fi

set recursive_deform (Param p, mat delta) = ParamPol:
  assert(not is_zero(p) and is_final(p) and is_fixed(delta,p)
	,"improper parameter");
  let empty=null_module(real_form(p)) in
  if ed_verbose { choose verbose or non-verbose version of the function }
  then rec_fun full_def (Split sc,Param p) ParamPol:
       { |sc| will simply scale the resulting ParamPol, |delta| is implicit }
    begin
      prints("full_def with: sc=", sc, ", p=", p);
      assert(is_standard(p)
	    ,"non standard parameter encountered in deformation");
      let acc=empty
      , at_nu0=sc*finalize_extended(p*0,delta).s_to_minus_1 { fully deform |p| }
      in
      for factor in reducibility_points(p)
      ~do
	let p_def=p*factor { next deformation of |p| }
	then def=deformation_terms(p_def,delta)
	in
	prints("adding deformation term: p=", p_def, new_line,"adding:", def)
      ; acc+:=def
      od
    ; for k@q in acc { traverse the sum of the deformation terms spun off }
      do { apply |full_def| recursively to all those terms }
        at_nu0 +:= full_def(sc*k,q) { gather harvest from those deformations }
      od
    ; at_nu0
    end
  else rec_fun full_def (Split sc,Param p) ParamPol:
       { |sc| will simply scale the resulting ParamPol, |delta| is implicit }
    begin
      assert(is_standard(p),"non standard parameter in deformation");
      let acc=empty
      , at_nu0=sc*finalize_extended(p*0,delta).s_to_minus_1 { fully deform |p| }
      in
{      let ()=prints("acc=",acc) in}
      for factor in reducibility_points(p)
      ~ { direction of deformation is down, towards 0; this is not essential }
      do
{      let ()=prints("working on: ", p*factor) in}
      acc+:=deformation_terms(p*factor,delta) od
    ; for k@q in acc { traverse the sum of the deformation terms spun off }
      do at_nu0 +:= full_def(sc*k,q) od
    ; at_nu0
    end
  fi { apply that recursive function to the initial argument: } (1,p)

set full_deform = recursive_deform@(Param,mat)
{ used to be: (Param p,mat delta) ParamPol: let (a,P)=rec_def(p,delta) in a+P }

set c_form_std (Param p,mat delta) = ParamPol:
  let G=real_form(p) in
  if is_equal_rank(G) then full_deform(p) { buiit in }
  else full_deform(p,delta) { defined above }
  fi
