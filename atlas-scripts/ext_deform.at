<basic.at
<extended.at
<extended_misc.at { for |fixed_block| }
<polynomial.at
<dual.at { for |length_diff| }

set ed_verbose=false
set ed_verbose2=false

set null_wt(int r) = ratvec: null(r)
set has_nu0 (Param p) = bool: =nu(p)

{ Compute the direct (P) extended Kazhdan-Lusztig-Vogan polynomials
  |B_fixed| should be the delta-fixed parameters in a block
  The result is a row-gathered matrix of (univariate) polynomials
}
set KL_P_polynomials ([Param] B_fixed,mat delta) = [[poly]]:
  assert( all(for p in B_fixed do is_fixed(delta,p) od)
  	, "Not every parameter is delta-fixed" );
  let (P,polys,jumps)=raw_ext_KL(B_fixed[0],delta) in
  for row@i in ^P
  do
    for entry@j in row
    do (-1)^length_diff(i,j,jumps)
     * if >=entry then polys[entry] else -polys[-entry] fi
    od
  od

set KL_Q_polynomials ([Param] B_fixed, mat delta) = [[poly]]:
  upper_unitriangluar_inverse (KL_P_polynomials(B_fixed,delta))

set deform (Param p, mat delta) = ParamPol:
( assert(is_fixed(delta,p),"parameter is not delta-fixed");
  let (B_f,index) = fixed_block(delta,p) { hopefully the same block as KL_P }
  , l_index=length(p) { use built-in function |length| for Param |p| }
  then P_polys=KL_P_polynomials(B_f,delta)
  then Q_polys=upper_unitriangluar_inverse(P_polys)
  in
  if ed_verbose then prints("index=",index) fi;
  let outer_sum = null_module(real_form(p))
  + for p_i@i in B_f[:index] { traverse |B_f| up to the index of |p| }
    do
      if ed_verbose then prints("outer loop i=",i) fi;
      let l_i=length(p_i)
      , onr=(-1)^rat_as_int((orientation_nr(p)-orientation_nr(p_i))/2)
      , inner_sum=0
      in
      for p_j@j_minus_i in B_f[i:index]
      do
        let j=j_minus_i+i, l_j=length(p_j) in
        if ed_verbose
        then prints("  inner loop j=",j)
        ;    prints("  length_diff:", l_index-l_j)
        fi;
        if is_odd(l_index-l_j)
        then
          let P_ij=poly:P_polys[i][j]
          , Q_jindex=poly:Q_polys[j][index]
	  then term= eval(P_ij,-1) * eval(Q_jindex,-1)
          in
          if ed_verbose then prints("   inner term: ", term) fi
 	; inner_sum+:=term
        fi
      od
    ; let contrib = (Split,Param):
        (onr*inner_sum {coefficient}, B_f[i] {monomial})
      in
      if ed_verbose then prints("contribution with i=", i, ":", contrib) fi
    ; contrib
    od
    in (1-s)*outer_sum
)

set rec_def (Param p,mat delta) = (Param,ParamPol):
  if ed_verbose2 then prints("rec_def with:", p) fi;
  if is_zero(p) or not is_final(p) or not is_fixed(delta,p) then error("improper parameter")
  else
    let empty=null_module(real_form(p))
    then recd = (Split c,Param p ) (Param,ParamPol): (p,empty) { dummy }
    in
    ( recd := { now create a recursive function be reassigning to |recd| }
      begin (Split coef,Param p): { coef to be multiplied to deformation terms }
        if ed_verbose2 then prints("recd with:", p) fi;
	if has_nu0(p) then (p,empty) { but deformed |p| has |coef| implicitly }
	elif not is_standard(p) then prints(p,%p); error("halt")
	else
	  let (x,lambda,gamma)=%p, rp=reducibility_points(p)
	  then inx=#rp, at_nu0=empty, acc=empty
	  in while inx>0 do
            let p_def=param(x,lambda,gamma*rp[inx-:=1]) in
            let def=deform(p_def,delta) in
	    if ed_verbose2 then prints("adding deformation term: p=", p_def, new_line, "adding:", def) fi;
	     acc+:=def od
	  ; for k@q in acc
	    do
	      let c=coef*k then (q0,nu0_terms) = recd(c,q)
	      in at_nu0 +:= nu0_terms+(c,q0)
	    od
	  ; { return deformed p and accumulated deformation terms }
	  (param(x,lambda,null_wt(#gamma)), at_nu0)
	fi
      end
    ) { value in parentheses is recursive |recd|; apply it: }
  (1,p)
  fi

set full_deform (Param p,mat delta) = ParamPol:let (a,P)=rec_def(p,delta) in a+P

set c_form_std (Param p,mat delta) = ParamPol:
let G=real_form(p) in if is_equal_rank(G) then full_deform(p) else full_deform(p,delta) fi
