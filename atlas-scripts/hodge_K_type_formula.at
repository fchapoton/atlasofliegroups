<K_type_formula.at
<hodge_normalize.at
<bigMatrices.at {for is_non_negative@i_poly_mat}
{move to polynomial.at}
set lower_unitriangular_inverse(i_poly_mat M)=transpose(upper_unitriangular_inverse(transpose(M)))

set hodgePrintPolyMatrix(i_poly_mat M,int space_size)= void:
  let space= " "*space_size, wd = max(for v in ##M do #poly_format(v,"v") od)
  in
    for row in M
    do prints(##for v in row do space+l_adjust(wd,poly_format(v,"v")) od)
    od
set hodgePrintPolyMatrix (i_poly_mat M) = void: hodgePrintPolyMatrix(M,3)


set hodge_K_type_formula_verbose=true
{
set mu (Param p) = rat:
  (p.x.torus_factor+p.real_form.rho_check) * lambda_plus_rho_res_T(p.x,p.lambda)
}

set mu_0(KGBElt x,vec v)=rat:
 (x.torus_factor+x.real_form.rho_check) * (1+x.involution)*v/2

set mu(KGBElt x,vec v)=int:
 rat_as_int((x.torus_factor+x.real_form.rho_check) * (1+x.involution)*v/2)

set get_m(KGBElt x_L,Param q, vec v,RealForm G)=
 let q_G_0=theta_induce_standard_warning(parameter(x_L,q.lambda,null(q.root_datum.rank)),G,false) in
{ q_G=first_param(finalize(theta_induce_standard_warning(parameter(x_L,q.lambda+v,null(q.root_datum.rank)),G,false)))  in }
{ mu(q_G)-}mu(q_G_0)

{hodge version of K_type_formula
 only using s_alpha s_beta
this does handle non-normal parameters
however it does not correctly handle non-standard parameters
where hodge HS identities are needed
this should give the same result as hodgeKtypeform in Fokko
first returned argument is for debugging
}
set hodge_K_type_formula_long(K_Type mu)=([Param],hodgeParamPol):
let G=mu.real_form then
(P,mu_L)=tau_q(mu) then
L=Levi(P) then
 ()=assert(dimension(mu_L)=1,"mu_L is not one-dimensional");
 assert(let ind=theta_induce_standard(mu_L*0,G) in
 #ind=1 and first_param(ind)=parameter(mu),"mu_L does not induce to mu") then
 ()=assert(theta_induce_standard(mu_L,G)*0=theta_induce_standard(mu_L*0,G), "mismatch") then
rv=hodgeParamPol:[] then
warnings=[Param]:[] then
cf=character_formula_one_dimensional(mu_L)   {mu_L is 1-dimensional} then
cf_0=rearrange(hodge_recursive_deform(cf)) in  {[(vec,Param)]}
 if hodge_K_type_formula_verbose then
  prints("cf=",cf);
  prints("cf deformed=",cf_0)  
 fi;
for (c,q) in cf_0 do
let x_L=q.x then
x_G=embed_KGB(x_L,G) then
q_G_0=theta_induce_standard_warning(parameter(x_L,q.lambda,null(q.root_datum.rank)),G,hodge_K_type_formula_verbose) in
 if hodge_K_type_formula_verbose then
  prints("q_G_0=",q_G_0);
  prints("====================",new_line,"doing q=",q," ",new_line, "Levi=",L)
 fi;
let shifts=u_cap_s_rho_shifts_and_cardinalities(P,x_G) in
 if hodge_K_type_formula_verbose then
  prints("#shifts:", #shifts,new_line);for (v,k) in shifts do prints(v, " ", k) od
 fi;
 for (v,k) in shifts do
  let  (new,coeff)=
  {only add shift v to lambda, not nu, all nu's are 0}
  let q_G=assert(=nu(q),"nu(q)\ne 0");
  theta_induce_standard_warning(parameter(x_L,q.lambda+v,null(q.root_datum.rank)),G,hodge_K_type_formula_verbose) then
   m_0=mu(q_G)-mu(q_G_0) then
   m=floor(m_0) {should be an integer?} in
{   m_0=mu(first_param(hodge_normalize(q_G)[0]))-mu(q_G) then}
   if hodge_K_type_formula_verbose then
    prints("----------------",new_line,"q_G:",q_G, " [",height(q_G),"]");
    prints("k=: ", k);
    prints("m_0=: ", m_0);
    prints("m=: ", m);
    if not is_integer(m-m_0) then prints("Warning: m-m_0=", m-m_0, "  is not an integer") fi;
    prints("mu(q_G_0)=", mu(q_G_0));
    prints("mu(q_G)=", mu(q_G))
   fi;
  {cases: is_zero(q_G); !is_normal(q_G); !is_standard(q_G); !is_final(q_G)}
  {CASES}
  if is_zero(q_G) then (nullHodgeParamPol(G),poly_1)
  else
   let hrd=hodge_recursive_deform(hodge_normalize(q_G)) in
   if hodge_K_type_formula_verbose then
    prints("q_G=",q_G,new_line, "shift:", v);
    prints("hrd=", hrd, new_line, "k=", k)
   fi;
{  (hrd,let m=rat_as_int(mu(first_param(hrd[0]))-mu(q_G_0)) in prints("now m=",m);poly_product(c,(-1)^k*vee^m)) }
  (hrd,poly_product(c,(-1)^k*vee^m))
  fi in
  {/CASES}
     if hodge_K_type_formula_verbose then
       prints("added:");print(coeff*new);prints()
     fi;
  rv+:=coeff*new
 od {for (v,k)}
od; {for (c,q)}
(warnings,rv)

set hodge_K_type_formula(K_Type mu)=hodgeParamPol:let (,f)=hodge_K_type_formula_long(mu) in f

set fill_out([K_Type] ktypes, int N)=[K_Type]:
let new_ktypes=ktypes in
for mu in ktypes do
 for tau in monomials(branch(parameter(mu),N)) do
  if find(new_ktypes,LKT(tau))=-1 then new_ktypes#:=LKT(tau) fi
 od
od;new_ktypes

set fill_out_recursively([K_Type] ktypes, int N)=
let rec_fun f([K_Type] ktypes_in)=[K_Type]: 
 let new=fill_out(ktypes_in,N) in 
 if #new=#ktypes_in then sort_by_height(new) else f(new) fi in  f(ktypes)

{matrix with rows/columns indexed by [K_Type]:ktypes,  long output}
set hodge_K_type_mat_long(K_Type mu, int N,[K_Type] ktypes)=(int,[K_Type],[Param],i_poly_mat,i_poly_mat):
let warnings=[Param]:[] then
M=zero_poly_matrix(#ktypes) in
for tau in ktypes do
 let index=find(ktypes,tau) then
 row=zero_poly_row(#ktypes) then
 (new_warnings,hktf)=hodge_K_type_formula_long(tau) then
 rf=rearrange(hktf) in
 for (g,kappa) in rf do
  let j=find(ktypes,LKT(kappa)) in
   if j!=-1 then row[j]:=g fi
 od;
 M[index]:=row;
 warnings##:=new_warnings
od;
let tM=transpose(M) in  {tM is lower triangular}
(find(ktypes,mu),ktypes,warnings,tM, lower_unitriangular_inverse(tM))

{default: use fill_out_recursively to generate ktypes}
set hodge_K_type_mat_long(K_Type mu, int N)=(int,[K_Type],[Param],i_poly_mat,i_poly_mat):
hodge_K_type_mat_long(mu,N,fill_out_recursively([mu],N))

{short versions, only return i_poly_mats}
set hodge_K_type_mat(K_Type mu, int N,[K_Type] ktypes)=(i_poly_mat,i_poly_mat):let(,,,A,B)=hodge_K_type_mat_long(mu,N,ktypes)
in (A,B)

set hodge_K_type_mat(K_Type mu, int N)=(i_poly_mat,i_poly_mat):hodge_K_type_mat(mu,N,fill_out_recursively([mu],N))

set test_hodge_K_type_mat(K_Type mu,int N)=(i_poly_mat,[bool],bool):
let (A,B)=hodge_K_type_mat(mu,N) in let
results=for i:#B do is_non_negative(transpose(B)[i]) od in (B,results,all(results))

set test_hodge_K_type_mat([K_Type] mus,int N)=([([[vec]],bool)],bool):
let pairs=for mu@i in mus do let (N,,r)=test_hodge_K_type_mat(mu,N) in (N,r) od in
(pairs, all( for (,r) in pairs do r od))

{graded version of branching_formula
 in the 1 Cartan case should give same result as branch_hodge (last argument returned)
 hope to modify it to work for all G
}
{hodge branching formula for standard module with nu=0}
set hodge_branch_std(K_Type mu, int N)=hodgeParamPol:
let (index,ktypes,,A,B)=hodge_K_type_mat_long(mu,N) then
vector=transpose(B)[index] then
temp=[(vec,Param)]:[] in
 for i:#vector do if vector[i]!=null(0) then
 temp#:=(vector[i],parameter(ktypes[i])) fi od;
dearrange(temp)

{hodge branching formula for standard module with nu=0}
set hodge_branch_std_temp(Param p, int N)=hodgeParamPol:
hodge_branch_std(LKT(p),N)

{hodge branching formula for ParamPol of modules with nu=0}
set hodge_branch_std_temp(ParamPol P, int N)=hodgeParamPol:
let rv=nullHodgeParamPol(P.real_form) in
 for c@p in P do rv+:=c*hodge_branch_std_temp(p,N) od;rv

{hodge branching formula for hodgeParamPol of modules with nu=0}
set hodge_branch_std_temp(hodgeParamPol P, int N)=hodgeParamPol:
let Q=rearrange(P) then
rv=nullHodgeParamPol(P.real_form) in
 for (c,p) in Q do rv+:=c*hodge_branch_std_temp(p,N) od;
rv

{hodge branching formula for arbitrary standard module p
 algorithm: hodge_branch_std_temp of the hodge_recursive deform
 of p
}
set hodge_branch_std(Param p, int N)=hodgeParamPol:
hodge_branch_std_temp(hodge_recursive_deform(p),N)

{hodge branching formula for arbitrary ParamPol of 
standard modules}
set hodge_branch_std(ParamPol P, int N)=hodgeParamPol:
hodge_branch_std_temp(hodge_recursive_deform(P),N)


{hodge branching formula for arbitrary irreducible}
{need: hodge_character_formula(Param p)}
{set hodge_branch_irr(Param p,int N)=hodgeParamPol:}

set column([K_Type] ktypes,i_poly_mat M,int i)=
let col=transpose(M)[i] in 
dearrange(for j:#col do (col[j],ktypes[j]) od )

