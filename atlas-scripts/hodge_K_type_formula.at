<K_type_formula.at
<hodge_normalize.at
<bigMatrices.at {for is_non_negative@i_poly_mat}
{move to polynomial.at}
set lower_unitriangular_inverse(i_poly_mat M)=transpose(upper_unitriangular_inverse(transpose(M)))

set hodge_K_type_formula_verbose=false

{hodge version of K_type_formula
 only using s_alpha s_beta
this does handle non-normal parameters
however it does not correctly handle non-standard parameters
where hodge HS identities are needed
this should give the same result as qKtypeform in Fokko
first returned argument is for debugging
}
set hodge_K_type_formula_long(K_Type mu)=([Param],qParamPol):
let (P,mu_L)=tau_q(mu) then
 ()=assert(dimension(mu_L)=1,"mu_L is not one-dimensional");
 assert(let ind=theta_induce_standard(mu_L*0,mu.real_form) in
 #ind=1 and first_param(ind)=parameter(mu),"mu_L does not induce to mu") then
 ()=assert(theta_induce_standard(mu_L,mu.real_form)*0=theta_induce_standard(mu_L*0,mu.real_form), "mismatch") then
rv=qParamPol:[] then
warnings=[Param]:[] then
{for testing:
cf=character_formula(mu_L) in  {mu_L is 1-dimensional}
}
cf=character_formula_one_dimensional(mu_L) in  {mu_L is 1-dimensional}
if hodge_K_type_formula_verbose then
prints("cf=",cf)
fi;
for c@q in cf do
if hodge_K_type_formula_verbose then
prints("doing q=",q," ",new_line, "Levi=",q.real_form)
fi;
 let shifts=u_cap_s_rho_shifts_and_cardinalities(P,embed_KGB(x(q),mu.real_form)) in
if hodge_K_type_formula_verbose then
prints("#shifts:", #shifts,new_line);for (v,k) in shifts do prints(v, " ", k) od
fi;
 for (v,k) in shifts do
  let coeff=vec:split_as_int(c)*(-1)^k*vee^(codim(x(q))+k) in
   if hodge_K_type_formula_verbose then
    prints(new_line,"=============================================",new_line,"applying shift: ", v, " ", k);
    prints("codim: ", codim(x(q)));
    prints("coeff: ", coeff)
   fi;
   let  new=
    let q_G=theta_induce_standard_warning(parameter(x(q),lambda(q)+v,nu(q)),P.real_form,hodge_K_type_formula_verbose) in
      if hodge_K_type_formula_verbose then
       prints("q_G:",q_G, " [",height(q_G),"]")
      fi;
     if is_zero(q_G) then nullqParamPol(mu.real_form)
     elif let (normal,)=is_normal(q_G) in not normal then
       warnings#:=q_G;
       if hodge_K_type_formula_verbose=true then
       prints("normalizing: ", q_G) fi;
       hodge_normalize(q_G)
     elif not is_standard(q_G) then [q_G] {need to implement handling this case also}
     else [q_G] fi in
     if hodge_K_type_formula_verbose then
       prints("added:");print(coeff*new)
     fi;
  rv+:=coeff*new
 od
od;(warnings,rv)

set hodge_K_type_formula(K_Type mu)=qParamPol:let (,f)=hodge_K_type_formula_long(mu) in f

set fill_out([K_Type] ktypes, int N)=[K_Type]:
let new_ktypes=ktypes in
for mu in ktypes do
 for tau in monomials(branch(parameter(mu),N)) do
  if find(new_ktypes,LKT(tau))=-1 then new_ktypes#:=LKT(tau) fi
 od
od;new_ktypes

set fill_out_recursively([K_Type] ktypes, int N)=
let rec_fun f([K_Type] ktypes_in)=[K_Type]: 
 let new=fill_out(ktypes_in,N) in 
 if #new=#ktypes_in then new else f(new) fi in f(ktypes)

set hodge_K_type_mat_long(K_Type mu, int N)=
let ktypes=fill_out_recursively([mu],N) then
{pairs=for mu in ktypes do (mu,hodge_K_type_formula(mu)) od  then}
warnings=[Param]:[] then
M=zero_poly_matrix(#ktypes) in
for tau in ktypes do
 let index=find(ktypes,tau) then
 row=zero_poly_row(#ktypes) then
 (new_warnings,hktf)=hodge_K_type_formula_long(tau) then
 rf=rearrange(hktf) in
 for (g,kappa) in rf do
  let j=find(ktypes,LKT(kappa)) in
   if j!=-1 then row[j]:=g fi
 od;
 M[index]:=row;
 warnings##:=new_warnings
od;
let tM=transpose(M) in  {tM is lower triangular}
(find(ktypes,mu),ktypes,warnings,tM, lower_unitriangular_inverse(tM))

set hodge_K_type_mat(K_Type mu, int N)=(i_poly_mat,i_poly_mat):let(,,,A,B)=hodge_K_type_mat_long(mu,N)
in (A,B)


set test_hodge_K_type_mat(K_Type mu,int N)=(i_poly_mat,[bool],bool):
let (A,B)=hodge_K_type_mat(mu,N) in let
results=for i:#B do is_non_negative(transpose(B)[i]) od in (B,results,all(results))

set test_hodge_K_type_mat([K_Type] mus,int N)=([([[vec]],bool)],bool):
let pairs=for mu@i in mus do let (N,,r)=test_hodge_K_type_mat(mu,N) in (N,r) od in
(pairs, all( for (,r) in pairs do r od))

{graded version of branching_formula
 in the 1 Cartan case should give same result as branch_q (last argument returned)
 hope to modify it to work for all G
}

set hodge_branching_formula(K_Type mu, int N)=[ParamPol]:
let (index,ktypes,,A,B)=hodge_K_type_mat_long(mu,N) then
vector=transpose(B)[index] then
temp=[(vec,Param)]:[] in
 for i:#vector do if vector[i]!=null(0) then  temp#:=(vector[i],parameter(ktypes[i])) fi od;
dearrange(temp)

set hodge_branching_formula(Param p, int N)=
assert(=p.nu,"nu!=0");hodge_branching_formula(LKT(p),N)

