<K_type_formula.at
<hodge_normalize.at

set hodge_K_type_formula_verbose=true

{hodge version of K_type_formula
this does handle non-normal parameters
however it does not correctly handle non-standard parameters 
where hodge HS identities are needed
this should give the same result as qKtypeform in Fokko
first returned argument is for debugging
}
set hodge_K_type_formula(K_Type mu)=([Param],qParamPol):
let (P,mu_L)=tau_q(mu) then
 ()=assert(dimension(mu_L)=1,"mu_L is not one-dimensional");
 assert(let ind=theta_induce_standard(mu_L*0,mu.real_form) in
 #ind=1 and first_param(ind)=parameter(mu),"mu_L does not induce to mu") then
 ()=assert(theta_induce_standard(mu_L,mu.real_form)*0=theta_induce_standard(mu_L*0,mu.real_form), "mismatch") then
rv=qParamPol:[] then
warnings=[Param]:[] then
cf=character_formula(mu_L) in  {mu_L is 1-dimensional, not mu_L*0 here}
{let ()=prints("cf=",cf) in}
for c@q in cf do
{ let ()=prints("doing q=",q," ", q.real_form) in}
 let shifts=u_cap_s_rho_shifts_and_cardinalities(P,embed_KGB(x(q),mu.real_form)) in
 for (v,k) in shifts do
  let coeff=vec:split_as_int(c)*(-1)^k*vee^(codim(x(q))+k) in
{   let ()=prints(new_line,"doing shift: ", v, " ", k) in
   let ()=prints("codim: ", codim(x(q))) in
   let ()=prints("coeff: ", coeff) in}
   let  new=
    let q_G=theta_induce_standard_warning(parameter(x(q),lambda(q)+v,nu(q)),P.real_form,hodge_K_type_formula_verbose) in
{           let ()=prints("q_G:",q_G) in}
     if is_zero(q_G) then nullqParamPol(mu.real_form) 
     elif let (normal,)=is_normal(q_G) in not normal then  
       warnings#:=q_G;
       hodge_normalize(q_G) 
     elif not is_standard(q_G) then [q_G] {need to implement handling this case also} 
     else [q_G] fi in
{let     ()=prints("new:",new, "coeff:", coeff) in}
  rv+:=coeff*new
 od
od;(warnings,rv)

set hodge_K_type_mat(K_Type mu, int N,ratvec v)=
let ktypes=sort_by_height(K_parameters_norm_upto(mu.real_form,N,v)) then
{pairs=for mu in ktypes do (mu,hodge_K_type_formula(mu)) od  then}
warnings=[Param]:[] then
M=zero_poly_matrix(#ktypes) in
for tau in ktypes do
 let index=find(ktypes,tau) then
 row=zero_poly_row(#ktypes) then
 (new_warnings,hktf)=hodge_K_type_formula(tau) then
 rf=rearrange(hktf) in
 for (g,kappa) in rf do
  let j=find(ktypes,LKT(kappa)) in
   if j!=-1 then row[j]:=g fi
 od;
 M[index]:=row;
 warnings##:=new_warnings
od;(find(ktypes,mu),ktypes,warnings,transpose(M))  {transpose(M) is lower triangular}

{move to polynomial.at}
set lower_unitriangular_inverse(i_poly_mat M)=transpose(upper_unitriangular_inverse(transpose(M)))

set test_hodge_K_type_mat(K_Type mu,int bound,ratvec v)=(i_poly_mat,[bool],bool):
let (index,ktypes,params,M)=hodge_K_type_mat(mu,bound,v) then 
N=lower_unitriangular_inverse(M) then 
results=for i:#N do is_non_negative(transpose(N)[i]) od in (N,results,all(results))

set test_hodge_K_type_mat(K_Type mu,int bound)=(i_poly_mat,[bool],bool):
test_hodge_K_type_mat(mu,bound,mu.root_datum.rho_check)

set test_hodge_K_type_mat([K_Type] mus,int bound,ratvec v)=([([[vec]],bool)],bool):
let pairs=for mu@i in mus do let (N,,r)=test_hodge_K_type_mat(mu,bound,v) in (N,r) od in
(pairs, all( for (,r) in pairs do r od))

set test_hodge_K_type_mat([K_Type] mus,int bound)=([([[vec]],bool)],bool):
test_hodge_K_type_mat(mus,bound,mus[0].root_datum.rho_check)






{graded version of branching_formula
 in the 1 Cartan case should give same result as branch_q (last argument returned)
 hope to modify it to work for all G
}
set hodge_branching_formula(K_Type mu, int N, ratvec v)=(int,[K_Type],[[vec]],[vec],[Param],[ParamPol]):
let (index,ktypes,warnings,M)=hodge_K_type_mat(mu,N,v) then
B=lower_unitriangular_inverse(M) then
vector=transpose(B)[index] then
temp=[(vec,Param)]:[] in
 for i:#vector do if vector[i]!=null(0) then  temp#:=(vector[i],parameter(ktypes[i])) fi od;
(index,ktypes,B,vector,warnings,dearrange(temp))

set hodge_branching_formula(K_Type mu,int N)=(int,[K_Type],[[vec]],[vec],[Param],[ParamPol]):
hodge_branching_formula(mu,N,mu.real_form.rho_check)

set hodge_branching_formula(Param p, int N, ratvec v)=(int,[K_Type],[[vec]],[vec],[Param],[ParamPol]):
assert(=p.nu,"nu!=0");hodge_branching_formula(LKT(p),N,v)

set hodge_branching_formula(Param p, int N)=(int,[K_Type],[[vec]],[vec],[Param],[ParamPol]):
assert(=p.nu,"nu!=0");hodge_branching_formula(LKT(p),N)
