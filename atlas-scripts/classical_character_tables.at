<basic.at
<combinatorics.at { for partitions@int }
<character_tables.at
<character_table_F.at
<character_table_G.at

{				type A				}

{ get an actual WeylElt from a partition <-> conjugacy class in W}
set conjugacy_class_S(Partition P) = WeylElt:  {for GL(n)}
(  assert(is_positive(P), "P is not a partition (has non-positive entries)")
;  let (n, , simples) = Levi_A(P)
in W_elt(if =n then trivial_group else GL(n) fi,simples)
)

{ for other type A root data like SL(n), we need to work a bit harder }
set conjugacy_class_A(RootDatum rd) = (Partition->WeylElt):
   let map = test_simple_type("A",rd) in
   (Partition P) WeylElt:
(  assert(is_positive(P), "P is not a partition (has non-positive entries)")
;  let (n, , simples) = Levi_A(P)
in assert(n=#map+1,"Partition is of "+ n +" rather than "+(#map+1))
;  W_elt(rd,for s in simples do map[s] od)
)

{ The inverse operation, find cycle type of a WeylElt for GL(n). This could be
  done using |classic_permutation| and |cycle_type| from combinatorics.at, but
  knowing that we have a GL(n) element, we can be a bit more efficient.
}
set cycle_type_GL (WeylElt w) = Partition:
  let n=w.root_datum.rank in cycle_type((vec:#n)*w)

{ sometimes we can avoid sorting the cycles into decreasing length order }
set unsorted_cycle_type_GL (WeylElt w) = [int]:
  let n=w.root_datum.rank in
  for cycle in permutation_cycles((vec:#n)*w) do #cycle od

set class_table_S (int n) = WeylClassTable:
  let rd=GL(n), reps = [Partition]: partitions(n)
  then lookup = (Partition->int): index_partition(reps)
  in W_class_table(rd, for rep in reps do conjugacy_class_S(rep) od
		  , (int i)int: cycle_class_size(reps[i])
		  , (WeylElt w) int: lookup(cycle_type_GL(w))
		  , (int i,int k)int: lookup(cycle_power(reps[i],k))
		  )

set class_table_A (RootDatum rd) = WeylClassTable:
  let partitions = [Partition]: partitions(rd.semisimple_rank+1)
  , type(WeylElt w) = Partition: cycle_type(classic_permutation(w))
  , class_rep = (Partition->WeylElt): conjugacy_class_A(rd)
  then lookup = (Partition->int): index_partition(partitions)
  in W_class_table( rd, for lambda in partitions do class_rep(lambda) od
		  , (int i)int: cycle_class_size(partitions[i])
		  , (WeylElt w) int: lookup(type(w))
		  , (int i,int k)int: lookup(cycle_power(partitions[i],k))
		  )

set character_table_S (int n) =
     (CharacterTable,(Partition->int),(Partition->int)):
  let partitions_n = partitions(n)
  then classes = [WeylElt,classical_class,string]:
    for lambda in partitions_n
    do (conjugacy_class_S(lambda),lambda.class_A,lambda.cycles_string)
    od
  , irreps = [classical_irrep,string,[int]]:
    for lambda in partitions_n ~ { reversal to go from trivial to sign }
    do (irrep_A(lambda),lambda.irrep_string
       ,for cyc_type in partitions_n do Murnaghan_Nakayama(lambda,cyc_type) od
       )
    od
  , lookup_partition = (Partition->int): index_partition(partitions_n)
  , top = #partitions_n-1
in ( character_table(class_table_S(n),classes,irreps)
   , lookup_partition { find index among conjugacy classes }
   , (Partition lambda) int: { index among irreps }
        top - lookup_partition(lambda)
   )

set character_table_A (RootDatum rd) =
      (CharacterTable,(Partition->int),(Partition->int)):
  let partitions = [Partition]: partitions(rd.semisimple_rank+1)
  , class_rep = (Partition->WeylElt): conjugacy_class_A(rd)
  then classes = [WeylElt,classical_class,string]:
    for lambda in partitions
    do (class_rep(lambda),lambda.class_A,lambda.to_string)
    od
  , irreps = [classical_irrep,string,[int]]:
    for lambda in partitions ~ { reversal to go from trivial to sign }
    do (irrep_A(lambda),lambda.to_string
       ,for cyc_type in partitions do Murnaghan_Nakayama(lambda,cyc_type) od
       )
    od
  , lookup_partition = (Partition->int): index_partition(partitions)
  , top = #partitions-1
in ( character_table(class_table_A(rd),classes,irreps)
   , lookup_partition { find index among conjugacy classes }
   , (Partition lambda) int: { index among irreps }
        top - lookup_partition(lambda)
   )

{				types B,C				}

set BC_classes (int n) = [Signed_cycles]:
   for PQ in partition_pairs(n) do to_cycles(PQ) od

{ word representative in types B and C of conjugacy class for partition pair;
  the parts of P correspond to are cycles without flip, those of Q with flip }
set class_word_BC (Partition P,Partition Q) = [int]:
(  assert((P:=P.strip_to_partition).>, "P is not a partition")
;  assert((Q:=Q.strip_to_partition).>, "Q is not a partition")
;  let (nP,,P_gens)=Levi_A(P) { for P part, do the same as in type A }
   , (nQ,,simples)=Levi_A(Q) { for Q part we need to post-process |simples| }
then
   Q_gens = { each cycle from Q gets a sign flip when its end is sensed }
      let j=0 { position in simples } in
      for i:nQ
      do let pos=nP+i { position in [0,n) where we are }
      in if j<#simples and i=simples[j] then j+:=1; [pos] { extend our cycle }
         else { tack on a sign flip at the final element of the cycle }
	    for k:nQ-i from pos do k od## for k:nQ-1-i from pos ~do k od
	 fi
      od.##
in P_gens##Q_gens
)


{ for general type B root data, we need to look up and use the diagram order }
set conjugacy_class_B (RootDatum rd) = (BiPartition->WeylElt):
   let map = test_simple_type("B",rd) then n=#map in
   (BiPartition pair) WeylElt:
(  let size = rank(pair)
in assert(size=n,"Cycles sum to "+size+" rather than "+n)
;  W_elt(rd,for s in class_word_BC(pair) do map[s] od)
)

set class_table_B (int n) = WeylClassTable:
   let rd=SO(n+n+1), classes = [BiPartition]: partition_pairs(n)
   then lookup = (BiPartition->int): index_bipartition(classes)
in W_class_table( rd, for pair in classes do W_elt(rd,class_word_BC(pair)) od
		, (int i)int: cycle_class_size(classes[i].to_cycles)
		, (WeylElt w) int: lookup(cycle_code(w).as_bipartition)
		, (int i,int k)int:
		    cycle_power(classes[i].to_cycles,k).to_partition_pair.lookup
		)

set class_table_B (RootDatum rd) = WeylClassTable:
   let classes = [BiPartition]: partition_pairs(rd.semisimple_rank)
   , type_code(WeylElt w) = [int]: signed_cycle_type_code(classic_permutation(w))
   , class_rep = (BiPartition->WeylElt): conjugacy_class_B(rd)
   then lookup = (BiPartition->int): index_bipartition(classes)
in W_class_table( rd, for pair in classes do class_rep(pair) od
		, (int i)int: cycle_class_size(classes[i].to_cycles)
		, (WeylElt w) int: lookup(type_code(w).as_bipartition)
		, (int i,int k)int:
		    cycle_power(classes[i].to_cycles,k).to_partition_pair.lookup
		)

set BC_irreps (int n) = [BiPartition]:
   pairs_of_total_sum(n,(int k):partitions(k)~[:]) { list [k],..,ones(k) }

{ for looking up a |BiPartition| among |BC_irreps|, use an adapted comparison: }
set index_BC_irrep = ([BiPartition] -> (BiPartition->int)):
   let leq (BiPartition (P,Q), BiPartition (R,S)) = bool:
      case P.sum-R.sum
      then false else true { size balance is decisive, inverted ordering! }
      in { equal size case: reverse compare left or (if same) right partitions }
	 if P=R else (R,P) then (S,Q) fi.leq_equal_sum_partitions
      esac
in ([BiPartition] list) (BiPartition->int): { assume |list| is sorted by |leq| }
      (BiPartition PQ) int:
	 binary_search_first( (int i)bool: leq(PQ,list[i]), 0, #list)

set character_table_B (int n) =
      (CharacterTable,(BiPartition->int),(BiPartition->int)):
   let class_list =  partition_pairs(n), irrep_list = BC_irreps(n)
   , rd=SO(n+n+1)
   then cycles = for pair in class_list do pair.to_cycles od
   , class_rep(int i) = WeylElt: W_elt(rd,class_word_BC(class_list[i]))
   then classes = [WeylElt,classical_class,string]:
      for c@i in cycles do ( class_rep(i), c.class_BC, c.cycles_string) od
   ,  irreps = [classical_irrep,string,[int]]:
      for rep in irrep_list
      do ( rep.irrep_BC, rep.irrep_string
         , for c in cycles do hyperoctahedral_character(rep,c) od
	 )
      od
   , lookup_class = (BiPartition->int): index_bipartition(class_list)
   , lookup_irrep = (BiPartition->int): index_BC_irrep(irrep_list)
in ( character_table(class_table_B(n),classes,irreps)
   , lookup_class { find index among conjugacy classes }
   , lookup_irrep
   )

set character_table_B (RootDatum rd) =
      (CharacterTable,(BiPartition->int),(BiPartition->int)):
   let n=rd.semisimple_rank
   then class_list =  partition_pairs(n), irrep_list = BC_irreps(n)
   , class_rep = conjugacy_class_B(rd)
   then cycles = for pair in class_list do pair.to_cycles od
   , class_rep(int i) = WeylElt: class_rep(class_list[i])
   then classes = [WeylElt,classical_class,string]:
      for c@i in cycles do ( class_rep(i), c.class_BC, c.cycles_string) od
   ,  irreps = [classical_irrep,string,[int]]:
      for rep in irrep_list
      do ( rep.irrep_BC, rep.irrep_string
         , for c in cycles do hyperoctahedral_character(rep,c) od
	 )
      od
   , lookup_class = (BiPartition->int): index_bipartition(class_list)
   , lookup_irrep = (BiPartition->int): index_BC_irrep(irrep_list)
in ( character_table(class_table_B(n),classes,irreps)
   , lookup_class { find index among conjugacy classes }
   , lookup_irrep
   )


{ for general type C root data, we need to look up and use the diagram order }
set conjugacy_class_C (RootDatum rd) = (BiPartition->WeylElt):
   let map = test_simple_type("C",rd) then n=#map in
   (BiPartition pair) WeylElt:
(  let size = rank(pair)
in assert(size=n,"Partition sizes sum to "+size+" rather than "+n)
;  W_elt(rd,for s in class_word_BC(pair) do map[s] od)
)

{ in class table construction we perfer |BiPartition| over |Signed_cycles| }
set class_table_C (int n) = WeylClassTable:
   let rd=Sp(n+n), classes = [BiPartition]: partition_pairs(n)
   then lookup = (BiPartition->int): index_bipartition(classes)
in W_class_table( rd, for pair in classes do W_elt(rd,class_word_BC(pair)) od
		, (int i)int: cycle_class_size(classes[i].to_cycles)
		, (WeylElt w) int: lookup(cycle_code(w).as_bipartition)
		, (int i,int k)int:
		    cycle_power(classes[i].to_cycles,k).to_partition_pair.lookup
		)

set class_table_C (RootDatum rd) = WeylClassTable:
   let classes = [BiPartition]: partition_pairs(rd.semisimple_rank)
   , type_code(WeylElt w) = vec: signed_cycle_type_code(classic_permutation(w))
   , class_rep = (BiPartition->WeylElt): conjugacy_class_C(rd)
   then lookup = (BiPartition->int): index_bipartition(classes)
in W_class_table( rd, for pair in classes do class_rep(pair) od
		, (int i)int: cycle_class_size(classes[i].to_cycles)
		, (WeylElt w) int: lookup(type_code(w).as_bipartition)
		, (int i,int k)int:
		    cycle_power(classes[i].to_cycles,k).to_partition_pair.lookup
		)

set character_table_C (int n) =
      (CharacterTable,(BiPartition->int),(BiPartition->int)):
   let class_list =  partition_pairs(n), irrep_list = BC_irreps(n)
   , rd=Sp(n+n)
   then cycles = for pair in class_list do pair.to_cycles od
   , class_rep(int i) = WeylElt: W_elt(rd,class_word_BC(class_list[i]))
   then classes = [WeylElt,classical_class,string]:
      for c@i in cycles do ( class_rep(i), c.class_BC, c.cycles_string) od
   ,  irreps = [classical_irrep,string,[int]]:
      for rep in irrep_list
      do ( rep.irrep_BC, rep.irrep_string
         , for c in cycles do hyperoctahedral_character(rep,c) od
	 )
      od
   ,  lookup_class = (BiPartition->int): index_bipartition(class_list)
   ,  lookup_irrep = (BiPartition->int): index_BC_irrep(irrep_list)
in ( character_table(class_table_C(n),classes,irreps)
   , lookup_class { find index among conjugacy classes }
   , lookup_irrep
   )

set character_table_C(RootDatum rd) =
      (CharacterTable,(BiPartition->int),(BiPartition->int)):
   let n=rd.semisimple_rank
   then class_list =  partition_pairs(n), irrep_list = BC_irreps(n)
   , class_rep = conjugacy_class_C(rd)
   then cycles = for pair in class_list do pair.to_cycles od
   , class_rep(int i) = WeylElt: class_rep(class_list[i])
   then classes = [WeylElt,classical_class,string]:
      for c@i in cycles do ( class_rep(i), c.class_BC, c.cycles_string) od
   ,  irreps = [classical_irrep,string,[int]]:
      for rep in BC_irreps(n)
      do ( rep.irrep_BC, rep.irrep_string
         , for c in cycles do hyperoctahedral_character(rep,c) od
	 )
      od
   , lookup_class = (BiPartition->int): index_bipartition(class_list)
   , lookup_irrep = (BiPartition->int): index_BC_irrep(irrep_list)
in ( character_table(class_table_B(n),classes,irreps)
   , lookup_class { find index among conjugacy classes }
   , lookup_irrep
   )
{				type D				}


{ word representative in types D of unsplit conjugacy class for partition pair }
set class_word_D(Partition lambda,Partition mu) = [int]:
(  assert((lambda:=lambda.strip_to_partition).>, "lambda is not a partition")
;  assert((mu:=mu.strip_to_partition).>, "mu is not a partition")
;  assert(=#mu%2, "mu has an odd number of parts")
;  assert(not(=mu and =lambda%2)
	 , "mu is empty and lambda has even parts: split class")
;  let (n,,L_gens) = Levi_A(lambda), (m,,simples) =Levi_A(mu)
   ,  rise(int a,int len) = [int]: for i:len from a  do i od
   ,  fall(int a,int len) = [int]: for i:len from a ~do i od
then  sign_pair(int k,int l) = [int]: { arguments are positions in |[0,m[| }
         rise(n+l,m-1-l)##rise(n+k,m-k) { |m-k-2|, plus 2 final for signs }
       ##fall(n+k,m-2-k)##fall(n+l,m-1-l) { remainder of conjugation }
then  M_gens = { each cycle pair from |mu| get sign flips when second is done }
      let odd=false { parity of number cycles from |mu| already treated }
      , j=0 { position in |simples| }
      , k=minus_1 { variable to record end of previous cycle } in
      for i:m
      do if j<#simples and i=simples[j] then j+:=1; [n+i] { extend our cycle }
         elif odd:=not odd
	 then [] next k:=i { break cycle, save index, wait for |sign_pair| }
	 else sign_pair(k,i) { wrap up two cycles by adding signs }
	 fi
      od.##
in L_gens##M_gens
)

{ word representative in types D of split conjugacy class for partition pair }
set class_word_D(Partition lambda,bool minus) = [int]:
(  assert((lambda:=lambda.strip_to_partition).>, "lambda is not a partition")
;  assert(lambda.is_very_even, "lambda is has odd parts: not a split class")
;  let n=sum(lambda), bars = let sum=minus_1 in for k in lambda do sum+:=k od
in if minus else complement(n,bars) { just have a word for each (even) cycle }
   then complement(n,bars) ## [n-2,n-1] { add adjacent flips in last cycle }
   fi
)

set class_word(D_class c) =  [int]:
   case c
   | unsplit_class(cycles): class_word_D(cycles.to_partition_pair)
   | split_class(lambda_minus): class_word_D(lambda_minus)
   esac


set conjugacy_class_SO(D_class c) = WeylElt:
   let n=rank(c) in W_elt(SO(n+n),class_word(c))

{ for general type D root data, we need to look up and use the diagram order }
set conjugacy_class_D(RootDatum rd) = (D_class->WeylElt):
   let map = test_simple_type("D",rd) then n=#map in
   (D_class cycles) WeylElt:
(  let size = rank(cycles)
in assert(size=n,"Cycles sum to "+size+" rather than "+n)
;  W_elt(rd,for s in class_word(cycles) do map[s] od)
)

set class_table_D(int n) = WeylClassTable:
   let rd=SO(n+n), classes = [D_class]: D_classes(n)
   then lookup = (D_class->int):
      let ranked = { |ranked[i]| is index in |classes| of class ranked |i| }
         sort(#classes,(int i,int j)bool: classes[i]<=classes[j])
      then list = for i in ranked do classes[i] od
      in (D_class c) int: { index in |classes| where one finds |c| }
         ranked[binary_search_first((int i)bool: c<=list[i], 0,#classes)]
in W_class_table( rd, for class in classes do conjugacy_class_SO(class) od
		, (int i)int: class_size(classes[i])
		, (WeylElt w)int: lookup(signed_permutation(w).to_D_class)
		, (int i,int k)int: lookup(cycle_power(classes[i],k))
		)

set class_table_D(RootDatum rd) = WeylClassTable:
   let classes = [D_class]: D_classes(rd.semisimple_rank)
   , class_rep = (D_class->WeylElt): conjugacy_class_D(rd)
   then lookup = (D_class->int):
      let ranked = { |ranked[i]| is index in |classes| of class ranked |i| }
         sort(#classes,(int i,int j)bool: classes[i]<=classes[j])
      then list = for i in ranked do classes[i] od
      in (D_class c) int: { index in |classes| where one finds |c| }
         ranked[binary_search_first((int i)bool:c<=list[i], 0,#classes)]
in W_class_table( rd, for class in classes do class_rep(class) od
		, (int i)int: class_size(classes[i])
		, (WeylElt w)int: lookup(classic_permutation(w).to_D_class)
		, (int i,int k)int: lookup(cycle_power(classes[i],k))
		)


{ all irreducible representations of D_n }
set D_irreps (int n) = [D_irrep]:
   for (lambda,):pair
     in pairs_of_total_sum(n,(int k):partitions(k)~[:]) { list [k],..,ones(k) }
   do case cmp_partitions(pair)
      then { first is stricly less } []
      in { an equal pair } [(lambda,false).split_irr,(lambda,true).split_irr]
      else { first is stricly greater } [pair.unsplit_irr]
      esac
   od.##

{ look up pair in sorted list of partition pairs,  in ordering of |D_irreps| }
set index_D_irreps = ([D_irrep]->(D_irrep->int)):
   let flatten(D_irrep chi) = (BiPartition,int):
      case chi
      | pair.unsplit_irr: (pair,minus_1)
      | (lambda,b).split_irr: ((lambda,lambda),#b)
      esac
   ,  before_eq (BiPartition(nu,):pair1,int flag1) = (BiPartition,int->bool):
	   let sum_nu = sum(nu) in
	   if flag1.<
	   then { compare against unsplit }
	      (BiPartition(mu,):pair0,int flag0) bool: { whether before arg1 }
		 case sum(mu)-sum_nu
		 then false { smaller |sum(mu)|, so arg0 after arg1 }
		 in pair1<=pair0 { reverse comparison, for |~[:]| above }
		 else true
		 esac
	   else { compare against split }
	      (BiPartition(mu,):pair0,int flag0) bool: { whether before arg1 }
		 case sum(mu)-sum_nu
		 then false
		 in if flag0.< then pair1<=pair0 { just reverse comparison }
		    else { comparing two split irreps }
		       case cmp_equal_sum_partitions(nu,mu) { reverse here too }
		       then true in flag0<=flag1 else false
		       esac
		    fi
		 else true
		 esac
	   fi
   in ([D_irrep] sorted_list) (D_irrep->int):
      let up_to = [(BiPartition,int->bool)]:
	  for elt in sorted_list do before_eq(flatten(elt)) od
      , len = #sorted_list
      in (D_irrep chi) int:
	 let key=flatten(chi)
	 in binary_search_first( (int i)bool: up_to[i](key), 0, len)

set character_table_D(int n) =
      (CharacterTable,(D_class->int),(D_irrep->int)):
   let class_list = D_classes(n)
   ,   irrep_list = D_irreps(n)
   then classes = [WeylElt,classical_class,string]:
      for c in class_list
      do (conjugacy_class_SO(c),c.class_D,c.cycles_string)
      od
   ,  irreps = [classical_irrep,string,[int]]:
      for rep in D_irreps(n)
      do ( rep.irrep_D, rep.irrep_string
         , for class in class_list do character(rep,class) od
	 )
      od
   ,  lookup_class = (D_class->int): index_D_classes(class_list)
   ,  lookup_irrep = (D_irrep->int): index_D_irreps(irrep_list)
in ( character_table(class_table_D(n),classes,irreps)
   , lookup_class { find index among conjugacy classes }
   , lookup_irrep
   )

set character_table_D(RootDatum rd) =
      (CharacterTable,(D_class->int),(D_irrep->int)):
   let  n=rd.semisimple_rank
   ,    class_rep = (D_class->WeylElt): conjugacy_class_D(rd)
   then irrep_list = D_irreps(n)
   ,    class_list =  D_classes(n)
   then classes = [WeylElt,classical_class,string]:
      for c in class_list do (class_rep(c),c.class_D,c.cycles_string) od
   ,  irreps = [classical_irrep,string,[int]]:
      for rep in irrep_list
      do ( rep.irrep_D, rep.irrep_string
         , for class in class_list do character(rep,class) od
	 )
      od
   ,  lookup_class = (D_class->int): index_D_classes(class_list)
   ,  lookup_irrep = (D_irrep->int): index_D_irreps(irrep_list)
in ( character_table(class_table_D(rd),classes,irreps)
   , lookup_class { find index among conjugacy classes }
   , lookup_irrep
   )

{ functions that expect a |CharacterTable| of simple type D }
set split_class_nrs(CharacterTable ct) = [int]:
   for i:ct.n_classes
   do case ct.classes(i) | else []
      | class_D(c):
        case c | else []
        | split_class(x): [ i ]
	esac
      esac
   od.##

set split_rep_nrs(CharacterTable ct) = [int]:
   for i:ct.n_classes
   do case ct.classical_reps(i) | else []
      | irrep_D(rep):
        case rep | else []
	| split_irr(x): [ i ]
	esac
      esac
   od.##

set split_table (CharacterTable ct) = ([classical_irrep],[classical_class],mat):
   let reps = split_rep_nrs(ct), classes = split_class_nrs(ct)
in ( for i in reps do ct.classical_reps(i) od
   , for j in classes do ct.classes(j) od
   , for i in reps do for j in classes do ct.table[i,j] od od
   )
