<basic.at
<Weylgroup.at { for |root_reflection| }

{ This file groups function concerning classification of and computation with
  Levi subgroups.

  It regroups things that used to be in W_characters.at and conjugate.at
}

{ We try as much as possible to work with Levi subgroups without building a
  complete |RootDatum| for them all the time, since that is somewhat costly. }

{ Some possible presentations of a Levi system

  A Levi system, not necessarily standard, can be defined either by the roots
  forming a simple system for it (represented by their indices, usually within
  |posroots(rd)|, though the code handles negative indices of negative roots
  too), or by a predicate selecting the indices of positive roots in the system.

  The function |Levi_info| deduces the predicate from the simple system, or from
  a Weyl group element $w$ (selecting coroots vanishing on $w$-fixed weights),
  and |Levi_datum| builds the root datum for the subsystem, given the predicate.
}

{ select posroots indices for (non standard) Levi, given by its simple system }
set Levi_info (RootDatum rd, [int] simples) = (RootDatum,(int->bool)):
   let orth=kernel(rd.rank ^ for i in simples do coroot(rd,i) od)
   in (rd,(int j) bool: =coroot(rd,j)*orth)

{ the |select| predicate for the above functions to use for a given |w| }
set Levi_info (WeylElt w) = (RootDatum,(int->bool)):
   let orth=eigen_lattice(matrix(w),1), rd=w.root_datum
   in (rd,(int i) bool: =coroot(rd,i)*orth)

{ a root datum can be formed from |Levi_info|, or simple (co)root index list }
set Levi_datum = sub_datum@(RootDatum,(int->bool)) { defined in basic.at }
set Levi_datum = sub_datum@(RootDatum,[int]) { also defined in basic.at }

set Levi_datum (WeylElt w) = RootDatum: w.Levi_info.Levi_datum

{ It turns out that Levi subsystems (whether or not standard) are conjugate in
  $W$ if and only if their |rho_check| coweights are in the same $W$-orbit.
  (Since dual Weyl groups are conjugate, we could have used |rho| instead of
  |rho_check|, and indeed did this initially. Some applications however need
  to work with |rho_check| anyway, which is why we chose to use that here.)
}

{moved from W_characters.at since it is needed here, in standard_Levi}
set standard_Levi_conjugacy_representatives (RootDatum rd) = [ [int] ]:
begin
   let reps_by_rho ([[int]] list) = [[int]]:
      let rho2s = [vec]:[] { list of known dominant $2\rho$ values }
   in for subset in list
      do let rho2=dominant(rd,two_rho(rd,subset))
      in if none(#rho2s,(int i)bool: rho2s[i]=rho2)
         then rho2s#:=rho2 { now we know |rho2|}; [subset] { contribute }
         else [] { |rho2| was already present, contribute nothing }
         fi
      od.##
   , r = rd.semisimple_rank
in { now apply |reps_by_rho| to each size class, and concatenate the results }
   for k:r+1 do reps_by_rho(choices_from(#r,k)) od.##
end

{ The following functions, up to |classify_standard_Levis|, aim to classify
  standard Levis under conjugation _and_ find conjugators for each one from the
  first of their class. The Levi orbit table produced is used in some functions
  in W_character.at; the ultimate goal of efficiently classifying Weyl group
  elements up to conjugation, with witnesses, is also achieved there.

  For each standard Levi system |standard_Levi| (a list of simple root indices)
  we determine the dominant orbit representative |rho2_dom| of its $2\rho$, a
  Weyl group element |w0| that witnesses this (|w0*rho2_dom=two_rho(rd,Levi)|),
  and the (non standard) image $L$ under |inverse(w0)| of |standard_Levi|, which
  has |two_rho(Levi_info(L))=rho2_dom| (this holds because the Levi system
  remains positive throughout the action by letters of |inverse(w0)|). A
  conjugate standard Levi system will give the same |rho2_dom|, but will not
  necessarily transform to the same system $L$; therefore we generate the orbit
  of $L$ under the stabiliser subgroup of the |rho2_dom|, with witnesses.

  The orbit generation here is taylored to the specific situation that we know
  that all elements of the acting subgroup fix |rho2_dom|, so the only way they
  can map all simple generators (in the sense of its sub-datum) of $L$ to
  (necessarily positive) roots of $L$ is by permuting them among each other.
  Also since |rho2_dom| is dominant for the full system, and so a fortiori
  dominant for the positive roots in any system in the orbit of $L$, the acting
  stabiliser subgroup will map positive roots of $L$ to positive roots. We can
  then work with positive root indices only, act on lists of such indices, and
  sort the result to test for equality.
}

set_type orbit_data = [int,WeylElt] { posroot set as binary number, conjugator }

set right_act([int] Levi,WeylElt w) = int: { encode |w^-1*Levi| in binary }
	let rd=w.root_datum in
	for i in Levi do 2^coroot_index(rd,coroot(rd,i)*w) od.sum

{ list of (L,w) where 2rho(L)=dominant(2rho(Levi)) and L=w*standard_Levi  }
set rho_stabiliser_orbit (RootDatum rd, [int] standard_Levi) = orbit_data:
   let (w0,rho2_dom) = from_dominant(rd,two_rho(rd,standard_Levi))
   then rho_stabiliser = Levi_datum(rd,(int i)bool: =coroot(rd,i)*rho2_dom)
   then root_perm = { list of posroot permutations for stabiliser generators }
      let two=2/1 then pow2(int n)=int:floor(two^n) { negatives to 0 } in
      for beta in rho_stabiliser.simple_roots
      do for alpha in rd.posroots
         do root_index(rd,reflect(rd,beta,alpha)).pow2
	 od
      od
   , unbinary (int bin) = [int]: { recover |Levi| from binary representation }
	let i=0 in
	while bin.>
	do let (q,r)=bin\%2 in if =r then [] else [i] fi
	next i+:=1; bin:=q
	od.##
   then act(int i,[int] roots) = int:
      let map = root_perm[i] in for j in roots do map[j] od.sum
   , orbit = [(right_act(standard_Levi,w0),/w0)] { starting point }
   , current=0
   in while current<#orbit
      do let (L_bin,w)=orbit[current] next current+:=1 then L=L_bin.unbinary in
         for k:rho_stabiliser.semisimple_rank
         do let new_L_bin=act(k,L) in
            if none(#orbit,(int i): let (x,)=orbit[i] in x=new_L_bin)
            then orbit #:=
              (new_L_bin,root_reflection(rd,rho_stabiliser.simple_roots[k])*w)
            fi
         od
      od; orbit

set_type Std_Levi_orbit = (vec rho2, [int] Levi_repr, [[int],WeylElt] others)
set_type Std_Levi_table = [Std_Levi_orbit]

{ group together conjugate standard Levis, with witness conjugating from first }
set classify_standard_Levis (RootDatum rd) =  Std_Levi_table:
   let classify_group ([[int]] list) = Std_Levi_table:
      let orbs = [orbit_data]:[], result = [Std_Levi_orbit]:[] in
      for Levi in list
      do let (w0,rho2_dom)=from_dominant(rd,two_rho(rd,Levi))
         then i = first(#result,(int i)bool: result[i].rho2=rho2_dom)
      in if i.< { is this a previously unseen |rho2_dom| value }
         then orbs #:= rho_stabiliser_orbit(rd,Levi)
         ;  result #:= (rho2_dom,Levi,[])
         else { |rho2_dom| value already seen, and tabulated in |orbs[i]| }
            let cur=result[i], orbit=orbs[i], L = int: right_act(Levi,w0)
            then (,w) =
	       let pos = first(#orbit,(int i)bool: let (rts,)=orbit[i] in rts=L)
	       in assert(pos.>=,"conjugate with dominant rho not found in orbit")
	       ;  orbit[pos]
            in result[i] := (cur.others #:= (Levi,w0*w); cur)
					  { Levi <-w0-- L <-w-- cur.Levi_repr }
	 fi
     od; result
  ,  r = rd.semisimple_rank
  in for k:r+1 do classify_group(choices_from(#r,k)) od.##

{
  From $w$ we find the associated non-standard Levi subsystem, the minimal one
  in whose Weyl group $w$ occurs. Our next task, surprisingly difficult, is to
  find a standard Levi system conjugate to it, and a conjugating element of $W$.

  For the case where we are given a non standard list of simple generators (not
  all positive, and in arbitrary order) for the full root system, there is an
  easy algorithm to find $w$ (called |chamber| below) that maps the set of
  simple roots of |rd| to those generators, and the permutation of them (map
  from positions to simple root index being mapped to it) so obtained. It goes:
  as long as the system contains a negative root, select one (recording its
  position) and apply the corresponding (non simple) root reflection to all
  roots; ultimately all roots become positive, and as a set we have obtained the
  simple roots. The list of their indices is our permutation; as letters of $w$,
  from right to left, take for each reflection applied the simple generator that
  ended up at the recorded position. This is done in |chamber_max_system| below.

  Our approach is then to extend the Levi system one root at a time to a maximal
  system, and then apply this algorithm. To find a root by which we can extend
  the Levi system to a larger one, we first locate using |minimal_extenders| a
  set of candidates (root indices, not necessarily positive ones), whose roots
  are minimally positive for some some linear form vanishing on |Levi|. From
  these, |extend_Levi| will then select a minimal one for |Levi| root addition.
}

{ list of posroot indices, minimal>0 for some linear form vanishing on |Levi| }
set minimal_extenders (RootDatum rd,[int] Levi) = [int]:
   let orth = { columns: generators in $X_*$ of annihilator subspace of |Levi| }
      kernel(rd.rank ^ for i in Levi do root(rd,i) od)
in case a_column_with((vec alpha)bool: !=alpha*orth {@*(vec,mat)}, rd.posroots)
   | no_vec: [] { |Levi| already spans subspace containing all roots }
   | solution(alpha):
      { find a column |f| of |orth| (coweight) witnessing |alpha*orth| nonzero }
      let f = requisition(a_column_with((vec cowt)bool: !=cowt*alpha, orth))
      , min=0 { minimal positive coroot evaluation on |wt| so far; 0 if none }
      , result = [int]: [] { list of root indices with minimal positive eval }
      in for beta@i in rd.posroots
         do let eval=f*beta then abs_eval=eval.abs in
            if =eval then () { ignore roots on which |f| vanishes }
            elif min=0 or abs_eval<min { cases where |result| is replaced }
            then min:=abs_eval; result:=[if eval<0 then -1-i else i fi]
            elif abs_eval=min { ex aequo case, now |result| is extended }
            then result #:= if eval<0 then -1-i else i fi
            fi
         od
      ; result
   esac

set extend_Levi (RootDatum rd,[int] Levi) = [int]:
   let mins = minimal_extenders(rd,Levi) in
   for m in mins
   do let alpha=root(rd,m) in
      if none(#Levi,(int i): is_root(rd,alpha-root(rd,Levi[i])) )
      then return Levi#m { found a valid |m|, add it to Levi and return }
      fi
   od; assert(#mins=0); { if there were any candidates, one should work }
   [] { return indication that |Levi| was already maximal }

{ return maximal Levi containing |Levi|, ordered in the way they were found }
set maximise (RootDatum rd,[int] !Levi) = [int]:
   let ssr = rd.semisimple_rank, max=Levi in
   while #max<ssr do max:=extend_Levi(rd,max); assert(!=#max) od; max

{ find chamber defined by a maximal system, and its simple root permutation }
set chamber_max_system (RootDatum rd, [int] sys) = (WeylElt,[int]):
   let roots= rd.rank # for index in sys do root(rd,index) od
   , ssr=rd.semisimple_rank
   then positions = { a list of positions in |roots| (rather than a Weyl word) }
      assert(#sys=ssr) { first check that |sys| has enough roots };
      while let i=first(ssr,(int i)bool: not is_posroot(rd,roots[i])) in i.>=
      do roots := left_reflect(rd,roots[i],roots); i { record position }
     ~od
   then { convert |positions| to indices in |rd| of corresponding |roots| }
     perm= for alpha in roots do root_index(rd,alpha) od
   in assert(all(ssr,is_member(perm)),"Not a complete system");
   (W_elt(rd,for pos in positions do perm[pos] od),perm)

{ for non-standard Levi: some conjugate standard Levi, and conjugator from it }
set from_standard_Levi ((RootDatum,[int]) (rd,Levi):arg) =
      (WeylElt, [int]): { chamber, unsorted standard Levi }
   let (chamber,perm) = chamber_max_system(rd,maximise(arg)) in
   (chamber,perm[:#Levi] { select start of simple indices list })

{ given |Std_Levi_table|: tabled representative of a standard Levi, conjugator }
{ does linear search for |rho2| in the table, then again in its orbit }
set standard_Levi_lookup (RootDatum rd,Std_Levi_table table) =
      ([int]->WeylElt, [int]):
([int] unsorted_standard_Levi) (WeylElt, [int]): { conjugator, Levi class repr }
   let rho2 = dominant(rd,two_rho(rd,unsorted_standard_Levi))
   , standard_Levi=unsorted_standard_Levi.sort
   then (,Levi_repr,others) =
      table[first(#table,(int i)bool: table[i].rho2=rho2)]
in if standard_Levi=Levi_repr
   then (id_W(rd),standard_Levi)
   else let (,conj) =
      others[first(#others,(int i)bool: let (L,)=others[i] in L=standard_Levi)]
      in (conj , Levi_repr)
   fi

{ given |Std_Levi_table|: tabled representative of any Levi, and conjugator }
set Levi_lookup (RootDatum rd,Std_Levi_table table) = ([int]->WeylElt,[int]):
   let lookup = standard_Levi_lookup(rd,table) in
([int] Levi) (WeylElt, [int]): { conjugator from, elected standard Levi }
   let (chamber,unsorted_standard_Levi) = from_standard_Levi(rd,Levi)
   then (conj,Levi_repr) = lookup(unsorted_standard_Levi)
   in (chamber*conj,Levi_repr)
