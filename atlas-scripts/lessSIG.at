<basic.at
<kl.at { for |composition_series| }
<parameters.at { for |param_pol| }

{ This file concerns the order relation on parameters generated by

q \le SIG p if there is an r in reducibility_points(p) with q a
            composition factor of p*r

and also

p*0 \le SIG p

}
{ change from #P to #alcove_center(P) is gain from alcove_center }
set alcove_center(ParamPol P) = sum(P.real_form,for p in monomials(P)
do alcove_center(p) od)

{ thought this might be a bit faster, but tests same }
set alcove_center2(ParamPol P) = sum(P.real_form,for @p in P do alcove_center(p) od)

{ All the parameters p*r, with r in reducibility_points(p), and p a
term of P}
set red_line(ParamPol P) = ParamPol:
let G=P.real_form, zero = 0*P in P + sum(G, for p in monomials(P) do sum(G,for r
in reducibility_points(p) do if r<1 then 1*(p*r) else zero fi od) od)

{ Implements iterative construction of all terms that can appear in the
  deformation calculation. During the iteration...
  P0 is the sum of real tempered parameters that might appear in computed deformation
  formulas (initialized as 0*p);
  P1 is the sum of all possibly nontempered parameters considered, and
  already deformed (initialized as 0*p);
  Pw is the sum of possibly nontempered parameters yet to be
  deformed (initialized as 1*p). Idea is to apply this function repeatedly,
  starting at (1*p,0*p,0*p) }

set sig_down_3(ParamPol Pw, ParamPol P1, ParamPol P0) = (ParamPol,
ParamPol, ParamPol):
let G=Pw.real_form , zero = 0*Pw, redPw = Pw+red_line(Pw), denoms =
for p in monomials(Pw+P1) do denom(nu(p)) od in
prints("cardinalities for (Pw,P1,P0,P1+P0) are (",#Pw,",",#P1,",",#P0,",",#(P1+P0),
"); largest denominator = ", max(denoms));
  (sum(G,for p in monomials(redPw) do if P1[p] = 0 then
  composition_series(p) - p else zero fi od),P1+redPw, P0+Pw*0)

{ same thing, but tries to speed up computation by replacing
composition_series(p) by partial_block(p). This should be a weakly
larger set, and in the present iterative setting should lead to
_nearly_ the same (slightly larger?) full_sig_down }

set sig_down_partial(ParamPol Pw, ParamPol P1, ParamPol P0) = (ParamPol,
ParamPol, ParamPol):
let G=Pw.real_form , zero = 0*Pw, redPw = Pw+red_line(Pw), denoms =
for p in monomials(Pw+P1) do denom(nu(p)) od in
prints("cardinalities for (Pw,P1,P0,P1+P0) are (",#Pw,",",#P1,",",#P0,",",#(P1+P0),
"); largest denominator = ", max(denoms));
  (sum(G,for p in monomials(redPw) do if P1[p] = 0 then
  param_pol(partial_block(p)[:1~],G) else zero fi od),P1+redPw, P0+Pw*0)

{ same thing, but replacing each parameter encountered by the CENTER
of the corresponding alcove of parameters. This version is to
illustrate the memory savings and smaller denominators provided by
using alcove-center }

set sig_down_alcove(ParamPol Pw, ParamPol P1, ParamPol P0) = (ParamPol,
ParamPol, ParamPol):
let G=Pw.real_form , zero = 0*Pw, redPw = alcove_center(Pw+red_line(Pw)), denoms =
for p in monomials(Pw+P1) do denom(nu(p)) od in
prints("cardinalities for (Pw,P1,P0,P1+P0) are (",#Pw,",",#P1,",",#P0,",",#(P1+P0),
"); largest denominator = ", max(denoms));
  (sum(G,for p in monomials(redPw) do if P1[p] = 0 then
  alcove_center(composition_series(p) - p) else zero fi od),P1+redPw,
  P0+Pw*0)

{ same thing, replacing composition_series by (faster to compute)
character_formula. Again, in present iterative setting, should lead to
a very similar full_sig_down. }

set sig_down_inv(ParamPol Pw, ParamPol P1, ParamPol P0) = (ParamPol,
ParamPol, ParamPol):
let G=Pw.real_form , zero = 0*Pw, redPw = Pw+red_line(Pw), denoms =
for p in monomials(Pw+P1) do denom(nu(p)) od in
prints("cardinalities for (Pw,P1,P0,P1+P0) are (",#Pw,",",#P1,",",#P0,",",#(P1+P0),
"); largest denominator = ", max(denoms));
  (sum(G,for p in monomials(redPw) do if P1[p] = 0 then
  sum(G, for (,q,) in KL_column(p) do 1*q od)-p else zero fi od),
  P1+redPw, P0+Pw*0)

{ replace composition_series by character_formula AND alcove_center }

set sig_down_inv_alcove(ParamPol Pw, ParamPol P1, ParamPol P0) = (ParamPol,
ParamPol, ParamPol):
let G=Pw.real_form , zero = 0*Pw, redPw = alcove_center(Pw+red_line(Pw)), denoms =
for p in monomials(Pw+P1) do denom(nu(p)) od in
prints("cardinalities for (Pw,P1,P0,P1+P0) are (",#Pw,",",#P1,",",#P0,",",#(P1+P0),
"); largest denominator = ", max(denoms));
  (sum(G,for p in monomials(redPw) do if P1[p] = 0 then
  alcove_center(character_formula(p) - p) else zero fi od),P1+redPw,
  P0+Pw*0)

{ replace composition_series by partial_block and
alcove_center. Should give a slightly larger full_sig_down than
sig_down_alcove }

set sig_down_partial_alcove(ParamPol Pw, ParamPol P1, ParamPol P0) = (ParamPol,
ParamPol, ParamPol):
let G=Pw.real_form , zero = 0*Pw, redPw = alcove_center(Pw+red_line(Pw)), denoms =
for p in monomials(Pw+P1) do denom(nu(p)) od in
prints("cardinalities for (Pw,P1,P0,P1+P0) are (",#Pw,",",#P1,",",#P0,",",#(P1+P0),
"); largest denominator = ", max(denoms));
  (sum(G,for p in monomials(redPw) do if P1[p] = 0 then
  alcove_center(param_pol(partial_block(p)[:1~],G)) else zero fi od),P1+redPw,
  P0+Pw*0)

{size of to-be-computed part}
set to_do(ParamPol Pw, ParamPol P1, ParamPol P0) = #Pw

{ PROCEDURE: fix parameter p. Start with triple = (1*p,0*p,0*p). Apply
sig_down_* to triple repeatedly, until first term is zero. Then the
second term is more or less all the parameters that needed to be
deformed, and the third is the list of all the possible tempered real
terms that could appear. }

{ this implements PROCEDURE. }
set full_sig_down(Param p) = void: let triple = (1*p,0*p,0*p) in while
to_do(triple) >0 do triple:=sig_down_3(triple) od;
let (,P1,P0) = triple then denoms = for p in monomials(P1) do denom(nu(p)) od in
prints("Final cardinalities for (P1,P0,P1+P0) are (",#P1,",",#P0,",",#(P1+P0),
"); largest denominator = ", max(denoms));
prints("number of alcoves = ",#alcove_center(P1))

set full_sig_down_partial(Param p) = void: let triple = (1*p,0*p,0*p) in while
to_do(triple) >0 do triple:=sig_down_partial(triple) od;
let (,P1,P0) = triple then denoms = for p in monomials(P1) do denom(nu(p)) od in
prints("Final cardinalities for (P1,P0,P1+P0) are (",#P1,",",#P0,",",#(P1+P0),
"); largest denominator = ", max(denoms));
prints("number of alcoves = ",#alcove_center(P1))

set full_sig_down_alcove(Param p) = void: let triple = (1*p,0*p,0*p) in while
to_do(triple) >0 do triple:=sig_down_alcove(triple) od;
let (,P1,P0) = triple then denoms = for p in monomials(P1) do denom(nu(p)) od in
prints("Final cardinalities for (P1,P0,P1+P0) are (",#P1,",",#P0,",",#(P1+P0),
"); largest denominator = ", max(denoms))

set full_sig_down_inv(Param p) = void: let triple = (1*p,0*p,0*p) in while
to_do(triple) >0 do triple:=sig_down_inv(triple) od;
let (,P1,P0) = triple then denoms = for p in monomials(P1) do denom(nu(p)) od in
prints("Final cardinalities for (P1,P0,P1+P0) are (",#P1,",",#P0,",",#(P1+P0),
"); largest denominator = ", max(denoms));
prints("number of alcoves = ",#alcove_center(P1))

set full_sig_down_inv_alcove(Param p) = void: let triple = (1*p,0*p,0*p) in while
to_do(triple) >0 do triple:=sig_down_inv_alcove(triple) od;
let (,P1,P0) = triple then denoms = for p in monomials(P1) do denom(nu(p)) od in
prints("Final cardinalities for (P1,P0,P1+P0) are (",#P1,",",#P0,",",#(P1+P0),
"); largest denominator = ", max(denoms))

set full_sig_down_partial_alcove(Param p) = void: let triple = (1*p,0*p,0*p) in while
to_do(triple) >0 do triple:=sig_down_partial_alcove(triple) od;
let (,P1,P0) = triple then denoms = for p in monomials(P1) do denom(nu(p)) od in
prints("Final cardinalities for (P1,P0,P1+P0) are (",#P1,",",#P0,",",#(P1+P0),
"); largest denominator = ", max(denoms))

