<basic.at

{ Functions for computing with Weyl words }

set_type
  W_word = (RootDatum root_datum,[int] word)
  { keep a RootDatum at hand for interpretation }

set # (W_word w) = int: #w.word { non reduced length of word }
set to_W_word (WeylElt w) = W_word: (w.root_datum,w.word)
set reduce (W_word w) = W_word: w.W_elt.to_W_word
set length (W_word w) = int: w.W_elt.length

{ action of Weyl word on X^* or X^*\otimes Q}
set act (W_word ww, vec v) = vec: W_elt(ww)*v
set act (W_word ww, ratvec rv) = ratvec:  let (v,den)=%rv in act(ww,v)/den

{ action of Weyl word on X_* or X_*\otimes Q }
set co_act (vec cowt, W_word ww) = vec: cowt*W_elt(ww)
set co_act (ratvec rcv, W_word ww) = ratvec:
   let (cowt,den)=%rcv in co_act(cowt,ww)/den

set w_matrix (W_word ww) = mat: ww.W_elt.matrix

set equal (W_word w, W_word u) = bool: w.W_elt=u.W_elt

set inverse (W_word(rd,w)) = W_word: { reverse w component } (rd,w~[:])

{	--- using W to make weight or coweights dominant ---	}

set non_dominant_index (RootDatum rd, vec v) = int:
  last(simple_coroots(rd),(vec alpha_v): (alpha_v*v).<)

set dual_non_dominant_index (RootDatum rd, vec cowt) = int:
  last(simple_roots(rd),(vec alpha): (cowt*alpha).<)

{ rho@rootDatum from basic.at; rho(rd,v) in its orbit and in chamber of v: }
set rho (RootDatum rd, ratvec v) = ratvec: chamber(rd,v)*rho(rd)
set dual_rho (ratvec cowt,RootDatum rd) = ratvec:
  rho_check(rd)*chamber(cowt,rd)

set w_long (RootDatum rd) = W_word: w0(rd).to_W_word

{ find some Weyl word (not lexicographically first) acting by the matrix M }
set word ((RootDatum,mat) rd_M) = W_word: W_elt(rd_M).to_W_word

set length ((RootDatum,mat) rd_M) = int: W_elt(rd_M).length

{ contrary to #@W_word, |length| computes the reduced length }
set length(W_word ww) = int: W_elt(ww).length

{ whether multiplication by simple reflection lengthens or shortens M }
set lengthens (RootDatum rd, mat M, int s) = bool: { for right multiplication }
  rd.is_positive_root(M*root(rd,s))
set lengthens (RootDatum rd, int s, mat M) = bool: { for left multiplication }
  rd.is_positive_coroot(coroot(rd,s)*M)

{ write given root (assumed positive) as |w*alpha| with alpha simple }
set from_simple (RootDatum rd, vec alpha) = (WeylElt,vec):
  let r = semisimple_rank(rd), w=id_W(rd) in
  while { first find index that will make alpha shorter, which should exist }
    let i = first( r, (int i):(coroot(rd,i)*alpha).> ) in
    assert(i.>=,"Not a positive root")  { some descent must be found }
  ; alpha != root(rd,i) { this is the condition of the outer while! }
  do alpha := W_gen(rd,i)*alpha; w := w#i
  od; (w,alpha)

set root_reflection (RootDatum rd, vec alpha) = WeylElt:
  let (w,beta) = from_simple(rd,alpha) in w*W_gen(rd,root_index(rd,beta))*/w

{			--- cross action ---				}


set cross (WeylElt w,KGBElt x) = KGBElt:
  assert(w.root_datum=x.root_datum);
  for s in w.word ~do x:=cross(s,x) od; x
set cross (WeylElt w,Param p) = Param:
  assert(w.root_datum=p.root_datum);
  for s in w.word ~do p:=cross(s,p) od; p

{		--- translating to dominant gamma ---			}


{ |gamma| is integrally dominant, need to add a sum of roots to it to make it
  dominant; this does not change the integral Weyl chamber of |gamma|,
  so when acting on parameters it is another parameter with the same types of
  roots, generating an isomorphic block
  this algorithm is crude: it adds a big enough multiple of |2*rho(rd)|
}
set make_dominant_using_roots (RootDatum rd, ratvec gamma) = (ratvec,vec):
  let diff = two_rho(rd) * { minimal scalar>=0 making |gamma+diff| dominant: }
    -min(0)(gamma*simple_coroots(rd)\2)
  in (gamma+diff,diff)

set make_dominant_using_roots (RootDatum rd, vec v) = (vec{dom},vec{shift}):
  let (w,shift) = make_dominant_using_roots(rd,v) in (w\1,shift)

{ assume infinitesimal character |gamma| of |p| is integrally dominant
  translate by sum of roots to make it dominant
  return (new parameter, sum of roots)
}
set translate_to_dominant (Param p) = (Param{dom},vec{shift}):
  let (x,lambda_rho,gamma) = %p
  then  (new_gamma,shift) = make_dominant_using_roots(root_datum(p),gamma)
  in (param(x,lambda_rho+shift,new_gamma),shift)

{      ---------- integrally dominant functions -------------		}

set integrally_from_dominant ((RootDatum,ratvec)(,v):rd_v) = (WeylElt,ratvec):
  from_dominant(integrality_datum(rd_v),v)
set integrally_dominant ((RootDatum,ratvec)(,v):rd_v) = ratvec:
  dominant(integrality_datum(rd_v),v)

{ act by Weyl group element w, then make result integrally dominant }
set int_dom_act (W_word(rd,):ww,ratvec v) = ratvec:
  integrally_dominant(rd,act(ww,v))

{ --------- basic group operations, reduced result ----------------- }

set left_mult (int i,W_word ww)  = W_word: (i#ww.W_elt).to_W_word
set right_mult (int i,W_word ww) = W_word: (ww.W_elt#i).to_W_word
set conjugate (int i, W_word ww) = W_word: (i#ww.W_elt#i).to_W_word

set multiply (W_word vw, W_word ww) = W_word: (vw.W_elt*ww.W_elt).to_W_word
set * = multiply@(W_word,W_word) { overload to the '*' opetrator }

set conjugate (W_word vw, W_word ww) = W_word: let v=vw.W_elt in
  (v*ww.W_elt*inverse(v)).to_W_word

{ Weyl group element raised to an integer power }
set ^ (W_word ww, int n) = W_word: (ww.W_elt^n).to_W_word

{ Some basic functions for when a Weyl word represents a twisted involution }

{ compute involution from twisted involution Weyl word }
set involution (InnerClass ic, W_word ww) = mat:
  assert (ww.root_datum=ic.root_datum); ww.W_elt*distinguished_involution(ic)

{ these functions do not seem to have much added value }
set imaginary_roots (InnerClass ic, W_word tw) = mat:
  imaginary_roots(ic,involution(ic,tw))
set real_roots (InnerClass ic, W_word tw) = mat:
  real_roots(ic,involution(ic,tw))
set imaginary_coroots (InnerClass ic, W_word tw) = mat:
  imaginary_coroots(ic,involution(ic,tw))
set real_coroots (InnerClass ic, W_word tw) = mat:
  real_coroots(ic,involution(ic,tw))

{ a W-invariant form on X^* (or its rational span) }

{ Each coroot alpha^v defines defines a rank-1 bilinear form on X^* by
  multiplying its evaluations at a pair of weights. Since alpha^v and -\alpha^v
  give the same form, summing over all positive coroots gives a W-invariant
  form, whose radical is the coradical of the root datum. In formula
  $$
    (\mu,\nu)=\sum_{\alpha^v\in\Delta^{\vee+}} <\alpha^v,\mu><\alpha^v\nu>
  $$
  The summation is conveniently done by multiplying a wide matrix M by ^M
}
set invariant_form_matrix (RootDatum rd) = mat: let M=poscoroots(rd) in M*^M
set invariant_form (RootDatum rd) = (ratvec,ratvec->rat):
  let A = rd.invariant_form_matrix in (ratvec v, ratvec w) rat: v*A*w

set nondegenerate_invariant_form (RootDatum rd) = (ratvec,ratvec->rat):
  let A = rd.invariant_form_matrix + (let M=radical_basis(rd) in M*^M)
  in (ratvec v, ratvec w) rat: v*A*w

{ a W-invariant form on X_*\otimes Q; not directly related to invariant_form }
set co_invariant_form_matrix (RootDatum rd) =mat: let M=posroots(rd) in M*^M
set co_invariant_form (RootDatum rd) = (ratvec,ratvec->rat):
  let A = rd.co_invariant_form_matrix in (ratvec v, ratvec w) rat: v*A*w

{ suppress a W_word at index k from a list, requires 0<=k<#list }
set delete ([W_word] list, int k) = [W_word]: list[:k]##list[k+1:]

{ order of W_word, uses order@mat from basic.at }
set order (W_word ww) = int: ww.W_elt.order

set is_elliptic (WeylElt w) = bool: =kernel(1-matrix(w))  { no eigenvalue 1 }
set is_regular (WeylElt w) = bool:
  { let w0=w.root_datum.w0 in w^(w0.length\w.length)=w0 ? }
  w.length*w.order=2*w.root_datum.nr_of_posroots

set is_elliptic (W_word ww) =bool: ww.W_elt.is_elliptic
set is_regular  (W_word ww) =bool: ww.W_elt.is_regular

{ use complex cross actions to find a KGBElt x0 in a fiber with no C- roots
  by descending through complex descents until none are left
  return (w,x0) where x=cross(w,x0)
}
set from_no_Cminus (KGBElt x) = (WeylElt,KGBElt):
  let rd=x.root_datum then w=id_W(rd), r=rd.semisimple_rank in
  while let s = last(r, (int i)bool: =status(i,x) { complex descent } ) in s.>=
  do w:=w#s; x:=cross(s,x) od; (w,x)

set from_no_Cplus (KGBElt x) = (WeylElt,KGBElt):
  let rd=x.root_datum then w=id_W(rd), r=rd.semisimple_rank in
  while let s = last(r, (int i)bool: status(i,x)=4 { complex ascent } ) in s.>=
  do w:=w#s; x:=cross(s,x) od; (w,x)

set make_no_Cminus (KGBElt x) = (KGBElt,W_word): { x' without C-; word applied }
  let (w,x0)=from_no_Cminus(x) in (x0,w.inverse.to_W_word)

set make_no_Cplus (KGBElt x) = (KGBElt,W_word): { elt without C+; word applied }
  let (w,x0)=from_no_Cplus(x) in (x0,w.inverse.to_W_word)

{ the same for parameters }
set from_no_Cminus (Param p) = (WeylElt, Param):
  let (w,x0)=from_no_Cminus(p.x) then w1=w.inverse
  in (w,parameter(x0,w1*p.lambda,w1*p.nu))

set from_no_Cplus (Param p) = (WeylElt, Param):
  let (w,x0)=from_no_Cplus(p.x) then w1=w.inverse
  in (w,parameter(x0,w1*p.lambda,w1*p.nu))

set make_no_Cminus (Param p) = Param: let (,q)=from_no_Cminus(p) in q
set make_no_Cplus (Param p) = Param:  let (,q)=from_no_Cplus(p) in q
