{computing weak unipotent Arthur packets}

<cells.at
<springer_reductive.at
<K_highest_weights.at
<springer_tables.at
<Vogan-dual.at
<nilpotent_centralizer.at

{extract just the parameters from [(int,int,Param)]}
set parameters([(int,int,Param)] triples)=[Param]:for (,,p) in triples do p od

{extract just the parameters from output of weak_packet(..)}
set parameters(([([Param],[WCell])],[(int,int,Param)]) (,triples))=
parameters(triples)

{extract just the parameters from output of weak_packets(..)}
set parameters([([([Param],[WCell])],[(int,int,Param)])] data)=
##for pair in data do parameters(pair) od

{extract just the cells (parameter indices) from output of weak_packet(...)}
set cells(([([Param],[WCell])],[(int,int,Param)]) (pairs,))=
##for (,cells) in pairs do for (param_indices,) in cells do param_indices od od

{SpringerTable: table of Springer data, see springer_tables.at
 NOTE: this must be the SpringerTable for the integral root system
 ComplexNilpotent: complex orbit for dual group
 [Param]: list of parameters, should be all_parameters_gamma(G,gamma) where
   gamma is regular and differs from gamma_target by X^*
 ratvec gamma_target: target infinitesimal character, probably O.H/2
result: ([list of parameters],[(int,int,Param)]=[(block number, cell number, parameter)])}

{weak_packet, given Springer table for the integrality datum of O_check.H/2,
 a list of parameters at regular infinitesimal character, and a target infinitesimal character}
set weak_packet_int(SpringerTable st_int,ComplexNilpotent O_check,[Param] params,ratvec gamma_target)=
([([Param],[WCell])],[(int,int,Param)]):
{returns (blocks_and_cells,[(int,int,Param)])}
assert(integrality_datum(O_check.root_datum.dual,O_check.H/2)=st_int.root_datum,
 "root datum mismatch, probably not using the integrality datum for the orbit");
if #params=0 then ([],[])
else
 let O=st_int.dual_map_i(O_check) then
 ()=if cells_verbose then
prints("gamma_target:",gamma_target);
 prints("Computing weak packet for ", params[0].real_form, new_line,
 "given # parameters: ", #params,new_line,
 "dual orbit:",new_line, " dual root datum: ", O_check.root_datum,new_line, " diagram: ", O_check.diagram, new_line,
 " normalized diagram: ", O_check.diagram_normalized, new_line,
 " H: ", O_check.H, new_line,
 " dimension: ", O_check.dim_nilpotent)
fi then
blocks_and_cells=prints("Computing blocks and cells for ",#params, " parameters");blocks_and_cells(params) then
()=if cells_verbose then
prints("computed ", #blocks_and_cells, " blocks, of sizes: ", for (b,) in blocks_and_cells do #b od)
fi  then
{ let  gamma=O_check.H/2 then}
 ()=if cells_verbose then prints("inf. char.=",gamma_target) fi then
 ()=if cells_verbose then
  prints("orbit:",new_line, " root datum: ", O.root_datum, new_line, " diagram: ", O.diagram, new_line,
   " normalized diagram: ", O.diagram_normalized, new_line,
   " H: ", O.H, new_line,
   " dimension: ", O.dim_nilpotent)
 fi then
 sigma=st_int.springer(O) then
 ()=if cells_verbose then prints("sigma=", sigma, " of dimension ",st_int.ct.dimension(sigma)) fi then
 parameters=parameters_given_AV_infinitesimal_character(st_int,O,blocks_and_cells,gamma_target) 
{ ()=if cells_verbose then
  prints("found ", #parameters, " parameters") fi}
 in
(blocks_and_cells,parameters)
fi


{same as previous command, with additional permutation:
 for computing dual_map_i and springer(O) we do some case-by-case/table constructions
 the labeling of simple roots in the given root datum, and the case-by-case constructed
 on (using simple_factors) may be different
 permutation is the matrix taking i^th simple root of given root datum to i^th simple root
 of the constructed one
}
set weak_packet_int(SpringerTable st_int,ComplexNilpotent O_check,[Param] params,ratvec gamma_target,mat permutation)=
([([Param],[WCell])],[(int,int,Param)]):
{returns (blocks_and_cells,[(int,int,Param)])}
if #params=0 then ([],[]) else
let ()=if cells_verbose then
prints("gamma_target:",gamma_target);
 prints("Computing weak packet for ", params[0].real_form, new_line,
 "dual orbit:",new_line, " dual root datum: ", O_check.root_datum,new_line, " diagram: ", O_check.diagram, new_line,
 " normalized diagram: ", O_check.diagram_normalized, new_line,
 " H: ", O_check.H, new_line,
 " dimension: ", O_check.dim_nilpotent)
fi then
blocks_and_cells=blocks_and_cells(params) then
()=if cells_verbose then
 prints("computed ", #blocks_and_cells, " blocks")
fi  then
 ()=if cells_verbose then prints("inf. char.=",gamma_target) fi then
 O=st_int.dual_map_i(O_check) then
 ()=if cells_verbose then
  prints("orbit:",new_line, " root datum: ", O.root_datum, new_line, " diagram: ", O.diagram, new_line,
   " normalized diagram: ", O.diagram_normalized, new_line,
   " H: ", O.H, new_line,
   " dimension: ", O.dim_nilpotent)
 fi then
 ()=prints("computing springer map of", O.diagram) then
 sigma=st_int.springer(O) then
 ()=if cells_verbose then prints("sigma=", sigma, " of dimension ",st_int.ct.dimension(sigma)) fi then
 parameters=parameters_given_AV_infinitesimal_character(st_int,O,blocks_and_cells,gamma_target,permutation)
 in
(blocks_and_cells,parameters)
fi

{*_trial commands are for testing only, they break the computation into steps
usage:
set (st_int,O_check_int,all,gamma_final,permutation)=weak_packet_trial(O,G)
set (st_int,O_check,blocks_and_cells,gamma_target,permutation)=weak_packet_int_trial(st_int,O_check,all,gamma,perm)
set (st_int,O_check,blocks_and_cells,gamma_target,permutation)=weak_packet_int_trial(weak_packet_trial(O,G))
then
set params=parameters_given_AV_infinitesimal_character(st_int,O_check,blocks_and_cells,gamma_target,permutation)
}

set weak_packet_int_trial(SpringerTable st_int,ComplexNilpotent O_check,[Param] params,ratvec gamma_target,mat permutation)=
(SpringerTable,ComplexNilpotent,[([Param],[WCell])],ratvec,mat):
if #params=0 then (st_int,O_check,[],null(0)/2,null(0,0)) else
let ()=if cells_verbose then
prints("gamma_target:",gamma_target);
 prints("Computing weak packet for ", params[0].real_form, new_line,
 "dual orbit:",new_line, " dual root datum: ", O_check.root_datum,new_line, " diagram: ", O_check.diagram, new_line,
 " normalized diagram: ", O_check.diagram_normalized, new_line,
 " H: ", O_check.H, new_line,
 " dimension: ", O_check.dim_nilpotent)
fi then
blocks_and_cells=blocks_and_cells(params) then
()=if cells_verbose then
 prints("computed ", #blocks_and_cells, " blocks")
fi  then
 ()=if cells_verbose then prints("inf. char.=",gamma_target) fi then
 O=st_int.dual_map_i(O_check) then
 ()=if cells_verbose then
  prints("orbit:",new_line, " root datum: ", O.root_datum, new_line, " diagram: ", O.diagram, new_line,
   " normalized diagram: ", O.diagram_normalized, new_line,
   " H: ", O.H, new_line,
   " dimension: ", O.dim_nilpotent)
 fi then
 ()=prints("computing springer map of", O.diagram) then
 sigma=st_int.springer(O) then
 ()=if cells_verbose then prints("sigma=", sigma, " of dimension ",st_int.ct.dimension(sigma)) fi 
 in
(st_int,O,blocks_and_cells,gamma_target,permutation)
fi

{call weak_packet_int(st_int,O_check,G,params,gamma_target):
 set params=all_paramaeters_gamma(G,O_check.H/2+2*rho(G)) and gamma_target=O.H/2
}
set weak_packet_int(SpringerTable st_int,ComplexNilpotent O_check,RealForm G)=
([([Param],[WCell])],[(int,int,Param)]):
{returns (blocks_and_cells,[(int,int,Param)])}
if cells_verbose then
 prints("weak_packets(st_int,O_check,G):", new_line,"O_check: ", O_check.diagram ,new_line, "G: ", G) fi;
let rd=st_int.root_datum then
gamma_target=O_check.H/2 then
gamma_reg=gamma_target+2*rho(rd) then
all=all_parameters_gamma(G,gamma_reg) in
weak_packet_int(st_int,O_check,all,gamma_target)

{given an orbit O_check on the dual side
 gamma=O_check.H/2
 rd=integrality_datum(rd,gamma)
 return all orbits for rd_dual whose G^vee-saturation is the original
 orbit
this is entirely on the dual side
the first version gives the correct orbit for
integrality_datum(G,O.H/2).dual
}
set integral_descent(ComplexNilpotent O_check)=ComplexNilpotent:
let rd=O_check.root_datum.dual {the original root datum on the group side} then
rd_int=integrality_datum(rd,O_check.H/2)  {on the group side} then
rd_int_dual=rd_int.dual  {on the dual side} in
(rd_int_dual,(),O_check.H)


{we need to move this to st_int.root_datum.dual
this uses a permutation, which we return since it is needed 
in the sequel}
set integral_descent(SpringerTable st_int,ComplexNilpotent O_check)=(ComplexNilpotent,mat):
let rd=O_check.root_datum.dual {the original root datum on the group side} then
O_check_rd_int=O_check.integral_descent {orbit for rd_int_dual} then
rd_int=integrality_datum(rd,O_check.H/2) {integrality datum on group side} then
{P is the permutation relating rd_int.derived and st_int.root_datum}
(,P)=nice_order(rd_int.derived) then
permutation=P.permutation_matrix in
{by definition permutation should related the Cartan matrices}
assert(permutation*st_int.root_datum.Cartan_matrix=rd_int.Cartan_matrix*permutation,"permutation does not relate the Cartan matrices");
{Note: st_int.root_datum.dual is *adjoint*, so O_check_rd_int.diagram = O_check_rd_int.H}
((st_int.root_datum.dual,(),O_check_rd_int.diagram*permutation),permutation)

{This is the primary weak_packet function}
{given complex orbit on dual side, and real form, compute weak Arthur packet}
set weak_packet(ComplexNilpotent O_check,RealForm G)=
([([Param],[WCell])],[(int,int,Param)]):
let ()=prints("Computing weak packets for ",G) then
delta_check=^G.distinguished_involution  {distinguished involution on dual side} in
if not twist(delta_check,O_check)=O_check then
prints("Skipping orbit: dual orbit is not delta_check fixed");([],[]) elif
is_abelian(G) then (blocks_and_cells(G.trivial),[(0,0,G.trivial)])
{avoid constructing SpringerTable for torus} else
let gamma_final=O_check.H/2 then
gamma=gamma_final+2*rho(G) then  {this is the target infinitesimal character, need to pass it}
all=all_parameters_gamma(G,gamma) then
rd=O_check.root_datum.dual then
()=prints("gamma:",gamma) then
()=prints("gamma_final:",gamma_final) then
rd_int=integrality_datum(rd,gamma) then
st_int=springer_table(rd_int) then
()=prints("integral data: st_int") then
()=prints("rd_int:",rd_int, new_line, "st_int.rd: ", st_int.root_datum) then
(O_check_int,permutation)=integral_descent(st_int,O_check) then
()=prints("O_check_int:", O_check_int) then
()=prints("permutation: ", permutation) then
()=prints("computing packet for:", O_check_int) then
(bc,wp)=weak_packet_int(st_int,O_check_int,all,gamma_final,permutation)
in
if G.is_split and =#parameters(wp) then prints("ERROR: , empty packet for split group") fi;
(bc,wp)
fi

{usage: set (st_int,O_check_int,all,gamma_final,permutation)=weak_packet_trial(O,G)}
set weak_packet_trial(ComplexNilpotent O_check,RealForm G)=
let gamma_final=O_check.H/2 then
gamma=gamma_final+2*rho(G) then  {this is the target infinitesimal character, need to pass it}
all=all_parameters_gamma(G,gamma) then
rd=O_check.root_datum.dual then
()=prints("gamma:",gamma) then
()=prints("gamma_final:",gamma_final) then
rd_int=integrality_datum(rd,gamma) then
st_int=springer_table(rd_int) then
()=prints("integral data: st_int") then
()=prints("rd_int:",rd_int, new_line, "st_int.rd: ", st_int.root_datum) then
(O_check_int,permutation)=integral_descent(st_int,O_check) then
()=prints("O_check_int:", O_check_int) then
()=prints("permutation: ", permutation) then
()=prints("computing packet for:", O_check_int) in
(st_int,O_check_int,all,gamma_final,permutation)

{run over a set of dual orbits}
set weak_packets([ComplexNilpotent] dual_orbits,RealForm G)=
prints("Computing weak packets for ", #dual_orbits," dual orbits of ",G);
[([([Param],[WCell])],[(int,int,Param)])]:
for O in dual_orbits do
 prints(new_line,"Computing weak packet for orbit: ", O.root_datum, " ", O.H, " dim=", O.dim_nilpotent);
 weak_packet(O,G)
od

{given just a RealForm G, compute the dual orbits then compute
all weak packets as you run over these dual orbits}
set weak_packets(RealForm G)=
[([([Param],[WCell])],[(int,int,Param)])]:
weak_packets(G.dual_orbits,G)

{given just a RealForm G, compute the dual orbits then compute
all weak packets as you run over these dual orbits}
set weak_packets_even(RealForm G)=
[([([Param],[WCell])],[(int,int,Param)])]:
weak_packets(G.even_dual_orbits,G)

{----precomputed cell trace version ----}

{weak_packet:
 given: a RootDatum rd and an even orbit O_check for the dual,
 a SpringerTable for rd,
 "cell_data": precomputed cell characters
 compute weak packet using the precomputed cell traces
} 
set weak_packets(
SpringerTable st,
ComplexNilpotent O_check,
[([Param],[([int],[int])])]  cell_data
{[Param]: list of parameters in block
 [([int] indices of parameters in cell,[int] character of cell)]
 }
)=([Param],[(int,int,Param)]):
assert(is_locally_isomorphic(integrality_datum(O_check.root_datum.dual,O_check.H/2),st.root_datum),
 "root datum mismatch, probably not using the integrality datum for the orbit");
let gamma_target=O_check.H/2 then
()=if cells_verbose then
 prints("gamma_target:",gamma_target);
 prints("Computing weak packet for ", #cell_data, " blocks ",
 "dual orbit:",new_line, " dual root datum: ", O_check.root_datum,new_line, " diagram: ", O_check.diagram, new_line,
 " normalized diagram: ", O_check.diagram_normalized, new_line,
 " H: ", O_check.H, new_line,
 " dimension: ", O_check.dim_nilpotent)
fi then
()=prints("using precomputed parameters and cells ") then
()=if cells_verbose then prints("inf. char.=",gamma_target) fi then
 O=st.dual_map_i(O_check) then
 ()=if cells_verbose then
  prints("orbit:",new_line, " root datum: ", O.root_datum, new_line, " diagram: ", O.diagram, new_line,
   " normalized diagram: ", O.diagram_normalized, new_line,
   " H: ", O.H, new_line,
   " dimension: ", O.dim_nilpotent)
fi then
sigma=st.springer(O) then
()=if cells_verbose then prints("sigma=", sigma, " of dimension ",st.ct.dimension(sigma)) fi then
wp=parameters_given_AV_infinitesimal_character(st,O,gamma_target,cell_data)
in (parameters(wp),wp)

{same as previous, running over a set of (even) orbits}
set weak_packets(SpringerTable st,[ComplexNilpotent] dual_orbits,[([Param],[([int],[int])])]  cell_data)=
[([Param],[(int,int,Param)])]:
for O in dual_orbits do weak_packets(st,O,cell_data) od

{compute SpringerTable also}
set weak_packets(RealForm G,[ComplexNilpotent] dual_orbits,[([Param],[([int],[int])])]  cell_data)=
[([Param],[(int,int,Param)])]:weak_packets(springer_table(G),dual_orbits,cell_data)

{compute G.even_dual_orbits also}
set weak_packets(
RealForm G,[([Param],[([int],[int])])]  cell_data)=
[([Param],[(int,int,Param)])]:weak_packets(springer_table(G),G.even_dual_orbits,cell_data)

{prepare cell_data for input to weak_packets(st,O,cell_data)}
set cell_data(CharacterTable ct,[Param] parameters)=
[([Param],[([int],[int])])]:
let bc=blocks_and_cells(parameters) then
cells=[[int]]:[],
characters=[[int]]:[] in
for i:#bc do
   let (parameters,cells)=bc[i] in
   (parameters,for cell in cells do
    let (params,)=cell in 
    (params,ct.cell_character(cell))
   od)
od

set cell_data(CharacterTable ct,RealForm G)=
cell_data(ct,all_parameters_gamma(G,rho(G)))

set weak_packets_pre(RealForm G)=
[([Param],[(int,int,Param)])]:
weak_packets(G,cell_data(character_table(G),G))

{------/precomputed cell trace version ----}

{run over a set of dual orbits}
set weak_packets([ComplexNilpotent] dual_orbits,RealForm G)=
[([([Param],[WCell])],[(int,int,Param)])]:
for O in dual_orbits do weak_packet(O,G) od

{reporting functions}

set mult([[(int,int,Param)]] packet)=((int,int,int)->int):(int orbit,int block,int cell):
let rv=0 in
for (b,c,p) in packet[orbit] do
 if b=block and c=cell then rv+:=1 fi
od;rv

set mult([(int,int,Param)] packet)=((int,int)->int):(int block,int cell):
let rv=0 in
for (b,c,p) in packet do
 if b=block and c=cell then rv+:=1 fi
od;rv

set parameters_map([[(int,int,Param)]] packet)=((int,int,int)->[Param]):(int orbit,int block,int cell):
let rv=[Param]:[] in
for (b,c,p) in packet[orbit] do
 if b=block and c=cell then rv#:=p fi
od;rv

set parameters_map([(int,int,Param)] packet)=((int,int)->[Param]):(int block,int cell):
let rv=[Param]:[] in
for (b,c,p) in packet do
 if b=block and c=cell then rv#:=p fi
od;rv

{number of time given block appears, i.e. number of parameters in this block}
set mult_block([(int,int,Param)] packet)=(int->int):(int block):
let rv=0 in
for (b,c,p) in packet do
 if b=block  then rv+:=1 fi
od;rv

{number of times the (orbit,block) pairs appears, in other words number of parameters
in given pair}
set mult_orbit_block([[(int,int,Param)]] packet)=((int,int)->int):(int orbit,int block):
let rv=0 in
for (b,c,p) in packet[orbit] do
 if b=block  then rv+:=1 fi
od;rv

set blocks([(int,int,Param)] packet)=sort_u(for (b,,) in packet do b od )
set cells([(int,int,Param)] packet)=sort_u(for (,c,) in packet do c od )
set cells([[(int,int,Param)]] packets) =sort_u(##for i:#packets do for (,c,) in packets[i] do c od od)
set blocks([[(int,int,Param)]] packets) =sort_u(##for i:#packets do for (b,,) in packets[i] do b od od)

set unipotent_representations(RealForm G)=[Param]:
G.weak_packets.parameters

set unipotents(RealForm G)=[Param]:unipotent_representations(G)

set show_short([([([Param],[WCell])],[(int,int,Param)])] blocks_and_cells_and_packets)=void:
let packets=for (,packet) in blocks_and_cells_and_packets do packet od then
grand_total=0 then
blocks=blocks(packets) then
cells=cells(packets) then
m=mult(packets) in
tabulate(
 ["orbit","|packet|"]#
 ##for i:#packets do
  let total=sum(for b in blocks do sum(for c in cells do m(i,b,c) od) od)
 in if total!=0 then grand_total+:=total;[[i.to_string,total.to_string]] else [] fi
od
#["Total",grand_total.to_string]
);prints()

set show_short(([([Param],[WCell])],[(int,int,Param)]) blocks_and_cells_and_packet)=void:
show_short([blocks_and_cells_and_packet])

set show( ([([Param],[WCell])],[(int,int,Param)]) blocks_and_cells_and_packet)=
let (bc,packet)=blocks_and_cells_and_packet then
blocks=blocks(packet) then
cells=cells(packet) then
m=mult(packet) in
prints("*: dual(cell) contains an Aq(lambda)");
tabulate(
 ["block#","cell#","|packet|"]#
{ ##for i:#packets do}
  ##for b in blocks do
   ##for c in cells do
    if m(b,c)!=0 then
     let (params,cells)=bc[b] then
     p=params[0] then
     cell=cells[c] then
     cell_flag={if not is_integral(p.root_datum,p.infinitesimal_character) then false.star else} is_dual_Aq(params,cell).star {fi} then
     flag=is_dual_Aq(params,cell).star in
[[b.to_string,c.to_string + cell_flag,m(b,c).to_string]] else [] fi 
   od
  od
      #["Total","",(#parameters(packet)).to_string]
  );prints()

set show( [([([Param],[WCell])],[(int,int,Param)])] blocks_and_cells_and_packets)=
prints("*: dual(cell) contains an Aq(lambda)");
tabulate(
 ["orbit#","block#","cell#","parameters"]#
 ##for i:#blocks_and_cells_and_packets do 
 let (bc,packet)=blocks_and_cells_and_packets[i] then
 blocks=blocks(packet) then
 cells=cells(packet) then
 m=mult(packet) in
  ##for b in blocks do 
   ##for c in cells do
    if m(b,c)!=0 then
     let (params,cells)=bc[b] then
     p=params[0] then
     cell=cells[c] then
     cell_flag={if not is_integral(p.root_datum,p.infinitesimal_character) then false.star else} is_dual_Aq(params,cell).star {fi} in
[[i.to_string,b.to_string,c.to_string + cell_flag,m(b,c).to_string]] else [] fi 
   od
  od
 od
     #["Total","",(#parameters(##for (,b) in blocks_and_cells_and_packets do b od)).to_string,""]
  );prints()

set mult([[(int,int,Param)]] packet)=((int,int,int)->int):(int orbit,int block,int cell):
let rv=0 in
for (b,c,p) in packet[orbit] do
 if b=block and c=cell then rv+:=1 fi
od;rv

set show_long(([([Param],[WCell])],[(int,int,Param)]) blocks_and_cells_and_packet)=void:
let (bc,packet)=blocks_and_cells_and_packet then
blocks=blocks(packet) then
cells=cells(packet) then
m=mult_block(packet) in
prints("*: dual(cell) contains an Aq(lambda)");
prints("*: dual(p) is an Aq(lambda)");
tabulate(
 ["block#","cell#","parameters", "inf. char."]#
  ##for b in blocks do
   ##for c in cells do
    for p in packet.parameters_map(b,c) do
     let (params,cells)=bc[b] then
     cell=cells[c] then
     cell_flag={if not is_integral(p.root_datum,p.infinitesimal_character) then false.star else} is_dual_Aq(params,cell).star {fi} then
     param_flag=if not is_integral(p.root_datum,p.infinitesimal_character) then false.star else is_dual_Aq(make_regular_irr(p)).star fi in
    [b.to_string,c.to_string+cell_flag,p.to_string+ param_flag, p.infinitesimal_character.to_string]
   od
  od
 od
     #["Total","",(#parameters(packet)).to_string,""]
  );prints()

set show_long([([([Param],[WCell])],[(int,int,Param)])] blocks_and_cells_and_packets)=void:
prints("*: dual(cell) contains an Aq(lambda)");
prints("*: dual(p) is an Aq(lambda)");
tabulate(
 ["orbit#","block#","cell#","parameters", "inf. char."]#
 ##for i:#blocks_and_cells_and_packets do
 let (bc,packet)=blocks_and_cells_and_packets[i] then
 blocks=blocks(packet) then
 packet_cells=cells(packet) in
{ m=mult_block(packet) in}
  ##for b in blocks do
   ##for c in packet_cells do
    for p in packet.parameters_map(b,c) do
     let (params,cells)=bc[b] then
     cell=cells[c] then
     cell_flag={if not is_integral(p.root_datum,p.infinitesimal_character) then false.star else} is_dual_Aq(params,cell).star {fi} then
     param_flag=if not is_integral(p.root_datum,p.infinitesimal_character) then false.star else is_dual_Aq(make_regular_irr(p)).star fi in
    [i.to_string,b.to_string,c.to_string+cell_flag,p.to_string+ param_flag, p.infinitesimal_character.to_string]
   od
  od
 od
od
     #["Total","","",(#parameters(##for (,b) in blocks_and_cells_and_packets do b od)).to_string,""]
  );prints()

set export([Param] parameters)=void:
prints("set parameters=[");
for p@i in parameters do
 let comma=if i<#parameters-1 then "," else "" fi then
 (,n)=%p.x, lambda=p.lambda, nu=p.nu in
 prints("parameter(G,",n,",",lambda,",",nu,")",comma) od;
prints("]")


{----------------more output routines---------------------------------}

set weak_packets([RealForm] list)=
##for G in list do
 ##for H in real_forms(G) do weak_packets(H)
od
od

set weak_packets_all_forms(RealForm G)=weak_packets([G])

set show_weak_packets_all_forms(RealForm G)=
let rf=real_forms(G) then
m=weak_packets_all_forms(G) in
for wp@i in m do prints(rf[i]); show(wp)
od

set show_weak_packets_all_forms_long([RealForm] groups)=void:
let rf=[RealForm]:[] then
()= for G in groups do rf##:=real_forms(G) od then
m=weak_packets(groups) in
prints(new_line,"Summary of weak packets:");for wp@i in m do
prints("------------------------------------------",new_line,rf[i]); show(wp) od

{--------------------inducing unipotents-----------------}

set induced_unipotents(RealForm G)=
remove_duplicates(
##for P in maximal_real_parabolics(G) do
 ##for p in unipotent_representations(P.Levi) do
  monomials(real_induce_irreducible(p,G))
 od
od)

{set show_long([([([Param],[WCell])],[(int,int,Param)])] blocks_and_cells_and_packets)=void:}

{show long, including flag to mark induced unipotents}
set show_long(( ( [([Param],[WCell])],    {wp} [(int,int,Param)] ),{[(int,int,Param)]} [Param])  {induced_unipotents} data)=
let (blocks_and_cells_and_packet,induced_unipotents)=data then
(bc,packet)=blocks_and_cells_and_packet then
blocks=blocks(packet) then
cells=cells(packet) then
m=mult_block(packet) in
tabulate(
 ["block#","cell#","parameters", "inf. char."]#
  ##for b in blocks do
   ##for c in cells do
    for p in packet.parameters_map(b,c) do
     let induced_flag=if find(induced_unipotents,p)>=0 then " " else " (I)" fi then
     (params,cells)=bc[b] in
    [b.to_string,c.to_string,p.to_string+ induced_flag, p.infinitesimal_character.to_string]
   od
  od
 od
     #["Total","",(#parameters(packet)).to_string,""]
  );prints()

set show_long(( [( [([Param],[WCell])],    {wp} [(int,int,Param)] )],{[(int,int,Param)]} [Param])  {induced_unipotents} data)=
let (blocks_and_cells_and_packets,induced_unipotents)=data in
tabulate(
 ["orbit#","block#","cell#","parameters", "inf. char."]#
 ##for i:#blocks_and_cells_and_packets do
 let (bc,packet)=blocks_and_cells_and_packets[i] then
 blocks=blocks(packet) then
 packet_cells=cells(packet) in
{ m=mult_block(packet) in}
  ##for b in blocks do
   ##for c in packet_cells do
    for p in packet.parameters_map(b,c) do
     let (params,cells)=bc[b] then
     cell=cells[c] then
     induced_flag=if find(induced_unipotents,p)>=0 then " " else " (I)" fi in
    [i.to_string,b.to_string,c.to_string,p.to_string+ induced_flag, p.infinitesimal_character.to_string]
   od
  od
 od
od
     #["Total","","",(#parameters(##for (,b) in blocks_and_cells_and_packets do b od)).to_string,""]
  );prints()



set induced_unipotents_long(RealForm G)=
let ind=induced_unipotents(G) then
all=unipotents(G) in
if not is_subset(ind,all) then prints("WARNING: not a subset") fi;
let comp=complement(ind,all) in
prints("#unipotents: ", #all,new_line, "#induced unipotents: ", #ind, new_line,
"#non-induced: ", #comp);
(ind,all,comp)

{see unipotent_conjecture.at for weak_packet_report@(RealForm,bool)
to optionally  include test_conjecture_report}
set weak_packet_report(RealForm G)=[([([Param],[WCell])],[(int,int,Param)])]:
let wp=weak_packets(G) in
prints(new_line,"===============================================================================");
show_nilpotent_orbits(G);prints();
show_short(wp);
show(wp);
show_long(wp);
prints(export(parameters(wp)));
wp

{same as previous, but including information about induced unipotents}
set weak_packet_report_ind(RealForm G)=[([([Param],[WCell])],[(int,int,Param)])]:
let wp=weak_packets(G) then
ind=induced_unipotents(G) in
prints(new_line,"===============================================================================");
show_nilpotent_orbits(G);prints();
show_short(wp);
show(wp);
show_long(wp,ind);
prints(export(parameters(wp)));
wp