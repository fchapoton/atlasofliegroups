<basic.at
<matrix.at { for |ech_up@(mat,[int])| }

{ General linear algebra over $\Z$. In so far as saturation of lattices is
  done, this actually relates to vector spaces over $\Q$, but all computations
  are done with integers only, distinguishing this script from Gaussian-elim.at
}

{ |M| is an $n\times k$ matrix, so columns of |M| span a $\Z$-submodule
  $ W=image(M)$ of $\Z^n$; get canonical generators for this submodule }
set image_lattice (mat M) = mat:
   let (M,,pivots,)=echelon(M) then c=#M
in for i@j in pivots
   do let col=M[j] then pivot=col[i]
   in for l: c-1-j from j+1 do M[l]-:=col*(M[i,l]\pivot) od
   od; M

{ whether |image_lattice(M)| is a saturated lattice (direct factor of $\Z^n$) }
set is_saturated (mat M) = bool:
   let (M,,pivots,)=echelon(M)
in set (M,):=ech_up(M,pivots); product(M.main_diagonal)=1

{ dimension |c| of image, together with a $\Z$-inverible matrix whose first |c|
  columns span that saturation of the image, the remainder a chosen complement }
set adapted_direct_sum (mat M) = (int,mat):
   let (M,,pivot,)=echelon(M) then (r,c)=shape(M), !M0=M
   then R=id_mat(r) { record row operations, held in inversed form }
in for j:c { loop over columns of M while it is being modified in the loop }
   do let col=M[j] then (d,C)=Bezout(col[j:pivot[j]+1]), tM=^M
   then tM_C=tM[j:pivot[j]+1] * C, R_C = R[j:pivot[j]+1] * ^C.inverse
   in M := c^ for i:r do if i<j or i>pivot[j] then tM[i] else tM_C[i-j] fi od
   ;  R := r# for i:r do if i<j or i>pivot[j] then  R[i] else  R_C[i-j] fi od
   ; assert(M[j,j]=d)
   od; assert(R*M=M0); (c,R)

set image_subspace (mat M) = mat: { generators for $\Q$-span of image of |M| }
   let (c,R)=adapted_direct_sum(M) in R[:c]

set image_complement_basis (mat M) = mat:
   let (c,R)=adapted_direct_sum(M) in R[c:]

set saturation = image_subspace@mat { intersetion of $\Z^n$ with $\Q$-span }

{ a basis representing the quotient by sublattice spanned by columns of |M|;
  tests that this sublattice is a direct factor, and throws an error if not }
set free_quotient_lattice_basis (mat M) = mat:
( let (E,,,)=echelon(M) in { pre-compute echelon }
  assert(E.is_saturated,"sublattice is not a direct factor")
; image_complement_basis(E)
)

{ a basis representing the quotient by saturation of sublattice, so no test }
set saturation_quotient_basis = image_complement_basis@mat


{ |M| is an $n\times k$ matrix; its columns span a submodule $W$ of $\Z^n$.
  Compute $n\times n$ matrix of projection onto the saturation (or $\Q$-span)
  of $W$, parallel to its complement from |adapted_sirect_sum(M)|.
}
set projector_to_image (mat M) = mat:
  let (c,R)=adapted_direct_sum(M) in R[ : , :c] * R.inverse[ :c, : ]


{ complementary projector, to chosen complement to |image_subspace(M)| }
set projector_mod_image (mat M) = mat:
  let (c,R)=adapted_direct_sum(M) in R[ : ,c: ] * R.inverse[c: , : ]

{ |M| is an $n\times k$ matrix; its columns span a submodule $W$ of $\Z^n$.
  A complement to |image_subspace(M)| is chosen by |adapted_direct_sum(M)|, and
  |decompose(M,w)=(u,v)| with |u| in |image_subspace(M)| and |v| in complement.
}
set decompose (mat M, vec v)= (vec,vec):
   let (c,R)=adapted_direct_sum(M) then R1=R.inverse
in (R[:,:c] * (R.inverse[:c,:] * v), R[:,c:] * (R.inverse[c:,:] * v) )

set decompose (mat M, ratvec w) = (ratvec,ratvec):
   let (v,d)=%w then (v1,v2)=decompose(M,v) in (v1/d,v2/d)


{ assuming M injective and Im(M) is A-stable, find unique B with A*M=M*B }
set restrict_action (mat A, mat M) = mat:
   #M # { every solution has size given my number of columns of M }
   for v in M
   do case solve(M,A*v)
      | ().no_solution: error("Image lattice M is not fixed by A")
      | w.solution: w
      esac
   od


{ assuming M full row rank and ker(M) is A-stable, find unique B with M*A=B*M }
set corestrict_action (mat A, mat M) = mat: { formal dual to |restrit_action| }
   let tM=^M in
   #tM ^ { every solution has size given my number of rows of M }
   for v in tM
   do case solve(tM,v*A)
      | ().no_solution: error("Kernel of M is not fixed by A")
      | w.solution: w
      esac
   od

{ |M| is an $n\times k$ matrix; its columns span a subspace $W$ of $\Q^n$.
  Assuming this subspace is |A|-stable, |A| induces an operator in $\Q^n/W$;
  return its matrix w.r.t the complement chosen by |adapted_direct_sum(M)|.
}
set quotient_matrix (mat A,mat M) = mat:
  let (c,R)=adapted_direct_sum(M) in (R.inverse[c: , : ]*A*R[ : ,c: ])

set solve_ratvec (mat A, vec v) = ratvec:
  (A,ratvec:v).solve.(rat_requisition("not in span"))

{ integer vector (lattice) solutions to linear system }


set in_lattice (mat A, ratvec u) = bool: { whether v in image lattice of A }
  let (b,n)=%u in n=1 and solve(A,b).any

set vec_solve (mat A, ratvec u) = maybe_a_vec: { integer solution to A*x=b }
  let (b,n)=%u in if n>1 then no_solution() else solve(A,b) fi

{ express columns of M relative to basis A of a sub-lattice that contains them
  A: nxm matrix, columns are a basis of a Z-module V of rank m
  M: nxr matrix, columns span a submodule of V; returns mxr matrix C,
  column i gives column i of M as a sum of columns of A i.e., A*C=M
}
set in_lattice_basis (mat A,mat M) = mat:
  #A { size m of solutions } # for v in M do required_solution(A,v) od
