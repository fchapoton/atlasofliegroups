<basic.at
<character_tables.at { for the type }
<springer_tables.at { for the type }
<geck_generic.at { for |lookup_springer_table| }
set fig_verbose=false
{W-rep sigma -> special W-rep sigma_s}
{

1) sigma =Springer(O,chi) -> Springer(O_s) where O is in the special piece of O_s

2) different algorithm (that doesn't require Springer(O,chi), which we don't currently have)

Theorem (Lusztig).

1a) Suppose L is a Levi in G, and CL is a left cell of W(L). Then TGInd(CL) is a left cell for W.

b) Suppose C is a left cell in W. Then C\otimes sgn is also a left cell in W.

c) If W \ne 1, then for any left cell C in W, there is a proper L and a left cell CL in L so that
  EITHER TGInd(CL) = C, OR TGIND(CL\otimes sgn) = C\otimes sgn.

*********
So here is the algorithm for finding the special W-rep sigma_s attached to sigma.

-1) if sigma is special return sigma (this step isn't necessary but speeds up the algorithm)
0)  If W is trivial, then sigma_s = sigma = trivial. Assume W not trivial.
1)  Try to find a proper Levi L and a W(L)-rep sigmaL so that sigma is contained in TGInd(sigmaL);
    if you succeed, then sigma_s = TFInd(sigmaL_s) = TGInd(sigmaL_s).
2)  If you fail, replace sigma by sigmaSgn = sigma\otimes sgn. Step 1) is guaranteed to succeed for sigmaSgn, giving sigmaSgn_s.
3)  The dual special orbit to sigmaSgn_s (found by the duality algorithm) has Springer rep sigma_s.

{note on 3:  sigma -> sigmaSgn -> sigmaSgn_s -> orbit_sgn -> dual(orbit_sgn) -> sigma_s
except in exceptional cases in E7/E8: sigma_s=sigmaSgn_s\otimes sgn}
}

{given G, tables=all_levi_Springer_tables(G), int char_G
the algorithm produces
[(L_n,table_n,char_n),...(L_1,table_1,char_1),(G,0,char_G)
where each table_j,char_j is an integer
start with tables[table_n].characters[char_n], this is special
j-induction takes you

}



{extract all terms sigma from given (reducible) character satisfying f(sigma)=desired_value
 usually f = generic or fake degree}
set select(CharacterTable ct, [int] character, int desired_value, (int->int) function)=[(int,int)]:
let dec=ct.decompose(character)  {[int]} in
##for i:#dec do
 if dec[i]>0 and function(i)=desired_value then  [(i,dec[i])] else[] fi
od

{select by fake degree}
set select_degree(CharacterTable ct, [int] character, int desired_value)=[(int,int)]:
select(ct,character,desired_value,ct.degree)

{select by generic degree}
set select_generic_degree(CharacterTable ct, [int] character, int desired_value)=[(int,int)]:
select(ct,character,desired_value,ct.generic_degree)

{select by two function values f_i(sigma)=desired_value_i}
set select(CharacterTable ct, [int] character, int desired_value_1,int desired_value_2, (int->int) function_1,(int->int) function_2)=[(int,int)]:
let dec=ct.decompose(character)  {[int]} in
##for i:#dec do
 if dec[i]>0 and function_1(i)=desired_value_1 and function_2(i)=desired_value_2  then  [(i,dec[i])] else[] fi
od

{select all terms with specified fake degree and (possibly different) generic degree}
set select_both_degrees\
 ( CharacterTable ct
 , [int] character
 , int desired_value_fake
 , int desired_value_generic
 ) = [(int,int)]:
select(ct,character,desired_value_fake,desired_value_generic,ct.degree,ct.generic_degree)

{J-induction from Lusztig's orange book page 77}
{induce sigma_L from W(L) to W(G), and keep terms sigma with gdeg(sigma)=gdeg(sigma_L)}
set J_induce (CharacterTable ct_L,CharacterTable ct_G,int index_character_L) =
( select_generic_degree
    (ct_G
    ,induce_character(ct_L.class_table
		     ,ct_G.class_table
		     ,ct_L.character(index_character_L))
    , ct_L.generic_degree(index_character_L)
    )
)

{J-induction from Lusztig's orange book page 77}
{induce sigma_L from W(L) to W(G), and keep terms sigma with gdeg(sigma)=gdeg(sigma_L)}
set J_induce (CharacterTable ct_L,RootDatum L,CharacterTable ct_G,int index_character_L) =
( select_generic_degree
    (ct_G
    ,induce_character(ct_L.class_table
		     ,L
		     ,ct_G.class_table
		     ,ct_L.character(index_character_L))
    , ct_L.generic_degree(index_character_L)
    )
)


{j-induction from Lusztig's orange book page 77}
{induce sigma_L from W(L) to W(G), and keep terms sigma with fdeg(sigma)=fdeg(sigma_L)}
set j_induce (CharacterTable ct_L,CharacterTable ct_G,int index_character_L)=
( select_degree
    (ct_G
    ,induce_character(ct_L.class_table
		     ,ct_G.class_table
		     ,ct_L.character(index_character_L))
    , ct_L.degree(index_character_L)
    )
)

set j_induce (CharacterTable ct_L,RootDatum L,CharacterTable ct_G,int index_character_L)=
( select_degree
    (ct_G
    ,induce_character(ct_L.class_table
		     ,L
		     ,ct_G.class_table
		     ,ct_L.character(index_character_L))
    , ct_L.degree(index_character_L)
    )
)


{induce sigma_L from W(L) to W(G), and keep terms sigma with gdeg(sigma)=gdeg(sigma_L) AND fdeg(sigma)=fdeg(sigma_L)}
set jJ_induce(CharacterTable ct_L,CharacterTable ct_G,int index_character_L) =
( select_both_degrees
    (ct_G
    ,induce_character(ct_L.class_table
		     ,ct_G.class_table
		     ,ct_L.character(index_character_L))
    , ct_L.degree(index_character_L)
    , ct_L.generic_degree(index_character_L)
    )
)

{induce sigma_L from W(L) to W(G), and keep terms sigma with gdeg(sigma)=fdeg(sigma)=desired_degree}
set jJ_select_induce\
  (CharacterTable ct_L
  ,CharacterTable ct_G
  ,int index_character_L
  ,int desired_degree)=
( select_both_degrees
    (ct_G
    ,induce_character(ct_L.class_table
		     ,ct_G.class_table
		     ,ct_L.character(index_character_L)
		     )
    ,desired_degree
    ,desired_degree
    )
)

{given G and Levi subgroups L,M of G
 satisfying: L is G-conjugate to a Levi subgroup of M
 find the Levi subgroup L' of M which is G-conjugate to L
application:
G, tables=[SpringerTable] for Levi subgroups of G
L,G in list of Levi subgroups of G
have the Springer tables tables[i] for M, tables[j] for L
Can induce from W(L) to W(G)
Want to induce from [conjugate of] W(L) to W(M)
need to find L'\subset M which is G-conjugate to L}

set find_Levi(RootDatum G,RootDatum M,RootDatum L)=
let L_std= standard_Levi(G,L) then
levis_M=Levi_subgroups(M) then
index=first(for Lprime in Levi_subgroups(M) do standard_Levi(G,Lprime)=L_std od) then
levi_M=levis_M[index] in
(levi_M,standard_Levi_witness(G,levi_M)

{not good enough to use local_isomorphism}
set find_Levi(RootDatum G,RootDatum L)=
let levis=Levi_subgroups(G) then
index=first(for M in levis do is_locally_isomorphic(L,M) od)
in (index,levis[index],local_isomorphism(L.derived,levis[index].derived))


{assume generic degrees have been computed for all levis}
set find_induced_generic([SpringerTable] levi_tables,
                         int index_table_G {index of table in list},
			 int index_char_G) {index of character in table_G}\
			 =(bool,([SpringerTable],int,int)):  {(success/failure),[tables], index_table_L, index_char_L}
let ()=if fig_verbose then
    prints("find_induced_generic", new_line, "index_table_G=", index_table_G, " index_char_G=", index_char_G) fi in
if  levi_tables[index_table_G].root_datum.is_abelian then
  return(true,(levi_tables,index_table_G,index_char_G))
else
 let st=levi_tables[index_table_G] then
 ct=st.ct then
 G=ct.root_datum then
 pi_G=ct.characters[index_char_G] then
 gdeg=ct.generic_degree(index_char_G) then
 ()=if fig_verbose then prints("generic degree: ", gdeg) fi in
  let levis_0=proper_Levi_subgroups(G) then
  levis=for i:#levis_0 do levis_0[i] od in
  for L in levis do
   let (index_table_L,)=lookup_springer_table(L,levi_tables) in
   let ()=if fig_verbose then prints("index_table_G: ", index_table_G,new_line,
             "index_char_G: ", index_char_G,new_line,"loop index_table_L=",index_table_L,new_line,
             "----------------------------------------------",
	     new_line, "index_table_G: ", index_table_G,new_line,"index_table_L: ", index_table_L,
	     new_line,"L=", levi_tables[index_table_L].root_datum, new_line) fi in
   let table_L=levi_tables[index_table_L] in
{   ()=show(tables[0].ct) in}
   for index_char_L:table_L.ct.n_classes do
     let ()= if fig_verbose then
         prints("trying: index_table_L=",index_table_L, " ", "index_char_L=",index_char_L, " ",table_L.generic_degree(index_char_L), new_line,
	 "gdeg:", gdeg) fi in
   if table_L.generic_degree(index_char_L)=gdeg then
    let ()=if fig_verbose then prints("has correct generic degree: #", index_char_L) fi in
{    let ()=prints("TEST", tables[0].root_datum, " ", ct.root_datum, " ", L) in}
    let (Lprime,w)=find_Levi(tables[0].root_datum,ct.root_datum,L) then  {w*Lprime=standard ind G}
   ()=prints("Lprime=", Lprime, "test:", Lprime=standard_Levi(tables[0].root_datum,Lprime)) in
let   ()=prints("index_table_G: ", index_table_G) in
let   ()=prints("index_table_L: ", index_table_L) in
let ()=prints("table_L: ", table_L.root_datum) in {
let   ()=prints("Lprime.simpleroots: ", Lprime.simple_roots) in
let  ()=prints("index_char_L: ", index_char_L) in}
let ind_all=induce_character_plus(table_L.ct,Lprime,tables[index_table_G].ct,table_L.ct.characters[index_char_L]) then

()= if fig_verbose then prints("L=",table_L.root_datum, new_line,"ct=",ct.root_datum,new_line,"ind_all: ");ct.view_char(ind_all) fi then
      ()=if fig_verbose then prints(table_L.ct.root_datum, " ", ct.root_datum, " ", index_char_L) fi then
    ind=J_induce(table_L.ct,L,ct,index_char_L)  then  {ind = [(index,mult)]}
      ()=if fig_verbose then prints("J_induction: ", ind) fi in
    if find(for (j,) in ind do j od,index_char_G)!=-1 then
       if fig_verbose then prints("found") fi;
    return(true,(levi_tables,index_table_L,index_char_L)) fi
    fi
   od   {end for index_char_L:table.n_classes}
  od;    {end for index_table_L:#levi_tables-1}
   return(false,([SpringerTable]:[],-1,-1))
fi

{assume generic degrees have been computed for all levis}
{algorithm sketched above: compute (L,sigma_L_s), then sigma_s= ind(sigma_L_s) (selected by both fake and generic degree)}
set special_geck_data([SpringerTable] levi_springer_tables, int index_table_G, (int index_char_G,bool tensor_sgn))=
([SpringerTable],[(RootDatum,int,(int,bool))]):   {([tables],(L,index_table_L,(index_char_L,bool_tensor_sgn))}
let ()=if fig_verbose then
   prints("find_smooth: ","index_table_G: ", index_table_G, "index_char_G: ", index_char_G, " tensor_sign:", tensor_sgn) fi in
let st=levi_springer_tables[index_table_G] then
ct=st.ct then
G=ct.root_datum in
let rec_fun my_function([SpringerTable] levi_tables,[(RootDatum,int,(int,bool))] triples)=(([SpringerTable],[RootDatum,int,(int,bool)])):
 let (L,index_table_L,(index_char_L,tensor_sign))=triples[0] in
 if is_abelian(L)
  then return(levi_tables,triples)
 elif levi_springer_tables[index_table_L].is_special_representation(index_char_L) then
  return(levi_tables,triples)
 else {/is_abelian}
 let (success,g_induced)=find_induced_generic(levi_springer_tables,index_table_L,index_char_L) in
 if success then
  let ()=if fig_verbose then prints("success", "L=",L) fi in
  let (,new_table_index,new_char_index)=g_induced then
  new=(levi_tables[new_table_index].root_datum,new_table_index,(new_char_index,false)) then
  ()=triples:=new#triples in
  my_function(levi_springer_tables,triples)
 else
   let ()=prints("AA") in
   let ()=if fig_verbose then prints("failure,sgn") fi in
   let (success_sgn,g_induced_sgn)=
   find_induced_generic(levi_springer_tables,index_table_L,levi_springer_tables[index_table_L].ct.tensor_sign_index(index_char_L)) in
   if success_sgn then
   let ()=prints("SSS") in
   let (,new_table_index,new_char_index)=g_induced_sgn  {in my_function(levi_springer_tables,new_table_index,new_char_index)}  then
   new=(levi_tables[new_table_index].root_datum,new_table_index,(new_char_index,true)) then
   ()=triples:=new#triples in
   my_function(levi_springer_tables,triples)
 {  then new_levi_springer_table=levi_springer_tables[new_table_index] then
    then orbit_sgn=springer_inverse(new_levi_springer_table,new_char_index)  then
    dual_orbit_sgn=new_levi_springer_table.dual_map(orbit_sgn) then}
{    in let ()=prints("L=",L, "new_table_index=", new_table_index,"new_char_index=", new_char_index)  }
{  (levi_springer_tables,triples#(levi_springer_tables[new_table_index].root_datum,new_table_index,levi_springer_tables[new_table_index].ct.tensor_sign_index(new_char_index)))}
   else
    assert(false,"error!!");return (levi_tables,triples) {should never get here, but need to return a value}
   fi  {if success_sgn}
  fi
 fi in  my_function(levi_springer_tables,[(G,index_table_G,(index_char_G,false))])

set special_geck_data([SpringerTable] levi_springer_tables, int index_table_G,int index_char_G)=
([SpringerTable],[(RootDatum,int,(int,bool))]):   {([tables],(L,index_table_L,(index_char_L,bool_tensor_sgn))}
special_geck_data(levi_springer_tables,index_table_G,(index_char_G,true))

set special_geck_data([SpringerTable] levi_springer_tables,int index_char_G)=
([SpringerTable],[(RootDatum,int,(int,bool))]):   {([tables],(L,index_table_L,(index_char_L,bool_tensor_sgn))}
special_geck_data(levi_springer_tables,0,index_char_G)

set all_levi_Springer_tables(RootDatum G)=[SpringerTable]:
let tables=all_levi_springer_tables(G) then
()=update_generic_degrees_geck(tables) in tables


set collapse([SpringerTable] tables, [(RootDatum,int,(int,bool))] triples)=(RootDatum,int,(int,bool)):
if #triples=1 then
 if fig_verbose then prints("collapse: returning special") fi;triples[0]
elif #triples=2 then
 if fig_verbose then prints("collapse: returning one step") fi;triples[0]
else
 let ()=if fig_verbose  then prints("collapsing, #triples=", #triples) fi then
working_triple=triples[0] in
for i:#triples-2 do
 let ()=if fig_verbose then prints("doing i=", i) fi in
 let (L,index_table_L,(index_char_L,tensor_sign_L))=triples[i] then
 ()=if fig_verbose then prints("L=", L,new_line, "index_table_L=", index_table_L,new_line, "index_char_L=", index_char_L,new_line,"tensor_sign_L: ", tensor_sign_L) fi then
 (M,index_table_M,(index_char_M,tensor_sign_M))=triples[i+1] then
 ()=if fig_verbose then prints("index_table_M=", index_table_M) fi then
 Lprime=find_Levi(tables[0].root_datum,tables[index_table_M].root_datum,L) then
 {if tensor_sign_M=true, then
    sigma_L -> sigma_L\otimes sign -> J_ind(sigma_L*sgn) -> [ J_ind(sigma_L*sgn)]*sgn
}
 (index_char_M,)={j}{J}j_induce(tables[index_table_L].ct,Lprime,tables[index_table_M].ct,index_char_L)[0] then  {note L here}
 ()=if tensor_sign_L then index_char_M:=tables[index_table_M].ct.tensor_sign_index(index_char_M) fi in
{ let ()=prints("step i: ",i,new_line, "M=", M,new_line, " L=", L, new_line,"index_char_L=", index_char_L, new_line,
" index_char_M: ", index_char_M, new_line) in}
 assert(tables[index_table_M].is_special_representation(index_char_M),"character of M is not special");
 working_triple:=(M,index_table_M,(index_char_M,tensor_sign_M))
od;
working_triple
fi

set to_special_geck_long([SpringerTable] levi_springer_tables, int index_table_G, (int index_char_G,bool tensor_sign))=(int,RootDatum,int,int,int):
let (,triples)=special_geck_data(levi_springer_tables,index_table_G,(index_char_G,tensor_sign)) then
(L,index_table_L,(index_char_L,tensor_sign_L))=collapse(levi_springer_tables,triples) then
ct=levi_springer_tables[index_table_G].ct then
ct_L=levi_springer_tables[index_table_L].ct then
{no: target index is just index_char_G, since this is just providing the generic degree}
{target_index=
 if tensor_sign_L
  then ct.tensor_sign_index(index_char_G)
 else
  index_char_G
 fi
}
target_index=index_char_G then
target_generic_degree=ct.generic_degree(target_index) then
Lprime=find_Levi(ct.root_datum,ct.root_datum,L) then
{Lprime=L  then}
ind=induce_character(ct_L,Lprime,ct,ct_L.characters[index_char_L])  then
()=if tensor_sign_L then ind:=ct.tensor_sign(ind) fi then
char=select_both_degrees(ct,ind,target_generic_degree,target_generic_degree) in
{assert(#char=1,"#char \ne 1, char="+ char.to_string);  may fail}
let (index,mult)=char[0] in
 if mult !=1 then prints("warning: multiplicity for index ", index," is: ", mult) fi;
{index:=
 if tensor_sign_L then ct.tensor_sign_index(index) else index fi;
{no: already tensored with sign}
}
assert(ct.generic_degree(index)=ct.degree(index),"not special");
(index_table_L,L,index_table_G,index_char_L,index)

set to_special_geck_long([SpringerTable] levi_springer_tables, int index_table_G,int index_char_G)=(int,RootDatum,int,int,int):
to_special_geck_long(levi_springer_tables,index_table_G,(index_char_G,true))

set to_special_geck_long([SpringerTable] levi_springer_tables, int index_char_G)=(int,RootDatum,int,int,int):
to_special_geck_long(levi_springer_tables,0,(index_char_G,true))

set to_special_geck([SpringerTable] levi_springer_tables, int index_table_G,int index_char_G)=int:
let (,,,,index)=to_special_geck_long(levi_springer_tables,index_table_G,(index_char_G,true)) in index

set to_special_geck([SpringerTable] levi_springer_tables, int index_char_G)=int:
to_special_geck(levi_springer_tables,0,index_char_G)

set test_special_geck([SpringerTable] tables)=void:
let ct=tables[0].ct then
all=for i:ct.n_classes do to_special_geck_long(tables,i) od in
prints("G=", tables[0].root_datum.nice_format);
tabulate(
["sigma","deg/gdeg", "rep_name", "sigma_s","deg/gdeg", "name"]#
for i:#all do
 let (a,b,c,d,i_s)=all[i] in
[i.to_string,ct.degree(i).to_string + "/" + ct.generic_degree(i),ct.irreducible_label(i),
i_s.to_string,
ct.degree(i_s).to_string + "/" + ct.generic_degree(i_s),
ct.irreducible_label(i_s)] od);prints("");
show(tables[0]);prints("");show(tables[0].ct)

{for convenience}
set induce([SpringerTable] tables,int index_table_L, int index_table_G, int index_char_L)=[int]:
induce_character(tables[index_table_L].ct,tables[index_table_G].ct, tables[index_table_L].characters[index_char_L])

set induce([SpringerTable] tables,(int index_table_L, int index_table_G, int index_char_L))=[int]:
induce_character(tables[index_table_L].ct,tables[index_table_G].ct, tables[index_table_L].characters[index_char_L])

set induce_view([SpringerTable] tables,int index_table_L, int index_table_G, int index_char_L)=void:
tables[index_table_G].ct.view_char(induce(tables,index_table_L,index_table_G,index_char_L))

set to_special(RootDatum G)=(int->int):
assert(G.derived.is_simple,"G must be simple");
let (type,rank)=simple_type(G) in
 assert(type="E" or type="F" or type="G", "G must be exceptional");
 if type="G" and rank=2 then to_special_G2@int
 elif type="F" and rank=4 then to_special_F4@int
 elif type="E" and rank=6 then to_special_E6@int
 elif type="E" and rank=7 then to_special_E6@int
 elif type="E" and rank=8 then to_special_E6@int
 else error("something is terribly wrong")
fi

set to_special(RootDatum G,int i)=int:to_special(G)(i)

set test_special_maps(RootDatum G)=bool:
let tables=all_levi_Springer_tables(G) in
all(for i:tables[0].ct.n_classes do
to_special(G,i)=to_special_geck(tables,i) od)

set test_special_maps([RootDatum] groups)=[bool]:
for G in groups do 
let result=test_special_maps(G) in prints(G.nice_format, ": ", result);result od

set test_special_maps()=
let groups=[
simply_connected(G2)
,simply_connected(F4)
,simply_connected(E6)
,simply_connected(E7)
{,simply_connected(E8)}]
in test_special_maps(groups)


set induce([SpringerTable] tables, int table_L, int table_G,int char_L)=
let ct_L=tables[table_L].ct then
ct_G=tables[table_G].ct then
M=find_Levi(tables[0].root_datum,ct_G.root_datum, ct_L.root_datum) in
induce_character(ct_L,M,ct_G,ct_L.characters[char_L])




