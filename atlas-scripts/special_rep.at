{W-rep sigma -> special W-rep sigma_s}
{

1) sigma =Springer(O,chi) -> Springer(O_s) where O is in the special piece of O_s

2) different algorithm (that doesn't require Spriner(O,chi), which we don't currently have)

Theorem (Lusztig).

1a) Suppose L is a Levi in G, and CL is a left cell of W(L). Then TGInd(CL) is a left cell for W.

b) Suppose C is a left cell in W. Then C\otimes sgn is also a left cell in W.

c) If W \ne 1, then for any left cell C in W, there is a proper L and a left cell CL in L so that EITHER TGInd(CL) = C, OR TGIND(CL\otimes sgn) = C\otimes sgn.

*********
So here is the algorithm for finding the special W-rep sigma_s attached to sigma.

-1) if sigma is special return sigma (this step isn't necessary but speeds up the algorithm)
0)  If W is trivial, then sigma_s = sigma = trivial. Assume W not trivial.
1)  Try to find a proper Levi L and a W(L)-rep sigmaL so that sigma is contained in TGInd(sigmaL);
    if you succeed, then sigma_s = TFInd(sigmaL_s) = TGInd(sigmaL_s).
2)  If you fail, replace sigma by sigmaSgn = sigma\otimes sgn. Step 1) is guaranteed to succeed for sigmaSgn, giving sigmaSgn_s.
3)  The dual special orbit to sigmaSgn_s (found by the duality algorithm) has Springer rep sigma_s.

{note on 3:  sigma -> sigmaSgn -> sigmaSgn_s -> orbit_sgn -> dual(orbit_sgn) -> sigma_s
except in exceptional cases in E7/E8: sigma_s=sigmaSgn_s\otimes sgn}
}

{given G, tables=all_levi_Springer_tables(G), int char_G
the algorithm produces
[(L_n,table_n,char_n),...(L_1,table_1,char_1),(G,0,char_G)
where each table_j,char_j is an integer
start with tables[table_n].characters[char_n], this is special
j-induction takes you 

}

set fig_verbose=false

{extract all terms sigma from given (reducible) character satisfying f(sigma)=desired_value
 usually f = generic or fake degree}
set select(CharacterTable ct, [int] character, int desired_value, (int->int) function)=[(int,int)]:
let dec=ct.decompose(character)  {[int]} in
##for i:#dec do
 if dec[i]>0 and function(i)=desired_value then  [(i,dec[i])] else[] fi
od

{select by fake degree}
set select_degree(CharacterTable ct, [int] character, int desired_value)=[(int,int)]:
select(ct,character,desired_value,ct.degree)

{select by generic degree}
set select_generic_degree(CharacterTable ct, [int] character, int desired_value)=[(int,int)]:
select(ct,character,desired_value,ct.generic_degree)

{select by two function values f_i(sigma)=desired_value_i}
set select(CharacterTable ct, [int] character, int desired_value_1,int desired_value_2, (int->int) function_1,(int->int) function_2)=[(int,int)]:
let dec=ct.decompose(character)  {[int]} in
##for i:#dec do
 if dec[i]>0 and function_1(i)=desired_value_1 and function_2(i)=desired_value_2  then  [(i,dec[i])] else[] fi
od

{select all terms with specified fake degree and (possibly different) generic degree}
set select_both_degrees(CharacterTable ct, [int] character, int desired_value_fake,int desired_value_generic)=[(int,int)]:
select(ct,character,desired_value_fake,desired_value_generic,ct.degree,ct.generic_degree)

{J-induction from Lusztig's orange book page 77}
{induce sigma_L from W(L) to W(G), and keep terms sigma with gdeg(sigma)=gdeg(sigma_L)}
set J_induce(CharacterTable ct_L,CharacterTable ct_G,int index_character_L)=
select_generic_degree(ct_G,induce_character(ct_L,ct_G,ct_L.characters[index_character_L]), ct_L.generic_degree(index_character_L))

{also version with RootDatum L included}
set J_induce(CharacterTable ct_L,RootDatum L,CharacterTable ct_G,int index_character_L)=
select_generic_degree(ct_G,induce_character(ct_L,L,ct_G,ct_L.characters[index_character_L]), ct_L.generic_degree(index_character_L))

{j-induction from Lusztig's orange book page 77}
{induce sigma_L from W(L) to W(G), and keep terms sigma with fdeg(sigma)=fdeg(sigma_L)}
set j_induce(CharacterTable ct_L,CharacterTable ct_G,int index_character_L)=
select_degree(ct_G,induce_character(ct_L,ct_G,ct_L.characters[index_character_L]), ct_L.degree(index_character_L))

{also version with RootDatum L included}
set j_induce(CharacterTable ct_L,RootDatum L,CharacterTable ct_G,int index_character_L)=
select_degree(ct_G,induce_character(ct_L,L,ct_G,ct_L.characters[index_character_L]), ct_L.degree(index_character_L))

{induce sigma_L from W(L) to W(G), and keep terms sigma with gdeg(sigma)=gdeg(sigma_L) AND fdeg(sigma)=fdeg(sigma_L)}
set jJ_induce(CharacterTable ct_L,CharacterTable ct_G,int index_character_L)=
select_both_degrees(ct_G,induce_character(ct_L,ct_G,ct_L.characters[index_character_L]),
		      ct_L.degree(index_character_L),ct_L.generic_degree(index_character_L))

{also version with RootDatum L included}
set jJ_induce(CharacterTable ct_L,RootDatum L,CharacterTable ct_G,int index_character_L)=
select_both_degrees(ct_G,induce_character(ct_L,L,ct_G,ct_L.characters[index_character_L]),
		      ct_L.degree(index_character_L),ct_L.generic_degree(index_character_L))

{induce sigma_L from W(L) to W(G), and keep terms sigma with gdeg(sigma)=fdeg(sigma)=desired_degree}
set jJ_select_induce(CharacterTable ct_L,CharacterTable ct_G,int index_character_L,int desired_degree)=
select_both_degrees(ct_G,induce_character(ct_L,ct_G,ct_L.characters[index_character_L]),desired_degree,desired_degree)


{assume generic degrees have been computed for all levis}
set find_induced_generic([SpringerTable] levi_tables,
                         int index_table_G {index of table in list},
			 int index_char_G) {index of character in table_G}\
			 =(bool,([SpringerTable],int,int)):  {(success/failure),[tables], index_table_L, index_char_L}
let ()=if fig_verbose then
    prints("find_induced_generic", new_line, "index_table_G=", index_table_G, " index_char_G=", index_char_G) fi in
if  levi_tables[index_table_G].root_datum.is_abelian then
  return(true,(levi_tables,index_table_G,index_char_G))
else
 let st=levi_tables[index_table_G] then
 ct=st.ct then
 G=ct.root_datum then
 pi_G=ct.characters[index_char_G] then
 gdeg=ct.generic_degree(index_char_G) then
 ()=if fig_verbose then prints("generic degree: ", gdeg) fi in
  let levis_0=proper_Levi_subgroups(G) then
  levis=for i:#levis_0 do levis_0[i] od in
  for L in levis do
   let (index_table_L,)=lookup_springer_table(L,levi_tables) in
   let ()=if fig_verbose then prints("index_table_G: ", index_table_G,new_line,
             "index_char_G: ", index_char_G,new_line,"loop index_table_L=",index_table_L,new_line,
             "----------------------------------------------",
	     new_line, "index_table_G: ", index_table_G,new_line,"index_table_L: ", index_table_L,
	     new_line,"L=", levi_tables[index_table_L].root_datum, new_line) fi in
   let table_L=levi_tables[index_table_L] in
{   ()=show(tables[0].ct) in}
   for index_char_L:table_L.ct.n_classes do
     let ()= if fig_verbose then
         prints("trying: index_table_L=",index_table_L, " ", "index_char_L=",index_char_L, " ",table_L.generic_degree(index_char_L), new_line,
	 "gdeg:", gdeg) fi in
   if table_L.generic_degree(index_char_L)=gdeg then
    let ()=if fig_verbose then prints("has correct generic degree: #", index_char_L) fi in
   let ind_all=induce_character(table_L.ct,L,ct,table_L.ct.characters[index_char_L]) then
      ()= if fig_verbose then prints("L=",table_L.root_datum, new_line,"ind_all: ");ct.view_char(ind_all) fi then
    ind=J_induce(table_L.ct,L,ct,index_char_L)  then  {ind = [(index,mult)]}
      ()=if fig_verbose then prints("J_induction: ", ind) fi in
    if find(for (j,) in ind do j od,index_char_G)!=-1 then
       if fig_verbose then prints("found") fi;
    return(true,(levi_tables,index_table_L,index_char_L)) fi
    fi
   od   {end for index_char_L:table.n_classes}
  od;    {end for index_table_L:#levi_tables-1}
   return(false,([SpringerTable]:[],-1,-1)) 
fi

{assume generic degrees have been computed for all levis}
{algorithm sketched above: compute (L,sigma_L_s), then sigma_s= ind(sigma_L_s) (selected by both fake and generic degree)}
set special_long([SpringerTable] levi_springer_tables, int index_table_G, int index_char_G)=
([SpringerTable],[(RootDatum,int,int)]):   {([tables],(L,index_table_L,index_char_L))}
let ()=if fig_verbose then prints("find_smooth: ", "index_table_G: ", index_table_G, "index_char_G: ", index_char_G) fi in
let st=levi_springer_tables[index_table_G] then
ct=st.ct then
G=ct.root_datum in
let rec_fun my_function([SpringerTable] levi_tables,[(RootDatum,int,int)] triples)=(([SpringerTable],[RootDatum,int,int])):
 let (L,index_table_L,index_char_L)=triples~[0] in
 if is_abelian(L)
  then return(levi_tables,triples)
 elif levi_springer_tables[index_table_L].is_special_representation(index_char_L) then
  return(levi_tables,triples)
 else {/is_abelian}
 let (success,g_induced)=find_induced_generic(levi_springer_tables,index_table_L,index_char_L) in
 if success then
  let ()=if fig_verbose then prints("success", "L=",L) fi in
  let (,new_table_index,new_char_index)=g_induced in
  let new=triples#(levi_tables[new_table_index].root_datum,new_table_index,new_char_index) in
  let ()=if fig_verbose then prints("L=",L,new_line,"new_table_index=",new_table_index) fi in
  my_function(levi_springer_tables,new)
 else
   let ()=if fig_verbose then prints("failure,sgn") fi in
   let (success_sgn,g_induced_sgn)=
   find_induced_generic(levi_springer_tables,index_table_L,levi_springer_tables[index_table_L].ct.tensor_sign_index(index_char_L)) in
   if success_sgn then
    let (,new_table_index,new_char_index)=g_induced_sgn  {in my_function(levi_springer_tables,new_table_index,new_char_index)}  in
 {  then new_levi_springer_table=levi_springer_tables[new_table_index] then
    then orbit_sgn=springer_inverse(new_levi_springer_table,new_char_index)  then
    dual_orbit_sgn=new_levi_springer_table.dual_map(orbit_sgn) then}
{    in let ()=prints("L=",L, "new_table_index=", new_table_index,"new_char_index=", new_char_index)  }
  (levi_springer_tables,triples#(levi_springer_tables[new_table_index].root_datum,new_table_index,levi_springer_tables[new_table_index].ct.tensor_sign_index(new_char_index)))
   else
    assert(false,"error!!");return (levi_tables,triples) {should never get here, but need to return a value}
   fi  {if success_sgn}
  fi
 fi in  my_function(levi_springer_tables,[(G,index_table_G,index_char_G)])


set all_levi_Springer_tables(RootDatum G)=[SpringerTable]:
let tables=all_levi_springer_tables(G) then
()=update_generic_degrees_geck(tables) in tables


set collapse([SpringerTable] tables, [(RootDatum,int,int)] triples)=
if #triples=1 then triples[0]
elif #triples=2 then triples[1] 
else
{first put the triples in increasing order}
let triples=for i:#triples do triples~[i] od then
working_triple=triples[0] in
for i:#triples-2 do
 let (L,index_table_L,index_char_L)=triples[i] in
 let (M,index_table_M,index_char_M)=triples[i+1] in
{ let ()=prints("i=",i, " index_table_L=", index_table_L, " ", L, " index_char_L=", index_char_L) in
 let ()=prints("i=",i, " index_table_M=", index_table_M, " ", M, " index_char_M=", index_char_M) in}
{ let (index_char_M,)=J_induce(tables[index_table_L].ct,L,tables[index_table_M].ct,index_char_L)[0] in}
 let (index_char_M,)=j_induce(tables[index_table_L].ct,L,tables[index_table_M].ct,index_char_L)[0] in
 assert(tables[index_table_M].is_special_representation(index_char_M),"character of M is not special");
 working_triple:=(M,index_table_M,index_char_M)
od;
working_triple
fi

set special([SpringerTable] levi_springer_tables, int index_table_G, int index_char_G)=
(int,RootDatum,int,int,[(int,int)]):  {=index_table_L,L,index_table_G,index_char_L,[(index,mult)]}
let (,triples)=special_long(levi_springer_tables,index_table_G,index_char_G) then
(L,index_table_L,index_char_L)=collapse(levi_springer_tables,triples) then
ct=levi_springer_tables[index_table_G].ct then
ct_L=levi_springer_tables[index_table_L].ct then
{ind=induce_character(ct_L,L,ct,ct_L.characters[index_char_L]) then
ind_sgn=induce_character(ct_L,L,ct,ct_L.characters[ct_L.tensor_sign_index(index_char_L)]) then
mult_ind=ct.inner_product(ct.characters[index_char_G],ind) then
mult_ind_sgn=ct.inner_product(ct.characters[index_char_G],ind_sgn) in
prints("mult_ind: ", mult_ind, new_line, "mult_ind_sgn: ", mult_ind_sgn);}
{assert(mult_ind+mult_ind_sgn=1,"multiplicities wrong");}
{()=prints("table L", index_table_L, " ", index_char_L) then}
()=assert(levi_springer_tables[index_table_L].is_special_representation(index_char_L),"representation of L is not special") then
j_ind=j_induce(levi_springer_tables[index_table_L].ct,L,levi_springer_tables[index_table_G].ct,index_char_L)  in
if #j_ind>0 then
 (index_table_L,L,index_table_G,index_char_L,j_ind) else let
j_ind_sgn=j_induce(levi_springer_tables[index_table_L].ct,L,levi_springer_tables[index_table_G].ct,ct_L.tensor_sign_index(index_char_L))  in
if (#j_ind_sgn)>0 then
(index_table_L,L,index_table_G,index_char_L,j_ind_sgn)
else(error("j/j_ind both failed"))
fi
fi

set special([SpringerTable] levi_springer_tables, int index_char_G)=
special(levi_springer_tables,0,index_char_G)

set test_special([SpringerTable] tables)=
let ct=tables[0].ct then
all=for i:ct.n_classes do special(tables,i) od in
prints("G=", tables[0].root_datum.nice_format);
tabulate(
["sigma","deg/gdeg", "rep_name", "sigma_s","deg/gdeg", "name"]#
for i:#all do
 let (a,b,c,d,list)=all[i] then
 (i_s,)=list[0] in
[i.to_string,ct.degree(i).to_string + "/" + ct.generic_degree(i),ct.irreducible_label(i),
i_s.to_string,
ct.degree(i_s).to_string + "/" + ct.generic_degree(i_s),
ct.irreducible_label(i_s)] od);prints("");
show(tables[0]);prints("");show(tables[0].ct)

{for convenience}
set induce([SpringerTable] tables,int index_table_L, int index_table_G, int index_char_L)=
induce_character(tables[index_table_L].ct,tables[index_table_G].ct, tables[index_table_L].characters[index_char_L])

set induce([SpringerTable] tables,(int index_table_L, int index_table_G, int index_char_L))=
induce_character(tables[index_table_L].ct,tables[index_table_G].ct, tables[index_table_L].characters[index_char_L])