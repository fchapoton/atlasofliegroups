<basic.at
<character_tables.at { for the type }
<springer_tables.at { for the type }
<geck_generic.at { for |lookup_springer_table| }

{W-rep sigma -> special W-rep sigma_s}
{

1) sigma =Springer(O,chi) -> Springer(O_s) where O is in the special piece of O_s

2) different algorithm (that doesn't require Spriner(O,chi), which we don't currently have)

Theorem (Lusztig).

1a) Suppose L is a Levi in G, and CL is a left cell of W(L). Then TGInd(CL) is a left cell for W.

b) Suppose C is a left cell in W. Then C\otimes sgn is also a left cell in W.

c) If W \ne 1, then for any left cell C in W, there is a proper L and a left cell CL in L so that EITHER TGInd(CL) = C, OR TGIND(CL\otimes sgn) = C\otimes sgn.

*********
So here is the algorithm for finding the special W-rep sigma_s attached to sigma.

-1) if sigma is special return sigma (this step isn't necessary but speeds up the algorithm)
0)  If W is trivial, then sigma_s = sigma = trivial. Assume W not trivial.
1)  Try to find a proper Levi L and a W(L)-rep sigmaL so that sigma is contained in TGInd(sigmaL);
    if you succeed, then sigma_s = TFInd(sigmaL_s) = TGInd(sigmaL_s).
2)  If you fail, replace sigma by sigmaSgn = sigma\otimes sgn. Step 1) is guaranteed to succeed for sigmaSgn, giving sigmaSgn_s.
3)  The dual special orbit to sigmaSgn_s (found by the duality algorithm) has Springer rep sigma_s.

{note on 3:  sigma -> sigmaSgn -> sigmaSgn_s -> orbit_sgn -> dual(orbit_sgn) -> sigma_s
except in exceptional cases in E7/E8: sigma_s=sigmaSgn_s\otimes sgn}
}

{given G, tables=all_levi_Springer_tables(G), int char_G
the algorithm produces
[(L_n,table_n,char_n),...(L_1,table_1,char_1),(G,0,char_G)
where each table_j,char_j is an integer
start with tables[table_n].characters[char_n], this is special
j-induction takes you

}

set fig_verbose=false

{extract all terms sigma from given (reducible) character satisfying f(sigma)=desired_value
 usually f = generic or fake degree}
set select(CharacterTable ct, [int] character, int desired_value, (int->int) function)=[(int,int)]:
let dec=ct.decompose(character)  {[int]} in
##for i:#dec do
 if dec[i]>0 and function(i)=desired_value then  [(i,dec[i])] else[] fi
od

{select by fake degree}
set select_degree(CharacterTable ct, [int] character, int desired_value)=[(int,int)]:
select(ct,character,desired_value,ct.degree)

{select by generic degree}
set select_generic_degree(CharacterTable ct, [int] character, int desired_value)=[(int,int)]:
select(ct,character,desired_value,ct.generic_degree)

{select by two function values f_i(sigma)=desired_value_i}
set select(CharacterTable ct, [int] character, int desired_value_1,int desired_value_2, (int->int) function_1,(int->int) function_2)=[(int,int)]:
let dec=ct.decompose(character)  {[int]} in
##for i:#dec do
 if dec[i]>0 and function_1(i)=desired_value_1 and function_2(i)=desired_value_2  then  [(i,dec[i])] else[] fi
od

{select all terms with specified fake degree and (possibly different) generic degree}
set select_both_degrees\
 ( CharacterTable ct
 , [int] character
 , int desired_value_fake
 , int desired_value_generic
 ) = [(int,int)]:
select(ct,character,desired_value_fake,desired_value_generic,ct.degree,ct.generic_degree)

{J-induction from Lusztig's orange book page 77}
{induce sigma_L from W(L) to W(G), and keep terms sigma with gdeg(sigma)=gdeg(sigma_L)}
set J_induce (CharacterTable ct_L,CharacterTable ct_G,int index_character_L) =
( select_generic_degree
    (ct_G
    ,induce_character(ct_L.class_table
		     ,ct_G.class_table
		     ,ct_L.character(index_character_L))
    , ct_L.generic_degree(index_character_L)
    )
)

{j-induction from Lusztig's orange book page 77}
{induce sigma_L from W(L) to W(G), and keep terms sigma with fdeg(sigma)=fdeg(sigma_L)}
set j_induce (CharacterTable ct_L,CharacterTable ct_G,int index_character_L)=
( select_degree
    (ct_G
    ,induce_character(ct_L.class_table
		     ,ct_G.class_table
		     ,ct_L.character(index_character_L))
    , ct_L.degree(index_character_L)
    )
)

{induce sigma_L from W(L) to W(G), and keep terms sigma with gdeg(sigma)=gdeg(sigma_L) AND fdeg(sigma)=fdeg(sigma_L)}
set jJ_induce(CharacterTable ct_L,CharacterTable ct_G,int index_character_L) =
( select_both_degrees
    (ct_G
    ,induce_character(ct_L.class_table
		     ,ct_G.class_table
		     ,ct_L.character(index_character_L))
    , ct_L.degree(index_character_L)
    , ct_L.generic_degree(index_character_L)
    )
)

{induce sigma_L from W(L) to W(G), and keep terms sigma with gdeg(sigma)=fdeg(sigma)=desired_degree}
set jJ_select_induce\
  (CharacterTable ct_L
  ,CharacterTable ct_G
  ,int index_character_L
  ,int desired_degree)=
( select_both_degrees
    (ct_G
    ,induce_character(ct_L.class_table
		     ,ct_G.class_table
		     ,ct_L.character(index_character_L)
		     )
    ,desired_degree
    ,desired_degree
    )
)


{assume generic degrees have been computed for all levis}
set find_induced_generic([SpringerTable] levi_tables,
                         int index_table_G {index of table in list},
			 int index_char_G) {index of character in table_G}\
			 =(bool,([SpringerTable],int,int)):  {(success/failure),[tables], index_table_L, index_char_L}
let ()=if fig_verbose then
    prints("find_induced_generic", new_line, "index_table_G=", index_table_G, " index_char_G=", index_char_G) fi in
if  levi_tables[index_table_G].root_datum.is_abelian then
  return(true,(levi_tables,index_table_G,index_char_G))
else
 let st=levi_tables[index_table_G] then
 ct=st.ct then
 G=ct.root_datum then
 pi_G=ct.characters[index_char_G] then
 gdeg=ct.generic_degree(index_char_G) then
 ()=if fig_verbose then prints("generic degree: ", gdeg) fi in
  let levis_0=proper_Levi_subgroups(G) then
  levis=for i:#levis_0 do levis_0[i] od in
  for L in levis do
   let (index_table_L,)=lookup_springer_table(L,levi_tables) in
   let ()=if fig_verbose then prints("index_table_G: ", index_table_G,new_line,
             "index_char_G: ", index_char_G,new_line,"loop index_table_L=",index_table_L,new_line,
             "----------------------------------------------",
	     new_line, "index_table_G: ", index_table_G,new_line,"index_table_L: ", index_table_L,
	     new_line,"L=", levi_tables[index_table_L].root_datum, new_line) fi in
   let table_L=levi_tables[index_table_L] in
{   ()=show(tables[0].ct) in}
   for index_char_L:table_L.ct.n_classes do
     let ()= if fig_verbose then
         prints("trying: index_table_L=",index_table_L, " ", "index_char_L=",index_char_L, " ",table_L.generic_degree(index_char_L), new_line,
	 "gdeg:", gdeg) fi in
   if table_L.generic_degree(index_char_L)=gdeg then
    let ()=if fig_verbose then prints("has correct generic degree: #", index_char_L) fi in
   let ind_all=induce_character(table_L.ct,L,ct,table_L.ct.characters[index_char_L]) then
      ()= if fig_verbose then prints("L=",table_L.root_datum, new_line,"ind_all: ");ct.view_char(ind_all) fi then
    ind=J_induce(table_L.ct,ct,index_char_L)  then  {ind = [(index,mult)]}
      ()=if fig_verbose then prints("J_induction: ", ind) fi in
    if find(for (j,) in ind do j od,index_char_G)!=-1 then
       if fig_verbose then prints("found") fi;
    return(true,(levi_tables,index_table_L,index_char_L)) fi
    fi
   od   {end for index_char_L:table.n_classes}
  od;    {end for index_table_L:#levi_tables-1}
   return(false,([SpringerTable]:[],-1,-1))
fi

{assume generic degrees have been computed for all levis}
{algorithm sketched above: compute (L,sigma_L_s), then sigma_s= ind(sigma_L_s) (selected by both fake and generic degree)}
set special_long([SpringerTable] levi_springer_tables, int index_table_G, (int index_char_G,bool tensor_sgn))=
([SpringerTable],[(RootDatum,int,(int,bool))]):   {([tables],(L,index_table_L,(index_char_L,bool_tensor_sgn))}
let ()=if fig_verbose then
   prints("find_smooth: ","index_table_G: ", index_table_G, "index_char_G: ", index_char_G, " tensor_sign:", tensor_sgn) fi in
let st=levi_springer_tables[index_table_G] then
ct=st.ct then
G=ct.root_datum in
let rec_fun my_function([SpringerTable] levi_tables,[(RootDatum,int,(int,bool))] triples)=(([SpringerTable],[RootDatum,int,(int,bool)])):
 let (L,index_table_L,(index_char_L,tensor_sign))=triples[0] in
 if is_abelian(L)
  then return(levi_tables,triples)
 elif levi_springer_tables[index_table_L].is_special_representation(index_char_L) then
  return(levi_tables,triples)
 else {/is_abelian}
 let (success,g_induced)=find_induced_generic(levi_springer_tables,index_table_L,index_char_L) in
 if success then
  let ()=if fig_verbose then prints("success", "L=",L) fi in
  let (,new_table_index,new_char_index)=g_induced then
  new=(levi_tables[new_table_index].root_datum,new_table_index,(new_char_index,false)) then
  ()=triples:=new#triples in
  my_function(levi_springer_tables,triples)
 else
   let ()=if fig_verbose then prints("failure,sgn") fi in
   let (success_sgn,g_induced_sgn)=
   find_induced_generic(levi_springer_tables,index_table_L,levi_springer_tables[index_table_L].ct.tensor_sign_index(index_char_L)) in
   if success_sgn then
   let (,new_table_index,new_char_index)=g_induced_sgn  {in my_function(levi_springer_tables,new_table_index,new_char_index)}  then
   new=(levi_tables[new_table_index].root_datum,new_table_index,(new_char_index,true)) then
   ()=triples:=new#triples in
   my_function(levi_springer_tables,triples)
 {  then new_levi_springer_table=levi_springer_tables[new_table_index] then
    then orbit_sgn=springer_inverse(new_levi_springer_table,new_char_index)  then
    dual_orbit_sgn=new_levi_springer_table.dual_map(orbit_sgn) then}
{    in let ()=prints("L=",L, "new_table_index=", new_table_index,"new_char_index=", new_char_index)  }
{  (levi_springer_tables,triples#(levi_springer_tables[new_table_index].root_datum,new_table_index,levi_springer_tables[new_table_index].ct.tensor_sign_index(new_char_index)))}
   else
    assert(false,"error!!");return (levi_tables,triples) {should never get here, but need to return a value}
   fi  {if success_sgn}
  fi
 fi in  my_function(levi_springer_tables,[(G,index_table_G,(index_char_G,false))])

set special_long([SpringerTable] levi_springer_tables, int index_table_G,int index_char_G)=
special_long(levi_springer_tables,index_table_G,(index_char_G,true))

set special_long([SpringerTable] levi_springer_tables,int index_char_G)=
special_long(levi_springer_tables,0,index_char_G)

set all_levi_Springer_tables(RootDatum G)=[SpringerTable]:
let tables=all_levi_springer_tables(G) then
()=update_generic_degrees_geck(tables) in tables


set collapse([SpringerTable] tables, [(RootDatum,int,(int,bool))] triples)=
if #triples=1 then
 if fig_verbose then prints("collapse: returning special") fi;triples[0]
elif #triples=2 then
 if fig_verbose then prints("collapse: returning one step") fi;triples[0]
else
 let ()=if fig_verbose  then prints("collapsing, #triples=", #triples) fi then
working_triple=triples[0] in
for i:#triples-2 do
 let (L,index_table_L,(index_char_L,tensor_sign_L))=triples[i] then
 (M,index_table_M,(index_char_M,tensor_sign_M))=triples[i+1] then
 {if tensor_sign_M=true, then
    sigma_L -> sigma_L\otimes sign -> J_ind(sigma_L*sgn) -> [ J_ind(sigma_L*sgn)]*sgn
}
 (index_char_M,)=j_induce(tables[index_table_L].ct,tables[index_table_M].ct,index_char_L)[0] then
 ()=if tensor_sign_L then index_char_M:=tables[index_table_M].ct.tensor_sign_index(index_char_M) fi in
{ let ()=prints("step i: ",i,new_line, "M=", M,new_line, " L=", L, new_line,"index_char_L=", index_char_L, new_line,
" index_char_M: ", index_char_M, new_line) in}
 assert(tables[index_table_M].is_special_representation(index_char_M),"character of M is not special");
 working_triple:=(M,index_table_M,(index_char_M,tensor_sign_M))
od;
working_triple
fi

set special([SpringerTable] levi_springer_tables, int index_table_G, (int index_char_G,bool tensor_sign))=
(int,RootDatum,int,int,int):  {=index_table_L,L,index_table_G,index_char_L,index)}
let (,triples)=special_long(levi_springer_tables,index_table_G,(index_char_G,tensor_sign)) then
(L,index_table_L,(index_char_L,tensor_sign_L))=collapse(levi_springer_tables,triples) then
ct=levi_springer_tables[index_table_G].ct then
ct_L=levi_springer_tables[index_table_L].ct then
{ind=induce_character(ct_L,L,ct,ct_L.characters[index_char_L]) then
ind_sgn=induce_character(ct_L,L,ct,ct_L.characters[ct_L.tensor_sign_index(index_char_L)]) then
mult_ind=ct.inner_product(ct.characters[index_char_G],ind) then
mult_ind_sgn=ct.inner_product(ct.characters[index_char_G],ind_sgn) in
prints("mult_ind: ", mult_ind, new_line, "mult_ind_sgn: ", mult_ind_sgn);}
{assert(mult_ind+mult_ind_sgn=1,"multiplicities wrong");}
{()=prints("table L", index_table_L, " ", index_char_L) then}
()=assert(levi_springer_tables[index_table_L].is_special_representation(index_char_L),"representation of L is not special") then
{()=prints("index_char_G: ", index_char_G) then
()=prints("tensor:", tensor_sign_L) then}
target_index=
 if tensor_sign_L
  then ct.tensor_sign_index(index_char_G)
 else
  index_char_G
 fi
then
target_generic_degree=ct.generic_degree(target_index) then
{()=prints("target index: ", target_index, new_line, "target_generic_degree: ", target_generic_degree) then}
ind=induce_character(ct_L,ct,ct_L.characters[index_char_L])  then
()=if tensor_sign_L then ind:=ct.tensor_sign(ind) fi then
char=select_degree(ct,ind,target_generic_degree) in
{let ()=prints("char: ", char) in}
assert(#char=1,"#char \ne 1");
let (index,mult)=char[0] in
 if mult !=1 then prints("warning: multiplicity for index ", index," is: ", mult) fi;
index:=
 if tensor_sign_L then ct.tensor_sign_index(index) else index fi;
{prints("test:  generic degree given: ", ct.generic_degree(index_char_G), " index special: ", ct.generic_degree(index));}
assert(ct.generic_degree(index_char_G)=ct.generic_degree(index),"Oh no! The generic degrees don't match");
(index_table_L,L,index_table_G,index_char_L,index)


set special([SpringerTable] levi_springer_tables, int index_table_G,int index_char_G)=
special(levi_springer_tables,index_table_G,(index_char_G,true))


set special([SpringerTable] levi_springer_tables, int index_char_G)=
special(levi_springer_tables,0,(index_char_G,true))

set test_special([SpringerTable] tables)=
let ct=tables[0].ct then
all=for i:ct.n_classes do special(tables,i) od in
prints("G=", tables[0].root_datum.nice_format);
tabulate(
["sigma","deg/gdeg", "rep_name", "sigma_s","deg/gdeg", "name"]#
for i:#all do
 let (a,b,c,d,i_s)=all[i] in
[i.to_string,ct.degree(i).to_string + "/" + ct.generic_degree(i),ct.irreducible_label(i),
i_s.to_string,
ct.degree(i_s).to_string + "/" + ct.generic_degree(i_s),
ct.irreducible_label(i_s)] od);prints("");
show(tables[0]);prints("");show(tables[0].ct)

{for convenience}
set induce([SpringerTable] tables,int index_table_L, int index_table_G, int index_char_L)=
induce_character(tables[index_table_L].ct,tables[index_table_G].ct, tables[index_table_L].characters[index_char_L])

set induce([SpringerTable] tables,(int index_table_L, int index_table_G, int index_char_L))=
induce_character(tables[index_table_L].ct,tables[index_table_G].ct, tables[index_table_L].characters[index_char_L])

set induce_view([SpringerTable] tables,int index_table_L, int index_table_G, int index_char_L)=
tables[index_table_G].ct.view_char(induce(tables,index_table_L,index_table_G,index_char_L))