<all_parameters.at
<K_norm.at
<real_nilpotent_orbits.at

set kn_verbose=false
set normalize(ratvec v)=vec: ratvec_as_vec(for r in v do r-v~[0] od)
{implementation of parts of Letter to Atlas II: nilpotent orbits}

{------------------  new data type -----------------------}

{REDEFINING KNilpotentData: (orbits,closures, [pairs])

 ([RealNilpotentOrbit],[[int]] closures, [[(K_type,ParamPol)]])

 RealNilpotentOrbit:O is a real nilpotent orbit for G
 closures is the closure relations
 all three arrays should have the same size
 the i^th entry of the last term is [(K_type,ParamPol)] for orbit #i
 given i, O=orbits[i]
 L=Levi_of_orbit(O)
 last term: [(mu_L,Q)] where 
 mu_L=KGBElt,ratvec) is an L\cap K-type and 
 ParamPol:Q is the extension defined by mu_L (a ParamPol for G)
}

set_type KNilpotentData = ( [RealNilpotentOrbit] orbits, [[int]] closures,[[(K_Type,ParamPol)]] pairs)
set root_datum(KNilpotentData data)=RootDatum:data.orbits[0].root_datum
set real_form(KNilpotentData data)=RealForm:data.orbits[0].real_form
{----------------- some convenient output commands for K-types ------------------}

set ParamPol_string(ParamPol P)=string:
##(for c@p in P do split_as_int(c)+ "*"+to_string(p) + " [" + height(p) +  "]" + new_line od)

set K_Type_string (K_Type p) = string:
  let (,w)=highest_weight(K0_params(parameter(p))[0]) in 
  if is_integer(lambda(p))
  then to_string("(x_",#x(p),",",lambda(p),")", to_string(w)," ",dimension(LKT(parameter(p))), " ", to_string(height(parameter(p))), 
           " ", to_string(K_norm(p)))
  else to_string("(x_",#x(p),",",[int]:ratvec_as_vec(numer(lambda(p))),"/",to_string(denom(lambda(p))),")", to_string(w)," ",dimension(LKT(parameter(p))), " ", to_string(height(parameter(p))), 
           " ", to_string(K_norm(p)))
  fi
set K_Type_string (Param p)=K_Type_string(K_type(p)) {error if nu(p)\ne 0}

set K_Type_strings (K_Type p) = [string]:
let (,w)=highest_weight(K0_params(parameter(p))[0]) in 
if is_integer(lambda(p))
 then [to_string("(x_",#x(p),",",[int]:ratvec_as_vec(lambda(p)),")"),
       to_string((w))]
  else 
      [to_string("(x_",#x(p),",",lambda(p),")"),
       to_string((w),dimension(LKT(parameter(p))))]
  fi

set K_Type_strings (Param p)=K_Type_strings(K_type(p)) {error if nu(p)\ne 0}


set K_Type_Pol_string(K_Type_Pol P)=string: let rv=string:"" in 
for c@p in P do
 let (,w)=highest_weight(K0_params(p)[0]) in 
 rv+:=split_as_int(c)+"*"+K_Type_string(p) + new_line od;rv

set K_Type_Pol_string(K_Type_Pol P, KGBElt x_K)=string: let rv=string:"" in 
for c@p in P do
{ let (x,v)=highest_weight(LKT(p),x_K) in }
 let (,w)=highest_weight(K0_params(p,x_K)[0]) in 
 rv+:=split_as_int(c)+"*"+K_Type_string(p)+"   " {+ to_string(v) }+ "  " + to_string(w) + "  " + dimension(LKT(p)) +  " <"+K_norm(p)+">"+new_line od;rv

set K_Type_Pol_strings(K_Type_Pol P, KGBElt x_K)=[[string]]:
let rv=[[string]]:[["c","K-type","hwt","Khwt","dim","ht","Knorm"]] in
for c@p in P do let
(,w)=highest_weight(K0_params(p,x_K)[0])  in
rv#:=
[to_string(split_as_int(c))]##
K_Type_strings(p)##[
to_string(w),
to_string(dimension(LKT(p))),
to_string(height(p)),
"<"+K_norm(p)+">"] od;rv

set K_Type_Pol_strings(K_Type_Pol P)=[[string]]:
K_Type_Pol_strings(P,KGB(P.real_form,0))

set kshow(ParamPol P,KGBElt x_K)=void:tabulate(K_Type_Pol_strings(P,x_K),"lllllll",1," ")
set kshow(ParamPol P)=void:tabulate(K_Type_Pol_strings(P),"lllllll",1," ")

set orbit_string(RealNilpotentOrbit O)=string:
let (H,x)=O in "(" + to_string(H) + ",x_" + to_string(#x) + ")"

set K_Type_string_short(K_Type mu)=string:
let (x,v)=mu in "(x_" + to_string(#x) +  "," + to_string(v) + ")"




set show_short(KNilpotentData data)=void:
prints("number of orbits:", #data.orbits);
for orbit@i in data.orbits do 
 let terms=data.pairs[i] in
 prints(i,") orbit:", orbit, new_line,"Levi:", Levi_of_orbit(orbit), new_line,"#L\cap K-types:", #terms,new_line) od

set show_medium(KNilpotentData data)=void:
prints("number of orbits:", #data.orbits);
for orbit@i in data.orbits do 
 let terms=data.pairs[i] in
 prints(new_line,i,") orbit:", orbit, new_line,"Levi:", Levi_of_orbit(orbit), new_line,"#L\cap K-types:", #terms,new_line);
tabulate(["#","mu_L","dim","#P","K_norms(P)"]#
for (mu_L,P)@j in terms do [to_string(j)+")",K_Type_string_short(mu_L),to_string(dimension(mu_L)),  to_string(#P),to_string(K_norms(P))] od
,"lllll",1," ")
od

set show_medium(KNilpotentData orig,KNilpotentData reduced)=void:
prints("number of orbits:", #orig.orbits);
for orbit@i in orig.orbits do 
 let terms_orig=orig.pairs[i] then
 terms_reduced=reduced.pairs[i] in
 prints(new_line,i,") orbit:", orbit, new_line,"Levi:", Levi_of_orbit(orbit), new_line,"#L\cap K-types:", #terms_orig,new_line);
tabulate(["#","mu_L","dim","#P","K_norms(P)","#Q","#K_norms(Q)"]#
for (mu_L,P)@j in terms_orig do let (,Q)=terms_reduced[j] in [to_string(j)+")",K_Type_string_short(mu_L),to_string(dimension(mu_L)),  to_string(#P),to_string(K_norms(P)), to_string(#Q), to_string(K_norms(Q))] od
,"lllllll",1," ")
od

{--------- utilities involving nilradicals --------------}

{given x a theta_x-stable set of roots R, return subset of R
consisting of each imaginary root alpha\in R, and one of each pair
alpha,theta(alpha)
if R isn't theta-stable this will fail}
set extract_roots(KGBElt x, [vec] roots)=[vec]:
let theta=involution(x) then
rv=[] in
while #roots>0 do
 let alpha=roots[0] in
 rv#:=alpha;
 roots:=delete(roots,0);
  if theta*alpha != alpha then
   let  index=find(roots,theta*alpha) in if (index=-1) then error("set of roots is not theta-stable") else
      roots:=delete(roots, find(roots,theta*alpha))  fi fi od;rv

{roots of H in s[1]
 s = -1 eigenspace of theta_x
 s[1] = 1 H-eigenspace of H on s
}
set s_one_roots(RealNilpotentOrbit O)=[vec]:
let theta=involution(O.x) then
()=assert(^theta*O.H = O.H,"H is not ^theta-fixed") then
P=parabolic_by_cwt(O.H,O.x) then
x_max=maximal(P) then {not x(P): this is P.x}
u=nilrad_roots_by_cwt(O.H,O.x) then
{u_complex=extract_roots(x,u) then  NO keep complex pairs for now}
roots=[vec]:[] then
()=for alpha in u do
if alpha*O.H=1 and (is_noncompact_imaginary(x_max)(alpha) or is_complex(x_max)(alpha))  then roots#:=alpha fi od
{then ()=for alpha in u_complex do if alpha*H=1 then roots#:=alpha fi od} 
in roots

{restriction of s_one_roots to H^{theta_x}
 each pair (alpha,theta(alpha)) contributes
 a single root restriction(alpha)=restriction(theta(alpha)),
 corresponding to the single vector X_\alpha-\theta(X_\alpha) in s[1]
 characters of H^theta are elements of X^*/(1-theta)X^*
}
set s_one_roots_restricted(RealNilpotentOrbit O)=[vec]:
let (H,x)=O then
roots=s_one_roots(O) in
roots:=extract_roots(x,roots)

{generate all subsets of [vec], uses generate_all_subsets@[int] in misc.at}
set generate_all_subsets([vec] S) = [[vec]]:
    for A in generate_all_subsets(for i:#S do i od) do for i in A do S[i] od od

{all subsets of the set of restrictions of roots of s[1] to Lie(H)^{\theta_x}
 see Knilpotent paper, Corollary 7.3(6)}
set subsets_of_s_one_roots(RealNilpotentOrbit O)=[[vec]]:
let roots=s_one_roots_restricted(O) in
delete(generate_all_subsets(roots),0) {don't want empty subset}

{H is in \mathfrak h, not \mathfrak h^*}
set rho_shifts(RealNilpotentOrbit O)=[(vec,int)]:
let (H,x)=O then
{drd=dual(root_datum(x)) then
(w,H_dom)=from_dominant(drd,H) then}
(H_dom,w)=from_dominant(H,root_datum(x)) then
x_dom=cross(inverse(w),x) then
O_dom=([int]:H_dom,x_dom) then
m=matrix(w) then
S=subsets_of_s_one_roots(O_dom) in  [(vec:null(rank(real_form(x))),0)]##for v in S do (sum(m*v),#v) od

{test shift independent of choice of x in P}
set test(Parabolic P)=bool:
let L=Levi(P) then 
p=trivial(L) then
rv=null_module(L) in
for x in equivalence_class_of(P) do 
 if in_distinguished_fiber(x) then rv+:=parameter(x(p),lambda(p)-two_rho_u_cap_s(P,x),nu(p)) fi od;
#rv=1

{ P is a theta-stable parabolic  
  p_L is a STFL for L
  construct a new, possibly non-standard parameter for L
  by subtracting the appropriate 2\rho(u\cap s) from lambda(p_L)
  NB: the resulting term might not be standard
}
set twist_by_minus_2rho_u_cap_s(Parabolic P,Param p_L)=Param:
assert(nu(p_L)=null(rank(Levi(P))),"nu(p_L)\ne 0");
let G=real_form(P.x) then
L=real_form(p_L) then
x_L=x(p_L) then
x_G=canonical_x_K(embed_KGB(x_L,G)) in
parameter(x_L,lambda(p_L)-two_rho_u_cap_s(P,x_G),null(rank(Levi(P))))

{given Q theta-stable, and the K-type formula P for a K-type mu_L of L=Levi(Q),
 return the K-type formula for mu_L twisted by -2rho(u\cap s)
 algorithm: apply previous function twist_by_minus_2rho_u_cap_s to P term by term,
 each individual term in the result may be a non-standard parameter for L,
 apply standardize to each term, to give a sum of STFL parameters for L:
 this is the K-type formula for a single L\cap K-type
}
set twist_by_minus_2rho_u_cap_s(Parabolic P,ParamPol K_type_formula)=ParamPol:
let K_type_formula_twisted=null_module(K_type_formula) then
 L=real_form(K_type_formula) in
 for c@p in K_type_formula do K_type_formula_twisted+:=c*standardize(twist_by_minus_2rho_u_cap_s(P,p))*0 od;
{debugging}
if kn_verbose then  let
 b=branch_std(K_type_formula,20) then
 b_twisted=branch_std(K_type_formula_twisted,20) in
 if #b >1 then prints("WARNING: more than one K-type (before twist)");
 for p in monomials(b) do prints(highest_weight(LKT(p),KGB(L,0))) od fi;
{ prints(new_line,"K_type_formula:", new_line, "highest weight is:", highest_weight(LKT(first_param(b)),KGB(L,0)));}
 if #b_twisted >1 then prints("WARNING: more than one K-type after twist");
 for p in monomials(b_twisted) do prints(highest_weight(LKT(p),KGB(L,0))) od fi
 {prints(new_line,"K_type_formula after twist:", new_line, "highest weight is:", highest_weight(LKT(first_param(b_twisted)),KGB(L,0)))} fi;
{end debugging}
K_type_formula_twisted

{ replace K-type mu with mu\otimes (-2\rho(u\cap s))}
set twist_by_minus_2rho_u_cap_s(Parabolic P,K_Type mu)=K_Type:
LKT(first_param(twist_by_minus_2rho_u_cap_s(P,K_type_formula(mu))))

{---------------------- Extension Algorithm ----------------------}

{this implements the algorithm of Proposition 7.3(6)
Phi(x_K,O,kgb_number_L,lambda_L)
x_K (KGBElt for G) is a basepoint for K
O is a RealNilpotentOrbit for G
L=Levi_of_orbit(O)
mu_L=(KGB(L,kgb_number_L),lambda_L) is an L\cap K-type
Phi is the function \tilde\mathcal E
}

{returns ((p_L_0,p_L),extension)}
set Phi(RealNilpotentOrbit O,int kgb_number_L, ratvec lambda_L)=K_Type_Pol:
let G=real_form(O.x) then
P=parabolic_of_orbit(O) then
L=Levi(P) then
p_L_0=Param:parameter(KGB(L,kgb_number_L),lambda_L) in
      if kn_verbose then prints(new_line,"Computing Phi:", new_line, "O=", O, new_line,
      " L=", L,new_line, "x_L=", kgb_number_L, " lambda_L=", lambda_L, new_line,"p_L_0:", p_L_0) fi;
assert(not is_zero(p_L_0),"p_L_0 is zero");
assert(is_standard(p_L_0),"p_L_0 is not standard");
assert(is_final(p_L_0),"p_L_0 is not final");
let
K_type_formula=K_type_formula(p_L_0) then
K_type_formula_twisted=twist_by_minus_2rho_u_cap_s(P,K_type_formula) then
     {()=if kn_verbose then let b=branch_std(K_type_formula,20) in
     prints(new_line,"testing K_type_formula:", new_line, "highest weight is:", highest_weight(LKT(first_param(b)),KGB(L,0)));
     if #b >1 then prints("WARNING: more than one K-type");
     for p in monomials(b) do prints(highest_weight(LKT(p),KGB(L,0))) od fi fi then
     ()=if kn_verbose then let b=branch_std(K_type_formula_twisted,20) in
     prints(new_line,"testing twisted K_type_formula:", new_line, "highest weight is:", highest_weight(LKT(first_param(b)),KGB(L,0)));
     if #b >1 then prints("WARNING: more than one K-type");
     for p in monomials(b) do prints(highest_weight(LKT(p),KGB(L,0))) od fi fi then}
rv=null_module(G) then
rhoshifts=rho_shifts(O) in
     if kn_verbose then if #rhoshifts>1 then prints("orbit is odd",new_line,"rho shifts:", rhoshifts) else prints("orbit is even") fi fi;
     if kn_verbose then 
       prints(
       new_line,"p_L_0:",p_L_0,
       new_line,"K_type_formula on L:", K_type_formula, 
       new_line, "K_type_formula on L twisted:",K_type_formula_twisted) 
     fi;
for c@p_L in K_type_formula_twisted do
     if kn_verbose then prints(new_line,"term in (twisted) K-type formula:",new_line, p_L) fi;
 for (shift,j)@k in rhoshifts do
  let q=parameter(x(p_L),lambda(p_L)-shift,nu(p_L)) {shifted parameter on L} then
  r_1=theta_induce_standard(q,G) {theta-induce up to G} then
  r_2=r_1*0 {restrict to K} in
      if kn_verbose then prints(new_line, "shift: ", shift, new_line,"inducing: ", q, new_line,"induced term: ", r_2) fi;
  rv+:=(-1)^j*c*r_2 
 od 
od;
      if kn_verbose then prints(new_line,"Result:");kshow(rv) fi;
rv
set Phi(RealNilpotentOrbit O,Param p_L)=K_Type_Pol:Phi(O,#x(p_L),lambda(p_L))
set Phi(RealNilpotentOrbit O,K_Type mu_L)=K_Type_Pol:Phi(O,#x(mu_L),lambda(mu_L))

{  unnormalized version of Phi }
{same algorithm but without the twist by -2\rho(u\cap s)}

set Phi_unnormalized(RealNilpotentOrbit O,int kgb_number_L, ratvec lambda_L)=K_Type_Pol:
let G=real_form(O.x) then
P=parabolic_of_orbit(O) then
L=Levi(P) then
p_L_0=Param:parameter(KGB(L,kgb_number_L),lambda_L) in
assert(not is_zero(p_L_0),"p_L_0 is zero");
assert(is_standard(p_L_0),"p_L_0 is not standard");
assert(is_final(p_L_0),"p_L_0 is not final");
let
K_type_formula=K_type_formula(p_L_0) then
rv=null_module(G) then
rhoshifts=rho_shifts(O) in
for c@p_L in K_type_formula do
 for (shift,j)@k in rhoshifts do
  let q=parameter(x(p_L),lambda(p_L)-shift,nu(p_L)) then
  r_1=theta_induce_standard(q,G) then
  r_2=r_1*0 in
  rv+:=(-1)^j*c*r_2 
 od 
od;
      if kn_verbose then prints(new_line,"Result:");kshow(rv) fi;
rv
set Phi_unnormalized(RealNilpotentOrbit O,Param p_L)=K_Type_Pol:Phi_unnormalized(O,#x(p_L),lambda(p_L))
set Phi_unnormalized(RealNilpotentOrbit O,K_Type mu_L)=K_Type_Pol:Phi_unnormalized(O,#x(mu_L),lambda(mu_L))

{ functions on real orbit as K-representation }
set functions_on_real_orbit(RealNilpotentOrbit O)=ParamPol:
let L=O.Levi_of_orbit then 
p=trivial(L)*0  then
q=standardize(p) in
assert(#q=1,"q is not a monomial");	
Phi_unnormalized(O,first_param(q))

set Phi_leading(RealNilpotentOrbit O, int kgb_number_L, ratvec lambda_L)=K_Type_Pol:
leading_terms(Phi(O,kgb_number_L,lambda_L))

set Phi_leading(RealNilpotentOrbit O,Param p_L)=K_Type_Pol:Phi_leading(O,#x(p_L),lambda(p_L))

{assume ParamPol has integral (not split) coefficients}
set vector_old([Param] basis,ParamPol P)=(bool,vec):
let sum=null_module(P) then
v=vec:for p in basis do let c=split_as_int(P[p]) in  sum+:=c*p;c od in
if sum=P then (true,v) else (false,vec:[]) fi 

set vector([Param] basis,ParamPol P)=maybe_a_vec:
let sum=null_module(P) then
v=vec:for p in basis do let c=split_as_int(P[p]) in  sum+:=c*p;c od in
if sum=P then v.solution else ().no_vec fi

set vector_old([K_Type] basis,ParamPol P)=(bool,vec):
vector_old(for mu in basis do parameter(mu) od,P)

set vector([K_Type] basis,ParamPol P)=maybe_a_vec:
vector(for mu in basis do parameter(mu) od,P)

{given list=[P_1,...,P_n] of ParamPols
test if P=\sum a_i P_i
}
{given ParamPols Q_1,...,Q_n and P test if
P=\sum a_i Q_i
Q_i and P are assumed to have integer coefficients
return true/false, and [ParamPol] R,[int] S so that
P=sum S[i]*R[i]
}
set in_span([ParamPol] list,ParamPol P)=([Param],mat,vec,bool):
if #list=0 then ([],null(0,0),null(0),false) else
let basis=monomials(list) {list of distinct Params} then
M=mat:for Q in list do let v=vector(basis,Q) in 
assert(any(v),"failure in in_span");requisition(v)  od then
T=vector(basis,P) in
assert(any(T),"can't find vector at all");
let T=requisition(T) then
inlattice=in_lattice(M,T) in (basis,M,T,inlattice) fi

{convenient to define in_span([[ParamPol]] list,ParamPol P)=
in_span( flatten the list,P)
}
set in_span([[ParamPol]] list_of_lists,ParamPol P)=([Param],mat,vec,bool):
let list=[ParamPol]:[] in
let ()=for new_list in list_of_lists do list##:=new_list od in
in_span(list,P)

{returns [ (mu_L,extension) ], such that all terms in extension have K_norm <= bound }
set Phi_upto(RealNilpotentOrbit O,int bound, ratvec v)=[(K_Type,ParamPol)]:
let bound_L=2*bound {heuristic: seems to be big enough } then
(H,x)=O then
G=real_form(x) then
L=Levi_of_orbit(O) then
L_cap_K_types=K_parameters_norm_upto(L,G,bound_L,v) in
{for a in L_cap_K_types do prints(a, " ", height(parameter(a)), " ",K_norm(a)) od;}
##for mu_L in L_cap_K_types do
 let extension=Phi(O,mu_L) in
 if #extension>0 and K_norm(extension)<=bound then [(mu_L,extension)] else [] fi od

set Phi_upto(KGBElt x_K,[RealNilpotentOrbit] orbits, int bound, ratvec v)=[(KGPElt,[(K_Type,ParamPol)])]:
for O in orbits do (O,Phi_upto(O,bound,v)) od

{compute Phi for all orbits, all mu_L up to (int_bound,v), return KNilpotentData}
set populate( int bound, [RealNilpotentOrbit] orbits, [[int]] closures, ratvec v)=
KNilpotentData:(orbits,closures,for orbit in orbits do Phi_upto(orbit,bound,v) od)

{assume v=rho_check(G)}
set populate( int bound, [RealNilpotentOrbit] orbits, [[int]] closures)=
KNilpotentData:populate(bound,orbits,closures,rho_check(root_datum(orbits[0].x)))

{nice display of various pieces of KNilpotentData}
set show(KGBElt x_K,KNilpotentData data)=void:
for orbit@i in data.orbits do 
 let a=data.pairs[i] in 
{for (orbit,a)@i in data do}
prints(
new_line,"--------------------------------------------",
new_line,"orbit #",i,
new_line, orbit_string(orbit), 
new_line, "Levi: ",Levi_of_orbit(orbit),
new_line);

for (mu_L,extension)@j in a do 
 let leading=leading_terms(extension) in
prints("orbit:", orbit_string(orbit), 
new_line,"#",j,") "," mu_L=",K_Type_string(mu_L),
new_line, "Phi(mu_L):");
kshow(extension,x_K);
prints(new_line, "leading terms(Phi(mu_L)) (",#leading,"):");
kshow(leading,x_K)
od od

set show(KGBElt x_K,KNilpotentData data,int orbit)=void:show(x_K,([data.orbits[orbit]],[[int]]:[[]],[data.pairs[orbit]]))

set show(KGBElt x_K,KNilpotentData data,int orbit,int pair)=void:
show(x_K,([data.orbits[orbit]],[[int]]:[[]],[data.pairs[pair]]))

set show_trivial_only(KGBElt x_K,KNilpotentData data)=void:for 
i:#data.orbits do show(x_K,data,i,0) od

{test if Q is contained in P: every term in Q occurs in P,
 with matching coefficients, up to uniform multiple
 i.e. for some integer c,
 mult(p in P)=c*mult(p in Q) for all terms p occuring in Q
 test: #terms(P-cQ) =  #terms(P)-#terms(Q) for some c
 (c=ratio of mulitplicities of some p)
 returns the integer c, or 0 if fails
}
set term_contained(ParamPol P,ParamPol Q)=int:
let
p=first_param(P) then
k=find(monomials(Q),p) in
if k=-1 then 0 else
 let c_q=split_as_int(Q[p]) then
 c_p=split_as_int(P[p]) then
 N=c_q/c_p in
  if not is_integer(N) then 0
  else let M=rat_as_int(N) in
 if #(monomials(Q-M*P))=#monomials(Q)-#monomials(P) then M else 0 fi fi fi

{assuming: all terms of P have the same K-norm, same condition for Q
 this will be the case when P,Q are each leading terms of something }
set term_contained_special(ParamPol P,ParamPol Q)=int:
if K_norm(P) != K_norm(Q) then 0 else term_contained(P,Q)  fi

{reduce P using a list [ParamPol]:smaller by subtracting off leading terms, returns a single ParamPol}
set reduceParamPol(ParamPol P, [ParamPol] smaller)=ParamPol:
if kn_verbose then prints("basic reduction: ",new_line, K_Type_Pol_string(P)) fi;
if #P=0 then P else
let rec_fun f(ParamPol Q,[ParamPol] smaller_terms)=ParamPol:
{ prints(new_line,"rec_fun with Q=",Q,new_line,"#params=", #smaller_terms, " #smaller:", #smaller);}
 if #smaller_terms=0 then Q else
  let R=smaller_terms[0] in if #R=0 then f(Q,delete(smaller_terms,0)) {iterate, deleting first term of smaller_terms} else
    let N=term_contained_special(leading_terms(R),leading_terms(Q)) in
      if N=0 then f(Q,delete(smaller_terms,0)) else 
      if kn_verbose then prints("reducing by subtracting:", new_line,K_Type_Pol_string(R), new_line,"with coefficient: ", N, new_line, "result:",new_line, K_Type_Pol_string(Q-N*R)) fi;
      f(Q-N*R,smaller) fi {if N=0 only delete first term of smaller_terms} {NB: GO BACK TO original smaller}
  fi                 {if #R=0, already iterated}
 fi in f(P,smaller)  {if #smaller_terms=0}
fi   {if #P=0 return null_module}

set collectSmallerTerms(KNilpotentData data, [int] smaller_orbits)=[ParamPol]:
##(for j in smaller_orbits do 
 let smaller_pairs=data.pairs[j] in
 for (,P) in smaller_pairs do P od od)

set reduceParamPol(KNilpotentData data, ParamPol Q, [int] smaller_orbits)=ParamPol:
reduceParamPol(Q,collectSmallerTerms(data,smaller_orbits))


set reduceParamPol(KNilpotentData data, int orbit, int x_L, ratvec lambda_L, [int] smaller_orbits)=ParamPol:
let O=data.orbits[orbit] then
Q=Phi(O,x_L,lambda_L) then
()=if kn_verbose then prints("reducing Q: ",new_line, K_Type_Pol_string(Q)) fi in
reduceParamPol(data,Q,smaller_orbits)

{data,orbit,pair -> (,P) -> reduce(P, terms from smaller_orbits), returns a single ParamPol}
set reduceParamPol(KNilpotentData data, int orbit, int pair, [int] smaller_orbits)=ParamPol:
let pairs=data.pairs[orbit] then
(,Q)=pairs[pair] then
()=if kn_verbose then prints("reducing: ",new_line, K_Type_Pol_string(Q)) fi then
smaller_terms=[ParamPol]:[] in
for j in smaller_orbits do 
 let ()=if kn_verbose then prints("reducing using orbit #",j) fi in
 let smaller_pairs=data.pairs[j] in
 for (,P) in smaller_pairs do smaller_terms#:=P od od;
reduceParamPol(Q,smaller_terms)

{data,orbit,pair -> (,P) -> reduce(P, term from single smaller orbit, returns a single ParamPol}
set reduceParamPol(KNilpotentData data, int orbit, int pair, int smaller_orbit)=ParamPol:reduceParamPol(data,orbit,pair,[smaller_orbit])

{data,orbit, pair=(mu_L,Q) ; replace pair with new_pair=(mu_L',Q'), returns new KNilpotentData}
set update(KNilpotentData data, int orbit_number, int pair, (K_Type,ParamPol) new_pair)=KNilpotentData:
let new_orbit_pairs=for i: #data.pairs[orbit_number] do if i=pair then new_pair else data.pairs[orbit_number][i] fi od then
all_pairs=for i:#data.pairs do if i=orbit_number then new_orbit_pairs else data.pairs[i] fi od in 
(data.orbits,data.closures,all_pairs)

{data,orbit, pair=(mu_L,Q), reduce Q using smaller_orbit, update data, returns KNilpotentData}
set reduce(KNilpotentData data, int orbit, int pair, int smaller_orbit)=KNilpotentData:
let P=reduceParamPol(data,orbit,pair,smaller_orbit) then
pairs=data.pairs[orbit] then
(mu_L,)=pairs[pair] in
update(data,orbit,pair,(mu_L,P))

{data,orbit, pair=(mu_L,Q), reduce Q using collection of smaller_orbits, update data, returns KNilpotentData}
set reduce(KNilpotentData data, int orbit, int pair, [int] smaller_orbits)=KNilpotentData:
for j in smaller_orbits do data:=reduce(data,orbit,pair,j) od;data

{data, orbit -> list of pairs, reduce all of these against smaller_orbits,
update data, returns KNilpotentData}
set reduce(KNilpotentData data, int orbit, [int] smaller_orbits)=KNilpotentData:
let pairs=data.pairs[orbit] in 
for j:#pairs do data:=reduce(data,orbit,j,smaller_orbits) od;data

{data, orbit -> list of pairs, reduce all of these against smaller_orbits as given by [[int]] closures,
update data, returns KNilpotentData}
set reduce(KNilpotentData data,[int] orbits)=KNilpotentData:
for j: #data.orbits do data:=reduce(data,j,data.closures[j]) od;data

{primary version
 run over all orbits, for each orbit run over all pairs (mu_L,Q)
 reduce each one against smaller orbits as given by [[int]] closures
 update data, returns KNilpotentData
}
set reduce(KNilpotentData data)=
reduce(data,#(#(data.orbits)))  { #(#(data.orbits))=[0,1,...,n] }


set leading_terms_basis(KNilpotentData data)=[(RealNilpotentOrbit,K_Type,ParamPol)]:
##for O@i in data.orbits  do 
 let pairs=data.pairs[i] in
  for (mu_L,P) in pairs do (O,mu_L,P) od od

set leading_terms(KNilpotentData data)=[ParamPol]:
let basis=leading_terms_basis(data) in 
 for i:#basis do let (,,P)=basis[i] in P od

set matrix([ParamPol] pols,[Param] basis)=mat:
 for P in pols do for Q in basis do split_as_int(P[Q]) od od



set matrix([ParamPol] list,[Param] basis)=mat:
matrix(list,basis)

set matrix([ParamPol] list)=mat:matrix(list,monomials(list))

set matrix(KNilpotentData data,[K_Type] basis)=mat:
matrix(leading_terms(data),for mu in basis do parameter(mu) od)

set rank(mat A)=let (B,,pivots,)=A.echelon in #pivots


