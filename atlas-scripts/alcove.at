{ an experimental script for finding good representative points in alcoves }

{ the application would be to simplify parameters with large numerators in their
  infinitesimal character to ones in their alcove that do not. That would
  require operating only in the -1 eigenspace if the involution at hand, which
  is not yet taken into account here; it will need a different alcove notion
}

<basic.at
<sort.at

{ David's proposal to improve a parameter by moving onto a wall; it cuurently
  does not take into account the possibility that this wall outside the alcove
}
set improve(Param p) = Param:
(  let rd=p.real_form.root_datum, gamma=p.infinitesimal_character
   then id = integrality_datum(rd,gamma)
in assert(is_dominant(rd,gamma))
;  if id.semisimple_rank=rd.semisimple_rank
   then p { if integral system has full rank, don't try to improve any more }
   else let coroots_mat=^id.simple_coroots
      then orth_basis = kernel(coroots_mat) { basis of part $X^*$ orth to |id| }
      then outside_poscoroots = { poscoroots not in row span of |coroots_mat| }
        columns_with((vec alpha_v) bool: !=alpha_v*orth_basis, rd.poscoroots)
      then xi_i0 = let ev = outside_poscoroots[0]*orth_basis
                   in orth_basis[first(#ev, (int j)bool: !=ev[j] )]
    in outside_poscoroots := { filter out those orthogonal to |xi_i0| }
         columns_with((vec beta_v)bool: !=beta_v*xi_i0, outside_poscoroots)
    ; let delays = { scalings of |xi_i0| to make each |beta*gamma| integral }
        for beta in outside_poscoroots do frac(beta*gamma)/abs(beta*xi_i0) od
      then (r,t) = (0,delays[0])
   in for d@i in delays do if d<t then set (r,t):=(i,d) fi od
   ;  let beta_0 = outside_poscoroots[r]
   in parameter_gamma(p.x,p.lambda,gamma - xi_i0 * sign(beta_0*xi_i0) * t)
   fi
)

{ Marc's approach to find the walls of an alcove, and for all of them that do
  not lie outside move to them, while for the forbidden walls take equal
  barycentric coordinates (take barycentre of smallest inside facet of alcove)
}
set is_in_coroot_span(RootDatum rd, [int] indices) = (int->bool):
   let orth = kernel(rd.rank ^ for i in indices do coroot(rd,i) od) in
   (int i) bool: = coroot(rd,i)*orth

{ find additive decomposition of coroot in simple coroots, for each contribution
  give index, nonzero coeffcieint, and fundamental weight
}
set coroot_constituents(RootDatum rd, vec alpha_v) = [int,int,ratvec]:
   for i:rd.semisimple_rank
   do let omega = fundamental_weight(rd,i) then v = rat_as_int(omega*alpha_v) in
      if !=v then [(i,v,omega)] else [] fi
   od.##

{ additively minimal coroots in the subsystem of coroots[indices] }
{ for each such coroot, add it coroot coefficients on that subsystem }
set lowest_coroots(RootDatum rd, [int] indices) = [int,[int,int,ratvec]]:
   let rk=rd.rank
   then simp_rts=rk # for i in indices do root(rd,i) od
   , simp_crts=rk # for i in indices do coroot(rd,i) od
   then sub_datum =  { subsystem for |indeices|, preferring coroots }
     root_datum(simp_rts,simp_crts,true)
in for alpha_v in poscoroots(sub_datum)
   do if any(for beta_v in simp_crts do is_coroot(sub_datum,alpha_v+beta_v) od)
      then []
      else [(coroot_index(rd,-alpha_v),coroot_constituents(sub_datum,alpha_v))]
      fi
   od.##

{ first component: affine coroots |(alpha_v,c)| for alcove of gamma, and its
  coordinates: first |coroot_index(rd,alpha_v)|, then is constant |c| added for
  affine coroot: (floor(alpha_v*gamma), finally |frac(alpha_v*gamma)|
  second component: alternative fractional parts for best point in alcove
  third component: best point in alcove, using those alternative fractional parts
}
set walls(RootDatum rd, ratvec gamma) = ([int,int,rat],[rat],ratvec):
(  assert(#gamma=rd.rank,"rational weight of wrong size")
;  if not rd.prefers_coroots { then replace |rd| by one that does }
   then rd:=root_datum(rd.simple_roots,rd.simple_coroots,true)
   fi
;  let levels = for alpha_v in coroots(rd) do frac(alpha_v*gamma) od
   , rk = rd.semisimple_rank, npr = rd.nr_of_posroots
   , gens=[int]: []
   then ranking = inv_standardisation(levels)
   then start = { skip over level 0 negative coroots in |ranking| }
       #for ind in ranking do if >levels[ind] or ind>=npr then break fi od
   , exclude = is_in_coroot_span(rd,gens)
in for place in ranking[start:] { treat the remaining coroots in |ranking| }
   do let index = place-npr { transform to standard coroot index }
   in if not exclude(index)
      then gens #:= index; exclude := is_in_coroot_span(rd,gens)
      ; if #gens=rk then break fi { once at semisimple rank, we are done }
      fi
   od
;  let lc = lowest_coroots(rd,gens)
   , !triv_rel = vec:for :2*rd.nr_of_posroots do 0 od
   then new_gens=for (i,)in lc do i od
   ,  relations = mat: #triv_rel { size of each relation } #
      for (i,arr) in lc
      do let rel=triv_rel in
         rel[i+npr]:=1; for (j,c,) in arr do rel[gens[j]+npr]:=c od
      ;  rel
      od
   then wall_triples = [int,int,rat]: { coroot index, integral, fractional part }
      for i in sort(gens ## new_gens)
      do let alpha_v=coroot(rd,i) then (n,f)=(alpha_v*gamma)\%1
         in assert(f=levels[i+npr],"mismatch in levels"); (i,n,f)
      od
   then coroot_fracs = [rat]: for :2*rd.nr_of_posroots do 0 od
in assert(=rd.coroots*relations,"relations don't relate") { |relations| should }
;  for rel in relations
   do let parts = [ratvec]: { (floor,frac) separated coroot evaluations }
         for (i,n,f) in wall_triples do [n,f]*rel[i+npr] od
   in assert(sum(2,parts)=[-1,1]/1,"wrong weighted sum of fractional parts")
   od
;  let alcove_weight = ratvec: { representative rational weight in alcove }
      sum(rd.rank, { sum over (fundamental weight)*coordinate contributions }
	for (i_aff,arr) in lc
	do let neg_count = #<i_aff { count negative root contributions |rel| }
	   then coefs = ratvec:
	      for (j,c,) in arr
	      do if <gens[j] then neg_count +:= 1; /c else 0 fi
	      od
	in if <i_aff then coroot_fracs[i_aff+npr] := /neg_count fi
	;  for (j,,fund_wt)@i in arr
	   do let frac = coroot_fracs[gens[j]+npr] := coefs[i]/neg_count in
	     fund_wt*(floor(coroot(rd,gens[j])*gamma)+frac) { contribution }
	   od
	od.##
	)
in for rel in relations
   do assert(coroot_fracs * rel = 1,"wrong new coordinates") od
;  (wall_triples
   ,for (i,,) in wall_triples do coroot_fracs[i+npr] od
   ,alcove_weight
   )
)

