{ an experimental script for finding good representative points in alcoves }

{ the application would be to simplify parameters with large numerators in their
  infinitesimal character to ones in their alcove that do not. That would
  require operating only in the -1 eigenspace if the involution at hand, which
  is not yet taken into account here; it will need a different alcove notion
}

<basic.at
<sort.at

{ David's proposal to improve a parameter by moving onto a wall; it cuurently
  does not take into account the possibility that this wall outside the alcove
}
set improve(Param p) = Param:
(  let rd=p.real_form.root_datum, gamma=p.infinitesimal_character
   then id = integrality_datum(rd,gamma)
in assert(is_dominant(rd,gamma))
;  if id.semisimple_rank=rd.semisimple_rank
   then p { if integral system has full rank, don't try to improve any more }
   else let coroots_mat=^id.simple_coroots
      then orth_basis = kernel(coroots_mat) { basis of part $X^*$ orth to |id| }
      then outside_poscoroots = { poscoroots not in row span of |coroots_mat| }
        columns_with((vec alpha_v) bool: !=alpha_v*orth_basis, rd.poscoroots)
      then xi_i0 = let ev = outside_poscoroots[0]*orth_basis
                   in orth_basis[first(#ev, (int j)bool: !=ev[j] )]
    in outside_poscoroots := { filter out those orthogonal to |xi_i0| }
         columns_with((vec beta_v)bool: !=beta_v*xi_i0, outside_poscoroots)
    ; let delays = { scalings of |xi_i0| to make each |beta*gamma| integral }
        for beta in outside_poscoroots do frac(beta*gamma)/abs(beta*xi_i0) od
      then (r,t) = (0,delays[0])
   in for d@i in delays do if d<t then set (r,t):=(i,d) fi od
   ;  let beta_0 = outside_poscoroots[r]
   in parameter_gamma(p.x,p.lambda,gamma - xi_i0 * sign(beta_0*xi_i0) * t)
   fi
)

{ Marc's approach to find the walls of an alcove, and for all of them that do
  not lie outside move to them, while for the forbidden walls take equal
  barycentric coordinates (take barycentre of smallest inside facet of alcove)
}
set is_in_coroot_span(RootDatum rd, [int] indices) = (int->bool):
   let orth = kernel(rd.rank ^ for i in indices do coroot(rd,i) od) in
   (int i) bool: = coroot(rd,i)*orth

{ find additive decomposition of coroot in simple coroots, for each contribution
  give index, nonzero coeffcieint, and fundamental weight
}
set coroot_constituents(RootDatum rd, vec alpha_v) = [int,int,ratvec]:
   for i:rd.semisimple_rank
   do let omega = fundamental_weight(rd,i) then v = rat_as_int(omega*alpha_v) in
      if !=v then [(i,v,omega)] else [] fi
   od.##

{ additively minimal coroots in the subsystem of coroots[indices] }
{ for each such coroot, add it coroot coefficients on that subsystem }
set lowest_coroots(RootDatum rd, [int] indices) = [int,[int,int,ratvec]]:
   let rk=rd.rank
   then simp_rts=rk # for i in indices do root(rd,i) od
   , simp_crts=rk # for i in indices do coroot(rd,i) od
   then sub_datum =  { subsystem for |indeices|, preferring coroots }
     root_datum(simp_rts,simp_crts,true)
in for alpha_v in poscoroots(sub_datum)
   do if any(for beta_v in simp_crts do is_coroot(sub_datum,alpha_v+beta_v) od)
      then []
      else [(coroot_index(rd,-alpha_v),coroot_constituents(sub_datum,alpha_v))]
      fi
   od.##

{ first component: affine coroots |(alpha_v,c)| for alcove of gamma, and its
  coordinates: first |coroot_index(rd,alpha_v)|, then is constant |c| added for
  affine coroot: (floor(alpha_v*gamma), finally |frac(alpha_v*gamma)|
  second component: alternative fractional parts for best point in alcove
  third component: best point in alcove, using those alternative fractional parts
}
set walls(RootDatum rd, ratvec gamma) = ([int,int,rat],[rat],ratvec):
(  assert(#gamma=rd.rank,"rational weight of wrong size")
;  if not rd.prefers_coroots { then replace |rd| by one that does }
   then rd:=root_datum(rd.simple_roots,rd.simple_coroots,true)
   fi
;  let levels = for alpha_v in coroots(rd) do frac(alpha_v*gamma) od
   , rk = rd.semisimple_rank, npr = rd.nr_of_posroots
   , gens=[int]: []
   then ranking = inv_standardisation(levels)
   then start = { skip over level 0 negative coroots in |ranking| }
       #for ind in ranking do if >levels[ind] or ind>=npr then break fi od
   , exclude = is_in_coroot_span(rd,gens)
in for place in ranking[start:] { treat the remaining coroots in |ranking| }
   do let index = place-npr { transform to standard coroot index }
   in if not exclude(index)
      then gens #:= index; exclude := is_in_coroot_span(rd,gens)
      ; if #gens=rk then break fi { once at semisimple rank, we are done }
      fi
   od
;  let lc = lowest_coroots(rd,gens)
   , !triv_rel = vec:for :2*rd.nr_of_posroots do 0 od
   then new_gens=for (i,)in lc do i od
   ,  relations = mat: #triv_rel { size of each relation } #
      for (i,arr) in lc
      do let rel=triv_rel in
         rel[i+npr]:=1; for (j,c,) in arr do rel[gens[j]+npr]:=c od
      ;  rel
      od
   then wall_triples = [int,int,rat]: { coroot index, integral, fractional part }
      for i in sort(gens ## new_gens)
      do let alpha_v=coroot(rd,i) then (n,f)=(alpha_v*gamma)\%1
         in assert(f=levels[i+npr],"mismatch in levels"); (i,n,f)
      od
   then coroot_fracs = [rat]: for :2*rd.nr_of_posroots do 0 od
in assert(=rd.coroots*relations,"relations don't relate") { |relations| should }
;  for rel in relations
   do let parts = [ratvec]: { (floor,frac) separated coroot evaluations }
         for (i,n,f) in wall_triples do [n,f]*rel[i+npr] od
   in assert(sum(2,parts)=[-1,1]/1,"wrong weighted sum of fractional parts")
   od
;  let alcove_weight = ratvec: { representative rational weight in alcove }
      sum(rd.rank, { sum over (fundamental weight)*coordinate contributions }
	for (i_aff,arr) in lc
	do let neg_count = #<i_aff { count negative root contributions |rel| }
	   then coefs = ratvec:
	      for (j,c,) in arr
	      do if <gens[j] then neg_count +:= 1; /c else 0 fi
	      od
	in if <i_aff then coroot_fracs[i_aff+npr] := /neg_count fi
	;  for (j,,fund_wt)@i in arr
	   do let frac = coroot_fracs[gens[j]+npr] := coefs[i]/neg_count in
	     fund_wt*(floor(coroot(rd,gens[j])*gamma)+frac) { contribution }
	   od
	od.##
	)
in for rel in relations
   do assert(coroot_fracs * rel = 1,"wrong new coordinates") od
;  (wall_triples
   ,for (i,,) in wall_triples do coroot_fracs[i+npr] od
   ,alcove_weight
   )
)

set is_lowest_for(RootDatum rd, [int] indices, int i) = bool:
      let a_v = coroot(rd,i)
      in none(for j in indices do is_coroot(rd,coroot(rd,j)-a_v) od)

{ first component: affine coroots |(alpha_v,c)| for alcove of gamma, and its
  coordinates: first |coroot_index(rd,alpha_v)|, then is constant |c| added for
  affine coroot: (floor(alpha_v*gamma), finally |frac(alpha_v*gamma)|
}
set wall_set(RootDatum rd, ratvec gamma) = [int]:
(  assert(#gamma=rd.rank,"rational weight of wrong size")
;  if not rd.prefers_coroots { then replace |rd| by one that does }
   then rd:=root_datum(rd.simple_roots,rd.simple_coroots,true)
   fi
;  let levels = for alpha_v in coroots(rd) do frac(alpha_v*gamma) od
   , rk = rd.semisimple_rank, npr = rd.nr_of_posroots
   , gens=[int]: []
   then ranking = inv_standardisation(levels)
   then start = { skip over level 0 negative coroots in |ranking| }
       #for ind in ranking do if >levels[ind] or ind>=npr then break fi od
in for place in ranking[start:] { treat the remaining coroots in |ranking| }
   do let index = place-npr { transform to standard coroot index }
   in if is_lowest_for(rd,gens,index) then gens #:= index fi
   od
;  sort(gens)
)

{ test hypothesis that root set allows for |-theta| fixed correction }
set validate_root_set(RootDatum rd, mat theta, [vec] coroots) = bool:
   let imag_coroots = [vec]:[] in
   for alpha_v in coroots
   do let th_av=theta*alpha_v in
      if th_av=alpha_v then imag_coroots ##:= [alpha_v,-alpha_v]; true
      else let sum=alpha_v+th_av in
        =sum { real root }
	or any(for a_v in imag_coroots do sum=a_v od) { complex with imaginary }
	or any(for a_v in coroots do a_v=-th_av od) { complex with partner }
      fi
   od.all

{ group coroots into connected components; for each group element alpha_v tell
  index in |rd|, |-theta| projection of root |alpha|, whether to make integral }
set classify(RootDatum rd, Param p, [int] indices) = [[int,vec,bool]]:
(  let groups = [[int,vec,bool]]:[], theta=p.x.involution
in for i in indices
   do let alpha=root(rd,i),alpha_v=coroot(rd,i)
      then projection2 = (1-theta)*alpha { twice the projection on $-1$ space }
      , npr = rd.nr_of_posroots
      then grs =
	 let test =
            for j in indices do if =coroot(rd,j)*projection2 then [] else [j] fi
	    od.##.is_member
         in for gr@j in groups
            do if for (k,,) in gr do test(k) od.any then [j] else [] fi od.##
      ,  condition = { whether to allow making the fractional part 0 }
         if !=projection2 then true { nut fractional part shoudl be 0 already }
	 elif projection2=alpha*2 { real root }
	 then i>=npr { real coroot is positive }
           or { after making real coroot integral, it becomes nonparity: }
	    ( let (x,lr,gamma)=%p in is_nonparity(alpha,param(x,lr,
	        gamma-alpha*(frac(alpha_v*gamma)/2))))
         else i>=npr or is_positive_root(rd,theta*-alpha)
	 fi
      in if =#grs { no matches ?}
         then groups #:= [(i,projection2,condition)] { add singleton group }
	 else groups := { filter away |grs|, and bundle with |i| as new group }
	    for j in complement(#groups,grs) do groups[j] od #
	    (for j in grs do groups[j] od.## # (i,projection2,condition))
	 fi
   od
;  groups
)

{ from a group given by coroot index, fractional part, whether to 0,
  compute correction to add to |gamma| to simplify fractional parts
}
set correction(RootDatum rd, [int,rat,bool] walls) = ratvec:
(  let relation =
      let k=kernel(rd.rank # for (i,,) in walls do coroot(rd,i)od) in
      assert(#k=1); case k~[0,0] then -k[0] in error("group rel") else k[0] esac
   , neg_count = 0
   , gen_roots = for (i,,) in walls[:~1] do i od
   then coefs = ratvec: { list of new coordinates to obtain }
      for (,,to_0)@i in walls
      do if to_0 then 0 else neg_count +:=1; /relation[i] fi od
   ,  A = (rd.rank # for i in gen_roots do coroot(rd,i)od) ##
       ^kernel(rd.rank ^ for i in gen_roots do root(rd,i)od) { group radical }
   then (A_inv,d) = invert(A) { a |A_inv[i]/d| dual base of coroots }
in coefs /:= neg_count { to barycenter of nonzero coordinates }
;  sum(rd.rank,for (,frac,)@i in walls[:1~] do A_inv[i]/d*(coefs[i]-frac) od)
)

set promote_in_alcove(Param p) = Param:
(  let rd=p.real_form.root_datum, (x,lr,gamma) = %p
   then walls = wall_set(rd,gamma)
in assert
   (validate_root_set(rd, x.involution, for i in walls do coroot(rd,i) od)
   ,"Set of wall lacks necessary symmetry "+walls.to_string
   )
;  let groups = classify(rd,p,walls)
   then corr =
      sum
      (rd.rank
      ,  for gr in groups
         do correction
            (rd
	    ,for (ind,,to_0) in gr do (ind,frac(coroot(rd,ind)*gamma),to_0) od
            )
         od
      )
in param(x, lr, gamma+corr)
)
