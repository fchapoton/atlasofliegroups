<nilpotent_orbits.at
<character_tables.at
<classical_W_classes_and_reps.at { for type abbreviation |BC_class|, |cycles| }

set sign_string (bool s) = string: if s then "-" else "+" fi
set parts_string (Partition lambda) = string: { partition without brackets }
  lambda.to_string[1:1~]
{ |cycles@(Partition,Partition)| tacks booleans one cycle lengths, the do this: }
set cycles_string ([int,bool] cycles) = string:
(  "[" ##
   for (l,s)@pos in cycles
   do if =pos then l.to_string##s.sign_string
      else "," ##  l.to_string##s.sign_string
      fi
   od.##
   ##  "]"
)

{     type C     }

{representation of H_n is given by a pair of partitions or a symbol}
{
  symbol:
  0 \le f_1 < f_2 < ... < f_a
  0 \le g_1 < f_2 < ....< g_b
  equivalence: [f_1,.., f_a] -> [0,f_1+1,..., f_a+1], same on g
  every symbol is equivalent to a unique one with a=b+1 and at most one 0
}

set_type Hn_rep  =(Partition,Partition) { (negative cycles, positive cycles) }
set_type Symbol = [[int]]  { must have 2 parts: [f,g], other conditions above }
set_type BC_Orbit = Partition
  { all odd(C) or even(B) parts must have even multiplicity }

{ normalize symbol: |f|=|g|+1 and at most 1 zero }
set normalize (Symbol S) = Symbol:
   let reduce([int] f)=[int]:
      let k = let nf=#f in first(nf,(int i)bool:f[i]>i) in
      if k.< then [] else for e in f[k:] do e-k od fi
   , expand([int] f,int r) = [int]: #r ## for e in f do e+r od
   then f=S[0].reduce, g=S[1].reduce then d=#f-(#g+1)
in case d in [f,g] then [expand(f,-d),g] else [f,expand(g,d)] esac

{ Symbol to Hn_rep (surjection, identifying equivalence classes of Symbols) }
set wrep (Symbol S) = Hn_rep:
( for f_i@i in S[0] do f_i-i ~od.strip_to_partition
, for g_i@i in S[1] do g_i-i ~od.strip_to_partition
)
{ Hn_rep to normalized Symbol }
set symbol (Hn_rep(p,q)) = Symbol:
(( let d=#p-(#q+1) in { if necessasry extend p or q by zeros so as to make d=0: }
   case d then p##:= for : -d do 0 od in () else q##:=for : d do 0 od esac
 )
; [for i:#p do p~[i]+i od,for j:#q do q~[j]+j od]
)

{ equality of Hn_reps }
set = (Hn_rep(a1,a2),Hn_rep(b1,b2)) = bool: a1=b1 and a2=b2

{ equality of symbols (not equivalence) }
set symbols_equal(Symbol a,Symbol b) = bool: a[0]=b[0] and a[1]=b[1]

set BC_classes(int n) = [BC_class]: partition_pairs(n)

{get actual conjugacy class representatives, i.e. elements of W(C_n),
 from pairs of partitions
pair of partitions (P,Q) of total size n -> conjugacy class in W(C_n)
P=(a_1,...,a_r) -> coxeter element of Sp(2a_1)x...xSp(2a_r)
Q=(b_1,...,b_s) -> coxeter element of GL(b_1)x...xGL(b_s)
}
set conjugacy_class_C(BC_class (P,Q))=WeylElt:
if #P+#Q=0 then id_W(trivial_group)  {special case}
else
 {first, given a single partition P=(a_1,...,a_r)
 construct the simple roots and coroots of GL(a_1)x...xGL(a_r)
 algorithm: P->v=(1,...,1,2,..,2,...,r,...,r)
 #of terms i is a_i
 then take the simple roots of GL(n) (n=\sum a_i) orthogonal to v
 }
 let (GL_roots,GL_coroots)=
  let partition=P##Q then
  v=##
   for i:#partition do
    for j:partition[i] do i+1
   od
  od
  then
{  ()=prints("v=",v) then}
  roots=##for alpha in GL(#v).simple_roots do
   if alpha*v=0 then [alpha] else [] fi od
  in (roots,roots)
 then
 {next, add single 2e_i term to simple roots of each GL factor from P
 corresponding e_i term to simple coroots}
   n=sum(P)+sum(Q)
 , bars = for i:#P from 1 do sum(P[:i])-1 od { at separations between factors }
 then
   long_roots=[vec]: for bar in bars do 2*e(n,bar) od
 , short_coroots=[vec]: for bar in bars do e(n,bar) od
 in
{ let ()=prints("GL_roots:",GL_roots,new_line,"long:roots",long_roots,new_line,"GL_coroots:",GL_coroots,new_line,"short_coroots",short_coroots) in}
 let sub_rd=root_datum(GL_roots##long_roots,GL_coroots##short_coroots,n) then
  w_sub=sub_rd.coxeter_element in
 minimal_representative(W_elt(Sp(2*n),w_sub.matrix))
fi

{dangerous bend
 conjugacy_class_C(pair) is a class for Sp(2n)
 in application, the character table will have its own root datum of type C,
  and these might not agree
}

set convert(WeylElt w,RootDatum rd)=WeylElt:W_elt(rd,w.word)

set character_table_C(int n) = CharacterTable:
   let pairs = partition_pairs(n)
   then classes = [WeylElt,classical_class,string]:
      for PQ in pairs
      do (conjugacy_class_C(PQ), PQ.class_BC,PQ.cycles.cycles_string)
      od
   ,  irreps = [classical_irrep,string,[int]]:
      for (P,Q):PQ in pairs
      do ( PQ.irrep_BC, PQ.to_string
         , for pair in pairs do hyperoctahedral_character(PQ,pair.cycles) od
	 )
      od
   in character_table(Sp(2*n),classes,irreps)
