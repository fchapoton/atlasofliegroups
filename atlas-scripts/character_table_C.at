<nilpotent_orbits.at
<character_tables.at
<classical_W_classes_and_reps.at { for type abbreviation |BC_class|, |cycles| }

set sign_string (bool s) = string: if s then "-" else "+" fi
set parts_string (Partition lambda) = string: { partition without brackets }
  lambda.to_string[1:1~]
{ |cycles@(Partition,Partition)| tacks booleans one cycle lengths, the do this: }
set cycles_string ([int,bool] cycles) = string:
(  "[" ##
   for (l,s)@pos in cycles
   do if =pos then l.to_string##s.sign_string
      else "," ##  l.to_string##s.sign_string
      fi
   od.##
   ##  "]"
)

{     type C     }

{representation of H_n is given by a pair of partitions or a symbol}
{
  symbol:
  0 \le f_1 < f_2 < ... < f_a
  0 \le g_1 < f_2 < ....< g_b
  equivalence: [f_1,.., f_a] -> [0,f_1+1,..., f_a+1], same on g
  every symbol is equivalent to a unique one with a=b+1 and at most one 0
}

set_type Hn_rep  =(Partition,Partition) { (negative cycles, positive cycles) }
set_type Symbol = [[int]]  { must have 2 parts: [f,g], other conditions above }
set_type BC_Orbit = Partition
  { all odd(C) or even(B) parts must have even multiplicity }

{ normalize symbol: |f|=|g|+1 and at most 1 zero }
set normalize (Symbol S) = Symbol:
   let reduce([int] f)=[int]:
      let k = let nf=#f in first(nf,(int i)bool:f[i]>i) in
      if k.< then [] else for e in f[k:] do e-k od fi
   , expand([int] f,int r) = [int]: #r ## for e in f do e+r od
   then f=S[0].reduce, g=S[1].reduce then d=#f-(#g+1)
in case d in [f,g] then [expand(f,-d),g] else [f,expand(g,d)] esac

{ Symbol to Hn_rep (surjection, identifying equivalence classes of Symbols) }
set wrep (Symbol S) = Hn_rep:
( for f_i@i in S[0] do f_i-i ~od.strip_to_partition
, for g_i@i in S[1] do g_i-i ~od.strip_to_partition
)
{ Hn_rep to normalized Symbol }
set symbol (Hn_rep(p,q)) = Symbol:
(( let d=#p-(#q+1) in { if necessasry extend p or q by zeros so as to make d=0: }
   case d then p##:= for : -d do 0 od in () else q##:=for : d do 0 od esac
 )
; [for i:#p do p~[i]+i od,for j:#q do q~[j]+j od]
)

{ equality of Hn_reps }
set = (Hn_rep(a1,a2),Hn_rep(b1,b2)) = bool: a1=b1 and a2=b2

{ equality of symbols (not equivalence) }
set symbols_equal(Symbol a,Symbol b) = bool: a[0]=b[0] and a[1]=b[1]

set BC_classes(int n) = [BC_class]:
   for PQ in partition_pairs(n) do to_cycles(PQ) od

{ word representative in types B and C of conjugacy class for partition pair;
  the parts of P correspond to are cycles without flip, those of Q with flip }
set class_word_BC(Partition P,Partition Q) = [int]:
(  assert((P:=P.strip_to_partition).>, "P is not a partition")
;  assert((Q:=Q.strip_to_partition).>, "Q is not a partition")
;  let nP=sum(P), nQ=sum(Q)
   ,  Pbars = let sum=minus_1 in for p in P do sum+:=p od
   ,  Qbars = let sum=minus_1 in for q in Q do sum+:=q od
then  P_gens = complement(nP,Pbars) { for P part, do the same as in type A }
   ,  Q_gens = { each cycle from Q gets a sign flip when its end is sensed }
      for i:nQ
      do let pos=nP+i { position in [0,n) where we are }
      in if isnt_member(Qbars)(i) then [pos] { extend our cycle }
         else { tack on a sign flip at the final element of the cycle }
	    for j:nQ-i from pos do j od## for j:nQ-i-1 from pos do j ~od
	 fi
      od.##
in P_gens##Q_gens
)

set conjugacy_class_C(BC_class cycles) = WeylElt:
   let n=cycles.rank in W_elt(Sp(2*n),class_word_BC(cycles.to_partition_pair))

set BC_irreps = partition_pairs@int

set character_table_C(int n) = CharacterTable:
   let class_list =  BC_classes(n)
   then classes = [WeylElt,classical_class,string]:
      for cycles in class_list
      do (conjugacy_class_C(cycles), cycles.class_BC,cycles.cycles_string)
      od
   ,  irreps = [classical_irrep,string,[int]]:
      for rep in BC_irreps(n)
      do ( rep.irrep_BC, rep.to_string
         , for cycles in class_list do hyperoctahedral_character(rep,cycles) od
	 )
      od
   in character_table(Sp(2*n),classes,irreps)
