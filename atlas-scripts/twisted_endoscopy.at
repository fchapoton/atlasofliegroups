{very preliminary version of twisted endoscopic lifting
given: (G,delta^v)
G=(split) real group
delta^v=distinguished involution of G^v
H^v=identity component of (G^v)^delta
H = dual group of H.split_form
  = endoscopic group for G
[Of course G shouldn't have to be split, and then H
will be the appropriate quasisplit form of H]

endoscopic(G,delta^v) returns (H,M)
H is complex (you should take its split_form
and M is a matrix relating T_H and T_G

At the moment this has been designed for G=GL(n,R)
it probably doesn't work in other cases: the embed_KGB
function is clumsy

also inverse_lift_std is now done by a brute force search,
until we figure out the right way
}
<mezo.at

set te_verbose=false

{this should be a built-in, or at least in some other file}
set partial_extended_block(Param p,mat delta)=[Param]:
let (B,,)=partial_extended_KL_block(p,delta) in B

set is_stable(ParamPol P)=bool:
let (M,)=stable(monomials(P)) then
v=[int]: for (c,p) in %P do c.split_as_int od in
in_lattice(^M,v)

set partial_KL_P_polynomials (Param p, mat delta) = i_poly_mat:
   let (,P,polys) = partial_extended_KL_block(p,delta)
in for row in rows(P) { mat to i_pol_mat convention flip }
   do for index in row do if index.< then -polys[-index] else polys[index] fi od
   od
{
set partial_fixed_block_of(mat delta,Param p)=
##for a in partial_block(p) do if is_fixed(delta,a) then [a] else [] fi od
}

set big_KL_P_polynomials(Param p,mat delta) = i_poly_mat:
{  let B=partial_fixed_block_of(delta,p) in}
  let (B,,)=partial_extended_KL_block(p,delta) in

  let (I_delta,g,complete_indices,delta_action)=tabulate_indices(B,delta)
  then B_delta = for i in I_delta do B[i] od
  , P=KL_P_polynomials(p)
  then P_delta=KL_P_polynomials(p,delta)
  in
  if =#P_delta
  then prints("Note: block not delta-fixed")
  ; KL_P_polynomials(B) {block is not fixed by delta}
  else let n=#complete_indices then rv=zero_poly_matrix(n) in
     for a:n
     do let (i,epsilon_i)=complete_indices[a] in
        for b:n-a from a
        do let (j,epsilon_j)=complete_indices[b] in
{ prints("a=",a," b=",b," i=",i," e_i=",epsilon_i," j=",j," e_j=",epsilon_j); }
           if a=b
           then  rv:=update_matrix_entry(rv,a,b,one) {diagonal entries}
           elif (epsilon_i*epsilon_j=1) { entries have same sign: P+P^delta}
           then let x=g[i], y=g[j] in
{ prints("P[i][j]=",P[i][j]," x=",x," y=",y," , Pdelta[x][y]=",P_delta[x][y]); }
	     rv:=update_matrix_entry(rv,a,b,poly_add(P[i][j],P_delta[x][y])\2)
	   elif epsilon_i*epsilon_j=minus_1
	   then {(+,-) or (-,+): P-P^delta} let x=g[i], y=g[j] in
	     rv:=update_matrix_entry(rv,a,b,poly_sub(P[i][j],P_delta[x][y])\2)
	   elif abs(epsilon_i)=1 and epsilon_j=0 {(\pm,ind): P}
	   then rv:=update_matrix_entry(rv,a,b,P[i][j])
	   elif epsilon_i=0 and abs(epsilon_j)=1  {(ind,\pm): P}
	   then rv:=update_matrix_entry(rv,a,b,P[i][j])
	   elif epsilon_i=0 and epsilon_j=0
	   then {(ind,ind): P(gamma,mu)+P(gamma,mu^delta)}
	     rv:=update_matrix_entry
		 (rv,a,b,poly_add(P[i][j],P[i][delta_action[j]]))
           fi
        od
     od
  ; rv
  fi

set big_KL_P_signed_polynomials (Param p,mat delta) = i_poly_mat:
{  let B=partial_fixed_block_of(delta,p) in}
  let (B,,)=partial_extended_KL_block(p,delta) in
  let (I_delta,g,complete_indices,delta_action)=tabulate_indices(B,delta) in
  if =#I_delta then KL_P_signed_polynomials(B)
  else
     let P=big_KL_P_signed_polynomials(B,delta)
     , lengths = for i:#g do length(B[i]) od
     , n=#complete_indices
     in
     for a:n do for b:n
     do let (i,)=complete_indices[a], (j,)=complete_indices[b] in
        P:=update_matrix_entry(P,a,b,P[a][b]*minus_1^(lengths[i]+lengths[j]))
     od od
  ; P
  fi

set twisted_root_datum(RootDatum G,mat T)=TwistedRootDatum:(G,T)

set pre_folded(TwistedRootDatum (rd,delta))=(mat,mat):
assert(is_distinguished(rd,delta),"delta is not distinguished");
let T=SubTorus:eigen_lattice(^delta,1) then   {T=(H^\delta)^0; columns are a basis of X_*(T)}
{T is nxr where n=rd.rank and r=dimension(T)}
{ T: matrix of map X_*(T)->X_*(H) \simeq Z^r -> Z^n: this is T.inject
 ^T: matrix of map X^*(H)->X^*(T) \simeq Z^n->Z^r:   this is T.project=T.restrict
}
roots_nonreduced=sort_u(for alpha in rd.posroots do T.restrict(alpha) od) then
roots=mat:##(for alpha in roots_nonreduced do if find(roots_nonreduced,2*alpha)=-1 then [alpha] else [] fi od) then
coroots=[] in
for alpha in roots do
 let pullback_alpha=let j=first(for beta in rd.roots do T.restrict(beta)=alpha od) in rd.roots[j] then
 v=sum(##(for beta in rd.roots do if T.restrict(beta)=alpha then  [coroot(rd,beta)]
   else []
  fi od)) then
 w=2*v/(v*pullback_alpha) {element of X_*(H) which lives in X_*(T)} then
 corestrict_w=solve(T,w).requisition {coordinates of w in the given basis of X_*(T)} in
 coroots#:=ratvec_as_vec(corestrict_w)
od;(roots,coroots)

set Folded(TwistedRootDatum (rd,delta))=(RootDatum,mat):
{assert(rd.is_semisimple or delta=id_mat(#delta),"root datum is not semisimple and delta !=1");}
assert(is_distinguished(rd,delta),"delta is not distinguished");
let T=SubTorus:eigen_lattice(^delta,1) then   {T=(H^\delta)^0; columns are a basis of X_*(T)}
{T is nxr where n=rd.rank and r=dimension(T)}
{ T: matrix of map X_*(T)->X_*(H) \simeq Z^r -> Z^n: this is T.inject
 ^T: matrix of map X^*(H)->X^*(T) \simeq Z^n->Z^r:   this is T.project=T.restrict
}
roots_nonreduced=sort_u(for alpha in rd.posroots do T.restrict(alpha) od) then
{roots=mat:##(for alpha in roots_nonreduced do if find(roots_nonreduced,2*alpha)=-1 then [alpha] else [] fi od) then}
roots=mat:##(for alpha in roots_nonreduced do if find(2*roots_nonreduced,alpha)=-1 then [alpha] else [] fi od) then
coroots=[] in
for alpha in roots do
 let pullback_alpha=let j=first(for beta in rd.roots do T.restrict(beta)=alpha od) in rd.roots[j] then
 v=sum(##(for beta in rd.roots do if T.restrict(beta)=alpha then  [coroot(rd,beta)]
   else []
  fi od)) then
 w=2*v/(v*pullback_alpha) {element of X_*(H) which lives in X_*(T)} then
 corestrict_w=solve(T,w).requisition {coordinates of w in the given basis of X_*(T)} in
 coroots#:=ratvec_as_vec(corestrict_w)
od;
(root_datum_from_positive((roots,coroots),rd.prefers_coroots),T)

{this returns: (RootDatum H,mat M) where
 Gd=G.dual, T_Gd=Cartan of Gd
 Hd=identity component of Gd^{delta^t}
 T_Hd=Cartan of G_d= identity component of (T_Gd)^{delta^t}
 H=Hd.dual = (twisted) endoscopic group of G
 left multiplication by M: H.simple_roots -> root_lattice of G
 left multiplication by ^M: G.simple_coroots -> coroot_lattice of H
 }
set endoscopic(RootDatum G,mat delta)=(RootDatum,mat):
let Gd=G.dual then
trd=twisted_root_datum(Gd,^delta) then
(Hd,T)=Folded(Gd,^delta) then
H=Hd.dual in
(H,T)


{atlas> set G=GL(5,R)
Variable G: RealForm (overriding previous instance, which had type RealForm)
atlas> set delta=G.distinguished_involution
Variable delta: mat (overriding previous instance, which had type mat)
atlas> set (H,M)=endoscopic (G,delta)
Variable H: RootDatum (overriding previous instance, which had type RootDatum)
Variable M: mat
atlas> H
Value: adjoint root datum of Lie type 'B2'
atlas> M*H.simple_coroots
Value:
|  1,  0 |
| -1,  2 |
|  0,  0 |
|  1, -2 |
| -1,  0 |

atlas> M*H.simple_roots
Value:
|  1,  0 |
| -1,  1 |
|  0,  0 |
|  1, -1 |
| -1,  0 |

atlas> ^M*G.simple_coroots
Value:
| -1,  0,  0, -1 |
|  1, -1, -1,  1 |
}

set restrict_action_weak (mat A, mat M) =  { shapes A: n by n, M: n by m }
   case solve(M,A*M) | B.solution: B
   | else null(0,0)
   esac


set lift(mat m,RootDatum H, RootDatum G,mat M)=WeylElt:
let W=G.W then
i=first(for w in W do any(solve(M,w.matrix*M)) and restrict_action(w.matrix,M)=m od)
in W[i]

set lift(WeylElt w_H,RootDatum H, RootDatum G,mat M)=WeylElt:
lift(w_H.matrix,H,G,M)

set lift(KGBElt x_H,mat M,RealForm G, mat delta)=KGBElt:
let lift=lift(x_H.involution,x_H.root_datum,G,M) in
KGB(G,first(for x in KGB(G) do lift.matrix*delta=x.involution od))

{Note: M*theta_x=theta_y*M where y=lift(x,M,G,delta)}
{
set embed(KGBElt x_H,mat M,RealForm G)=embed(x_H,M,KGB(G))

set embed_KGB(RealForm H,mat M,RealForm G)=
let KGB_G=KGB(G) in
for x in KGB(H) do (x,embed(x,M,KGB_G)) od
}

set sign_difference(Param p_G, mat delta)=int:
(-1)^(length(p_G)-delta_l_int(p_G,delta))

set lift_std(Param p_H,mat M,RealForm G, mat delta)=
let x=lift(p_H.x,M,G,delta) then
lift_0=parameter((x,M*p_H.lambda,M*p_H.nu)) in
{(-1)^(length(lift_0)-delta_l_int(lift_0,delta))*lift_0}
sign_difference(lift_0,delta)*lift_0

set lift_std(Param p_H,RealForm G, mat delta)=
let (,M)=endoscopic(G,delta) in lift_std(p_H,M,G,delta)


set lift(ParamPol P_H,mat M,RealForm G,mat delta)=
null_module(G) + for (c,p) in %L_packet_representative(P_H) do c*lift_std(p,M,G,delta) od

set lift_irr(Param p_H, mat M, RealForm G, mat delta)=
lift(p_H.character_formula,M,G,delta)

set lift_irr(Param p_H, RealForm G, mat delta)=
let (,M)=endoscopic(G,delta) in lift_irr(p_H,M,G,delta)

set inverse_lift_std(Param p_G,mat delta)=
let G=p_G.real_form then
(H,M)=endoscopic(G,delta) then
H=H.split_form then
x_H= let index_H=first(for x in KGB(H) do lift(x,M,G,delta)=p_G.x od) in KGB(H,index_H) then
p_H=parameter(x_H,left_inverse(M)*p_G.lambda,left_inverse(M)*p_G.nu) in
sign_difference(p_G,delta)*param_pol(L_packet(p_H))

set inverse_lift_std_by_search(Param p_G,mat delta)=ParamPol:
let G=p_G.real_form then
(H_0,M)=endoscopic(G,delta) then
 H=H_0.split_form then
inf_char_H=left_inverse(M)*p_G.infinitesimal_character then
() =assert(M*inf_char_H=p_G.infinitesimal_character,"inf chars don't match") then
all=all_parameters_gamma(H,inf_char_H) then
index=int: first(for p@i in all do  first_param(lift_std(p,M,G,delta))=p_G od) in
if index=-1 then prints("inverse_lift_std_by_search failed for p_G=",p_G);null_module(H) else
sign_difference(p_G,delta)*param_pol(L_packet(all[index])) fi


set inverse_lift_std(Param p,mat delta)=inverse_lift_std_by_search(p,delta)

set extended_character_formula (Param p,mat delta) =
let (B,,)=partial_extended_KL_block(p,delta) in
let (I_delta,g,complete_indices,delta_action)=tabulate_indices(B,delta),
{P=big_KL_P_signed_polynomials(p,delta) then}
P=big_KL_P_polynomials(p,delta) then
()=if te_verbose then printPolyMatrix(P) fi  then
index=find(complete_indices,(find(B,p),1)) in
{let ()=prints("index=", index) in}
null_module(p.real_form) +
for i:#complete_indices
do let f=eval(P[i][index],s) in
{let ()=prints(new_line,"i= ", i, " f=",f) in}
 let (j,c)=complete_indices[i] in
 {let ()=prints("j=",j, " f=",f, " c=",c, " ", "f*c=", f*c, "  ",B[j]) in} f*c*B[j]
od

{set extended_character_formula_2 (Param p,mat delta) = extended_character_formula(p,block_of(p),delta)}

set inverse_lift_irr(Param p_G,mat delta,RealForm H)=
let P=extended_character_formula(p_G,delta) then
()=if te_verbose then prints("P=",P) fi then
PH=null_module(H) + for (c,p) in %P do c*inverse_lift_std(p,delta) od in
{let ()=prints("PH=", PH) in
(PH,composition_series(PH))}
composition_series(PH)

set inverse_lift_irr(Param p_G,mat delta)=
let (H,)=endoscopic(p_G.real_form,delta) in 
inverse_lift_irr(p_G,delta, H.split_form)

set inverse_lifts_irr_long([Param] params,mat delta)=
for p@i in params do
 let inv=inverse_lift_irr(p,delta) in
 prints(new_line,"i=",i, " p=", p,new_line,"inverse_lift: ", inv)
od

set abv(Param p_H,mat M,RealForm G,mat delta)=
let lift_std=first_param(lift_std(p_H,M,G,delta)) then
()=if te_verbose then prints("lift_std=", lift_std) fi in
inverse_lift_irr(lift_std,delta) 

set abv(Param p_H,RealForm G,mat delta)=
let (,M)=endoscopic(G,delta) in abv(p_H,M,G,delta)

set abv([Param] params_H,RealForm G,mat delta)=
for p_H in params_H do let
(,M)=endoscopic(G,delta) then
abv=abv(p_H,M,G,delta) in
prints(new_line,"p_H=",p_H,new_line,"infinitesimal character of p_H: ", p_H.infinitesimal_character,new_line,"abv.infinitesimal character:", abv.infinitesimal_character,new_line,"abv=", abv);abv od
{
set lift(ParamPol P_H,mat M,RealForm G,mat delta)=
null_module(G) + for (c,p) in %L_packet_representative(P_H) do c*lift_std(p,M,G,delta) od

set lift_trivial(RealForm G)=
let (H,M)=endoscopic(G,G.distinguished_involution) in
lift(H.split_form.trivial.character_formula,M,G,G.distinguished_involution)

set test(RealForm G)=
{(lift_trivial(G), extended_character_formula(G.trivial, block_of(G.trivial), G.distinguished_involution))}
(lift_trivial(G), extended_character_formula(G.trivial,  G.distinguished_involution))
set test(RealForm G)=
{(lift_trivial(G), extended_character_formula(G.trivial, block_of(G.trivial), G.distinguished_involution))}
(lift_trivial(G), extended_character_formula(G.trivial,  G.distinguished_involution))


set test(Param p_G,mat delta)=
let G=p_G.real_form then
(H,M)=endoscopic(G,G.distinguished_involution) then
H=H.split_form then
p_H=inverse_lift_irr(p_G,delta,H) then
lift_p_H=lift(p_H,M,G,delta) then
lift=lift(p_H.composition_series,M,G,G.distinguished_involution) then
ex=extended_character_formula(p_G,delta) in
prints(lift=ex or lift=-ex);(lift,ex)

{the lattice spanned by the columns of M is T-stable}
set is_stable(mat T, mat M)=bool:any(solve(M,T*M))
set is_stable(WeylElt w, mat M)=bool:is_stable(w.matrix,M)
}