<basic.at
<elliptic.at { for |elliptics_for_Levi@(RootDatum,[int])| }
<sort.at { for sorting lists of posroot indices }
<Weylgroup.at { for |order_W@RootDatum| }
<tabulate.at { for |tabulate| }
<cyclotomic.at

{ The purpose of this file is working with Weyl group characters }

{ A first task is to list the $W$ conjugacy classes.

  Every Weyl group element $w$ has an associated Levi subgroup (not necessarily
  standard), whose roots are those whose reflections fix all weights fixed by
  $w$ (its eigenspace for $1$ in the reflection representation). Then $w$ is in
  the Weyl group of this Levi subgroup, and by construction is elliptic there.

  The Weyl subgroup of any Levi subgroup is conjugate in $W$ to that of a
  standard Levi subgroup, so for the purpose of finding the conjugacy classes of
  $W$ it suffices to consider only standard Levi subgroups. A first task is to
  classify standard Levi subgroups (determined by subsets of the simple roots)
  by conjugacy. It turns out that Levi subsystems (whether or not standard) are
  conjugate in $W$ if and only if their sum-of-posroots ($2\rho$) are conjugate.

  So compute $2\rho$ values for standard Levi subsystems, use |dominant| to
  decide $W$-conjugacy, and classify all subsets of the set of simple roots
  (from |power_set| in basic.at) by conjugacy of their associated $2\rho$s.
}

{ $2\rho$ for standard Levi, from predicate to |select| simple root indices }
set two_rho(RootDatum rd, (int->bool) select {from simple indices}) = vec:
  root_datum(columns_with(select,rd.simple_roots)
            ,columns_with(select,rd.simple_coroots)
            ).two_rho

set standard_Levi_conjugacy_representatives (RootDatum rd) = [ [int] ]:
begin
   let reps_by_rho ([[int]] list) = [[int]]:
       let rho2s = [vec]:[] { list of known dominant $2\rho$ values } in
     ##for subset in list
       do let rho2=dominant(rd,two_rho(rd,is_member(subset)))
       in if none(#rho2s,(int i)bool: rho2s[i]=rho2)
          then rho2s#:=rho2 { now we know |rho2|}; [subset] { contribute }
          else [] { |rho2| was already present, contribute nothing }
          fi
       od
   , r = rd.semisimple_rank
   then subsets_by_size = [[[int]]]: for :r+1 do [] od
in for subset in power_set(r) do subsets_by_size[#subset] #:= subset od
;  { now apply |reps_by_rho| to each size class, and concatenate the results }
   for list in subsets_by_size do reps_by_rho(list) od.##
end

{ A second task is to enumerate elliptic conjugacy classes for each standard
  Levi subsystem. The function |elliptics_for_Levi@(RootDatum,[int])| defined
  in elliptic.at accomplishes this.
}

{. list of conjugacy class representatives of rd .}
set conjugacy_class_reps (RootDatum rd) = [WeylElt]:
##for subset in standard_Levi_conjugacy_representatives(rd)
  do elliptics_for_Levi(rd,subset)
  od

set conjugacy_classes = conjugacy_class_reps@RootDatum

{ A third task is to test for conjugacy in $W$. For the moment, lacking a method
  to effectively conjugate a general Levi subsystm toward a standard one, we use
  a method that basically compares characteristic polynomials, but adds a
  special test to discriminate between two classes of elliptic elements for F4
  that share a characteristic polynomial (an outer automorphism switches them).
  This method does not work when the implied Levi subsystem is composite and
  contains a factor F4.
}

set Levi_datum (RootDatum rd, (int->bool) select {from posroot indices}) =
      RootDatum:
   root_datum(simple_system_from_positive
      (columns_with(select,rd.posroots),columns_with(select,rd.poscoroots)) )

{ value of $2\rho$ for not necessarily standard Levi; for conjugacy testing }
set subsystem_2rho (RootDatum rd, (int->bool) select {from posroot indices}) =
      vec: { two_rho(Levi_datum(rd,select)), but we can compute it directly: }
   sum(rd.rank #
       ##for alpha@i in rd.posroots do if select(i) then [alpha] else [] fi od)

{ select posroots indices for (non standard) Levi, given by its simple system }
set Levi_info (RootDatum rd, [int] Levi) = (RootDatum,(int->bool)):
   let orth=kernel(rd.rank ^ for i in Levi do coroot(rd,i) od) in
   (rd,(int j) bool: =coroot(rd,j)*orth)

{ the |select| predicate for the above functions to use for a given |w| }
set Levi_info (WeylElt w) = (RootDatum,(int->bool)):
   let orth=eigen_lattice(matrix(w),1), rd=w.root_datum in
   (rd,(int i) bool: =coroot(rd,i)*orth)

set Levi_datum ((RootDatum,[int])pair) = RootDatum: pair.Levi_info.Levi_datum
set Levi_datum (WeylElt w) = RootDatum: w.Levi_info.Levi_datum

{ conjugacy test; not complete for composite types with a F4 factor }
set is_conjugate (WeylElt x,WeylElt y) = bool:
   { there follows a rather complicated and/or expression: }
   let rd=x.root_datum in y.root_datum=rd { easy and necessary } and
   char_poly(matrix(x))=char_poly(matrix(y)) { easy and necessary } and
(  let L_x = x.Levi_info, L_y = y.Levi_info
in dominant(rd,subsystem_2rho(L_x))=dominant(rd,subsystem_2rho(L_y)) and
(  let Levi_x = Levi_datum(L_x) then type_codes = %Lie_type(Levi_x).semisimple
in none(for (code,) in type_codes do code="F" od) { done unless F4 factors } or
(  assert(#type_codes=1,"Can't handle composite Levi subgroups with F4 factor")
;  if order(x)=6 and length(x)=10 { the hard case } else true
   then let is_negated(WeylElt w,RootDatum rd) = (int->bool):
      let M = w.matrix+1 in (int i)bool: =M*root(rd,i) { root in -1 eigenspace }
      , Levi_y = Levi_datum(y)
      then alpha = root(Levi_x,first(24,is_negated(x,Levi_x)))
      ,    beta =  root(Levi_y,first(24,is_negated(y,Levi_y)))
   in dominant(rd,alpha)=dominant(rd,beta) { whether these have same length }
   fi
)))

{ some simple functions that exploit the conjugacy test }
set conjugacy_class_rep (WeylElt w, [WeylElt] classes) = WeylElt:
   for rep in classes do if is_conjugate(w,rep) then return rep fi od;
   error("missing class")

set conjugacy_class_rep (WeylElt w) = WeylElt:
  conjugacy_class_rep(w,conjugacy_class_reps(w.root_datum))


{ explicitly enumerate the conjugacy class of |w|, with conjugacy witnesses }
set conjugators_and_conjugacy_class (WeylElt !w) = ([WeylElt],[WeylElt]):
   let rd=w.root_datum, class = [w]
   then conjugators= [id_W(rd)], current=0, ssr=semisimple_rank(rd)
   , absent (WeylElt x) = none(for y in class do @: y=x od)
in while current<#class
   do let c = conjugators[current], w=class[current] in current+:=1
   ;  for s:ssr
      do let sws=s#w#s in
         if absent(sws) then class #:= sws; conjugators #:= s#c fi
      od
   od; (conjugators,class)

set full_conjugacy_class (WeylElt w) = [WeylElt]:
   let (,class)=conjugators_and_conjugacy_class(w) in class

set conjugator (WeylElt x, WeylElt w) = WeylElt:
   assert(is_conjugate(x,w),"Weyl group elements are not conjugate");
   let (conjugators,class)=conjugators_and_conjugacy_class(w) in
   conjugators[last(#class,(int i)bool: class[i]=x)]

{ The next task is to determine the order of a conjugacy class of |w| without
  enumerating it, computing using some basic group theory. Since we shall reduce
  to a minimal (non standard) Levi subsystem in whose Weyl group |w| lives, we
  can compute the order of its centralizer in that Weyl group, where it is
  elliptic. This will allow computing the order of the conjugacy class in the
  Levi Weyl group, but this needs to be multiplied by the number of Levi systems
  conjugate to the one at hand. This is the index in $W$ of the normaliser $N_L$
  of the Levi system, but we cannot find the size of $N_L$ without some amount
  of explicit enumeration. We first do a direct approach, then an improvement.

  The function |Levi_orbit| generates the orbit under $W$ of a Levi subsystem,
  represented by the indices of the positive roots forming its simple
  generators. It uses the fact that simple reflections have an easy action on
  such sets of postive roots: either the set contains the simple root for the
  applied reflection, in which case the Levi system is unchanged so no new orbit
  element is produced, or else one just reflects each of the generators for the
  Levi system, which remain positive. One does need to sort the result in order
  to have a unique representation of each simple system, for equality testing.
}

{ $W$-orbit of (non standard) Levi subsystem, represented by simple systems }
set Levi_orbit (RootDatum rd, [int] Levi { posroot indices } ) = [[int]]:
   let root_perm =
     for i:rd.semisimple_rank
     do for alpha in rd.posroots do root_index(rd,W_gen(rd,i)*alpha) od
     od { this is negative on the main diagonal, but those entries are unused }
   then act(int i,[int] roots) = (bool,[int]):
      if is_member(roots)(i)
      then (false,roots) { Levi's own simple reflection normalises system }
      else (true, let map = root_perm[i] in for j in roots do map[j] od.sort)
      fi
   , orbit = [Levi], current=0
in while current<#orbit
   do let L=orbit[current] in current+:=1
   ;  for s:rd.semisimple_rank
      do let (moved,M)=act(s,L) in
         if moved and none(#orbit,(int i):orbit[i]=M) then orbit #:= M fi
      od
   od; orbit


{ Computing just the size of this Levi orbit can be done a bit more efficiently
  than generating it, though it requires a some preliminary computation. The
  idea is to use the stabiliser subgroup $M$ in $W$ of $\rho_L$; though it does
  not contain $N_L$, the intersection $M\cap N_L$ has known index in $N_L$,
  namely the size of $W_L$ (every coset by $W_L$ meets the instersection
  uniquely). So we generate the hopefully small orbit under $M$ of images of the
  Levi system, then by dividing the size of $M$ by that of the orbit find the
  size of the intersection, which multiplied by that of $W_L$ gives the size
  of $N_L$, and dividing the size of $W$ by that gives our Levi orbit size.

  The orbit generation here is taylored to the specific situation, whence we do
  it using local code (the |begin|-|end| block below) rather than writing or
  using a more general orbit generation. The special circumstance is that we
  know that all elements of the acting subsgroup fix $\rho_L$, so the only way
  they can map all simple generators of $L$ to roots of $L$ is by permuting them
  among each other. We can then ignore the distinction between a root and its
  opposite (working only with positive root indices) and not worry about
  choosing the simple generators for the positive part of each Levi system
  (which is why we had to single out the "do nothing" case above): the Levi
  system implied by a set of indices is the one additively generated by those
  roots and their opposites, and this results in the same system only if the
  indices are the same up to permutation. So again we can use an equality test
  for orbit membership, provided we sort our lists of indices to be increasing.
}

set Levi_normalizer_index ((RootDatum,(int->bool))(rd,select):Levi_info) = int:
   let rho2_L = subsystem_2rho(Levi_info)
   then rho_L_stabiliser = Levi_datum(rd,(int i)bool: =coroot(rd,i)*rho2_L)
   then stab_orbit = [[int]]:
      begin
      let root_perm =
         let ab (int i) = int: if i.< then -1-i else i fi { to positive index }
         in for beta in rho_L_stabiliser.simple_roots
            do for alpha in rd.posroots
               do root_index(rd,reflect(rd,beta,alpha)).ab
               od
            od
      , Levi = { indices in |rd| for simple system of Levi }
         list(rd.nr_of_posroots,(int i): select(i) and coroot(rd,i)*rho2_L=2)
      then act(int i,[int] roots) = [int] :
         let map = root_perm[i] in for j in roots do map[j] od.sort
      , orbit = [Levi]
      , current=0
      in while current<#orbit
         do let L=orbit[current] in current+:=1
         ;  for k:#root_perm
            do let M=act(k,L) in
               if none(#orbit,(int i):orbit[i]=M) then orbit #:= M fi
            od
         od
      ; { stab_orbit = } orbit
      end
   in rho_L_stabiliser.order_W \ #stab_orbit { index of $W_L$ in $N_L$ }

set Levi_orbit_size ((RootDatum,(int->bool))(rd,):Levi_info) = int:
  rd.order_W \ (Levi_info.Levi_normalizer_index * Levi_info.Levi_datum.order_W)

{ Now onward to the task of getting the size of the conjugacy class of |w| in
  for |Levi_datum(w)|, where ignoring the central torus it is elliptic. This
  root datum can have multiple simple factors, and we can decompose |w| as
  commuting product of elements of the Weyl groups of the simple factors, and
  its conjugacy class will be the Cartesian product of the conjugacy classes of
  the factors (the same goes for the centraliser). The following function
  determines this decomposition, where each |WeylElt| in the result is
  associated to a different root datum, which is simple up to a central torus.
}

set elliptic_simple_decomposition (WeylElt w) = [WeylElt,(string,int)]:
   let rd_L = Levi_datum(w)
   then (type,map)=Cartan_matrix_type(rd_L.Cartan_matrix)
   then codes = %type.semisimple, w_L=W_elt(rd_L,w.matrix) { convert }
   , offset=0 { rank within |type| already seen in loop below }
   , !r = rd_L.rank { full rank, needed when gathering roots/coroots }
in for (,rank):code in codes { traverse the simple factors }
   do let sub_map = map[offset:offset+rank] { index mapping for this factor }
      then factor_word =
	 ## for s in w_L.word
	    do let i=find(sub_map,s) in if i.>= then [i] else [] fi
	    od
      , simple_datum = root_datum
	( r # for i in sub_map do rd_L.simple_roots[i]   od
	, r # for i in sub_map do rd_L.simple_coroots[i] od
	)
   in ( W_elt(simple_datum,factor_word), code )
   next offset +:= rank
   od

set centralizer_order = (WeylElt->int):
  let elliptic_simple_order(WeylElt w,(string type, int rank)) = int:
     { here |w| is elliptic, with simple associated datum of given type,rank }
     case char_index(type,"ABCD")
     in rank+1 { type $A_n$ has unique elliptic, an $n+1$ cycle permutation }
     , order_of_centralizer_elliptic_BCD(w)
     , order_of_centralizer_elliptic_BCD(w)
     , order_of_centralizer_elliptic_BCD(w)
     else exceptional_elliptic_centr_order(type,rank,w.matrix.char_poly)
     esac
  in { centralizer_order = }
  (WeylElt w) int:
    for (w_i,type_rank) in elliptic_simple_decomposition(w)
    do elliptic_simple_order(w_i,type_rank)
    od . product * Levi_normalizer_index(w.Levi_info)

{. number of elements of a conjugacy class .}
set size_of_conjugacy_class (WeylElt w) = int:
  w.root_datum.order_W \ w.centralizer_order
set sizes_of_conjugacy_classes (RootDatum rd) = [int]:
  for w in conjugacy_class_reps(rd) do w.size_of_conjugacy_class od

{ test: sum of sizes of conjugacy class = |W| }
set test_size_of_conjugacy_classes (RootDatum rd) = (int,int):
  let c=conjugacy_classes(rd) in
  (sum(for w in c do  size_of_conjugacy_class(w)  od), order_W(rd))

{. sorting routines for conjugacy classes .}
set sort_by( (WeylElt -> int) f)= ([WeylElt] v) [WeylElt]:
    for index in inv_standardisation(for x in v do f(x) od) do v[index] od
set sort_by_order = ([WeylElt] -> [WeylElt]): sort_by(order@WeylElt)

{. print order, length, Levi.}
set print_conjugacy_classes ([WeylElt] C) = void:
  let data=["order","length","Levi"] { column headers }
  # for w in C.(sort_by(length@WeylElt))
    do [ w.order.to_string
       , w.length.to_string
       , w.Levi_datum.Lie_type.semisimple.to_string[10:1~]
       ]
    od
  in tabulate(data,"rrl",2," ")

set print_conjugacy_classes (RootDatum rd) = void:
  print_conjugacy_classes(conjugacy_class_reps(rd))

{. print elliptic classes only .}
set print_elliptic_conjugacy_classes (RootDatum rd) = void:
  print_conjugacy_classes(sort_by_order(elliptic(rd)))

{. w\in W is conjugate to classes[i] .}
set conjugacy_class_number (WeylElt w) = int:
  let classes=w.root_datum.conjugacy_class_reps in
  first(#classes, (int i)bool: is_conjugate(w,classes[i]))

{   some long print commands   }

{. print order, length, Levi, size_of_class, cyclotomic polynomial.}
set print_conjugacy_classes_long([WeylElt] C)=void:
  let count=0
  then data=["order","length","Levi","size","cyclotomic"]#
    for w in sort_by_order(C)
    do let (L,)=Levi_info(w), size=size_of_conjugacy_class(w)
       , cyclotomics=product_of_cyclotomic(rat_poly(char_poly(w)))
       in count+:=size;
    [int_format(order(w)), int_format(length(w)),to_string(Lie_type(L))[9:]
    ,int_format(size), to_string(cyclotomics)]
    od
  in tabulate(data,"rrrrr",2," ");
  prints(new_line,"sum of sizes of conjugacy classes:", count,new_line
        ,"Order of W: ",order_W(C[0].root_datum))

set print_conjugacy_classes_long (RootDatum rd) = void:
  print_conjugacy_classes_long(conjugacy_class_reps(rd))

{. print elliptic classes only .}
set print_elliptic_conjugacy_classes (RootDatum rd) = void:
  print_conjugacy_classes(sort_by_order(elliptic(rd)))
set print_elliptic_conjugacy_classes_long (RootDatum rd) = void:
  print_conjugacy_classes_long(sort_by_order(elliptic(rd)))
