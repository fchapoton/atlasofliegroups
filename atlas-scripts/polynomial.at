<basic.at

{ Several representations of univariate polynomials are defined below, all have
  in common a dense representation of coefficients starting at degree 0
}

set_type i_poly = vec { compact storage, machine integers as coefficients }
set_type i_poly_mat = [[i_poly]] { sublists are matrix rows, not columns! }

{ addition of vectors (overrides definition in basic.at) to allow vectors of
  possibly different lengths, implicitly extending on the right by zeros as
  needed. This gives the right thing for coefficient vectors of polynomials.
}

set fix_add = +@(vec,vec)
set fix_sub = -@(vec,vec) { save fixed-length vector addition and subtraction }
set dot_product = *@(vec,vec) { and scalar product }

{ prepare for binding arithmetic on |i_poly| values differently inside this file }
forget +@(vec,vec)
forget -@(vec,vec)
forget *@(vec,vec)

set constant_poly (int n) = i_poly: if =n then [] else [n] fi

{ for convenience declare some constants, the ! makes changes to these illegal }
set !poly_0 = constant_poly(0),
    !poly_1 = constant_poly(1),
    !poly_2 = constant_poly(2),
    !poly_q  = i_poly: [0,1],
    !poly_q2 = i_poly: [0,0,1]

set + = flex_add@(i_poly,i_poly)
set - = flex_sub@(i_poly,i_poly)
set * = convolve@(i_poly,i_poly)

set poly_product = *@(i_poly,i_poly) { this binding will remain exported }
set poly_plus    = +@(i_poly,i_poly) { this binding will remain exported }
set poly_minus   = -@(i_poly,i_poly) { this binding will remain exported }

{ reduce polynomial by dropping trailing zeros; shouldn't really be needed }
set strip (i_poly v) = i_poly: v + poly_0 { operator + does actual stripping }
set degree (i_poly P) = int: #P.strip-1 { degree, or -1 for the zero polynomial }

{ evaluate polynomial at integer }
set evaluate_at_1 (i_poly v) = int: { often we need this easy case }
   dot_product(v,ones(#v)) { use vector dot-product here }

set eval (i_poly v,int k) = int:
  let sum=0 in  for e in v ~do sum:= e + k*sum od; sum

{ evaluate polynomial at Split value }
set eval (i_poly v,Split w)= Split:
  let sum=Split:0 in  for e in v ~do sum:= e + w*sum od; sum

set at_s (i_poly v) = Split: eval(v,Split:(0,1))

set monic_divide (i_poly P, i_poly D) = (i_poly,i_poly): { quotient, remainder }
   assert(#D>0 and D~[0]=1,"Not a monic divisor");
   let deg_D = D.degree, l_P=#P in
   if l_P<deg_D then (poly_0,P##null(deg_D-l_P))
   else
      for i: l_P-deg_D { quotient has $\deg P+1-\deg D$ terms }
      do let c=P~[i] in for j:deg_D from 1 do P~[i+j] -:= c*D~[j] od
      od
   ;  (P[deg_D:] {quotient from upper part}, P[:deg_D] {remainder} )
   fi

{division of integer polynomials, d is not required to be monic, but might fail}
{. division of integer polynomials p=dq+r .}
set divide(i_poly p,i_poly d) = (i_poly,i_poly):
   let rec_fun f(i_poly q, i_poly r) = (i_poly,i_poly):
      if #r<#d then (q,r)
      else let t=i_poly: null(#r-#d) # rat_as_int(r~[0]/d~[0]) in f( q+t , r-t*d )
      fi
   in f(poly_0,p)


{			  Polynomial matrices				}


set shape (i_poly_mat M) = (int,int): if =#M then (0,0) else (#M,#M[0]) fi

set transpose(i_poly_mat M)=i_poly_mat: { sublists must be of equal length }
  let n=#M in
  if n=0 then M { not much we can do for an empty list }
  else for j:#M[0] do for i:n do M[i][j] od od
  fi

{ dot product of two vectors of polynomials (the name avoids *@(mat,mat)) }
set dot_product([i_poly] v,[i_poly] w) = i_poly:
  let sum=i_poly:[] in for p@i in v do sum +:= p*w[i] od; sum

{ multiply two matrices of polynomials; here row-based representation really
  makes a difference. Note that using operator * is unambiguous here
}
set *(i_poly_mat A,i_poly_mat B) = i_poly_mat:
  let n=#A, B_tr=transpose(B) { best to rearrange B once and for all }
  then m=#B_tr { number of rows of B_tr, or columns of B, and of result }
  in for i:n do for j:m do dot_product(A[i],B_tr[j]) od od

{ add lists of polynomials, assumed of same length (name avoids +@(mat,mat)) }
set poly_list_add([i_poly] v,[i_poly] w) = [i_poly]:
( assert(#v=#w,"length mismatch adding lists of polynomials")
; for p@i in v do p+w[i] od
)
set poly_list_sub([i_poly] v,[i_poly] w) = [i_poly]:
( assert(#v=#w,"length mismatch adding lists of polynomials")
; for p@i in v do p-w[i] od
)

set -(i_poly_mat M) = i_poly_mat: for row in M do for p in row do -p od od

{ add or subtract matrices of the same size }
set +(i_poly_mat A,i_poly_mat B)=i_poly_mat:
( assert(#A=#B,"number of rows mismatch adding matrices of polynomials")
; for row@i in A do poly_list_add(row,B[i]) od
)
set -(i_poly_mat A,i_poly_mat B)=i_poly_mat:
( assert(#A=#B,"number of rows mismatch adding matrices of polynomials")
; for row@i in A do poly_list_sub(row,B[i]) od
)

set scalar_multiply([i_poly] v,i_poly f) = [i_poly]:
  for p in v do p*f od

{ polynomial scalar times polynomial matrix }
set *(i_poly f,i_poly_mat M) = i_poly_mat:
  for row in M do scalar_multiply(row,f) od
{ integer scalar case can be doen a bit more efficiently }
set *(int c, i_poly_mat M) = i_poly_mat:
  for row in M do for p in row do p*c { use the *@(vec,int) built-in } od od

{ update one entry in a list of polynomials, for instance in a row of a matrix }
set update_row([i_poly] R, int j,i_poly v) = [i_poly]: R[j]:=v; R
{ update one row of a matrix (replacing it by a given new row) }
set update_matrix_row(i_poly_mat M, int i, [i_poly] row)= i_poly_mat: M[i]:=row; M
{ update one entry in a matrix }
set update_matrix_entry(i_poly_mat M, int i, int j, i_poly v)= i_poly_mat:
  let row=M[i] in row[j]:=v; M[i]:=row; M



set zero_poly_row (int n) = [i_poly]: for :n do poly_0 od
set zero_poly_matrix (int rows, int columns) = i_poly_mat:
  let !row=zero_poly_row(columns) in for :rows do row od
set zero_poly_matrix(int n) = i_poly_mat:zero_poly_matrix(n,n)
set scalar_poly_matrix (int n, int c) = i_poly_mat:
  let !row=zero_poly_row(n) { model row, almost equal to each wanted row } in
  for i:n do update_row(row,i,constant_poly(c)) od
set identity_poly_matrix (int n) = i_poly_mat: scalar_poly_matrix(n,1)
set mat_as_poly_mat (mat M) = i_poly_mat:
 let (r,c)=shape(M) in for i:r do for j:c do [M[i,j]] od od

set + (i_poly_mat M, i_poly p) = i_poly_mat: { add polynomial scalar matrix }
  for row@i in M  do for e@j in row do if i=j then e+p else e fi od od
set - (i_poly_mat M, i_poly p) = i_poly_mat: M+-p

set ^ = (i_poly,int->i_poly): { power of a polynomial }
  let one=i_poly:[1] { use local constant for efficiency } in
  (i_poly p,int n) i_poly: { the actual powering function }
    if n=0 then [1]
    else { no point in trying to do this by repeated squaring: is not faster }
      let f=p in while (n-:=1)>0 do f *:= p od; f
    fi

{ equality of polynomial matrices }
set = (i_poly_mat A,i_poly_mat B) = bool:
  all(#A, (int i): let r=A[i],s=B[i] in #r=#s and all(#r, (int j): r[j]=s[j] ))

{ polynomial matrix is 0 if all its entries are zero-length polynomials }
set is_zero (i_poly_mat M) = bool:
  all(#M, (int i): let r=M[i] in all(#r, (int j): =#r[j]) )

set upper_unitriangular_inverse (i_poly_mat P) = i_poly_mat:
  let n=#P { number of rows in matrix }, dummy_row=zero_poly_row(0)
  then Q= for :n do dummy_row od { prepare |n| rows, but leave them empty now }
  in { solve equation $P*Q=I$ for $Q$, proceeding from bottom to top }
  for i:n { reverse traversal loop with reverse accumulation -> straight value }
  ~do let Pi=P[i] { we use only this part of P during this iteration } in
    Q[i] := { computed row is stored as |Q[i]|, and contributed to result }
    (zero_poly_row(i) # poly_1) { beginning of row |Q[i]| is somewhat boring }
    ## { concatenate with more interesting newly computed part of |Q[i]| }
      for j: n-i-1 from i+1 { left to right, but computations are independent }
      do let sum=poly_0 in for k: j-i from i+1 do sum -:= Pi[k] * Q[k][j] od
      ; sum    { contribute $Q_{i,j} = - \sum_{k=i+1}^j P_{i,k}Q_{k,j}$ }
      od
  ~od

{ compute PMP^{-1} where P is a permutation of [1,,,n]
  and M is a polynomial matrix
}
set poly_permute_basis([int] P, i_poly_mat A) = i_poly_mat: { P is permutation }
  for i:#A do let row=A[P[i]] in for j:#row do row[P[j]] od od

{ some printing functions }

{ make a printable string out of a polynomial and name of indeterminate,
  for use in other print functions }
set stringPoly (i_poly v, string q)= string:
  if =v then "0"
  else
    let rv="" in
    for c@k in v do
      if c!=0 then
	let coef = if c<0 then "-" else "+" fi +
            if abs(c)=1 and k>0 then "" else int_format(abs(c)) fi
	,   term = if k>1 then q+"^"+int_format(k) elif k=0 then "" else q fi
	in rv ##:= coef+term
      fi
    od
  ; rv
  fi

{ nice printing of a polynomial }
set printPoly (i_poly v) = void: prints(stringPoly(v,"q"))

{ M=poly_mat is a polynomial matrix; e.g.
  expr> set M= poly_mat: [[ [0,1], [0,0,1]], [[0], [1]]]
  expr> printPolyMatrix (M)
   +q +q^2
   0 +1
}

set printPolyMatrix(i_poly_mat M,int space_size)= void:
  let space= " "*space_size, wd = max(for v in ##M do #stringPoly(v,"q") od)
  in
    for row in M
    do prints(##for v in row do space+l_adjust(wd,stringPoly(v,"q")) od)
    od

set printPolyMatrix (i_poly_mat M) = void: printPolyMatrix(M,3)



{ restore normal vector arithmetic }
forget +@(vec,vec)
forget -@(vec,vec)
forget *@(vec,vec)
set + = fix_add@(vec,vec)
set - = fix_sub@(vec,vec)
set * = dot_product@(vec,vec)

set sgn_poly (int k) = i_poly:
  assert(!=k,"taking sign of 0"); [if k.< then -1 else 1 fi]

set divide_by (int k,i_poly v) = i_poly: ratvec_as_vec(v/k)

{i_polynomial has only non-negative coefficients}
set is_non_negative = (i_poly->bool): >=@vec { same condition as "dominance" }

set top_left_square_block (i_poly_mat M,int size) = i_poly_mat:
  for row in M[:size] do row[:size] od
