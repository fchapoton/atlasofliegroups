<Vogan-dual.at

set is_valid(KGBElt_gen y,ratvec gamma)=bool:is_integer(square(y)-gamma)

set parameter(KGBElt x,KGBElt_gen y,ratvec gamma)=Param:parameter(x,gamma-y.torus_factor,gamma)

set y_gen(Param p)=KGBElt_gen: let y=(dual(p.inner_class),-^p.x.involution,p.infinitesimal_character-p.lambda) in
assert(is_valid(y,p.infinitesimal_character),"y_gen(p) is not valid");y

set simple_imaginary_roots(KGBElt x)=mat:
let (simple_imaginary_roots,)=simple_imaginary_subsystem(x) in simple_imaginary_roots

set simple_imaginary_reflections(KGBElt x)=[WeylElt]:
for alpha in simple_imaginary_roots(x) do root_reflection(x.root_datum,alpha) od

set fiber(KGBElt x)=[KGBElt]:
for (y,) in cross_sub_orbit(simple_imaginary_reflections(x),x) do y od

set fiber(RealForm G,mat theta)=[KGBElt]:
##for x in KGB(G) do if involution(x)=theta then [x] else [] fi od

{given G, gamma,y -> defines an L-homomorphism phi: W_R -> LG}

set L_packet(RealForm G,ratvec gamma, KGBElt_gen y_gen)=[Param]:
assert(is_valid(y_gen,gamma), "(y_gen,gamma) is not valid");  
let fiber=fiber(G,-^y_gen.involution) in
##for x in fiber do
 let p=parameter(x,y_gen,gamma)  then
 P=finalize(p) in
 monomials(P) od

set L_packet(Param p)=[Param]:
for x in fiber(p.x) do parameter(x,p.lambda,p.nu) od

set L_packet_representative(Param p)=Param:
first_param(param_pol(L_packet(p)))

set L_packet_stable_sum(Param p)=ParamPol:
param_pol(L_packet(p))

{union of L-packets, with multiplicity one, for each parameter occuring
 these L-packets can contain parameters NOT in the given [Param]}
set L_packets([Param] params)=[[Param]]:
let representatives=[Param]:[] in
for p in params do
 let rep=L_packet_representative(p) in 
 if find(representatives,rep)=-1 then representatives#:=rep fi
 od;
for p in representatives do L_packet(p) od

{P is a sum of standards:}
set is_stable_std(ParamPol P)=bool:
all(for p in monomials(P) do P[p]=P[L_packet_representative(p)] od)

{P is a sum of irreducibles:}
set is_stable_irr(ParamPol P)=bool:
is_stable_std(character_formula(P))

{default: sum of irreducibles}
set is_stable(ParamPol P)=bool:is_stable_irr(P)


{misguided:}
set L_packet_representative(ParamPol P)=ParamPol:
let rv=null_module(P.real_form) in
while #P>0 do
 let (c,p)=first_term(P) in
 P+:=-c*p;
  if rv[L_packet_representative(p)] = 0 then
   rv+:=c*p
  fi
 od;rv

{
set L_packets_old([Param] list)=[[Param]]:
let P=param_pol(list) then
P_reps=L_packet_representative(P) in
for p in monomials(P_reps) do
  ##for x in fiber(p.x) do
   let p_new=parameter(x,p.lambda,p.nu) in
   if P[p_new]!=0 then [p_new] else [] fi
  od
od

set stable_matrix([[Param]] packets)=
let all=##packets then
M=null(#all,#packets) then
increment=0 in
for col_number:#packets do
  for j:#packets[col_number] do
     M[col_number,increment+j]:=1
  od
od;
M
}






{lifting from quasisplit group to inner form}
{on parameter level: formal, take (x,lambda,nu) 
to \sum (x_i,lambda,nu) for G where {x_i} is the fiber
for G over p.x.involution}
set inner_lift_std(Param p,RealForm G)=ParamPol:
param_pol(for x in fiber(G,p.x.involution) do parameter(x,p.lambda,p.nu) od,G)

{for ParamPol, replace each sum p_i over an L-packet with a single p_i,
since inner_lift_std stabilizes it}
set inner_lift_std(ParamPol P,RealForm G)=ParamPol:
null_module(G) + for c@p in L_packet_representative(P) do c*inner_lift_std(p,G) od

{P is a sum of irreducibles; it  should be stable, although we don't test for this
inner_lift(P,G):
  P -> cf=character_formula(P)
    -> inner_lift_std(cf)
    -> composition_series($)
}    
set inner_lift(ParamPol P,RealForm G)=ParamPol:
composition_series(inner_lift_std(character_formula(P),G))

set inner_lift_std(Param p,int i)=ParamPol: inner_lift_std(p,p.real_form.real_forms[i])
set inner_lift_std(ParamPol P,int i)=ParamPol: inner_lift_std(P,P.real_form.real_forms[i])
set inner_lift(Param p,int i)=ParamPol: inner_lift(p,p.real_form.real_forms[i])
set inner_lift(ParamPol P,int i)=ParamPol: inner_lift(P,P.real_form.real_forms[i])


{p=parameter(p.x,p.y_gen,p.infinitesimal_character) should true}




{


set dual_inner_class (ratvec gamma, InnerClass ic) = InnerClass:
dual_integral(ic,gamma)
set dual_real_forms(ratvec gamma,InnerClass ic)=[RealForm]:
real_forms(dual_inner_class(gamma,ic))

set dual_inner_class (ratvec gamma, KGBElt x) = InnerClass:
dual_inner_class(gamma,x.inner_class)

set dual_real_forms (ratvec gamma, KGBElt x) = [RealForm]:
dual_real_forms(gamma,x.inner_class)






{y is a KGB element on the dual side, possibly for a subgroup H^v of G^v
 return all KGB elements for G compatible with y, i.e.
 transpose(theta_x)=-theta_y, so that
 parameter(x,y) is allowed, i.e.
 parameter(x,y,gamma) is allowed for appropriate gamma
usually: H^v is the subgroup on the dual side corresponding to integral
 root system; precisely given gamma\in X^*_Q,
 H=integrality_datum(G,gamma) is on the group side (endoscopic group)
 dual(H) is a subgroup on G^v}

set dual_KGB(RealForm G,KGBElt y)=[KGBElt]:fiber(G,-^involution(y))
set dual_real_form(Param p)=dual(p).real_form

set L_packet(RealForm G,ratvec gamma, KGBElt y)=
assert(is_valid(y,gamma), "(y,gamma) is not valid");
let fiber=fiber(G,-^y.involution) in
for x in fiber do parameter(x,y,gamma) od



{these two should agree:
L_packet(p) and L_packet(p.real_form,p.infinitesimal_character, dual(p).x)}






{
set dual_KGB (KGBElt x,ratvec gamma, InnerClass dual_int_ic) = KGBElt:
{  let  dual_tf=infinitesimal_character(p) - lambda(p)}
  let  dual_tf=gamma-x.root_datum.rho
  then dual_theta = -^involution(x)  { |dual_tf| is |dual_theta|-stable }
  then (simple_ims,) =
quit
    simple_system_from_positive(imaginary_sys(dual_int_ic,dual_theta))
  then (rho_corr,dLR) { correct the change of rho_check implicit in dual_tf }
    = fixed_lift(dual_theta-1,rho(root_datum(p))-rho(integrality_datum(p)))
  then integral_shift=integral_shift(rho_corr-rho_r(x),simple_ims,dLR)
  then phi = dual_tf + rho_corr { dual_theta stable rep.tive of dual square }
  then ()=prints("integral_shift:", integral_shift, "phi=", phi)
   then ()=prints("rho_corr:", rho_corr) 
  in KGB_elt(dual_int_ic,
             dual_theta,
             phi+integral_shift)
	     }
}	     