<Vogan-dual.at

set square (KGBElt_gen x)=ratvec:
  square_unnormalized(inner_class(x),involution(x),(torus_factor(x)+rho_check(x.inner_class))/2)

set is_valid(KGBElt_gen y,ratvec gamma)=bool:is_integer(square(y)-gamma)

set parameter(KGBElt x,KGBElt_gen y,ratvec gamma)=Param:parameter(x,gamma-y.torus_factor,gamma)
set y_gen(Param p)=KGBElt_gen: let y=(dual(p.inner_class),-^p.x.involution,p.infinitesimal_character-p.lambda) in
assert(is_valid(y,p.infinitesimal_character),"y_gen(p) is not valid");y

set simple_imaginary_roots(KGBElt x)=mat:
let (simple_imaginary_roots,)=simple_imaginary_subsystem(x) in simple_imaginary_roots

set simple_imaginary_reflections(KGBElt x)=[WeylElt]:
for alpha in simple_imaginary_roots(x) do root_reflection(x.root_datum,alpha) od

set fiber(KGBElt x)=[KGBElt]:
for (y,) in cross_sub_orbit(simple_imaginary_reflections(x),x) do y od

set fiber(RealForm G,mat theta)=[KGBElt]:
##for x in KGB(G) do if involution(x)=theta then [x] else [] fi od

set L_packet(RealForm G,ratvec gamma, KGBElt_gen y_gen)=
assert(is_valid(y_gen,gamma), "(y_gen,gamma) is not valid");
let fiber=fiber(G,-^y_gen.involution) in
for x in fiber do parameter(x,y_gen,gamma) od

set L_packet(Param p)=
for x in fiber(p.x) do parameter(x,p.lambda,p.nu) od

set L_packet_representative(Param p)=
first_param(param_pol(L_packet(p)))

set L_packet_representative(ParamPol P)=
let rv=null_module(P.real_form) in
while #P>0 do
 let (c,p)=first_term(P) in
 P+:=-c*p;
  if rv[L_packet_representative(p)] = 0 then
   rv+:=c*p
  fi
 od;rv




{p=parameter(p.x,p.y_gen,p.infinitesimal_character) should true}




{


set dual_inner_class (ratvec gamma, InnerClass ic) = InnerClass:
dual_integral(ic,gamma)
set dual_real_forms(ratvec gamma,InnerClass ic)=[RealForm]:
real_forms(dual_inner_class(gamma,ic))

set dual_inner_class (ratvec gamma, KGBElt x) = InnerClass:
dual_inner_class(gamma,x.inner_class)

set dual_real_forms (ratvec gamma, KGBElt x) = [RealForm]:
dual_real_forms(gamma,x.inner_class)






{y is a KGB element on the dual side, possibly for a subgroup H^v of G^v
 return all KGB elements for G compatible with y, i.e.
 transpose(theta_x)=-theta_y, so that
 parameter(x,y) is allowed, i.e.
 parameter(x,y,gamma) is allowed for appropriate gamma
usually: H^v is the subgroup on the dual side corresponding to integral
 root system; precisely given gamma\in X^*_Q,
 H=integrality_datum(G,gamma) is on the group side (endoscopic group)
 dual(H) is a subgroup on G^v)
}
set dual_KGB(RealForm G,KGBElt y)=[KGBElt]:fiber(G,-^involution(y))
set dual_real_form(Param p)=dual(p).real_form

set L_packet(RealForm G,ratvec gamma, KGBElt y)=
assert(is_valid(y,gamma), "(y,gamma) is not valid");
let fiber=fiber(G,-^y.involution) in
for x in fiber do parameter(x,y,gamma) od



{these two should agree:
L_packet(p) and L_packet(p.real_form,p.infinitesimal_character, dual(p).x)}






{
set dual_KGB (KGBElt x,ratvec gamma, InnerClass dual_int_ic) = KGBElt:
{  let  dual_tf=infinitesimal_character(p) - lambda(p)}
  let  dual_tf=gamma-x.root_datum.rho
  then dual_theta = -^involution(x)  { |dual_tf| is |dual_theta|-stable }
  then (simple_ims,) =
quit
    simple_system_from_positive(imaginary_sys(dual_int_ic,dual_theta))
  then (rho_corr,dLR) { correct the change of rho_check implicit in dual_tf }
    = fixed_lift(dual_theta-1,rho(root_datum(p))-rho(integrality_datum(p)))
  then integral_shift=integral_shift(rho_corr-rho_r(x),simple_ims,dLR)
  then phi = dual_tf + rho_corr { dual_theta stable rep.tive of dual square }
  then ()=prints("integral_shift:", integral_shift, "phi=", phi)
   then ()=prints("rho_corr:", rho_corr) 
  in KGB_elt(dual_int_ic,
             dual_theta,
             phi+integral_shift)
	     }