{!
 This script serves to compute the trace of a torus element of finite order
 (initially those whose square is central) in an irreducible (finite
 dimensional) representation of a complex group as defined by highest weight

 It uses a formula, a hybrid of Weyl's character formula and Weyl's dimension
 formula, for the evaluation of a character at a (not necessarily regular)
 semisimple element given in https://www2.bc.edu/mark-reeder/WeylChar.pdf,
 Proposition 6.1
!}

<basic.at
<W_orbit.at { for |W_orbit| }
<finite_dimensional.at { for |dimension@(RootDatum,ratvec)| }

set verbose_wcf=false

{ see if w is equivalent to v mod Z^n for some v in list}
set find_ratvec_mod_vec ([ratvec] v, ratvec w) = int:
   first(for r in v do =(r-w)%1 od)

{ keep coset representatives of list of ratvecs mod Z^n}
set reduce_ratvecs_mod_lattice ([ratvec] S) = [ratvec]:
   let reduced= for s in S do s%1 od, result=[ratvec]:[] in
   for x in reduced
   do if all(for y in result do x!=y od) then result#:=x fi
   od; result

{ action is by dual(rd) since v is in X_*(T)_Q }
set W_orbit_torus_element(RootDatum rd,ratvec v)=[ratvec]:
   reduce_ratvecs_mod_lattice(W_orbit(dual(rd),v))

set weyl_dimension_formula = dimension@(RootDatum,ratvec)

{ see centralizer@(KGBElt,ratvec) in K_highest_weights.at
  don't need x, and test is <alpha,v> is an integer
}
set centralizer(RootDatum rd,ratvec v) = RootDatum:
   let roots = columns_with((vec alpha): is_integer(alpha*v), posroots(rd))
   then coroots = rank(rd) # for alpha in roots do coroot(rd,alpha) od
   in root_datum(simple_from_positive(roots,coroots))


{ assuming x^2 is central: e^{-\alpha}(x)=\pm1, and
  the roots for which it is 1 is the centralizer,
  so the quotient is a power of 2
}
set weyl_denominator_quotient(RootDatum rd, ratvec v)=int:
   let rd_v=centralizer(rd,v) in 2^(nr_of_posroots(rd)-nr_of_posroots(rd_v))

{ compute $exp(2\pi i<lambda,v>$; assuming lambda\in P, 2v\in R^v this is \pm1 }
set exp (ratvec lambda, ratvec v) = int:
   {let ()=prints("exp lambda=", lambda, " v=", v) then }
   let c=lambda*v in assert(is_integer(c), "<lambda,v> is not an integer");
   (-1)^rat_as_int(c)

{ Weyl Character Formula evaluated on an element x\in T with x^2\in Z(G)
  returns (rat theta,rat k): Trace(pi(x))=e^{2\pi i theta}*k
  NB: |k| is really an integer, but in order to allow larger values before
  overflow occurs, we use the wider type |rat|
  Computed using the Weyl character formula at the singular element x,
  see https://www2.bc.edu/mark-reeder/WeylChar.pdf Proposition 6.1
  since x^2\in Z, \pi(x)=\zeta^{1/2}diag(\pm 1,...,\pm 1) where
  zeta^{1/2} is a square root of the central character evaluated as x^2
  zeta=e^{\pi i\theta}
}
{.Weyl character formula for highest weight lambda evaluated on an element x in T with x^2 in Z.}
set wcf (RootDatum rd, ratvec lambda,ratvec v) = (rat,rat):
(  let S=W_orbit_torus_element(rd,v)
   , denominator=weyl_denominator_quotient(rd,v)
   , result=rat: 0
   in if verbose_wcf
      then prints("centralizer(x): ", centralizer(rd,v), new_line
                 ,"denominator: ", denominator)
      fi
   ;  for w in S
      do let rd_w=centralizer(rd,w) in
         result+:= exp(lambda,2*(w-v))
                  *(dimension(rd_w,lambda+rho(rd)-rho(rd_w))/denominator)
     od; (lambda*v,result)
)

{.Weyl character formula for finite dimensional p evaluated on an element x in T with x^2 in Z.}
set wcf (Param p,ratvec v) = (rat,rat):
   wcf(root_datum(p),highest_weight_finite_dimensional(fd_only(p)),v)

{
set wcf_check(RootDatum rd, ratvec v, int k)=
let weights=box(k+1, ss_rank(rd)) then  {all [a_1,...,a_rank] with 0\le a_i\le k}
M=ratvecs_as_ratmat(fundamental_weights(rd)) in
for mu in weights do
 let lambda=M*mu in
  if is_integer(lambda) then
  let p=finite_dimensional(split_form(rd),ratvec_as_vec(lambda)) in
  prints("", dimension(p), " ",wcf(rd,lambda,v)) fi od
}
{
set wcf_check_long(RootDatum rd, ratvec v, int k)=
let weights=box(k+1, ss_rank(rd)) then  {all [a_1,...,a_rank] with 0\le a_i\le k}
M=ratvecs_as_ratmat(fundamental_weights(rd)) in
for mu in weights do
 let lambda=M*mu in
  if is_integer(lambda) then
  let p=finite_dimensional(split_form(rd),ratvec_as_vec(lambda)) in
  prints(signature_str(p), " ", wcf(rd,lambda,v)) fi od
}

