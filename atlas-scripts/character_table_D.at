<basic.at
<character_tables.at
<character_table_C.at

{ word representative in types D of unsplit conjugacy class for partition pair }
set class_word_D(Partition lambda,Partition mu) = [int]:
(  assert((lambda:=lambda.strip_to_partition).>, "lambda is not a partition")
;  assert((mu:=mu.strip_to_partition).>, "mu is not a partition")
;  assert(=#mu%2, "mu has an odd number of parts")
;  assert(not(=mu and =lambda%2)
	 , "mu is empty and lambda has even parts: split class")
;  let n=sum(lambda), m=sum(mu)
   ,  Mbars = let sum=minus_1 in for k in mu do sum+:=k od
   ,  Lbars = let sum=minus_1 in for k in lambda do sum+:=k od
   ,  rise(int a,int len) = [int]: for i:len from a  do i od
   ,  fall(int a,int len) = [int]: for i:len from a ~do i od
then  L_gens = complement(n,Lbars) { for lambda part, do the same as in type A }
   ,  sign_pair(int k,int l) = [int]: { arguments are positions in |[0,m[| }
         rise(n+l,m-1-l)##rise(n+k,m-k) { |m-k-2|, plus 2 final for signs }
       ##fall(n+k,m-2-k)##fall(n+l,m-1-l) { remainder of conjugation }
then  M_gens = { each cycle pair from P gets sign flips when second end sensed }
      let odd=false { parity of number of Mbars elements seen }, k=minus_1 in
      for i:m
      do if isnt_member(Mbars)(i) then [n+i] { extend our cycle }
         elif odd:=not odd
	 then [] next k:=i { break cycle, save index, wait for sign }
	 else sign_pair(k,i) { wrap up two cycles by adding signs }
	 fi
      od.##
in L_gens##M_gens
)

{ word representative in types D of split conjugacy class for partition pair }
set class_word_D(Partition lambda,bool minus) = [int]:
(  assert((lambda:=lambda.strip_to_partition).>, "lambda is not a partition")
;  assert(lambda.is_very_even, "lambda is has odd parts: not a split class")
;  let n=sum(lambda), bars = let sum=minus_1 in for k in lambda do sum+:=k od
in if minus else complement(n,bars) { just have a word for each (even) cycle }
   then complement(n,bars) ## [n-2,n-1] { add adjacent flips in last cycle }
   fi
)

set conjugacy_class(D_class c) = WeylElt:
   let word = [int]:
     case c
     | unsplit_class(cycles): class_word_D(cycles.to_partition_pair)
     | split_class(lambda_minus): class_word_D(lambda_minus)
     esac
in W_elt(SO(2*rank(c)),word)

{ all irreducible representations of D_n }
set D_irreps (int n) = [D_irrep]:
   let unsplit =
      for (lambda,mu) in partition_pairs(n)
      do if not leq_partitions(lambda,mu) then [(lambda,mu).unsplit_irr]
         else []
	 fi
      od.##
   , (q,r)=n\%2
   then split=
      if !=r then []
      else
         for lambda in partitions(q)
         do [(lambda,false).split_irr,(lambda,true).split_irr]
         od.##
      fi
   in unsplit##split

set character_table_D(int n) = CharacterTable:
   let pairs = partition_pairs(n), classes =  D_classes(n)
   then classes = [WeylElt,classical_class,string]:
      for c in classes do (conjugacy_class(c),c.class_D,c.string_rep) od
   ,  irreps = [classical_irrep,string,[int]]:
      for rep in D_irreps(n)
      do ( rep.irrep_D, rep.string_rep
         , for class in classes do character(rep,class) od
	 )
      od
in character_table(SO(2*n),classes,irreps)

{ functions that expect a |CharacterTable| of simple type D }
set split_class_nrs(CharacterTable ct) = [int]:
   for i:ct.n_classes
   do case ct.classes(i) | else []
      | class_D(c):
        case c | else []
        | split_class(x): [ i ]
	esac
      esac
   od.##

set split_rep_nrs(CharacterTable ct) = [int]:
   for i:ct.n_classes
   do case ct.classical_reps(i) | else []
      | irrep_D(rep):
        case rep | else []
	| split_irr(x): [ i ]
	esac
      esac
   od.##

set split_table (CharacterTable ct) = ([classical_irrep],[classical_class],mat):
   let reps = split_rep_nrs(ct), classes = split_class_nrs(ct)
in ( for i in reps do ct.classical_reps(i) od
   , for j in classes do ct.classes(j) od
   , for i in reps do for j in classes do ct.table[i,j] od od
   )
