<basic.at
<character_tables.at
<character_table_C.at

{get actual conjugacy class representatives, i.e. elements of W(D_n),
 from pairs or triples of partitions
get these from type BC_n: construct w in W(BC_n) -> matrix -> w in W(D_n)
NOTE: roles of (P,Q) are switched here
in type C:
P=(a_1,...,a_r) -> coxeter element of Sp(2a_1)x...xSp(2a_r)
Q=(b_1,...,b_s) -> coxeter element of GL(b_1)x...xGL(b_s)
in type D:
to lie in type D, s must be even:
P=(a_1,...,a_r) -> coxeter element of GL(a_1)x...xGL(a_r)
Q=(b_1,...,b_s) -> coxeter element of O(2b_1)x...xO(2b_s)
the "coxeter element" of O(2b) comes from Sp(2b), and has determinant -1
=>cneed s to be even
}
set conjugacy_class_D(D_class c) = WeylElt:
  case c
  | unsplit_class(cycles):
     let (P,Q)=cycles.to_partition_pair, n=rank(cycles)
     then rd = SO(2*n), M=conjugacy_class_C(Q,P {note switch here}).matrix
     in lift_sc(W_elt(rd,M))  {lift_sc: W(SO) -> W(Spin)}
  | split_class(P,switch):
     let rd=SO(2*sum(P)), M=conjugacy_class_C([int]:[],P).matrix in
     if switch else lift_sc(W_elt(rd,M))
     then let delta=distinguished_involution(inner_class(rd,"u")) in
        lift_sc(W_elt(rd, delta*M*delta)) {lift_sc: W(SO) -> W(Spin)}
     fi
  esac

{all irreducible representations of D_n}
set D_irreps (int n) = [D_irrep]:
   let unsplit =
      for (lambda,mu) in partition_pairs(n)
      do if not leq_partitions(lambda,mu) then [(lambda,mu).unsplit_irr]
         else []
	 fi
      od.##
   , (q,r)=n\%2
   then split=
      if !=r then []
      else
         for lambda in partitions(q)
         do [(lambda,false).split_irr,(lambda,true).split_irr]
         od.##
      fi
   in unsplit##split

{conjugacy classes in type D:
pair of partitions (P,Q)
#P+#Q=n
P\ne Q
number of parts of Q is even
union
(P,false),(P,true)
where #P=n, P is very even
}
set D_classes(int n) = [D_class]:
   for (P,Q):pair in partition_pairs(n)
   do if not is_even(#Q) then []
      elif not(=Q and is_very_even(P)) then [cycles(P,Q).unsplit_class]
      else [(P,true).split_class,(P,false).split_class]
      fi
   od.##

{make a character table of type D}
set character_table_D(int n) = CharacterTable:
   let order=n.fac*2^(n-1)
   then classes = D_classes(n)
   then ncc=#classes
   then index = index_D_classes(classes)
   then centralizer_orders = for class in classes do class.centralizer_order od
   then reps=D_irreps(n)
   then sign(bool s) = string: if s then "-" else "+" fi
in
  (Lie_type(Spin(2*n))    {lie_type}
  , order    {order (of W)}
  , ncc      {n_classes}
  , (int j) classical_class: classes[j].class_D
  , (int j) string: { class_label }  classes[j].string_rep
  , for class in classes do conjugacy_class_D(class) od {class_reps}
  , (int j) int: classes[j].cycle_type_order       {class_order}
  , (int j, int p) int: cycle_power(classes[j],p).index   {class_power}
  , centralizer_orders   {class}
  , for co in centralizer_orders do order\co od    {class_sizes}
  , (int i) classical_irrep: reps[i].irrep_D
  , (int i) string: reps[i].string_rep { irreducible representation label }
  , [[int]]:[] {sym_powers_reflection}
  , [int]:[]  {degrees}
  , [int]:[]  {fake degrees}
    {character table:}
  , for cl in D_classes(n) do
     for pi in reps do character(pi,cl)
     od
    od
  )

set split_classes(CharacterTable ct)=[classical_class]:
##for i:ct.n_classes do if ct.classes(i).get_class_D.is_split then [ct.classes(i)] else [] fi od

set split_reps(CharacterTable ct)=
##for i:ct.n_classes do if ct.classical_reps(i).get_irrep_D.is_split then [ct.classical_reps(i)] else [] fi od

set index(CharacterTable ct,D_irrep pi)=int:
index_D_reps(for i:ct.n_classes do ct.classical_reps(i).get_irrep_D od,pi)

set  index(CharacterTable ct,classical_irrep pi)=int:
index_D_reps(for i:ct.n_classes do ct.classical_reps(i).get_irrep_D od,pi.get_irrep_D)

set index(CharacterTable ct,classical_class c)=int:
index_D_classes(for i:ct.n_classes do ct.classes(i).get_class_D od,c.get_class_D)

set index(CharacterTable ct,D_class c)=int:
index_D_classes(for i:ct.n_classes do ct.classes(i).get_class_D od,c)

set split_table(CharacterTable ct)=
let reps=ct.split_reps
   then classes=ct.split_classes in
(reps,classes,for pi in reps do
 for c in classes do
  ct.characters[index(ct,pi)][index(ct,c)] od od)
