<basic.at
<Weylgroup.at

{ orbit of |x| by cross actions from |gens|, with example transportin w }
set cross_sub_orbit ([WeylElt] gens, KGBElt x) = ([KGBElt],[WeylElt]):
  let rd = x.root_datum then orbit= [x], ws = [id_W(rd)], done=0
  then absent (KGBElt y) = bool: none(#orbit,(int i)bool:orbit[i]=y)
  in
  while done<#orbit
  do
    let a=orbit[done], w = ws[done] in done+:=1 { pop |(w,a)| from queue }
  ; for s in gens
    do let b=cross(s,a) in
      if absent(b) then ws #:= s*w ;  orbit #:= b fi
    od
  od; (orbit,ws)

set cross_orbit (KGBElt x) = ([KGBElt],[WeylElt]):
  cross_sub_orbit(x.root_datum.W_gens,x)

{ solve for w in W in y=cross(w,x); at least one solution should exist }
set cross_divide (KGBElt y,KGBElt x) = WeylElt:
  let (orbit,ws)=cross_orbit(x) then i=first(#orbit,(int i)bool:orbit[i]=y) in
  if i<0 then error("Did not find ",y," in orbit of ",x) fi; ws[i]

{
set cross_W_orbit_extra([int] S,KGBElt x) = ([W_word],[KGBElt]):
  let rd = RootDatum: real_form(x), words = [[int]:[]], orbit= [x], done=0
  then absent (KGBElt y) = bool:
         let i=#orbit-1 in while i>=0 and y!=orbit[i] do i-:=1 od; i<0
  in
  while done<#orbit
  do
    let w = words[done], a=orbit[done] in
    done+:=1
  ; for i in S
    do let b=cross(i,a) in
      if absent(b) then ( words #:= i#w, orbit #:= b ) fi
    od
  od; (for w in words do (rd,w) od,orbit)

{ just the W(S)-orbit W.x }
set cross_W_orbit (([int],KGBElt) pair) = [KGBElt]:
  let (,orbit) = cross_W_orbit_extra(pair) in orbit

{ assume S=all simple roots }
set cross_W_orbit_extra(KGBElt x) = ([W_word],[KGBElt]):
  cross_W_orbit_extra(#x.root_datum.semisimple_rank,x)
set cross_W_orbit(KGBElt x) =
  cross_W_orbit(#semisimple_rank(real_form(x)),x)
set cross_W_orbit_W_elements(KGBElt x) = [W_word]:
  let (words,) = cross_W_orbit_extra(#semisimple_rank(real_form(x)),x) in words

{ find Weyl word sending |x| to |y|, or return (rd,[-1]) to signal failure }
set find_W_cross(KGBElt x,KGBElt y) = W_word:
  let (wwords,orbit) = cross_W_orbit_extra(x) then i=#orbit-1 in
  while >=i and y!=orbit[i] do i-:=1 od;
  if >=i then wwords[i] else { fail: } (real_form(x),[-1]) fi

{ just the subset of W(S) that applied to x gives a bijection to W(S).x }
  set cross_W_orbit_W_elements ([int] S,KGBElt x) = [W_word]:
    let (words,)=cross_W_orbit_extra(S,x) in words
}
