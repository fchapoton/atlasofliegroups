<K_highest_weights.at
<tabulate.at
<convert_c_form.at {for Param@mu}

set codim(KGBElt x)=int:nr_of_posroots(root_datum(x))-dimension(x)
set codim(Param p)=int:codim(x(p))

{\sum a_i(q)p_i where a_i(q) is a polynomial}

{the data type hodgeParamPol is [ParamPol]
[P_0,P_1,..,P_n] <-> P_0+P_1*q^2+...+P_n*q^n
The advantage of the non-obvious convention is that we can use the
features of ParamPol to take care of combining terms.
See the functions rearrange and dearrange.
}
set_type hodgeParamPol=[ParamPol]

set *(Split c,[ParamPol] pols)=for f in pols do c*f od
{Note: error if #pols=0}

set nullHodgeParamPol(RealForm G)=hodgeParamPol:[null_module(G)]
set hodge_param_pol(Param p)=hodgeParamPol:[p]

set coefficient(hodgeParamPol P,Param p)=i_poly:
for i:#P do split_as_int(P[i][p]) od

{equality is term by term}
set =(hodgeParamPol P,hodgeParamPol Q)=bool:
 (#P=#Q) and all(for i:#P do P[i]=Q[i] od)

set real_form(hodgeParamPol P)=RealForm:
if #P=0 then torus(0,0,0) else P[0].real_form fi

{rearrange:
 takes hodgeParamPol:[P_0,P_1,..,P_n] <-> P_0+P_1*q+...+P_n*q^{n-1}
 to
 (a_0+a_1q+...a_kq^k)*p_0 + (b_0+...+b_rq^r)*p_1 + ... (...)p_m
 represented by [([a_0,...,a_k],p_0),...,([...],p_m)]
 where {p_i} are the monomials of all of the {P_j}
 the coefficients are i_pols
This is a more natural way to think of a hodgeParamPol, but less convenient
computationally.
}
set rearrange(hodgeParamPol pols)=[(i_poly,Param)]:
for p in monomials(pols) do
 (for i:#pols do split_as_int(pols[i][p]) od,p) od


{go other way:
 given f_0(q)p_0 + ... + f_n(q) p_n, take it to [P_0,...,P_m]
[a_0+a_1q+...a_kq^k]*p_0 + [b_0+...+b_rq^r]*p_1 + ... [...]*p_n
 <->  by [([a_0,...,a_k],p_0),...,([...],p_n)] goes to 
 P_0+P_1*q^2+...+P_m*q^m, represented by
 [P_0,P_1,..,P_n]
}
set dearrange([(vec,Param)] f,RealForm G)=hodgeParamPol:
if #f=0 then nullHodgeParamPol(G) else
let n=max(for (v,) in f do #v od) in
for i:n do
 sum(G,for j:#f do let (v,p)=f[j] then w=v##null(n-#v) in w[i]*p od)
od fi

{this fails with an error if #f=0}
set dearrange([(vec,Param)] f)=hodgeParamPol:dearrange(f,let (,p)=f[0] in p.real_form)

{dearrange an array [(vec,K_Type)], simply replace each K_type mu with parameter(mu)}
set dearrange([(vec,K_Type)] f,RealForm G)=dearrange(for (v,mu) in f do (v,parameter(mu)) od,G)
set dearrange([(vec,K_Type)] f)=dearrange(for (v,mu) in f do (v,parameter(mu)) od)

{polynomial  in q, or constant, times hodgeParamPol}
set *(i_poly f,hodgeParamPol P)=hodgeParamPol:
let r=rearrange(P) in dearrange(for (g,p) in r do (convolve(f,g),p) od,P.real_form)
set *(int c,hodgeParamPol P)=hodgeParamPol:[c]*P

set +(hodgeParamPol P,hodgeParamPol Q)=hodgeParamPol:
if #P<=#Q then
 for i:#Q do if i<=#P-1 then P[i]+Q[i] else Q[i] fi od
else
 for i:#P do if i<=#Q-1 then P[i]+Q[i] else P[i] fi od
fi
set one_minus_q=[1,-1]
set -(hodgeParamPol P,hodgeParamPol Q)=hodgeParamPol:P+(-1)*Q

set evaluate_at_s(hodgeParamPol Q)=ParamPol:
null_module(Q.real_form) + sum(Q.real_form,for i:#Q do s^i*Q[i] od)

set evaluate_at_1(hodgeParamPol Q)=ParamPol:
null_module(Q.real_form) + sum(Q.real_form,for i:#Q do Q[i] od)

set v_to_s(hodgeParamPol Q)=ParamPol:evaluate_at_s(Q)
set v_to_1(hodgeParamPol Q)=ParamPol:evaluate_at_1(Q)

{modified version of built-in q_branch}
set hodge_branch_std(Param p, int N)=hodgeParamPol:
if p.real_form.nr_of_Cartan_classes>1 then prints("Warning: G has more than one conjugacy class of Cartan subgroups.") fi;
dearrange(q_branch(p,N),p.real_form)  {q_branch is built-in}

set hodge_branch_std(ParamPol P, int N)=hodgeParamPol:
let rv=nullHodgeParamPol(P.real_form) in
for c@p in P do rv+:=c*hodge_branch_std(p,N) od;rv

{multiply hodgeParamPol by q^k (k\ge 0)}
set shift(hodgeParamPol P, int k)=hodgeParamPol:
let null=nullHodgeParamPol(P.real_form) in
(hodgeParamPol:##for i:k do null od)##P

set hodge_branch_std(hodgeParamPol P, int N)=hodgeParamPol:
let rv=nullHodgeParamPol(P.real_form) in
for i:#P do rv+:=shift(hodge_branch_std(P[i],N),i) od;rv

{set hodge_branch_irr(Param p,int N)=hodgeParamPol:hodge_branch_std(hodge_grading_irreducible(p),N)}

{nice output}
set show(hodgeParamPol P)=void:
for (f,p) in rearrange(P) do prints("(",poly_format(f,"v"),")","*",p) od

{alternative output version}
set print(hodgeParamPol P)=void:
let header=["c","x","lambda","nu","codim_O","LKT","dim_K","height","mu"] then
values=for (c,p) in rearrange(P) do
let (,x)=%p.x then
(,,wt)=highest_weights(p)[0] in
[poly_format(c,"v"),x.to_string,p.lambda.to_string,p.nu.to_string,codim(x(p)).to_string,let (,v)=LKTs(p)[0] in v.to_string,LKTs(p)[0].dimension.to_string,
height(p).to_string,p.mu.to_string] od in tabulate(header#values,"lllllllll",2," ")

set print_hodge_branch_std(Param p,int N)=void:print(hodge_branch_std(p,N))




