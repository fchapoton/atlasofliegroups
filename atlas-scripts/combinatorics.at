{ The purpose of this module is to collect basic combinatorial functions,
  like factorials, binomial coefficients, generators of partitions and so on
}

<basic.at
<sort.at
<lazy_lists.at { for |inf_list| type and related stuff }
<groups.at { for root data computed by |GL|, |Sp|, |SO| }

set fac (int n) = int:
   if n<2 then assert(n.>=,"Factorial of negative integer"); 1
   else let p=n in for i:n-2 from 2 do p*:=i od; p
   fi

set binom (int n, int k) = int:
   if n.>= and k+k>n then k:=n-k fi; { use symmetry to limit |k| }
   case k then 0 in 1, n
   else let p=n*(n-1) in for i:k-2 from 2 do p:=p\i*(n-i) od; p\k
   esac

set binom (rat n, int k) = rat:
   if n.denom=1 and n.>= and k+k>n then k:=n.numer-k fi; { try for efficiency }
   case k then 0 in 1, n
   else let p=n*(n-1) in for i:k-2 from 2 do p:=p/i*(n-i) od; p/k
   esac

set multi_choose (int n,int k) = int: binom(n+k-1,k)

set falling_power (int n, int k) = int: assert(>=0,"Negative exponent");
   let p=1 in for i:k from n-k+1 do p*:=i od; p

set rising_power (int n, int k) = int: assert(>=0,"Negative exponent");
   let p=1 in for i:k from n do p*:=i od; p


{ extract components at even or odd positions }
set even_places ([int] v) = for i:ceil(#v/2) do v[2*i] od
set odd_places  ([int] v) = for i:floor(#v/2) do v[2*i+1] od


{				Partitions				}

set_type Partition = [int]   { list of decreasing parts, no trailing zeros }

set strip_to_partition ([int] list) = Partition:
   let i=0, nl=#list in while i<nl and =list~[i] do i+:=1 od; list[:i~]
{ alternatively: |for x in list do if =x then break fi od| }

set is_decreasing ([int] v) = bool: all(for i:#v-1 do v[i]>=v[i+1] od)

set frequencies (Partition lambda) = vec:
  let v=null(0) in
  for l in lambda
  do if l>=#v then v ##:= null(l-#v)#1 else v[l]+:=1 fi
  od; v

set repeat_parts (vec frequencies) = Partition:
  ## for f@i in frequencies ~ do if =i then [] else for :f do i od fi od

set sort_to_partition ([int] parts) = Partition:
  parts.frequencies.repeat_parts

{ transpose of a partition (parts assumed already in decreasing order) }
set transpose (Partition lambda) = Partition:
  if #lambda=0 then []
  else let l=#lambda in
    for i:lambda[0] { value |lambda[0]| is sentinel ensuring |l>0| below }
    do while lambda[l-1]<=i do l-:=1 od; l
    od
  fi

set partitions = (int n) [Partition]:
  if n.< then []
  else
    let table = [[ [Partition] ]]: { partitions by sum, then by largest part }
      for m:n+1
      do if =m then [ [[]] ] { empty partition of 0 } else [] { nothing yet } fi
      od
    in
    for m:n from 1
    do table[m] := ([Partition]: []) { no partitions with largest part 0 } #
      for k: if m=n then n else min(m,n-m) { truncate to need } fi from 1
	 { form list of partitions of |m| with largest part |k| }
      do let rem = m-k { amount remaining after using one part |k| of |m| } in
        { traverse all partitions of |rem| with parts at most |min(k,rem)|: }
	for lambda in ##table[rem][:min(k,rem)+1] do k#lambda od
      od
    od
  ; ##table~[0] { concatenate entries of final table row }
  fi

{ partitions with even multiplicity of parts of one parity (odd or even) }
set parity_restricted_partitions (int n, bool restrict_odd_parts) = [Partition]:
  if n.< or restrict_odd_parts and n.is_odd then [] { impossible, so nothing }
  else
    let table = [[ [Partition] ]]: { partitions by sum, then by largest part }
      for m:n+1
      do if =m then [ [[]] ] { empty partition of 0 } else [] { nothing yet } fi
      od
    in
    for m:n from 1
    do table[m] := ([Partition]: []) { no partitions with largest part 0 } #
      for k: if m=n then n else min(m,n-m) { truncate to need } fi from 1
	 { form list of partitions of |m| with largest part |k| }
      do { traverse all partitions |m-k| with parts at most |min(k,m-k)|: }
        if if restrict_odd_parts then k.is_odd else k.is_even fi
        then { restrict use of k to using it twice } let rem=m-k-k in
          if rem.< then []  { if a negative remainder, then no solutions here }
          else for lambda in ##table[rem][:min(k,rem)+1] do [k,k]##lambda od
          fi
	else let rem = m-k in
          for lambda in ##table[rem][:min(k,rem)+1] do k#lambda od
        fi
      od
    od
  ; ##table~[0] { concatenate entries of final table row }
  fi

{
  Core and quotient operations can be defined in terms of associating to any
  partition $\lambda$ the subset $\{ lambda[i]-i-1 | i\in\N \}$ of $\Z$. This
  set represents the set of vertical edges terminating the rows of the Young
  diagram, recorded by their diagonal positions (the main diagonal separating
  positions in $\N$ from its complement, i.e., its splits between -1 and 0).

  This set is bounded above while its complement is bounded below; more
  specifically the set meets $\N$, and its complement the complement of $\N$, in
  equal size finite sets. An ordered pair of partitions can be "spliced
  together" as follows: take there associated sets, transform the former by
  $i\mapsto 2i$ and the latter by $i\mapsto 2i+1$, merge the results and find
  the partition corresponding to the set. If the Young diagrams original
  partitions together have $n$, the spliced partition can be covered by $n$
  dominos. More generally we could add a fixed integer $d$ in the first
  transformation and subtract it in the second; then $d$ will be the unbalance
  of black and white squares in the diagram of the resulting partition, and
  after removing $n$ dominos from it we are left with a "2-core" still having
  the same unbalance. It is a staircase diagram with |core_length(d)| parts.
  The pair of original partitions is the "2-quotient" of the spliced partition.
}

set core_length (int n) = int: if n.<= then 2*-n else 2*n-1 fi
set core_number (int k) = int: assert(k.>=); case k in -k\2, -k\-2 esac

{ splicing two partitions |mu|, |nu|, with 2-core with (unbalance) number |d| }
set from_core_quotient_2 (int d,Partition mu,Partition nu) = Partition:

{ Implementation is delicate, as we must represent infinite sets finitely.
   Initially take just one number for each (nonzero) part of each partition, and
   record the first numbers |k|, |l| that are omitted in this representation.
   Also reverse the order to increasing, since this is what |merge@([int,[int])|
   defined in sort.at assumes. Before merging, we need to "even out" the
   (negative) heads of the lists by adding omitted terms to one of them, those
   whose absent would produce gaps in the merged result. The first such term to
   be added (if any) is 3 more than the first omitted term in the other list.
}
(  let evens = for m@i in mu do 2*(m-i-1+d) ~od { space out and reverse }
   ,   odds = for n@i in nu do 2*(n-i-1-d)+1 ~od { likewise }
   ,   k = 2*(-#mu-1+d), l = 2*(-#nu-1-d)+1 { last omitted values before lists }
in if k>l
   then evens := for i:(k-l)\2 from l\2+2 do i+i od ## evens
   else odds := for i:(l-k)\2 from k\2+1 do i+i+1 od ## odds
   fi
;  for d@i in merge(evens,odds)~[:] do d+i+1 od.strip_to_partition
)

set core_quotient_2 (Partition lambda) =(int,Partition,Partition):
   let l=#lambda
   then (prev_even,prev_odd) = case l in (-l-2,-l-1), (-l-1,-l-2) esac
   , mu=[int]:[0], nu=[int]:[0] { partitions in reverse (increasing) order }
in for a@i in lambda
  ~do let d=a-i-1 in
      case d
      in mu #:= mu~[0]-1+(d-prev_even)\2; prev_even:=d
      ,  nu #:= nu~[0]-1+(d-prev_odd )\2; prev_odd :=d
      esac
   od; ( -(#nu-#mu)\2, mu~[:].strip_to_partition, nu~[:].strip_to_partition )

{				Permutations				}

{ Matrix whose left-mulitplication to a column vector permutes it by |pi|.
  It has nonzero entries at each (pi(j),j), it could have been defined (using
  |matrix| from basic.at) as |matrix((#pi,#pi),(int i,int j): #(i=pi[j]) )|.
}
set permutation_matrix ([int] pi) = mat:
   let n=#pi then I=n.id_mat in n# for v in pi do I[v] od

set permutation (mat P) { assumed a permutation matrix} = [int]:
  (vec: #P.n_rows)*P { right-act on row [0,1,...,n-1] for one-line form }

set compose_permutations ([int] sigma, [int] pi) = [int]:
  for i in pi do sigma[i] od

set inverse ([int] pi) = [int]: { hope that name causes no conflict }
  let n=#pi then result=for :n do n od { sentinel values} in
  for i@j in pi
  do assert(i.>= and i<n and result[i]=n { in range, and no seen before }
           ,to_string("not a permutation (",i,")"));
     result[i]:=j
  od; result

{ longer name for non-checking (so faster) version of the above }
set permutation_inverse ([int] pi) = [int]:
  let result=null(#pi) in for i@j in pi do result[i]:=j od; result

set permute ([int] pi,vec v) = vec: { replaces |v[i]| by |v[pi.inverse[i]]| }
  assert(#pi=#v { and |pi| is a permutation },"length mismatch");
  let result=null(#v) in for i@j in pi do result[i]:=v[j] od; result

set permutation_cycles ([int] pi) = [[int]]:
  let n=#pi then todo = for :n do true od in
  while let i=first(todo) in i.>=
  do
    while todo[i] do todo[i]:=false; i next i:=pi[i] od
  od

{ Find classical (permutation or signed permutation) description of Weyl group
  elements in classical types. The associated root datum must have one simple
  factor of type A-D, with standard (Bourbaki) numbering of the Dynkin diagram.
  Such a root datum can be obtained from classical factors in the Lie type from
  |Cartan_matrix_type|, by taking Levi subdatum of the corresponding simple
  roots/coroots, following the mapping that |Cartan_matrix_type| also supplies.

  The output is a (signed) permutation in one-line format. For type $A_n$ this
  is just a permutation of $n+1$ (hence 0-based), for types $B_n$, $C_n$, $D_n$
  this is a permutation of the $2n$ elements $-n, ,..., -2 -1, 1, 2, ..., n$,
  commuting with $x \mapsto -x$, and the one-line format consists of a list of
  the images of $1, 2, ..., n$ (1-based); it determines the signed permutation.
}
set classic_permutation (WeylElt w) = [int]:
  let rd=w.root_datum then (lt,map)=Cartan_matrix_type(rd.Cartan_matrix)
  then factors=%lt then nf=#factors
  in assert(nf=1,"Root datum diagram is not connected ("+ nf +" components");
  let (type,rank)=factors[0] in
  assert(map=#rank,"Dynkin diagram is not in standard order");
  case char_index(type,"ABCD")
  else error("Root datum of exceptional type "+type)
  in let n=rank+1 in (vec:#n)*W_elt(GL(n),w.word) { right act on [0,1,...,n-1] }
  , (vec:for i:rank from 1 do i od)*W_elt(Sp(rank+rank),w.word)
  , (vec:for i:rank from 1 do i od)*W_elt(Sp(rank+rank),w.word)
  , (vec:for i:rank from 1 do i od)*W_elt(SO(rank+rank),w.word)
  esac

set cycle_type ([int] pi) = Partition: { cycle sizes in decreasing order }
  for cycle in permutation_cycles(pi) do #cycle od.reverse_sort

set signed_cycle_type ([int] sigma) = [int,bool]: { pairs of cycle and sign }
  let cycles = for a in sigma do abs(a)-1 od.permutation_cycles
  ,   flip   = for a in sigma do a.< od { whether negative, per position }
  then size = for cycle in cycles do #cycle od
  ,    sign = for cycle in cycles do for i in cycle do #flip[i] od.sum.is_odd od
  in for i in inv_standardisation(size) do (size[i],sign[i]) ~od

{			    Formal power series				}
pentagonal_series : inf_list:
@:(1
  , (1,false,1).
    (rec_fun f (int k, bool upper, int i) inf_list:
     @: if i+i= if upper else k*(3*k-1) then k*(3*k+1) fi
        then (minus_1^k, f(k+#upper,not upper,i+1))
        else (0,f(k,upper,i+1))
        fi
    )
  )

set n_parts = memoize(inverse(pentagonal_series))
set n_partitions (int n) = int:
  let (x,ff)=n_parts() in for :n do set(x,ff):=ff() od; x