{ The purpose of this module is to collect basic combinatorial functions,
  like factorials, binomial coefficients, generators of partitions and so on
}

<basic.at
<sort.at
<groups.at { for root data computed by |GL|, |Sp|, |SO| }

set fac (int n) = int:
   if n<2 then assert(n.>=,"Factorial of negative integer"); 1
   else let p=n in for i:n-2 from 2 do p*:=i od; p
   fi

set binom (int n, int k) = int:
   if n.>= and k+k>n then k:=n-k fi; { use symmetry to limit |k| }
   case k then 0 in 1, n
   else let p=n*(n-1) in for i:k-2 from 2 do p:=p\i*(n-i) od; p\k
   esac

set binom (rat n, int k) = rat:
   if n.denom=1 and n.>= and k+k>n then k:=n.numer-k fi; { try for efficiency }
   case k then 0 in 1, n
   else let p=n*(n-1) in for i:k-2 from 2 do p:=p/i*(n-i) od; p/k
   esac

set multi_choose (int n,int k) = int: binom(n+k-1,k)

set falling_power (int n, int k) = int: assert(>=0,"Negative exponent");
   let p=1 in for i:k from n-k+1 do p*:=i od; p

set rising_power (int n, int k) = int: assert(>=0,"Negative exponent");
   let p=1 in for i:k from n do p*:=i od; p


{ extract components at even or odd positions }
set even_places ([int] v) = for i:ceil(#v/2) do v[2*i] od
set odd_places  ([int] v) = for i:floor(#v/2) do v[2*i+1] od


{				Partitions				}

set_type Partition = [int]   { list of decreasing parts, no trailing zeros }

set is_decreasing ([int] v) = bool: all(for i:#v-1 do v[i]>=v[i+1] od)

set frequencies (Partition lambda) = vec:
  let v=null(0) in
  for l in lambda
  do if l>=#v then v ##:= null(l-#v)#1 else v[l]+:=1 fi
  od; v

set repeat_parts (vec frequencies) = Partition:
  ## for f@i in frequencies ~ do if =i then [] else for :f do i od fi od

set sort_to_partition ([int] parts) = Partition:
  parts.frequencies.repeat_parts

{ transpose of a partition (parts assumed already in decreasing order) }
set transpose (Partition lambda) = Partition:
  if #lambda=0 then []
  else let l=#lambda in
    for i:lambda[0] { value |lambda[0]| is sentinel ensuring |l>0| below }
    do while lambda[l-1]<=i do l-:=1 od; l
    od
  fi

set partitions = (int n) [Partition]:
  if n.< then []
  else
    let table = [[ [Partition] ]]: { partitions by sum, then by largest part }
      for m:n+1
      do if =m then [ [[]] ] { empty partition of 0 } else [] { nothing yet } fi
      od
    in
    for m:n from 1
    do table[m] := ([Partition]: []) { no partitions with largest part 0 } #
      for k: if m=n then n else min(m,n-m) { truncate to need } fi from 1
	 { form list of partitions of |m| with largest part |k| }
      do let rem = m-k { amount remaining after using one part |k| of |m| } in
        { traverse all partitions of |rem| with parts at most |min(k,rem)|: }
	for lambda in ##table[rem][:min(k,rem)+1] do k#lambda od
      od
    od
  ; ##table~[0] { concatenate entries of final table row }
  fi

{ partitions with even multiplicity of parts of one parity (odd or even) }
set parity_restricted_partitions (int n, bool restrict_odd_parts) = [Partition]:
  if n.< or restrict_odd_parts and n.is_odd then [] { imposiible, so nothing }
  else
    let table = [[ [Partition] ]]: { partitions by sum, then by largest part }
      for m:n+1
      do if =m then [ [[]] ] { empty partition of 0 } else [] { nothing yet } fi
      od
    in
    for m:n from 1
    do table[m] := ([Partition]: []) { no partitions with largest part 0 } #
      for k: if m=n then n else min(m,n-m) { truncate to need } fi from 1
	 { form list of partitions of |m| with largest part |k| }
      do { traverse all partitions |m-k| with parts at most |min(k,m-k)|: }
        if if restrict_odd_parts then k.is_odd else k.is_even fi
        then { restrict use of k to using it twice } let rem=m-k-k in
          if rem.< then []  { if a negative remainder, then no solutions here }
          else for lambda in ##table[rem][:min(k,rem)+1] do [k,k]##lambda od
          fi
	else let rem = m-k in
          for lambda in ##table[rem][:min(k,rem)+1] do k#lambda od
        fi
      od
    od
  ; ##table~[0] { concatenate entries of final table row }
  fi



{				Permutations				}

{ Matrix whose left-mulitplication to a column vector permutes it by |pi|.
  It has nonzero entries at each (pi(j),j), it could have been defined (using
  |matrix| from basic.at) as |matrix((#pi,#pi),(int i,int j): #(i=pi[j]) )|.
}
set permutation_matrix ([int] pi) = mat:
   let n=#pi then I=n.id_mat in n# for v in pi do I[v] od

set permutation (mat P) { assumed a permutation matrix} = [int]:
  (vec: #P.n_rows)*P { right-act on row [0,1,...,n-1] for one-line form }

set compose_permutations ([int] sigma, [int] pi) = [int]:
  for i in pi do sigma[i] od

set inverse ([int] pi) = [int]: { hope that name causes no conflict }
  let result=null(#pi) in for i@j in pi do result[i]:=j od; result

set permute ([int] pi,vec v) = vec: { replaces |v[i]| by |v[pi.inverse[i]]| }
  assert(#pi=#v { and |pi| is a permutation },"length mismatch");
  let result=null(#v) in for i@j in pi do result[i]:=v[j] od; result

set permutation_cycles ([int] pi) = [[int]]:
  let n=#pi then todo = for :n do true od in
  while let i=first(todo) in i.>=
  do
    while todo[i] do todo[i]:=false; i next i:=pi[i] od
  od

{ Find classical (permutation or signed permutation) description of Weyl group
  elements in classical types. The associated root datum must have one simple
  factor of type A-D, with standard (Bourbaki) numbering of the Dynkin diagram.
  Such a root datum can be obtained from classical factors in the Lie type from
  |Cartan_matrix_type|, by taking Levi subdatum of the corresponding simple
  roots/coroots, following the mapping that |Cartan_matrix_type| also supplies.

  The output is a (signed) permutation in one-line format. For type $A_n$ this
  is just a permutation of $n+1$ (hence 0-based), for types $B_n$, $C_n$, $D_n$
  this is a permutation of the $2n$ elements $-n, ,..., -2 -1, 1, 2, ..., n$,
  commuting with $x \mapsto -x$, and the one-line format consists of a list of
  the images of $1, 2, ..., n$ (1-based); it determines the signed permutation.
}
set classic_permutation (WeylElt w) = [int]:
  let rd=w.root_datum then (lt,map)=Cartan_matrix_type(rd.Cartan_matrix)
  then factors=%lt then nf=#factors
  in assert(nf=1,"Root datum diagram is not connected ("+ nf +" components");
  let (type,rank)=factors[0] in
  assert(map=#rank,"Dynkin diagram is not in standard order");
  case char_index(type,"ABCD")
  else error("Root datum of exceptional type "+type)
  in let n=rank+1 in (vec:#n)*W_elt(GL(n),w.word) { right act on [0,1,...,n-1] }
  , (vec:for i:rank from 1 do i od)*W_elt(Sp(rank+rank),w.word)
  , (vec:for i:rank from 1 do i od)*W_elt(Sp(rank+rank),w.word)
  , (vec:for i:rank from 1 do i od)*W_elt(SO(rank+rank),w.word)
  esac

set cycle_type ([int] pi) = Partition: { cycle sizes in decreasing order }
  for cycle in permutation_cycles(pi) do #cycle od.reverse_sort

set signed_cycle_type ([int] sigma) = [int,bool]: { pairs of cycle and sign }
  let cycles = for a in sigma do abs(a)-1 od.permutation_cycles
  ,   flip   = for a in sigma do a.< od { whether negative, per position }
  then size = for cycle in cycles do #cycle od
  ,    sign = for cycle in cycles do for i in cycle do #flip[i] od.sum.is_odd od
  in for i in inv_standardisation(size) do (size[i],sign[i]) ~od
