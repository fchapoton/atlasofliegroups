<basic.at
<combinatorics.at { for |classic_permutation| }
<nilpotent_orbits.at { for the type |ComplexNilpotent|, |diagram_normalized| }

<springer_tables.at
<coordinates.at

{ Springer correspondence from nilpotent orbits to representations of W in type A
  Orbits and W-irreps both correspond to partitions of rank+1, which gives the
  (here bijective) map from orbits to W-irreps for type A }

{ Partition of $n$ to a ComplexNilpotent for a given type $A_{n-1}$ root datum }

set nilpotent_orbit_GL ([int] parts) = ComplexNilpotent:
   let (n,Levi_type,simples) = Levi_A(parts)
   then rd = GL(n), v = adjoint_2rho(Levi_type)
   then H = vec: sum(n # for pos@i in simples do coroot(rd,pos)*v[i] od)
in complex_nilpotent(rd,H)

set nilpotent_orbit_A(RootDatum rd) = (Partition->ComplexNilpotent):
   let map = test_simple_type("A",rd) in
   (Partition P) ComplexNilpotent:
(  assert(is_positive(P), "P is not a partition (has non-positive entries)")
;  let (n,Levi_type,simples) = Levi_A(P)
   then v = assert(n=#map+1,"Partition is of "+ n +" rather than "+(#map+1))
          ; adjoint_2rho(Levi_type)
   then H = sum(rd.rank # for pos@i in simples do coroot(rd,map[pos])*v[i] od)
in complex_nilpotent(rd,H)
)

{ an inverse operation, starting from |stratified_diagram(orbit)| }
set diagram_A_to_partition ([int] diagram) = Partition:
   assert(diagram=diagram~[:],"Stratified diagram should be a palindrome");
   let freq = [int]: (0#diagram).cumulate_forward.frequencies
   then n=#freq+1 { twice the largest part } then max=n\2
   then mult(int i) = int: { mulitplicity of part |i| in partition }
     let m = if i+2<=max then freq[max-i]-freq[max-i-2] else freq[max-i] fi
     in assert(m.>=,"Invalid diagram, negative mulitplicity of "+i); m
in for i:max from 1 ~ do for :mult(i) do i od od.##

{ ---------------- type A/SL(n) ------------------}

{diagram:

ComplexOrbit O            (for SL(n))
Partition    P            (for orbit in type A)
Pair of partitions (p,q)  (for representation of W(A_n))

O->P:  P=partition_of_orbit(O)
P->O:  O=complex_nilpotent_A(rd,P)

P-> (p,q): (p,q)=springer_A(P)
O-> (p,q): (p,q)=springer_A(P)

(p,q)->O: O=inverse_springer_A(rd,P)
(p,q)->P: O=inverse_springer_partition_A(P)
}

{ natural coordinates are for GL(n), so we need to map to and from for SL(n) }

{ transfer map for X^*: for a GL(n) weight |v|, |GL_to_SL_change_of_basis(n)*v|
  is the corresponding weight of SL(n). Since the SL(n) lattice X^* is the
  quotient of the GL(n) lattice by |[1,..,1]=ones(1)|, in which the basis is
  chosen to be the image of the first n-1 basis vectors, it suffices to map
  the final basis vector to -ones(n-1)
}
set GL_to_SL_change_of_basis(int n) = mat:
  id_mat(n-1)#-ones(n-1)

{ change of basis for X_*
  set A=GL_to_SL_co_change_of_basis(n)
  then, for example, A*rho_check(GL(n))=rho_check(SL(n))
}
set GL_to_SL_co_change_of_basis(int n)=ratmat:
inverse_change_basis(SL(n).dual,GL(n).simple_coroots)

{map from partition for an orbit of GL(n) to semisimple element H}
{in SL(n) coordinates}
set semisimple_element_A(Partition P) = ratvec:  {a coweight for SL(n)}
  let rho2_GL(int a) = for i:a do i+i-a+1 od { ladder [-a+1,-a+3,...,a-3,a-1] }
  then v = ratvec: for a in P do rho2_GL(a) od.##/2 then n=#v
  in GL_to_SL_co_change_of_basis(n)*(dominant(GL(n),v))

{partition of n -> ComplexNilpotent for SL(n)}
set complex_nilpotent_A (Partition P) = ComplexNilpotent:  {for SL(n)}
  complex_nilpotent(SL(sum(P)),ratvec_as_vec(2*semisimple_element_A(P)))

{ to make it independent of the isogeny and center use the diagram }
set complex_nilpotent_A(RootDatum rd,Partition P) = ComplexNilpotent:
   assert(sum(P)=rd.semisimple_rank+1,"rank mismatch");
   let diag = [int]: complex_nilpotent_A(P).diagram
   , orbits = nilpotent_orbits(rd) { build orbits for actual root datum |rd| }
   then index =  { look up for a match }
     first(for O in orbits do stratified_diagram(O)=diag od)
in orbits[index]

set partition_of_orbit_A(ComplexNilpotent O) = [int]:
   let orbit_partitions=partitions(O.root_datum.ss_rank+1)
   then index =
     first(for P in orbit_partitions do complex_nilpotent_A(O.root_datum,P)=O od)
in orbit_partitions[index]

{
set springer_A(CharacterTable ct,ComplexNilpotent O)=int:
  let P=O.partition_of_orbit_A, reps=ct.class_reps
  in first(#reps,(int i): cycle_type(classic_permutation(reps[i]))=P)
}

{Springer(orbit with partition P) = classical_irrep with partition P}
set springer_A(CharacterTable ct,ComplexNilpotent O)=int:
  let P=O.partition_of_orbit_A
  in first(ct.n_classes,(int i): ct.classical_reps(i).get_irrep_A=P)

set inverse_springer_partition_A(Partition P)=Partition: P

{inverse Springer map, from pair Partition of n
to ComplexNilpotent for GL(n)
}
set inverse_springer_A(Partition P)=ComplexNilpotent:
complex_nilpotent_A(P)


{------------------ duality ----------------------------------}

set A_dual(Partition P) = Partition: P.transpose

set dual_map_A(ComplexNilpotent O) = ComplexNilpotent:
   let P=partition_of_orbit_A(O) in complex_nilpotent_A(P.A_dual)

set springer_table_A (CharacterTable ct) = SpringerTable:
( ct
, ct.root_datum.orbits
, dual_map_A@ComplexNilpotent
, dual_map_A@ComplexNilpotent
, (ComplexNilpotent O) int: springer_A(ct,O)
)
