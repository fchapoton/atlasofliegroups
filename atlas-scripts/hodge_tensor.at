<hodge_functions.at
{<hodge_K_type_formula.at}
<tensor_product.at


{compute hodge function f\otimes F
 f is an arbitrary Hodge function
 F is a finite dimensional representation of K,
  given as a function from KGB to [ratvec] (should be [vec]?)
   see tensor_product.at
 formula is:
 (f\otimes F)(mu)=
}


set branch_function_std(Param p)=multiplicity_function:
(K_Type mu):split_as_int(branch_std(p,K_norm(mu))[parameter(mu)])

{set branch_std(Param p)=(Param->int):
(Param q):branch_std(p)(LKT(q))
}

set hodge_function_std(Param p)=hodge_function:
((K_Type mu):coefficient(hodge_branch_std(p,K_norm(mu)),parameter(mu)),p.real_form)

set shift(vec v,hodge_function f)=hodge_function:
((K_Type mu): f.f(K_Type:(mu.x,mu.lambda+v)),f.real_form)

{moved Psi_S to hodge_functions.at}
{
set Psi_S(hodge_function f,[K_Type] ktypes)=KHodgeParamPol:
(dearrange(##for mu in ktypes do if #f(mu)=0 then [(vec,K_Type)]:[] else  [(f(mu),mu)] fi  od,ktypes[0].real_form),())
set Psi_S(hodge_function f,[K_Type] ktypes,RealForm G)=KHodgeParamPol:
(dearrange(##for mu in ktypes do if #f(mu)=0 then [(vec,K_Type)]:[] else  [(f(mu),mu)] fi  od,G),())
}

{Phi_S is in hodge_K_type_formula.at}

set * (i_poly P, hodge_function f)=hodge_function:
((K_Type mu):convolve(P,f.f(mu)),f.real_form)

{f=hodge_function, weights (weight function of a K-type), mu
 (f\otimes weights)(mu)=\sum_tau mult(tau,mu\otimes(weights)^*)*f(tau)
 this is a finite sum over the K-types tau appearing in mu\otimes(weights)^*
}

set dual((KGBElt ->[ratvec]) weights)=(KGBElt->[ratvec]):(KGBElt x):for v in weights(x) do -v od

{general hodge tensor product}
set hodge_tensor(hodge_function f, (KGBElt -> [ratvec]) weights,K_Type mu)=i_poly:
let rv=poly_0 in for c@p in tensor_product(mu,dual(weights)) {K_Type_Pol}
do let mu=LKT(p) in  prints("mu=",mu, "f.f(mu)=",f.f(mu));  rv:=poly_plus(rv,split_as_int(c)*f.f(mu)) od;rv

{general hodge tensor product, as a hodge_function}
set hodge_tensor(hodge_function f, (KGBElt -> [ratvec]) weights)=hodge_function:
((K_Type mu):hodge_tensor(f,weights,mu),f.real_form)

{L\subset L_1\subset G (see hodgeTempered.pdf section 7 or so}
{hodge tensor product of hodge function on L with wedge^k(u\cap s_1)
u_1 is nilradical of q_1=l_1+u_1, is contained in nilradical u of q=l+u
}
set hodge_tensor_wedge_k_u_cap_s(hodge_function f,Parabolic P_1,int k)=hodge_function:
let weights=sums_nci_nilrad_roots_wedge_k_restricted_to_H_theta(P_1, k) in
minus_vee_to_the_k(k)*hodge_tensor(f,weights)

{same, as a hodge function}
set hodge_tensor_exterior_u_cap_s(hodge_function f,Parabolic P)=hodge_function:
let rv=nullHodgeFunction(P.real_form) in
 for k:#nilrad_roots(P)
 do rv+:=hodge_tensor_wedge_k_u_cap_s(f,P,k) od;rv

{hodge tensor of hodge_function_std(p) with arbitrary weight function}
set hodge_tensor_std(Param p, (KGBElt -> [ratvec]) weights,K_Type mu)=i_poly:
hodge_tensor(hodge_function_std(p),weights,mu)

{hodge tensor of hodge_function_std(p) with arbitrary weight function,
as a hodge_function}
set hodge_tensor_std(Param p, (KGBElt -> [ratvec]) weights)=hodge_function:
((K_Type mu):hodge_tensor_std(p,weights,mu),p.real_form)

{hodge tensor of hodge_function_std(ParamPol P) with arbitrary weight function}
set hodge_tensor_std(ParamPol P, (KGBElt -> [ratvec]) weights,K_Type mu)=i_poly:
let rv=poly_0 in for c@p in P do
rv:=poly_plus(rv,split_as_int(c)*hodge_tensor_std(p,weights,mu)) od;rv

{hodge tensor of hodge_function_std(ParamPol P) with arbitrary weight function,
as a hodge_function}
set hodge_tensor_std(ParamPol P, (KGBElt -> [ratvec]) weights)=hodge_function:
((K_Type mu):hodge_tensor_std(P,weights,mu),P.real_form)

{hodge tensor hodge_function_std(p) with wedge^k(u_1\cap s)}
set hodge_tensor_wedge_k_u_cap_s_std(Param p,Parabolic P_1,int k)=hodge_function:
{get out of the induction!}
if k=0 then branch_function_std_as_hodge_function(p)
else
let weights=sums_nci_nilrad_roots_wedge_k_restricted_to_H_theta(P_1, k) in
minus_vee_to_the_k(k)*hodge_tensor_std(p,weights)
fi

{hodge tensor hodge_function_std(p) with wedge^k(u_1\cap s), as a hodge function}
set hodge_tensor_exterior_u_cap_s_std(Param p,Parabolic P)=hodge_function:
let rv=nullHodgeFunction(p.real_form) in
 for k:#nilrad_roots(P)+1
 do rv+:=hodge_tensor_wedge_k_u_cap_s_std(p,P,k) od;rv

{assume S is sorted by height}
{map from KHodgeParamPols to hodgeParamPols, given a set S of K-types}
set Phi_S_inverse(KHodgeParamPol KP,[K_Type] S)=hodgeParamPol:
let rec_fun solve_one(KHodgeParamPol KP,[K_Type] S,hodgeParamPol rv)=hodgeParamPol:
let n=first(for mu in S do !=coefficient(KP,mu) od) in
 if n=-1 then rv else
  let c=coefficient(KP,S[n]) then
  p=parameter(S[n]) in
  solve_one(KP-Phi_S(c*p,S),S,rv+c*p) fi
in solve_one(KP,S,nullHodgeParamPol(KP.real_form))

{map from hodge functions to hodgeParamPols, given a set S of K-types}
set Omega_S_inverse(hodge_function f,[K_Type] S)=hodgeParamPol:Phi_S_inverse(Psi_S(f,S),S)

set hodge_tensor_std_as_function(Param p, (KGBElt -> [ratvec]) weights)=hodge_function:
((K_Type mu):hodge_tensor_std(p,weights,mu),p.real_form)

set hodge_tensor_wedge_k_u_cap_s_std_as_function(Param p,Parabolic P_1,int k)=hodge_function:
let weights=sums_nci_nilrad_roots_wedge_k_restricted_to_H_theta(P_1, k) in
minus_vee_to_the_k(k)*hodge_tensor_std_as_function(p,weights)

set hodge_tensor_exterior_u_cap_s_std_as_function(Param p,Parabolic P)=hodge_function:
let rv_hf=nullHodgeFunction(p.real_form) in
for k:#nilrad_roots(P)+1
do
let add=hodge_tensor_wedge_k_u_cap_s_std_as_function(p,P,k) in prints("k:",k,"add:",add);rv_hf+:=add od;rv_hf


