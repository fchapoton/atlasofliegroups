<hodge_functions.at
<hodge_K_type_formula.at
<tensor_product.at


{compute hodge function f\otimes F
 f is an arbitrary Hodge function
 F is a finite dimensional representation of K,
  given as a function from KGB to [ratvec] (should be [vec]?)
   see tensor_product.at
 formula is:
 (f\otimes F)(mu)=
}


set branch_function_std(Param p)=multiplicity_function:
(K_Type mu):split_as_int(branch_std(p,K_norm(mu))[parameter(mu)])

{set branch_std(Param p)=(Param->int):
(Param q):branch_std(p)(LKT(q))
}

set hodge_function_std(Param p)=hodge_function:
(K_Type mu):coefficient(hodge_branch_std(p,K_norm(mu)),parameter(mu))

set shift(vec v,hodge_function f)=hodge_function:
(K_Type mu): f(K_Type:(mu.x,mu.lambda+v))

{moved Psi_S to hodge_functions.at}
{
set Psi_S(hodge_function f,[K_Type] ktypes)=KHodgeParamPol:
(dearrange(##for mu in ktypes do if #f(mu)=0 then [(vec,K_Type)]:[] else  [(f(mu),mu)] fi  od,ktypes[0].real_form),())
set Psi_S(hodge_function f,[K_Type] ktypes,RealForm G)=KHodgeParamPol:
(dearrange(##for mu in ktypes do if #f(mu)=0 then [(vec,K_Type)]:[] else  [(f(mu),mu)] fi  od,G),())
}

{Phi_S is in hodge_K_type_formula.at}

set * (i_poly P, hodge_function f)=hodge_function:
(K_Type mu):convolve(P,f(mu))

set hodge_tensor(hodge_function f, (KGBElt -> [ratvec]) weights,K_Type tau)=i_poly:
let rv=poly_0 in for c@p in tensor_product(tau,weights) {K_Type_Pol} 
do let mu=LKT(p) in  rv:=poly_plus(rv,split_as_int(c)*f(mu)) od;rv

set hodge_tensor(hodge_function f, (KGBElt -> [ratvec]) weights)=hodge_function:
(K_Type mu):hodge_tensor(f,weights,mu)

set hodge_tensor_wedge_k_u_cap_s(hodge_function f,Parabolic P,int k)=hodge_function:
let weights=sums_nci_nilrad_roots_wedge_k_restricted_to_H_theta(P, k) in
minus_vee_to_the_k(k)*hodge_tensor(f,weights)

set hodge_tensor_exterior_u_cap_s(hodge_function f,Parabolic P)=hodge_function:
let rv=nullHodgeFunction(P.real_form) in 
 for k:#nilrad_roots(P) 
 do rv+:=hodge_tensor_wedge_k_u_cap_s(f,P,k) od;rv


{assume S is sorted by height}
set Phi_S_inverse(KHodgeParamPol KP,[K_Type] S)=hodgeParamPol:
let rec_fun solve_one(KHodgeParamPol KP,[K_Type] S,hodgeParamPol rv)=hodgeParamPol:
let n=first(for mu in S do !=coefficient(KP,mu) od) in
 if n=-1 then rv else
  let c=coefficient(KP,S[n]) then
  p=parameter(S[n]) in
  solve_one(KP-Phi_S(c*p,S),S,rv+c*p) fi 
in solve_one(KP,S,nullHodgeParamPol(KP.real_form))

set Omega_S_inverse(hodge_function f,[K_Type] S)=hodgeParamPol:Phi_S_inverse(Psi_S(f,S),S)

{
set convert(hodge_function f, int bound)=hodgeParamPol:
}



{
set subtract_term(hodgeParamPol P, K_Type mu)=hodgeParamPol:
P-
}
{
set hodge_std(Param p,K_Type mu)=i_poly:hodge_std(p)(mu)
}

{
set hodge_spherical_tensor_A1(int k, int N)=
let p=trivial(G)*0 then
hp=hodge_branch_std(p,N)}
