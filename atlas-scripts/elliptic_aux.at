<simple_factors.at
<elliptic.at

{replace each entry j of list_in with new_numbers[j]
example: replace([5,8,3],[0,1,2,0,0,2]) = [5,8,3,5,5,3]}

set replace([int] new_numbers,[int] list_in)=[int]:
for i:#list_in do new_numbers[list_in[i]] od

set replace([int] new_numbers,[[int]] list_of_lists)=[[int]]: 
for list in list_of_lists do replace(new_numbers,list) od


{example:
product_of_two_lists ([[1,2],[3,4]],[[5,6],[1,1]])=
[[ 1, 2, 5, 6 ],[ 1, 2, 1, 1 ],[ 3, 4, 5, 6 ],[ 3, 4, 1, 1 ]]
}
set product_of_two_lists([[int]] a,[[int]] b)=##for x in a do for y in b do x##y od od


{example:
a=[[1,2],[3,4]]
b=[[5],[6,7]]
c=[[8,9,10],[11]]
product_of_lists ([a,b,c])=
[  1,  2,  5,  8,  9, 10 ]
[  1,  2,  5, 11 ]
[  1,  2,  6,  7,  8,  9, 10 ]
[  1,  2,  6,  7, 11 ]
[  3,  4,  5,  8,  9, 10 ]
[  3,  4,  5, 11 ]
[  3,  4,  6,  7,  8,  9, 10 ]
[  3,  4,  6,  7, 11 ]
}
set product_of_lists([[[int]]] lists)=
let a=lists[0] in 
for i:#lists-1 from 1 do a:=product_of_two_lists(a,lists[i]) od;a

{elliptic elements of a RootDatum, not necessarily simple}
set elliptic(RootDatum root_datum)=[WeylElt]:
if ss_rank(root_datum)=0 then [WeylElt]:[id_W(root_datum)] else
let (root_numbering,factors)=simple_factors(root_datum) in
for v in product_of_lists(
for i:#factors do 
  let new_numbers=root_numbering[i] then
  rd=factors[i] in 
   for w in elliptic_simple(rd) do replace(new_numbers,w.word) od od) do id_W(root_datum)##v  od fi




