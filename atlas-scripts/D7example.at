<basic.at
<std_decs.at { predeclare types of rd, ic, G, block, etc. }
<groups.at
<extended.at

rd:=root_datum("D7",[[1/2]])
ic:=inner_class (rd,"c")
G:=quasisplit_form (ic)
set root = trivial(G)*/3

set !id = integrality_datum(root)

void: block := block_of(root) { the cast to void suppresses voluminous output }
delta:=distinguished_involution (inner_class(rd,"u"))

set !G0 = SO(8,6)
set !rd0 = root_datum(G0)
set !ic0 = inner_class(G0)
set !root0= trivial(G0)*/3
set !block0 = block_of(root0)
set !delta0 = diagonal([1,1,1,1,1,1,-1])
set !id0 = integrality_datum(root0)

{ Compute base change matrix M such that simple_roots(rd0)=M*simple_roots(rd)
  and ^simple_coroots(rd) = ^simple_coroots(rd0)*M }
set !M  = let (inv,d)=invert(rd.simple_roots) in rd0.simple_roots*inv \d
set !M1 = M^-1

set to_0 (KGBElt x) = KGBElt:
  assert(x.inner_class=ic,"expected inner class ic");
  KGB_elt(ic0,M*x.involution*M1,x.torus_factor*M1)
set from_0 (KGBElt x) = KGBElt:
  assert(x.inner_class=ic0,"expected inner class ic0");
  KGB_elt(ic,M1*x.involution*M,x.torus_factor*M)

set to_0 (Param p) = Param:
  assert(p.inner_class=ic,"expected inner class ic");
  let (x,lambda_rho,nu)=%p in param(x.to_0, M*lambda_rho, M*nu)
set from_0 (Param p) = Param:
  assert(p.inner_class=ic0,"expected inner class ic0");
  let (x,lambda_rho,nu)=%p in param(x.from_0, M1*lambda_rho, M1*nu)

set to_0 (extended_param E) = extended_param:
  assert(E.ic=ic,"expected inner class ic"); let theta0=M*E.theta*M1 in
  ( ic0, M*E.delta*M1
  , M*E.gamma, M*E.lambda_rho, theta0
  , E.g*M1, E.l*M1, -^theta0
  , M*E.tau, E.t*M1 )

set first_1i2f_Cayley(extended_param E,vec alpha) = extended_param:
  let rd = E.ic.root_datum
  then w = reflection(rd,2)*reflection(rd,1), neg = is_negative_root(rd)
  , theta_p = reflection(rd,alpha)*E.theta
  , alpha_v = coroot(rd,alpha)
  then rho_r_shift =
    sum (columns_with((vec alpha):neg(w*alpha),real_posroots(rd,theta_p)))
  in ( E.ic, E.delta
     , E.gamma, E.lambda_rho + rho_r_shift, theta_p
     , E.g, E.l+alpha_v*(alpha*E.torus_factor\2), -^theta_p
     , E.tau - alpha*(alpha_v*E.tau\2) , E.t)

: ext_tp = ([Param] param, mat type, mat link0, mat link1)

{ find numbers in original |block| of parameters listed in |eb| }
set fixed_points (ext_tp eb, [Param] block) = [int]:
  let i=0 in for q in eb.param do while block[i]!=q do i+:=1 od; i od

set list = [73,96,97,103,104,160,161,162,164]
set st = [1,2]

alpha   := root(id,st[0])
alpha_v := coroot(id,st[0])
beta    := root(id,st[1])
beta_v  := coroot(id,st[1])

set !alpha0 = root(id0,st[0])
set !alpha_v0 = coroot(id0,st[0])
set !beta0 = root(id0,st[1])
set !beta_v0 = coroot(id0,st[1])


{ positions in |fixed_points| of parameters enumerated in |list| (increasing) }
set indices ([int] fixed_points) = ([int] list) [int]:
  let i=0 in for x in list do while fixed_points[i]!=x do i+:=1 od; i od

: item = (int n, Param param, [string] links)

set cluster (ext_tp eb) =
  ([int] fixed_points,[int] list, [int] st) [item]:
  for i@pos in fixed_points.indices(list)
  do ( list[pos] { this equals |fixed_points[i]| }
     , eb.param[i]
     , for j in st { 2 simple reflections generating this cluster }
       do let links= [ eb.link0[i,j], eb.link1[i,j] ] in
         extended_status_texts[eb.type[i,j]] ##
         ## for l in links
            do if l<0 then " -" ## int_format(fixed_points[-1-l])
               elif l=#fixed_points then "."
               else " +" ## int_format(fixed_points[l])
               fi
            od
       od
     )
  od

set print_cluster ([Param] block, ext_tp eb, [int] list, [int] st) = void:
  for c in eb.cluster(fixed_points(eb,block),list,st) do print(c) od

set !eb  = ext_tp: extended_block(root,delta)
set !eb0 = ext_tp: extended_block(root0,delta0)

set !cl = eb.cluster(fixed_points(eb,block),list,st)
set !cl0 = eb0.cluster(fixed_points(eb0,block0),list,st)

set go() = print_cluster(block,eb,list,[1,2])
set go0() = print_cluster(block0,eb0,list,[1,2])

{ construct some interesting extended parameters }

{ first focus on element 3 of 9-element cluster cl }

p := cl[3].param
x := p.x
theta := x.involution

set E = E(delta,p) { downstairs default parameter }
set E0 = E(delta0,p.to_0)

q:= cl[6].param
set Eq = E(delta,q) { upstairs default parameter }

set E1 = E.to_0
set F0 = first_1i2f_Cayley (E0, alpha0)

set F1 = first_1i2f_Cayley (E1, alpha0)

assert( z_quot(E0,F0)=1 and z_quot(E1,F1)=-1 )
assert( sign(E0,E1)=1 and sign(F0,F1)=1      )

set theta0 = E0.x.involution
set thetap0 = F0.x.involution

set F2 = ( F0.ic, F0.delta, F0.gamma, F0.lambda_rho, F0.theta
         , F0.g, -F0.l, F0.omega, F0.tau, -F0.t)

assert( valid(F2) and sign(F0,F2)=1 )

set F3 = ( F1.ic, F1.delta, F1.gamma, F1.lambda_rho, F1.theta
         , F1.g, vec:[6,0,0,-1,0,0,-1], F1.omega, F1.tau, vec:[0,0,0,0,0,0,1])

assert( valid(F3) and sign(F2,F3)=1 )

{ do some surgery to simplify the example }
set set_l (extended_param E, vec l) =
  let F=(E.ic,E.delta,E.gamma,E.lambda_rho,E.theta,E.g, l ,E.omega,E.tau, E.t)
  in if valid(F) then F else error("invalid parameter") fi

set set_t (extended_param E, vec t) =
  let F=(E.ic,E.delta,E.gamma,E.lambda_rho,E.theta,E.g,E.l,E.omega,E.tau, t)
  in if valid(F) then F else error("invalid parameter") fi

void: F1:=set_l(F1,[0,0,0,-1,0,0,-1])
void: F3:=set_l(F3,[0,0,0,-1,0,0,-1])

assert( sign(F1,F3)=1 );

{ reconstruct elements downstairs }

void: E1:=set_l(E1,[0,0,0,-1,0,0,-1])
assert( first_1i2f_Cayley (E1,alpha0) = F1 )

set E3 = (E1.ic, E1.delta, E1.gamma, E1.lambda_rho, E1.theta
         , E1.g, vec:[0,0,0,-1,0,0,-1], E1.omega, E1.tau, vec:[0,0,0,0,0,0,1])

assert (valid(E3) and first_1i2f_Cayley (E3,alpha0)=F3 )
