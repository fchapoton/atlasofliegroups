<springer_tables.at
<nilpotent_orbit_partitions.at

{ Springer correspondence from nilpotent orbits to representations of W
  in type B/C
  orbit: partition encoded as semisimple H -> W(C_n)-irrep as pair of partitions
  see Carter pg. 419}

{ ---------------- type C ------------------}

{diagram:

ComplexOrbit:        O      (for Sp(2n) or PSp(2n)
Partition of 2n:     P      (for orbit in type C)
Pair of total sum n: (p,q)  (for irreducible representation of W(C_n))

O->P:  P=partition_of_orbit(O)
P->O:  O=complex_nilpotent_C(rd,P)

P-> (p,q): (p,q)=springer_C(P)
O-> (p,q): (p,q)=springer_C(P)

(p,q)->O: O=inverse_springer_C(rd,P)
(p,q)->P: O=inverse_springer_partition_C(P)
}

set partitions_C = (int->[Partition]):
  let gen =  parity_restricted_partitions(true) { restrict odd parts }
  in (int n) [Partition]: gen(n+n)


{ convert 1-based list of part multiplicities to H for Sp(2n) or SO(m) }
set part_mults_to_classical_H ([int] frequencies_shifted) = vec:
(  let freq_H = frequencies_shifted { vector to be modified }
in for f@i in frequencies_shifted ~ { frequency |f| of |i+i|, decreasing |i| }
   do if i>=2 then freq_H[i-2]+:=freq_H[i] fi { cumulate backward by steps 2 }
   od
;  freq_H[0]\:=2 { multiplicity of 0 in H was double counted, +1 for SO(odd) }
;  for fH@i in freq_H ~do for :fH do i od od.##
)

set freq_test_C ([int] frequencies) = [int]:
   assert(=frequencies.odd_places%2,"type C wrong partition"); frequencies

{ from (Jordan) partition (or composition) to Sp(2n) complex nilpotent orbit }
set nilpotent_orbit_Sp (Partition lambda) = ComplexNilpotent:
   let freqs = frequencies(lambda).freq_test_C
in complex_nilpotent(Sp(sum(lambda)),part_mults_to_classical_H(freqs[1:]))

set nilpotent_orbit_C (RootDatum rd) = (Partition->ComplexNilpotent):
   let map = test_simple_type("C",rd) then n=#map { semisimple rank }
in (Partition lambda) ComplexNilpotent:
(  assert(sum(lambda)=n+n,"Jordan type should be for C"+n)
;  let freqs = frequencies(lambda).freq_test_C
   then H_Sp = part_mults_to_classical_H(freqs[1:])
   then H = vec:
     sum(rd.rank # for c@i in cumulate_forward(H_Sp) do coroot(rd,map[i])*c od)
in complex_nilpotent(rd,H)
)

{ an inverse operation, starting from |stratified_diagram(orbit)| }
set diagram_C_to_partition ([int] diagram) = Partition:
   let H_Sp = vec:
      let (q,r) = diagram~[0]\%2 in assert(=r,"Final diagram entry is odd)")
      ; diagram~[0]:=q
      ; diagram.cumulate_backward
   then freq_H = [int]: frequencies(H_Sp)
   then max = #freq_H { maximal entry plus one } next freq_H[0] *:= 2
   then mult(int i) = int: { multiplicity of part |i| in result }
      let m =
         if i+1<max then freq_H[i-1]-freq_H[i+1] else freq_H[i-1] fi
      in assert(m.>=,"Invalid diagram, negative mulitplicity of "+i); m
in for i:max from 1 ~ do for :mult(i) do i od od.##

{ when |O| is an orbit for some |rd| passing |test_simple_type("C",rd)| }
set partition_of_orbit_C (ComplexNilpotent O) = Partition:
   let perm = test_simple_type("C",O.root_datum)
   in stratified_diagram(O,perm).diagram_C_to_partition


set partitions_B = (int->[Partition]):
  let gen =  parity_restricted_partitions(false) { restrict even parts }
  in (int n) [Partition]: gen(n+n+1)

set freq_test_B ([int] frequencies) = [int]:
(  assert(=frequencies.even_places%2,"type B wrong partition")
;  assert(frequencies.odd_places.sum.is_odd,"partition for type D, not B")
;  frequencies
)

{ from (Jordan) partition (or composition) to SO(2n+1) complex nilpotent orbit }
set nilpotent_orbit_SO_odd (Partition lambda) = ComplexNilpotent:
   let freqs = frequencies(lambda).freq_test_B
in complex_nilpotent(SO(sum(lambda)),part_mults_to_classical_H(freqs[1:]))

set nilpotent_orbit_B (RootDatum rd) = (Partition->ComplexNilpotent):
   let map = test_simple_type("B",rd) then n=#map { semisimple rank }
in (Partition lambda) ComplexNilpotent:
(  assert(sum(lambda)=n+n+1,"Jordan type should be for B"+n)
;  let freqs = frequencies(lambda).freq_test_B
   then H_SO = part_mults_to_classical_H(freqs[1:])
   then H = vec:
     let v = cumulate_forward(H_SO) then (q,r) = v~[0]\%2 in assert(=r)
     ; v~[0]:=q { correct for final simple coroot [0,..,0,2] of SO(2n+1) }
     ; sum(rd.rank # for c@i in v do coroot(rd,map[i])*c od)
in complex_nilpotent(rd,H)
)

{ an inverse operation, starting from |stratified_diagram(orbit)| }
set diagram_B_to_partition ([int] diagram) = Partition:
   let H_SO = vec: diagram.cumulate_backward
   then freq_H = [int]: frequencies(H_SO)
   then max = #freq_H { maximal entry plus one } next freq_H[0] +:= freq_H[0]+1
   then mult(int i) = int: { multiplicity of part |i| in result }
      let m =
         if i+1<max then freq_H[i-1]-freq_H[i+1] else freq_H[i-1] fi
      in assert(m.>=,"Invalid diagram, negative mulitplicity of "+i); m
in for i:max from 1 ~ do for :mult(i) do i od od.##

{ when |O| is an orbit for some |rd| passing |test_simple_type("C",rd)| }
set partition_of_orbit_B (ComplexNilpotent O) = Partition:
   let perm = test_simple_type("B",O.root_datum)
   in stratified_diagram(O,perm).diagram_B_to_partition



{springer map from partition P of 2n to pair of partitions (P,Q) sum(P)+sum(Q)=n}
set springer_C(Partition P)=(Partition,Partition):
assert(is_valid("C",P),"Not a valid type C partition");
let P=sort(P)  {increasing} then
P=if is_even(#P) then P else 0#P fi {even # of parts} then
Q=P+for i:#P do i od {add [0,1,2,...,]}
then v=[int]:[],w=[int]:[] in
{each odd part 2a+1 contributes a to v, each even part 2a contributes a to w}
for a in Q do if a.is_odd then v#:=a\2 else w#:=a\2 fi od;
assert(#v=#w,"error, v and w should have the same size");
{let ()=prints("v=",v, " w=", w)}
(delete_leading_zeros(v-for i:#v do i od),delete_leading_zeros( w-for i:#w do i od))

set springer_C(CharacterTable ct,ComplexNilpotent O)=int:
let (a,b)=springer_C(partition_of_orbit_C(O)) then
n=O.root_datum.ss_rank then
index=first(for i:ct.n_classes do let (P,Q)=get_irrep_BC(ct.classical_reps(i)) in
{prints("a:", pad(a,n), new_line, "x[0]: ",pad(x[0],n), new_line, pad(b,n), " ", pad(x[1], n));}
sort(pad(a,n))=sort(pad(P,n)) and sort(pad(b,n))=sort(pad(Q,n)) od) in
{pad(a,n)=pad(x[0],n) and pad(b,n)=pad(x[1],n) od) in} index


set inverse_springer_partition_C((Partition,Partition) partition_pair)=(bool,Partition):
let (P,Q)=partition_pair then n=sum(P)+sum(Q) then
()=assert(sum(P)+sum(Q)=n,"P,Q do not add up to correct size");
P:=sort(pad(P,n));
Q:=sort(pad(Q,n)) then
orbits=partitions_C(n) in
let index=first(for O in orbits do let (A,B)=springer_C(O) in sort(pad(A,n))=P and sort(pad(B,n))=Q od)
in if index=-1 then (false,null(0))
else
(true,orbits[index])
fi

{inverse Springer map, from pair (P,Q) of partitions,
both of size n, and sum(P)+sum(Q)=n,
to ComplexNilpotent for Sp(2n)
}
set inverse_springer_C((Partition,Partition) partition_pair)=(bool,ComplexNilpotent):
let (valid,P)=inverse_springer_partition_C(partition_pair) in
if valid then (valid,nilpotent_orbit_Sp(P)) else
(false,trivial_group.zero_orbit) fi


{ ---------------- type B ------------------}

{Springer correspondence from nilpotent orbits to representations of W in type B
 orbit: partition -> representation= pair of partitions
 see Carter pg. 419}

{diagram:

ComplexOrbit O            (for SO(2n+1))
Partition    P            (for orbit of SO(2n+1))
Pair of partitions (p,q)  (for representation of W(SO(2n+1)))

O->P:  P=partition_of_orbit(O)
P->O:  O=complex_nilpotent_B(P)

P-> (p,q): (p,q)=springer_B(P)
O-> (p,q): (p,q)=springer_B(P)

(p,q)->O: O=inverse_springer_B(P)
(p,q)->P: O=inverse_springer_partition_B(P)
}

set pad([int] v,int N)=v##null(N-#v)
set pad(ratvec v,int N)=v##null(N-#v)

{springer map from partition P of 2n to pair of partitions (P,Q) sum(P)+sum(Q)=n}
set springer_B(Partition P)=(Partition,Partition):
assert(is_valid("B",P),"Not a valid type B partition");
let P=sort(P)  {increasing} then
Q=P+for i:#P do i od {add [0,1,2,...,]}
then v=[int]:[],w=[int]:[] in
{each odd part 2a+1 contributes a to v, each even part 2a contributes a to w}
for a in Q do if a.is_odd then v#:=a\2 else w#:=a\2 fi od;
assert(#v=#w+1,"error, #v should equal #w+1");
(v-for i:#v do i od, w-for i:#w do i od)

set springer_B(ComplexNilpotent O)=(Partition,Partition):
springer_B(partition_of_orbit_B(O))

set springer_B(CharacterTable ct,ComplexNilpotent O)=int:
let (a,b)=springer_B(partition_of_orbit_B(O)) then
n=
a:=a.delete_trailing_zeros;
b:=b.delete_trailing_zeros;
O.root_datum.ss_rank then
index=first(for i:ct.n_classes do let (P,Q)=get_irrep_BC(ct.classical_reps(i)) in
{need n+1: sometimes a or b has length n+1 not n}
sort(pad(a,n))=sort(pad(P,n)) and sort(pad(b,n))=sort(pad(Q,n)) od) in
index

set inverse_springer_partition_B((Partition,Partition) partition_pair)=(bool,Partition):
let (P,Q)=partition_pair then n=sum(P)+sum(Q) then
()=assert(sum(P)+sum(Q)=n,"P,Q do not add up to correct size");
P:=sort(pad(P,n));
Q:=sort(pad(Q,n)) then
orbits=partitions_B(2*n) in
let index=first(for O in orbits do let (A,B)=springer_B(O) in sort(pad(A,n))=P and sort(pad(B,n))=Q od)
in if index=-1 then (false,null(0))
else
(true,orbits[index])
fi

{inverse Springer map, from pair (P,Q) of partitions,
both of size n, and sum(P)+sum(Q)=n,
to ComplexNilpotent for SO(2n+1)
}
set inverse_springer_B((Partition,Partition) partition_pair) =
    (bool,ComplexNilpotent):
let (valid,P)=inverse_springer_partition_B(partition_pair) in
if valid then (valid,nilpotent_orbit_SO_odd(P)) else
(false,trivial_group.zero_orbit) fi


{------------------ duality ----------------------------------}

set f([int] P, int i)=int:
for k:#P-i-1 from i+1 do  if P[k]<P[i]-1 then return k fi od;-1

{collapse a partition of 2n to a valid C-partition}
set rec_fun C_collapse(Partition P)=Partition:
assert(sum(P).is_even,"Partition not even");
if is_valid("C",P) then P.delete_trailing_zeros else
 let Q=if P~[0]=0 then P else P#0  fi then
 i=first(for k:#Q do Q[k].is_odd and multiplicity(Q[k],Q).is_odd and Q[k]>Q[k+1] od) then
 j=f(Q,i) in
 Q[i]-:=1;Q[j]+:=1;
 C_collapse(Q)
fi

{collapse a partition of 2n+1 to a valid B-partition}
set rec_fun B_collapse(Partition P)=Partition:
assert(sum(P).is_odd,"Partition not odd");
if is_valid("B",P.delete_trailing_zeros) then P.delete_trailing_zeros else
 let Q=if P~[0]=0 then P else P#0  fi then
 i=first(for k:#Q-1 do Q[k].is_even and multiplicity(Q[k],Q).is_odd and Q[k]>Q[k+1] od) then
 j=f(Q,i) in
 Q[i]-:=1;Q[j]+:=1;
 B_collapse(Q)
fi

set add_one(Partition P)=Partition:P[0]+:=1;P
set subtract_one(Partition P)=Partition:P~[0]-:=1;P

set BC_dual(Partition P)=
if sum(P).is_odd then {from type B_n to type C_n}
P.subtract_one.C_collapse.transpose.C_collapse
else  {from type C_n to type B_n}
P.add_one.B_collapse.transpose.B_collapse
fi

{for debugging}
set BC_dual_long(Partition P)=[int]:
if sum(P).is_odd then {from type B_n to type C_n}
let ()=prints("from B_",sum(P), " to ", "C_",sum(P)) then
 P1=P.subtract_one then
 ()=prints("-1: ", P1) then
 P2=P1.C_collapse then
 ()=prints("C-collapse: ", P2) then
 P3=P2.transpose then
 ()=prints("transpose: ",P3) then
 P4=P3.C_collapse then
 ()=prints("C-collapse: ",P4) in P4
else
let ()=prints("from C_",sum(P), " to ", "B_",sum(P)) then
 P1=P.add_one then
 ()=prints("+1: ", P1) then
 P2=P1.B_collapse then
 ()=prints("B-collapse: ", P2) then
 P3=P2.transpose then
 ()=prints("transpose: ",P3) then
 P4=P3.B_collapse then
 ()=prints("B-collapse: ",P4) in P4
fi

set test_duality_C(int n)=void:
let all=partitions_C(n) in
tabulate(
for P in all do [P.to_string,P.BC_dual.BC_dual.to_string] od)

set dual_map_C(ComplexNilpotent O_C)=ComplexNilpotent:
let P=partition_of_orbit_C(O_C) in
nilpotent_orbit_B(O_C.root_datum.dual)(BC_dual(P))

set dual_map_B(ComplexNilpotent O_B)=ComplexNilpotent:
let P=partition_of_orbit_B(O_B)
in nilpotent_orbit_C(O_B.root_datum.dual)(BC_dual(P))

set springer_table_C(CharacterTable ct)=SpringerTable:
let rd=ct.root_datum then
orbits=rd.orbits then
dual_map(ComplexNilpotent O)=ComplexNilpotent: dual_map_C(O) then
dual_map_i(ComplexNilpotent O)=ComplexNilpotent: dual_map_B(O) then
springer(ComplexNilpotent O)=springer_C(ct,O) in
(ct,orbits,dual_map,dual_map_i,springer)

set springer_table_B(CharacterTable ct)=SpringerTable:
let rd=ct.root_datum then
orbits=rd.orbits then
dual_map(ComplexNilpotent O)=ComplexNilpotent: dual_map_B(O) then
dual_map_i(ComplexNilpotent O)=ComplexNilpotent: dual_map_C(O) then
springer(ComplexNilpotent O)=springer_B(ct,O) in
(ct,orbits,dual_map,dual_map_i,springer)
