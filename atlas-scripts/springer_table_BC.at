<basic.at
<combinatorics.at { for |core_quotient_2| }
<springer_tables.at
<nilpotent_orbit_partitions.at
<character_tables_reductive.at { for |character_table@RootDatum| }

{ Springer correspondence from nilpotent orbits to representations of W
  in type B/C
  orbit: partition encoded as semisimple H -> W(C_n)-irrep as pair of partitions
  see Carter pg. 419}

{ ---------------- type C ------------------}

{diagram:

ComplexOrbit:        O      (for Sp(2n) or PSp(2n)
Partition of 2n:     P      (for orbit in type C)
Pair of total sum n: (p,q)  (for irreducible representation of W(C_n))

O->P:  P=partition_of_orbit(O)
P->O:  O=complex_nilpotent_C(rd,P)

P-> (p,q): (p,q)=springer_C(P)
O-> (p,q): (p,q)=springer_C(P)

(p,q)->O: O=inverse_springer_C(rd,P)
(p,q)->P: O=inverse_springer_partition_C(P)
}

set partitions_C = (int->[Partition]):
  let gen =  parity_restricted_partitions(true) { restrict odd parts }
  in (int n) [Partition]: gen(n+n)


{ convert 1-based list of part multiplicities to H for Sp(2n) or SO(m) }
set part_mults_to_classical_H ([int] frequencies_shifted) = vec:
(  let freq_H = frequencies_shifted { vector to be modified }
in for f@i in frequencies_shifted ~ { frequency |f| of |i+i|, decreasing |i| }
   do if i>=2 then freq_H[i-2]+:=freq_H[i] fi { cumulate backward by steps 2 }
   od
;  freq_H[0]\:=2 { multiplicity of 0 in H was double counted, +1 for SO(odd) }
;  for fH@i in freq_H ~do for :fH do i od od.##
)

set freq_test_C ([int] frequencies) = [int]:
   assert(=frequencies.odd_places%2,"type C wrong partition"); frequencies

{ from (Jordan) partition (or composition) to Sp(2n) complex nilpotent orbit }
set nilpotent_orbit_Sp (Partition lambda) = ComplexNilpotent:
   let freqs = frequencies(lambda).freq_test_C
in complex_nilpotent(Sp(sum(lambda)),part_mults_to_classical_H(freqs[1:]))

set nilpotent_orbit_C (RootDatum rd) = (Partition->ComplexNilpotent):
   let map = test_simple_type("C",rd) then n=#map { semisimple rank }
in (Partition lambda) ComplexNilpotent:
(  assert(sum(lambda)=n+n,"Jordan type should be for C"+n)
;  let freqs = frequencies(lambda).freq_test_C
   then H_Sp = part_mults_to_classical_H(freqs[1:])
   then H = vec:
     sum(rd.rank # for c@i in cumulate_forward(H_Sp) do coroot(rd,map[i])*c od)
in complex_nilpotent(rd,H)
)

{ an inverse operation, starting from |stratified_diagram(orbit)| }
set diagram_C_to_partition ([int] diagram) = Partition:
   let H_Sp = vec:
      let (q,r) = diagram~[0]\%2 in assert(=r,"Final diagram entry is odd)")
      ; diagram~[0]:=q
      ; diagram.cumulate_backward
   then freq_H = [int]: frequencies(H_Sp)
   then max = #freq_H { maximal entry plus one } next freq_H[0] *:= 2
   then mult(int i) = int: { multiplicity of part |i| in result }
      let m =
         if i+1<max then freq_H[i-1]-freq_H[i+1] else freq_H[i-1] fi
      in assert(m.>=,"Invalid diagram, negative mulitplicity of "+i); m
in for i:max from 1 ~ do for :mult(i) do i od od.##

{ when |O| is an orbit for some |rd| passing |test_simple_type("C",rd)| }
set partition_of_orbit_C (ComplexNilpotent O) = Partition:
   let perm = test_simple_type("C",O.root_datum)
   in stratified_diagram(O,perm).diagram_C_to_partition


set partitions_B = (int->[Partition]):
  let gen =  parity_restricted_partitions(false) { restrict even parts }
  in (int n) [Partition]: gen(n+n+1)

set freq_test_B ([int] frequencies) = [int]:
(  assert(=frequencies.even_places%2,"type B wrong partition")
;  assert(frequencies.odd_places.sum.is_odd,"partition for type D, not B")
;  frequencies
)

{ from (Jordan) partition (or composition) to SO(2n+1) complex nilpotent orbit }
set nilpotent_orbit_SO_odd (Partition lambda) = ComplexNilpotent:
   let freqs = frequencies(lambda).freq_test_B
in complex_nilpotent(SO(sum(lambda)),part_mults_to_classical_H(freqs[1:]))

set nilpotent_orbit_B (RootDatum rd) = (Partition->ComplexNilpotent):
   let map = test_simple_type("B",rd) then n=#map { semisimple rank }
in (Partition lambda) ComplexNilpotent:
(  assert(sum(lambda)=n+n+1,"Jordan type should be for B"+n)
;  let freqs = frequencies(lambda).freq_test_B
   then H_SO = part_mults_to_classical_H(freqs[1:])
   then H = vec:
     let v = cumulate_forward(H_SO) then (q,r) = v~[0]\%2 in assert(=r)
     ; v~[0]:=q { correct for final simple coroot [0,..,0,2] of SO(2n+1) }
     ; sum(rd.rank # for c@i in v do coroot(rd,map[i])*c od)
in complex_nilpotent(rd,H)
)

{ an inverse operation, starting from |stratified_diagram(orbit)| }
set diagram_B_to_partition ([int] diagram) = Partition:
   let H_SO = vec: diagram.cumulate_backward
   then freq_H = [int]: frequencies(H_SO)
   then max = #freq_H { maximal entry plus one } next freq_H[0] +:= freq_H[0]+1
   then mult(int i) = int: { multiplicity of part |i| in result }
      let m =
         if i+1<max then freq_H[i-1]-freq_H[i+1] else freq_H[i-1] fi
      in assert(m.>=,"Invalid diagram, negative mulitplicity of "+i); m
in for i:max from 1 ~ do for :mult(i) do i od od.##

{ when |O| is an orbit for some |rd| passing |test_simple_type("C",rd)| }
set partition_of_orbit_B (ComplexNilpotent O) = Partition:
   let perm = test_simple_type("B",O.root_datum)
   in stratified_diagram(O,perm).diagram_B_to_partition

{ Springer map from Cn nilpotent orbit to BiPartition indexing a W-irrep }
set springer_C (ComplexNilpotent O) = BiPartition:
   let (,(mu,lambda)) = { partitions are swapped for type C, see |wrep@Orbit| }
      core_quotient_2(partition_of_orbit_C(O))
   in (lambda,mu)

{ Springer map from partition P of 2n to bipartition (P,Q) of total size n }
set springer_C (Partition P) = BiPartition:
(  assert(is_valid("C",P),"Not a valid type C partition")
;  let (,(mu,lambda)) { partitions are swapped for type C, see |wrep@Orbit| }
      = core_quotient_2(sort(P))
   in (lambda~[:],mu~[:]) { return partitions in increasing order, why? }
)

set springer_C (CharacterTable ct,ComplexNilpotent O) = int:
  let (a,b)=springer_C(partition_of_orbit_C(O))
  , n=O.root_datum.semisimple_rank
  then index=first
    (for i:ct.n_classes
     do let (P,Q)=get_irrep_BC(ct.classical_reps(i)) in
{prints("a:", pad(a,n), new_line, "x[0]: ",pad(x[0],n), new_line, pad(b,n), " ", pad(x[1], n));}
       sort(pad(a,n))=sort(pad(P,n)) and sort(pad(b,n))=sort(pad(Q,n))
     od)
in {pad(a,n)=pad(x[0],n) and pad(b,n)=pad(x[1],n) od) in} index


set inverse_springer_partition_C (BiPartition (P,Q)) =
      (bool,Partition): { whether in image of springer_C, and if so pre-image }
   let lambda = from_core_quotient_2(0,(Q,P))
in (is_valid("C",lambda),lambda)

{ inverse Springer map, from pair (P,Q) of partitions, both (padded with zeros
  to be?) of size n, and sum(P)+sum(Q)=n, to ComplexNilpotent for Sp(2n)
}
set inverse_springer_C(BiPartition partition_pair) = (bool,ComplexNilpotent):
    let (valid,P)=inverse_springer_partition_C(partition_pair)
in  if valid then (valid,nilpotent_orbit_Sp(P))
    else (false,trivial_group.zero_orbit)
    fi


{ ---------------- type B ------------------}

{Springer correspondence from nilpotent orbits to representations of W in type B
 orbit: partition -> representation= pair of partitions
 see Carter pg. 419}

{diagram:

ComplexOrbit O            (for SO(2n+1))
Partition    P            (for orbit of SO(2n+1))
Pair of partitions (p,q)  (for representation of W(SO(2n+1)))

O->P:  P=partition_of_orbit(O)
P->O:  O=complex_nilpotent_B(P)

P-> (p,q): (p,q)=springer_B(P)
O-> (p,q): (p,q)=springer_B(P)

(p,q)->O: O=inverse_springer_B(P)
(p,q)->P: O=inverse_springer_partition_B(P)
}

set pad([int] v,int N)=v##null(N-#v)
set pad(ratvec v,int N)=v##null(N-#v)

{ Springer map from Cn nilpotent orbit to BiPartition indexing a W-irrep }
set springer_B (ComplexNilpotent O) = BiPartition:
   let (,pair) = { partitions unswapped for type B, see |wrep@Orbit| }
      core_quotient_2(partition_of_orbit_B(O))
   in pair

{ Springer map from partition P of 2n+1 to bipartition (P,Q) of total size n }
set springer_B (Partition P) = BiPartition:
(  assert(is_valid("B",P),"Not a valid type C partition")
;  let (,(lambda,mu)) { partitions unswapped for type B, see |wrep@Orbit| }
      = core_quotient_2(sort(P))
   in (lambda~[:],mu~[:]) { return partitions in increasing order, why? }
)

set springer_B (CharacterTable ct,ComplexNilpotent O) = int:
( let (a,b)=springer_B(partition_of_orbit_B(O))
  , n=O.root_datum.semisimple_rank
in a:=a.delete_trailing_zeros; b:=b.delete_trailing_zeros
; let index=first
    (for i:ct.n_classes
     do let (P,Q)=get_irrep_BC(ct.classical_reps(i)) in
{need n+1: sometimes a or b has length n+1 not n}
          sort(pad(a,n))=sort(pad(P,n)) and sort(pad(b,n))=sort(pad(Q,n))
     od)
  in index
)

set inverse_springer_partition_B (BiPartition partition_pair) =
      (bool,Partition): { whether in image of springer_C, and if so pre-image }
   let lambda = from_core_quotient_2(0,partition_pair)
in (is_valid("B",lambda),lambda)

{ inverse Springer map, from pair (P,Q) of partitions, both (padded with zeros
  to be?) of size n, and sum(P)+sum(Q)=n, to ComplexNilpotent for SO(2n+1)
}
set inverse_springer_C(BiPartition partition_pair) = (bool,ComplexNilpotent):
    let (valid,P)=inverse_springer_partition_B(partition_pair)
in  if valid then (valid,nilpotent_orbit_SO_odd(P))
    else (false,trivial_group.zero_orbit)
    fi


{------------------ duality ----------------------------------}

set C_adjust (Partition P) = Partition:
(  assert(sum(P).is_even,"Partition not even");
   let freq=frequencies(P) then l=#freq\2 { so |2*(l-1)+1<#freq| }
in while (l:=last(l,(int i)bool: freq[i+i+1].is_odd) ).>= { stop at "none" }
   do assert(l.>) { since at least another odd part size has odd multiplicity }
   ;  let k=last(l,(int i)bool: freq[i+i+1].>) { for next odd part that occurs }
   in assert(k.>=) { for the reason above: odd (multiplicity) implies nonzero }
   ; (let L=l+l in freq[L+1]-:=1; freq[L]+:=1)
   ; (let K=k+k in freq[K+2]+:=1; freq[K+1]-:=1)
   ; l:=k+1 { so search for next smaller |l| will start at |k| }
   od
;  repeat_parts(freq) { reconstruct a partition }
)

set B_adjust (Partition P) = Partition:
(  assert(sum(P).is_odd,"Partition not odd");
   let freq=frequencies(P)
   then l=(#freq+1)\2 { so |2*(l-1)<#freq| }
   next freq[0]:=1 { potential part to increase, ignored by |repeat_parts| }
in
   while (l:=last(l,(int i)bool: freq[i+i].is_odd) ).> { stop at none, or |l=0| }
   do let k=last(l,(int i)bool: freq[i+i].>) { for next even part that occurs }
   in assert(k.>=) { because if no other, |i=0| makes |freq[i+i].>| }
   ; (let L=l+l in freq[L]-:=1; freq[L-1]+:=1)
   ; (let K=k+k in freq[K+1]+:=1; freq[K]-:=1)
   ; l:=k+1 { so search for next smaller |l| will start at |k| }
   od
;  repeat_parts(freq) { reconstruct a partition }
)

set add_one(Partition P)=Partition:P[0]+:=1;P
set subtract_one(Partition P)=Partition:P~[0]-:=1;P

set BC_dual(Partition P)=
if sum(P).is_odd then {from type B_n to type C_n}
P.subtract_one.C_adjust.transpose.C_adjust
else  {from type C_n to type B_n}
P.add_one.B_adjust.transpose.B_adjust
fi

set B_to_C_dual (Partition lambda) = Partition:
   lambda:=lambda.strip_to_partition; lambda~[0]-:=1;
   lambda.C_adjust.transpose.C_adjust

set C_to_B_dual (Partition lambda) = Partition:
   if =#lambda then lambda:=[1] else lambda[0]+:=1 fi;
   lambda.B_adjust.transpose.B_adjust

set dual_map_C(RootDatum rd) = (ComplexNilpotent->ComplexNilpotent):
   let perm = test_simple_type("C",rd)
   , drd = dual(rd) { this avoids recomputing the dual datum all the time }
in if perm = #semisimple_rank(rd) { case of standard order, somewhat easier }
   then (ComplexNilpotent O_C) ComplexNilpotent:
      drd.nilpotent_orbit_B(diagram(O_C).diagram_C_to_partition.C_to_B_dual)
   else (ComplexNilpotent O_C) ComplexNilpotent:
      drd.nilpotent_orbit_B
        (stratified_diagram(O_C,perm).diagram_C_to_partition.C_to_B_dual)
   fi

set dual_map_B(RootDatum rd) = (ComplexNilpotent->ComplexNilpotent):
   let perm = test_simple_type("B",rd), drd = dual(rd)
in if perm = #semisimple_rank(rd) { case of standard order, somewhat easier }
   then (ComplexNilpotent O_B) ComplexNilpotent:
      drd.nilpotent_orbit_C(diagram(O_B).diagram_B_to_partition.B_to_C_dual)
   else (ComplexNilpotent O_B) ComplexNilpotent:
      drd.nilpotent_orbit_B
        (stratified_diagram(O_B,perm).diagram_B_to_partition.B_to_C_dual)
   fi

set dual_map_C (ComplexNilpotent O_C) = ComplexNilpotent:
   O_C.root_datum.dual.nilpotent_orbit_B(BC_dual(partition_of_orbit_C(O_C)))

set dual_map_B(ComplexNilpotent O_B)=ComplexNilpotent:
   O_B.root_datum.dual.nilpotent_orbit_C(BC_dual(partition_of_orbit_B(O_B)))

set springer_table_C (RootDatum rd) = SpringerTable:
   let (table, , irrep_of_bipartition) = character_table_C(rd)
   , orbit = (Partition->ComplexNilpotent): nilpotent_orbit_C(rd)
in ( table
   , for lambda in partitions_C(rd.semisimple_rank) do orbit(lambda) od
   , dual_map_C(rd)
   , dual_map_B(dual(rd)) { inverse of dual map is dual map for B }
   , (ComplexNilpotent O) int: irrep_of_bipartition(springer_C(O))
   )

set springer_table_B (RootDatum rd) = SpringerTable:
   let (table, , irrep_of_bipartition) = character_table_B(rd)
   , orbit = (Partition->ComplexNilpotent): nilpotent_orbit_B(rd)
in ( table
   , for lambda in partitions_B(rd.semisimple_rank) do orbit(lambda) od
   , dual_map_B(rd)
   , dual_map_C(dual(rd)) { inverse of dual map is dual map for C }
   , (ComplexNilpotent O) int: irrep_of_bipartition(springer_B(O))
   )

set springer_table_C(CharacterTable ct)=SpringerTable:
   let orbits=orbits(ct.root_datum)
   , dual_map = dual_map_C@ComplexNilpotent
   , dual_map_i = dual_map_B@ComplexNilpotent
   , springer(ComplexNilpotent O)=springer_C(ct,O)
in (ct,orbits,dual_map,dual_map_i,springer)

set springer_table_B(CharacterTable ct)=SpringerTable:
   let orbits=orbits(ct.root_datum)
   , dual_map = dual_map_B@ComplexNilpotent
   , dual_map_i = dual_map_C@ComplexNilpotent
   , springer(ComplexNilpotent O)=springer_B(ct,O)
in (ct,orbits,dual_map,dual_map_i,springer)

