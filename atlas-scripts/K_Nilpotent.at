<complex_nilpotent_orbits.at
<K_norm.at

set kn_verbose=true

{KN algorithm requires using defining parabolic by -H}
set -(RealNilpotent O)=RealNilpotent:
let (H,x,)=O in RealNilpotent:(-H,x,[])

{assume solve is valid}
set Solve(mat A,vec v)=requisition(solve(A,v))

{debugging commands just for this file}
set debug(bool verbose,string message)=void:if verbose then prints(message) fi
set db(string message)=debug(kn_verbose,message)

{given basis [Param] convert ParamPol to a vector in this basis
 assuming ParamPol has integer coefficients
 returns a vector if all entries in the ParamPol occur in the basis
 otherwise returns no_vec
}
set vector([Param] basis,ParamPol P)=maybe_a_vec:
let sum=null_module(P) then
v=vec:for p in basis do let c=split_as_int(P[p]) in  sum+:=c*p;c od in
if sum=P then v.solution else ().no_vec fi

{same as previous using K_Types}
set vector([K_Type] basis,K_Type_Pol P)=maybe_a_vec:
vector(for mu in basis do parameter(mu) od,P)

{concatenate matrices with same number of rows}
set merge_matrices([mat] matrices)=mat:
if #matrices=0 then id_mat(0) else
let rv=null(n_columns(matrices[0]),0) in
for M in matrices do rv##:=M od;rv  fi

{principal data structure for K_nilpotent calculation}
set_type KNilpotentData = (
RealForm real_form,
int bound,  {K_norm bound}
ratvec v,   {for use in K_norm in reductive case, default is rho_check(G)}
[ComplexNilpotent] complex_orbits, {complex nilpotent orbits, sorted by increasing dimension}
bool precompute_real_orbits, {flag to use the Vogan algorithm to compute real orbits}
[RealNilpotent] real_orbits, {real forms of each complex orbit}
[[(K_Type,K_Type_Pol)]] pairs,
  {#pairs = #real_orbits
  for each real orbit, an array [(mu_L,P)] of pairs L\cap K-type mu_L and K_Type_Pol:Phi(mu_L)}
[ ([K_Type],[K_Type],mat) ] T_matrices,
  {#T_matrices=#real_orbits
   for each orbit: (K_basis,L_cap_K_basis,T), #=m
   K_basis: K_types (for G) coming from orbit #=n
   L_cap_K_basis: K_type for L coming from orbit
   T=mxn matrix given the operator Phi in these bases}
[([K_Type],[K_Type],mat)] Y_matrices,
  {#Y_matrices=#complex_orbits
   for each complex orbit, (K_basis,L_cap_K_basis,Y)
   K_basis,L_cap_K_basis: coming from all
    (real forms of complex) orbits of smaller dimension
   Y is the matrix giving the image of Phi in these bases}
[([K_Type],[K_Type],mat,mat)] Q_and_P_Y_matrices,
  {#Q_matrices=#complex_orbits
   (K_basis,L_cap_K_basis,Q,P_Y):
   K_basis and L_cap_K_basis: closure of complex orbit,
    i.e. all real forms of orbit and all orbits of smaller dimension
   Q=matrix of T/T\cap Y
   P_Y=projector_mod_image(Y)
}
[mat] Z_matrices
{#Z_matrices=#real_orbits
 Z=L_Q*image_lattice(P_Y*Tbar)
 where Tbar is the T for the real closure of the orbit
}
)

set root_datum(KNilpotentData d)=RootDatum: d.real_form.root_datum
set Q_matrices(KNilpotentData d)=for (,,Q,) in d.Q_and_P_Y_matrices do Q od
set P_Y_matrices(KNilpotentData d)=for (,,,P_Y) in d.Q_and_P_Y_matrices do P_Y od

{----- real and complex nilpotent orbits -------}

{complex_orbit@RealNilpotent->ComplexNilpotent see real_nilpotent_orbits.at}

set complex_orbit_number(KNilpotentData d,ComplexNilpotent OC)=int:find(d.complex_orbits,OC)
set real_orbit_number(KNilpotentData d,RealNilpotent O)=int:find(d.real_orbits,O)
set complex_orbit_number(KNilpotentData d,RealNilpotent O) =int:complex_orbit_number(d,complex_orbit(O))
set complex_orbit_number(KNilpotentData d,int real_orbit) =int:complex_orbit_number(d,d.real_orbits[real_orbit])

set real_forms_of(KNilpotentData d,int complex_orbit)=[int]:
##for O@i in d.real_orbits do if
complex_orbit(O)=d.complex_orbits[complex_orbit] then [i] else [] fi od

set other_real_forms(KNilpotentData d,int real_orbit)=[int]:real_forms_of(d,complex_orbit_number(d,real_orbit))

{complex nilpotent -> set of complex nilpotents}
set closure(KNilpotentData d,int complex_nilpotent)=[int]:
let dim=dim_nilpotent(d.complex_orbits[complex_nilpotent]) in
##for  OC@i in d.complex_orbits do if dim_nilpotent(OC)<dim then [i] else [] fi od##[complex_nilpotent]

{complex orbits -> set of real nilpotents}
set closure_real(KNilpotentData d,int complex_orbit)=[int]:
##for a in closure(d,complex_orbit) do real_forms_of(d,a) od

{real orbit -> itself plus all real orbits of smaller dimension}
set closure_of_real_orbit(KNilpotentData d,int real_nilpotent)=[int]:
let complex_nilpotent=complex_orbit_number(d,real_nilpotent) then
dim=dim_nilpotent(d.complex_orbits[complex_nilpotent]) in
##for  OC@i in d.complex_orbits do if dim_nilpotent(OC)<dim then real_forms_of(d,i) else [] fi od##[real_nilpotent]


set smaller_orbits(KNilpotentData d,int real_orbit)=[int]:
let O=d.real_orbits[real_orbit] then
dim_O=dimension(O) in
##for o@i in d.real_orbits do if dimension(o)<dim_O then [i] else [] fi od

{---------------bases of K_types and L_cap_K_types----------}
{list of K_Types coming from given orbit}

set K_basis(K_Type_Pol P)=[K_Type]:for Q in monomials(P) do K_type(Q) od

set K_basis([K_Type_Pol] pols)=[K_Type]:
if #pols=0 then [] else
for Q in monomials(pols) do  K_type(Q) od fi

set K_basis(KNilpotentData data, int real_orbit)=
if #data.pairs=0 or #data.pairs[real_orbit]=0 then [] else
K_basis(for (,P) in data.pairs[real_orbit] do P od) fi

{list of K_Types coming from given orbits}
set K_basis(KNilpotentData data, [int] real_orbits)=
if #data.pairs=0 or #real_orbits=0 then [] else
K_basis(##for i in real_orbits do
for (,P) in data.pairs[i] do P od od)
fi

set K_basis_closure(KNilpotentData data,int complex_orbit)=
K_basis(data,closure_real(data,complex_orbit))

set K_basis_closure_of_real_orbit(KNilpotentData data,int real_orbit)=
K_basis(data,closure_of_real_orbit(data,real_orbit))

{K-types from all orbits
this should be the same as K_parameter_norm_upto(G,data.bound)
}
set K_basis(KNilpotentData data)=[K_Type]:
K_basis(data, #(#data.real_orbits))

{given a matrix in K_basis, convert to K_basis_new
 requirement: K_basis is a subset of K_basis_new (unless n_columns(M)=0)}
set change_basis([K_Type] K_basis, [K_Type] K_basis_new,mat M)=mat:
if n_columns(M)=0 then null(#K_basis_new,0) else
for col in M do let v=vector(K_basis_new, expand(col,K_basis,K_basis[0].real_form)) in
assert(any(v),"change_basis failed");
requisition(v) od fi

{list of L\cap K-types from data for given orbit}
set L_cap_K_basis(KNilpotentData d,int real_orbit)=[K_Type]:
for (mu_L,) in d.pairs[real_orbit] do mu_L od

{list of L\cap K-types from data for given orbits}
set L_cap_K_basis(KNilpotentData d,[int] real_orbits)=[K_Type]:
if #d.pairs=0 or #real_orbits=0 then [] else
##for i in real_orbits do L_cap_K_basis(d,i) od  fi

{matrix constructed from list of pairs [(K_Type,K_Type_Pol)]
 defining a map from L\cap K-types to K-types
 each K_Types if for L\cap K, each K_Type_Pol is for G
rows <-> K-types (for G)
columns <-> L\cap K-types
each column gives Phi(L\cap K-type) as a sum of K-types
}
set T_matrix([ (K_Type,K_Type_Pol) ] pairs)=([K_Type],[K_Type],mat):
if #pairs=0 then ([K_Type]:[],[K_Type]:[], null(0,0)) else
let K_basis=K_basis(for (,P) in pairs do P od) then
L_cap_K_basis=for (mu_L,) in pairs do mu_L od then
rv=null(#K_basis,#L_cap_K_basis) in
for (mu_L,P) in pairs do
   let col=vector(K_basis,P) in
   assert(any(col),"could not construct column of matrix");
   rv[find(L_cap_K_basis,mu_L)]:=requisition(col) od ;
(K_basis,L_cap_K_basis,rv) fi



set merge_matrices([ ([K_Type],[K_Type],mat) ] matrices)=([K_Type],[K_Type],mat):
if #matrices=0 then ([],[],null(0,0)) else
let K_basis=sort_u(##for (mu,,) in matrices do mu od) then
L_cap_K_basis=##for (,mu_L,) in matrices do mu_L od in
(K_basis,L_cap_K_basis,merge_matrices(for (kbasis,,T) in matrices do  change_basis(kbasis,K_basis,T) od)) fi

set merge_T_matrices(KNilpotentData d,[int] real_orbits)=
merge_matrices(for i in real_orbits do d.T_matrices[i] od)

set merge_Q_matrices(KNilpotentData d,[int] real_orbits)=
merge_matrices(for i in real_orbits do
let (K_basis,L_cap_K_basis,,)=d.Q_and_P_Y_matrices[i] in (K_basis,L_cap_K_basis, d.Q_matrices[i]) od)

set merge_P_Y_matrices(KNilpotentData d,[int] real_orbits)=
merge_matrices(for i in real_orbits do
let (K_basis,L_cap_K_basis,)=d.T_matrices[i] in (K_basis,L_cap_K_basis, d.P_Y_matrices[i]) od)

{(K_basis,L_cap_K_basis,Y) all for smaller orbits,not including P_Y}
set compute_Y_matrix(KNilpotentData d,int complex_orbit)=
let OC=d.complex_orbits[complex_orbit] then
dim_OC=dim_nilpotent(OC) then
smaller_orbits=##for O@i in d.real_orbits do
  if dimension(O)<dim_OC then [i] else [] fi od in
merge_T_matrices(d,smaller_orbits)

{K_basis_closure=K_basis_closure(d,complex_orbit) then
L_cap_K_basis_closure=L_cap_K_basis_closure(d,complex_orbit) then
Y=change_basis(K_basis,K_basis_closure,Y0) in
(K_basis_closure,L_cap_K_basis_closure,Y,projector_mod_image(Y)) }

{--------- utilities involving nilradicals --------------}

{given x a theta_x-stable set of roots R, return subset of R
consisting of each imaginary root alpha\in R, and one of each pair
alpha,theta(alpha)
if R isn't theta-stable this will fail}
set extract_roots(KGBElt x, [vec] roots)=[vec]:
let theta=involution(x) then
rv=[] in
while #roots>0 do
 let alpha=roots[0] in
 rv#:=alpha;
 roots:=delete(roots,0);
  if theta*alpha != alpha then
   let  index=find(roots,theta*alpha) in if (index=-1) then error("set of roots is not theta-stable") else
      roots:=delete(roots, find(roots,theta*alpha))  fi fi od;rv

{roots of H in s[1]
 s = -1 eigenspace of theta_x
 s[1] = 1 H-eigenspace of H on s
}
set s_one_roots(RealNilpotent O)=[vec]:
let theta=involution(O.x) then
()=assert(^theta*O.H = O.H,"H is not ^theta-fixed") then
P=parabolic_by_cwt(O.H,O.x) then
x_max=maximal(P) then {not x(P): this is P.x}
u=nilrad_roots_by_cwt(O.H,O.x) then
{u_complex=extract_roots(x,u) then  NO keep complex pairs for now}
roots=[vec]:[] then
()=for alpha in u do if alpha*O.H=1 and (is_noncompact_imaginary(x_max)(alpha) or is_complex(x_max)(alpha))  then roots#:=alpha fi od
in roots

{restriction of s_one_roots to H^{theta_x}
 each pair (alpha,theta(alpha)) contributes
 a single root restriction(alpha)=restriction(theta(alpha)),
 corresponding to the single vector X_\alpha-\theta(X_\alpha) in s[1]
 characters of H^theta are elements of X^*/(1-theta)X^*
}
set s_one_roots_restricted(RealNilpotent O)=[vec]:
let (H,x,)=O then
roots=s_one_roots(O) in roots:=extract_roots(x,roots)

{only want the non-compact imaginary roots after restriction
these are the nci roots, and one of each pair of complex roots
}
set s_one_nc_cx_roots_restricted(RealNilpotent O)=[vec]:
let rv=[] then
(H,x,)=O then
roots=s_one_roots(O) in
for alpha in roots do
 if is_noncompact_imaginary(alpha,x) then rv#:=alpha
 elif is_complex(alpha,x) then
  if find(rv,involution(x)*alpha)=-1 then rv#:=alpha fi fi od;rv

set s_one_cpt_cx_roots_restricted(RealNilpotent O)=[vec]:
let rv=[] then
(H,x,)=O then
roots=s_one_roots(O) in
for alpha in roots do
 if is_compact_imaginary(alpha,x) then rv#:=alpha
 elif is_complex(alpha,x) then
  if find(rv,involution(x)*alpha)=-1 then rv#:=alpha fi fi od;rv

set rho_one_cpt(RealNilpotent O)=vec:
let roots=s_one_cpt_cx_roots_restricted(O) in
if #roots=0 then null(rank(O.root_datum)) else sum(s_one_cpt_cx_roots_restricted(O)) fi

{all subsets of the set of restrictions of roots of s[1] to Lie(H)^{\theta_x}
 see KNilpotent paper, Corollary 7.3(6)}
set subsets_of_s_one_roots(RealNilpotent O)=[[vec]]:
let roots=s_one_nc_cx_roots_restricted(O) in
{let roots=s_one_roots_restricted(O) in}
delete(generate_all_subsets(roots),0) {don't want empty subset}

{H is in \mathfrak h, not \mathfrak h^*}
set rho_shifts(RealNilpotent O)=[(vec,int)]:
let ()=prints("rho_shifts with ", O) in
let (H,x,)=O then
(H_dom,w)=from_dominant(H,root_datum(x))  then
{wH_dom=H so
replace (H,x) with (H_dom,w^{-1}x)=w^{-1}(H,x)
compute rho_shifts, then apply w}
O_dom=RealNilpotent:(H_dom,cross(inverse(w),x),[]) then
m=matrix(w) then
S=subsets_of_s_one_roots(O_dom) in  [(vec:null(rank(real_form(x))),0)]##for A in S do (sum(m*A),#A) od

{find w so that wx=y (cross action)}
set find_cross_action(KGBElt x,KGBElt y)=WeylElt:
let (orbit,w_elements)=cross_orbit(x) then
match=find(orbit,y) in w_elements[match]

{appropriate rho_shifts for given x_L
 rho_shifts(O) are computed with respect to O.x (in distinguished fiber)
 if w*O.x=canonical_x_K(embed_KGB(x_L))
 then replace each shift by w*shift}
set rho_shifts(RealNilpotent O, KGBElt x_L)=[(vec,int)]:
let ()=prints("rho_shifts2 with ", O, " and ", x_L, " ", x_L.real_form, new_line, "simple:", x_L.real_form.simple_roots) in
let rhoshifts=rho_shifts(O) then
{x_can_L=canonical_x_K(x_L) then
x_can_G=embed_KGB(x_can_L,O.real_form) then}
()=prints("KGB(L):");print_KGB(x_L.real_form) then
x_G=canonical_x_K(embed_KGB(x_L,O.real_form)) then
x_O=x_min(parabolic_of_orbit(O)) then
()=prints("x_G=",x_G) then
()=prints("x_O=",x_O) then
w=cross_divide(x_O,x_G) in
let ()=prints("GOT w=",w) in
let ()=prints("x_G=",x_G, " x_O=", x_O) in
{w^{-1}(O.x)=x_can_G so
replace v with }
for (v,k) in rhoshifts do 
let ()=prints("v=",v, "inverse(w)*v=", inverse(w)*v) in
(inverse(w)*v,k) od

{ P is a theta-stable parabolic
  p_L is a STFL for L
  construct a new, possibly non-standard parameter for L
  by subtracting the appropriate 2\rho(u\cap s) from lambda(p_L)
  NB: the resulting term might not be standard
}
set twist_by_minus_2rho_u_cap_s(Parabolic P,Param p_L)=Param:
assert(nu(p_L)=null(rank(Levi(P))),"nu(p_L)\ne 0");
let G=real_form(P.x) then
L=real_form(p_L) then
x_L=x(p_L) then
x_G=canonical_x_K(embed_KGB(x_L,G)) in
parameter(x_L,lambda(p_L)-two_rho_u_cap_s(P,x_G),null(rank(Levi(P))))

{given Q theta-stable, and the K-type formula P for a K-type mu_L of L=Levi(Q),
 return the K-type formula for mu_L twisted by -2rho(u\cap s)
 algorithm: apply previous function twist_by_minus_2rho_u_cap_s to P term by term,
 each individual term in the result may be a non-standard parameter for L,
 apply standardize to each term, to give a sum of STFL parameters for L:
 this is the K-type formula for a single L\cap K-type
}
set twist_by_minus_2rho_u_cap_s(Parabolic P,K_Type_Pol K_type_formula)=K_Type_Pol:
let K_type_formula_twisted=null_module(K_type_formula) then
 L=real_form(K_type_formula) in
 for c@p in K_type_formula do K_type_formula_twisted+:=c*standardize(twist_by_minus_2rho_u_cap_s(P,p))*0 od;
{debugging}
if kn_verbose then  let
 b=branch_std(K_type_formula,20) then
 b_twisted=branch_std(K_type_formula_twisted,20) in
 if #b >1 then prints("WARNING: more than one K-type (before twist)");
 for p in monomials(b) do prints(highest_weight(LKT(p),KGB(L,0))) od fi;
{ prints(new_line,"K_type_formula:", new_line, "highest weight is:", highest_weight(LKT(first_param(b)),KGB(L,0)));}
 if #b_twisted >1 then prints("WARNING: more than one K-type after twist");
 for p in monomials(b_twisted) do prints(highest_weight(LKT(p),KGB(L,0))) od fi
 {prints(new_line,"K_type_formula after twist:", new_line, "highest weight is:", highest_weight(LKT(first_param(b_twisted)),KGB(L,0)))} fi;
{end debugging}
assert(#branch_std(K_type_formula_twisted,20)<=1,"error in twist_by_minus_2rho_u_cap_s");
K_type_formula_twisted

{ replace K-type mu with mu\otimes (-2\rho(u\cap s))}
set twist_by_minus_2rho_u_cap_s(Parabolic P,K_Type mu)=K_Type:
LKT(first_param(twist_by_minus_2rho_u_cap_s(P,K_type_formula(mu))))

{---------------------- Extension Algorithm ----------------------}

{this implements the algorithm of Proposition 7.3(6)
Phi(x_K,O,kgb_number_L,lambda_L)
x_K (KGBElt for G) is a basepoint for K
O is a RealNilpotent for G
L=Levi_of_orbit(O)
mu_L=(KGB(L,kgb_number_L),lambda_L) is an L\cap K-type
Phi is the function \tilde\mathcal E
}

{returns K_Type_Pol (i.e. K_Type_Pol of STFL parameters) for G}
set Phi(RealNilpotent O,int kgb_number_L, ratvec lambda_L)=K_Type_Pol:
let G=real_form(O.x) then
P=parabolic_of_orbit(O) {NOTE: parabolic defined by -O.H} then
L=Levi(P) then
()=prints("HERE IS L:");print_KGB(L) then
p_L_0=Param:parameter(KGB(L,kgb_number_L),lambda_L) in
      if kn_verbose then prints(new_line,"Computing Phi:", new_line, "O=", O, new_line,
      " L=", L,new_line, "x_L=", kgb_number_L, " lambda_L=", lambda_L, new_line,"p_L_0:", p_L_0) fi;
assert(not is_zero(p_L_0),"p_L_0 is zero");
assert(is_standard(p_L_0),"p_L_0 is not standard");
{assert(is_final(p_L_0),"p_L_0 is not final");}
let
K_type_formula=K_type_formula(p_L_0) then
K_type_formula_twisted=twist_by_minus_2rho_u_cap_s(P,K_type_formula) then
     b=branch_std(K_type_formula,50) then
     ()=assert(#b<=1,"More than one K-type (before twist)")  then
     {()=if kn_verbose then let b=branch_std(K_type_formula,20) in
     prints(new_line,"testing K_type_formula:", new_line, "highest weight is:", highest_weight(LKT(first_param(b)),KGB(L,0)));
     if #b >1 then prints("WARNING: more than one K-type");
     for p in monomials(b) do prints(highest_weight(LKT(p),KGB(L,0))) od fi fi then
     ()=if kn_verbose then let b=branch_std(K_type_formula_twisted,20) in
     prints(new_line,"testing twisted K_type_formula:", new_line, "highest weight is:", highest_weight(LKT(first_param(b)),KGB(L,0)));
     if #b >1 then prints("WARNING: more than one K-type");
     for p in monomials(b) do prints(highest_weight(LKT(p),KGB(L,0))) od fi fi then}
rv=null_module(G) in
     if kn_verbose then
       prints(
       new_line,"p_L_0:",p_L_0,
       new_line,"K_type_formula on L:", K_type_formula,
       new_line, "K_type_formula on L twisted:",K_type_formula_twisted)
     fi;
for c@p_L in K_type_formula_twisted do
     if kn_verbose then prints(new_line,"term in (twisted) K-type formula:",new_line, p_L) fi;
let ()=prints("x_L=",x(p_L)) in
let ()=prints("KGB(L)=");print_KGB(x(p_L).real_form) in
let ()=prints("O=",O) in
let rhoshifts=rho_shifts(O,x(p_L)) in
let ()=prints("L=",L) in
let ()=prints("default shifts:", rho_shifts(O)) in
let ()=prints("new shifts:", rhoshifts) in
 for (shift,j)@k in rhoshifts do
  let q=parameter(x(p_L),lambda(p_L)-shift,nu(p_L)) {shifted parameter on L}{NOTE: +shift not -shift} then
  r_1=theta_induce_standard(q,G) {theta-induce up to G} then
  r_2=r_1*0 {restrict to K} in
      if kn_verbose then prints(new_line, "shift: ", shift, new_line,"inducing: ", q, new_line,"induced term: ", r_2)
 fi;
  rv+:=(-1)^j*c*r_2
 od
od;
      if kn_verbose then prints(new_line,"Result:"){;kshow(rv)} fi;
rv
set Phi(RealNilpotent O,Param p_L)=K_Type_Pol:Phi(O,#x(p_L),lambda(p_L))
set Phi(RealNilpotent O,K_Type mu_L)=K_Type_Pol:Phi(O,#x(mu_L),lambda(mu_L))

set Phi(RealNilpotent O,K_Type_Pol mu_L)=K_Type_Pol:
let rv=null_module(O.real_form) in
for c@p in mu_L do rv+:=c*Phi(O,p) od;rv

{  unnormalized version of Phi }
{same algorithm but without the twist by -2\rho(u\cap s)}

set Phi_unnormalized(RealNilpotent O,int kgb_number_L, ratvec lambda_L)=K_Type_Pol:
let G=real_form(O.x) then
P=parabolic_of_orbit(O) then
L=Levi(P) then
p_L_0=Param:parameter(KGB(L,kgb_number_L),lambda_L) in
let ()=prints(p_L_0) in
assert(not is_zero(p_L_0),"p_L_0 is zero");
assert(is_standard(p_L_0),"p_L_0 is not standard");
{assert(is_final(p_L_0),"p_L_0 is not final");}
let
()=prints("OK") then
K_type_formula=K_type_formula(p_L_0) then
()=prints("OK") then
rv=null_module(G) then
rhoshifts=rho_shifts(O) in
{rhoshifts=rho_shifts_odd(O) in}
     if kn_verbose then if #rhoshifts>1 then prints("UNNORMALIZED orbit is dd",new_line,"rho shifts:", rhoshifts) else prints("orbit is even") fi fi;
     if kn_verbose then
       prints(
       new_line,"p_L_0:",p_L_0,
       new_line,"K_type_formula on L:", K_type_formula)
     fi;
for c@p_L in K_type_formula do
     if kn_verbose then prints(new_line,"Term in K-type formula:",new_line, p_L) fi;
 for (shift,j)@k in rhoshifts do
  let q=parameter(x(p_L),lambda(p_L)-shift,nu(p_L)) {shifted parameter on L}{NOTE: +shift not -shift} then
  r_1=theta_induce_standard(q,G) then
  r_2=r_1*0 in
      if kn_verbose then prints(new_line, "shiftSHIFT: ", shift, new_line,"inducing: ", q, new_line,"induced term: ", r_2) fi;
{  rv+:=(-1)^j*c*r_2 }
  rv+:=(-1)^j*c*r_2
 od
od;
      if kn_verbose then prints(new_line,"Result:"){;kshow(rv)} fi;
rv
set Phi_unnormalized(RealNilpotent O,Param p_L)=K_Type_Pol:Phi_unnormalized(O,#x(p_L),lambda(p_L))
set Phi_unnormalized(RealNilpotent O,K_Type mu_L)=K_Type_Pol:Phi_unnormalized(O,#x(mu_L),lambda(mu_L))

set Phi_unnormalized(RealNilpotent O,K_Type_Pol mu_L)=K_Type_Pol:
let rv=null_module(O.real_form) in
for c@p in mu_L do rv+:=c*Phi_unnormalized(O,p) od;rv

set dominant(RealNilpotent O)=RealNilpotent:
let (H,x,)=O then
(w,H_dom)=from_dominant(O.root_datum,H) then
O_dom=(H_dom,cross(inverse(w),x),()) in 
assert(is_conjugate_orbit(O_dom,O),"dominant(orbit) failed");O_dom

{ functions on real orbit as K-representation }
set functions_on_real_orbit(RealNilpotent O_in)=K_Type_Pol:
{let O=dominant(O_in) {seems to matter} then}
let O=O_in then
L=O.Levi_of_orbit then
p_L=finalize(trivial(L)*0) {in SU(2,1) trivial(G)*0 is not final}  in
Phi(O,p_L)

{-------------------------------------------------------------------}

{some linear algebra over Z}

set vector([Param] basis,K_Type_Pol P)=maybe_a_vec:
let sum=null_module(P) then
v=vec:for p in basis do let c=split_as_int(P[p]) in  sum+:=c*p;c od in
if sum=P then v.solution else ().no_vec fi

set vector([K_Type] basis,K_Type_Pol P)=maybe_a_vec:
vector(for mu in basis do parameter(mu) od,P)

{given K_Type_Pols list=[Q_1,...,Q_n] and K_Type_Pol:P test if
P=\sum a_i Q_i with a_i\in Z
return true/false, and [K_Type_Pol] R,[int] a so that
P=sum a[i]*R[i]
}
set in_span([K_Type_Pol] list,K_Type_Pol P)=([Param],mat,vec,bool):
if #list=0 then ([],null(0,0),null(0),false) else
let basis=monomials(list) {list of distinct Params} then
M=mat:for Q in list do let v=vector(basis,Q) in
assert(any(v),"failure in in_span");requisition(v)  od then
T=vector(basis,P) in
{assert(any(T),"can't find vector at all");}
if not any(T) then (basis,M,null(0),false) else
let T=requisition(T) then
inlattice=in_lattice(M,T) in (basis,M,T,inlattice) fi fi

{convenient to define in_span([[K_Type_Pol]] list,K_Type_Pol P)=
in_span( flatten the list,P)
}
set in_span([[K_Type_Pol]] list_of_lists,K_Type_Pol P)=([Param],mat,vec,bool):
let list=[K_Type_Pol]:[] in
let ()=for new_list in list_of_lists do list##:=new_list od in
in_span(list,P)

{returns all (?) [(mu_L,extension)], such that all terms in extension have K_norm <= bound }
set Phi_upto(RealNilpotent O,int bound, ratvec v)=[(K_Type,K_Type_Pol)]:
let bound_L=2*bound {heuristic: 2 seems to be big enough } then
(H,x,)=O then
G=real_form(x) then
L=Levi_of_orbit(O) then
L_cap_K_types=K_parameters_norm_upto(L,G,bound_L,v) in
{for a in L_cap_K_types do prints(a, " ", height(parameter(a)), " ",K_norm(a)) od;}
##for mu_L in L_cap_K_types do
 let extension=Phi(O,mu_L) in
 if #extension>0 and K_norm(extension)<=bound then [(mu_L,extension)] else [] fi od

set Phi_upto(KGBElt x_K,[RealNilpotent] orbits, int bound, ratvec v)=[(RealNilpotent,[(K_Type,K_Type_Pol)])]:
for O in orbits do (O,Phi_upto(O,bound,v)) od

{initialize KNilpotentData for G, with given bound, optional ratvec, optional
flag to compute nilpotent orbits using Vogan's algorithm}
set initialize_KNilpotent(RealForm G, int bound,ratvec v, bool compute_real_orbits)=KNilpotentData:
let complex_orbits= sort_by_dimension(complex_nilpotent_orbits(G.root_datum)) then
real_orbits = [] in
(G,
 bound,
 v,
 complex_orbits,
 compute_real_orbits,
 real_orbits, {real orbits}
 [], {pairs}
 [], {T_matrices}
 [], {Y_matrices}
 [([K_Type],[K_Type],mat,mat)]:[],  {Q_and_P_Y_matrices}
 []  {Z_matrices}
)

set initialize_KNilpotent(RealForm G, int bound,bool compute)=KNilpotentData:initialize_KNilpotent(G,bound,rho_check(G),compute)
set initialize_KNilpotent(RealForm G, int bound)=KNilpotentData:initialize_KNilpotent(G,bound,rho_check(G),false)

{crude guess of possible real orbits, given complex orbits
 the actual real orbits are a subset of these}
set potential_real_nilpotent_orbits(RealForm G,[ComplexNilpotent] complex_orbits)=[RealNilpotent]:
let delta=distinguished_involution(G) in
##for (rd,H)@i in complex_orbits
 do
  if H*delta=H {H must be ^delta-fixed to give a real orbit} then
   let roots_of_Levi=simple_roots_from_coweight(rd,H) then
   P_complex= (rd,roots_of_Levi) then
   theta_stable_parabolics=theta_stable_parabolics(G,P_complex) in
   for P in theta_stable_parabolics do RealNilpotent:(H,x_min(P),[]) od
   else []
  fi
 od

set potential_real_nilpotent_orbits(RealForm G)=[RealNilpotent]:
potential_real_nilpotent_orbits(G,complex_nilpotent_orbits(G))

{assume everything computed up to complex orbit i-1}
{not including Q and P_Y}
set fill_one_step(KNilpotentData d, int complex_orbit)={KNilpotentData:}
let G=d.real_form then
OC=d.complex_orbits[complex_orbit] then
()=db("Complex orbit OC="+OC.to_string) then
Y_matrix=compute_Y_matrix(d,complex_orbit) then
(K_basis,L_cap_K_basis,Y)=Y_matrix then
p_real_orbits=
if d.precompute_real_orbits  then real_nilpotent_orbits(OC,G)  else
potential_real_nilpotent_orbits(G,[OC]) fi in
d.Y_matrices#:=Y_matrix;
if kn_verbose then for O in p_real_orbits do prints("doing orbit ",O) od fi;
(for O in p_real_orbits do
  let orbit_valid=false in
  if d.precompute_real_orbits then orbit_valid:=true else
   {only do this if precompute_real_orbits is false (through END)}
   {add orbit to list only if it passes the test: functions_on_real_orbit(O) 
    does not come from smaller orbits}      
   let ()=db("potential real orbit:" + O.to_string) in
   let f=functions_on_real_orbit(O) then
   w0=vector(K_basis,f) in
   if not any(w0) then db("no w0, orbit is valid");orbit_valid:=true
    else let w=requisition(w0) then
    v0=solve(Y,w) in
{    if any(v0) then prints("orbit is not valid") fi;}
    if not any(v0) then orbit_valid:=true fi
   fi
  fi;
  {END}
  if orbit_valid then let
   pairs=Phi_upto(O,d.bound,d.v) then
   T_matrix=T_matrix(pairs) then
   (K_basis_T,L_cap_K_basis_T,T)=T_matrix in
   (
   d.real_orbits#:=O,
   d.pairs#:=pairs,
   d.T_matrices#:=T_matrix
   )
  fi
od) {for O in p_real_orbits};
{now fill in Q and P_Y}
let (K_basis_T,L_cap_K_basis_T,T0)=merge_T_matrices(d,closure_real(d,complex_orbit)) then
K_basis=K_basis_closure(d,complex_orbit) then
{K_basis: from closure of complex orbit}
(K_basis_Y,L_cap_K_basis_Y,Y0)=d.Y_matrices[complex_orbit] then
{K_basis_Y: from orbits of smaller dimension}
Y=change_basis(K_basis_Y,K_basis,Y0) then
T=change_basis(K_basis_T,K_basis,T0) then
T_cap_Y=intersection(T,Y) then
S=mod_image_projector(T_cap_Y) then
ST=S*T in
d.Q_and_P_Y_matrices#:=(K_basis_T,L_cap_K_basis_T,ST,S);
{now fill in Z matrices}
let Z_matrices=for i in real_forms_of(d,complex_orbit) do
let complex_orbit=complex_orbit_number(d,i) then
K_basis=K_basis(d,closure_real(d,complex_orbit)) then
(,,Q,P_Y)=d.Q_and_P_Y_matrices[complex_orbit] then
(kbasis,,Tbar0)=merge_T_matrices(d,closure_of_real_orbit(d,i)) then
Tbar=change_basis(kbasis,K_basis,Tbar0) in
image_lattice(P_Y*Tbar) od in
d.Z_matrices##:=Z_matrices;d

set fill_upto(KNilpotentData d,int n)=KNilpotentData:
for i:n+1 do
  d:=fill_one_step(d,i) od;d

set fill(KNilpotentData d)=KNilpotentData:
fill_upto(d,#d.complex_orbits-1)

set failed=([K_Type]:[],[K_Type]:[],null(0,0),null(0),null(0),false)

set search(KNilpotentData d,[int] real_orbits,K_Type_Pol P)=([K_Type],[K_Type],mat,vec,vec,bool):
let (K_basis,LK_basis,T)=merge_T_matrices(d,real_orbits) then
w0=vector(K_basis,P) then
()=if not any(w0) then {db("Cannot find vector representing P");} return(failed) fi then
w=requisition(w0) then
v0=solve(T,w) then
()=if not any(v0) then return(failed) fi then
v=requisition(v0) in
(K_basis,LK_basis,T,v,w,true)

set search(KNilpotentData d,int real_orbit,[int] real_orbits,K_Type mu_L)=([K_Type],[K_Type],mat,vec,vec,bool):
let O=d.real_orbits[real_orbit] in
search(d,real_orbits,Phi(O,parameter(mu_L)))

set failed_av_ann=([K_Type]:[],[K_Type]:[],-1,null(0,0),null(0),null(0),false)
set failed_av=([K_Type]:[],[K_Type]:[],[int]:[],null(0,0),null(0),null(0),false)

set av_ann(KNilpotentData d,K_Type_Pol P)=([K_Type],[K_Type],int,mat,vec,vec,bool):
for OC@i in d.complex_orbits do
 let real_orbits=closure_real(d,i) then
 (K_basis,L_cap_K_basis,T,v,w,success)=search(d,real_orbits,P) in
 if success then prints("AV(Ann(p)):");prints("Complex orbit #",i,": H=", OC.semisimple_element);
 return(K_basis,L_cap_K_basis,i,T,v,w,success) fi od;failed_av_ann

set av_ann(KNilpotentData d,Param p)=([K_Type],[K_Type],int,mat,vec,vec,bool):
av_ann(d,character_formula(p)*0)

set av_from_av_ann(KNilpotentData d,int complex_orbit,K_Type_Pol P)=
let OC=d.complex_orbits[complex_orbit] then
real_orbits=real_forms_of(d,complex_orbit) then
S=delete(generate_all_subsets(real_orbits),0) {ignore empty subset}  then
smaller_orbits=smaller_orbits(d,real_orbits[0]) in
for A in S do let
 (K_basis,L_cap_K_basis,T,v,w,success)=search(d,A##smaller_orbits,P) in
 if success then
 let  ()=prints("AV(p)");for i in A do prints("real orbit #",i,": ",d.real_orbits[i]) od in return(K_basis,L_cap_K_basis,[int]:A,T,v,w,success) fi  od;
return(failed_av)

set av_from_av_ann(KNilpotentData d,int complex_orbit,Param p)=
av_from_av_ann(d,complex_orbit,character_formula(p)*0)

set av(KNilpotentData d,K_Type_Pol P)=
let (,,complex_orbit,,,,)=av_ann(d,P) in
av_from_av_ann(d,complex_orbit,P)

set av(KNilpotentData d,Param p)=
av(d,character_formula(p)*0)

{  -------------------Q versions ------------}

{given v=[a_1,a_2,...,a_n]
return [0^{a+1},...,1^{a_i},...0^{a_n}]
}
set projector(vec v, int i)=mat:
diagonal(##for j:i do null(v[j]) od ##
ones(v[i])##
##for j:#v-i-1 from i+1 do null(v[j]) od)


{given subspaces [V_1,V_2,...,V_n]
 if w is in V_{i_1}\oplus V_{i_r}
 return [i_1,..,i_r]
 returns either ().no_vec or [i_1,...,i_r].solution
}
set summands(vec w, [mat] subspaces)=maybe_a_vec:
let M=merge_matrices(subspaces) then
v=solve(M,w) in
if not any(v) then  no_vec() else
let v=requisition(v) then
sizes=for M in subspaces do n_columns(M) od in
solution(##for i:#subspaces do
 if !=projector(sizes,i)*v then [i] else [] fi od) fi

set search_Q(KNilpotentData d,int complex_orbit,K_Type_Pol P)=
let K_basis=K_basis(d,real_forms_of(d,complex_orbit)) then
L_cap_K_basis=L_cap_K_basis(d,real_forms_of(d,complex_orbit)) then
Y=d.Y_matrices[complex_orbit] then
Q=d.Q_matrices[complex_orbit] then
P_Y=d.P_Y_matrices[complex_orbit] then
w0=vector(K_basis,P) then
()=if not any(w0) then return(failed) fi then
w=requisition(w0) then
v0=solve(Q,P_Y*w) then
()=if not any(v0) then return(failed) fi then
v=requisition(v0) in
(K_basis,L_cap_K_basis,Q,v,w,true)

set av_ann_Q(KNilpotentData d,K_Type_Pol P)=([K_Type],[K_Type],int,mat,vec,vec,bool):
for OC@i in d.complex_orbits do
{let ()=prints("i:", i) then} let
 (K_basis,L_cap_K_basis,T,v,w,success)=search_Q(d,i,P)  in
 if success then prints("AV(Ann(p)):");prints("Complex orbit #",i,": H=", OC.semisimple_element);
 return(K_basis,L_cap_K_basis,i,T,v,w,success) fi od;failed_av_ann

set av_ann_Q(KNilpotentData d,Param p)=([K_Type],[K_Type],int,mat,vec,vec,bool):
av_ann_Q(d,character_formula(p)*0)

{given v=[a_1,a_2,...,a_n]
return diag[0^{a+1},...,1^{a_i},...0^{a_n}]
}
set projector(vec v, int i)=
diagonal(##for j:i do null(v[j]) od ##
ones(v[i])##
##for j:#v-i-1 from i+1 do null(v[j]) od)

set av_from_av_ann_Q(KNilpotentData d,int complex_orbit,K_Type_Pol P)=
let K_basis=K_basis_closure(d,complex_orbit) then
w0=vector(K_basis,P) in
if not any(w0) then return(null(0))  else
let w=requisition(w0) then
(,,Q,P_Y)=d.Q_and_P_Y_matrices[complex_orbit] then
v=requisition(solve(Q,P_Y*w)) then
{()=prints("v=",v) then}
real_orbits=real_forms_of(d,complex_orbit) then
dim_subspaces=for i in closure_real(d,complex_orbit) do let (,,T)=d.T_matrices[i] in n_columns(T) od then
rv=##for i in real_orbits do
 let proj=projector(dim_subspaces,i) in if !=(proj*v) then [i] else [] fi od in
prints("AV(p): ", rv); rv fi

set av_from_av_ann_Q_cheating(KNilpotentData d,int complex_orbit,K_Type_Pol P)=
let K_basis=K_basis_closure(d,complex_orbit) then
w0=vector(K_basis,P) in
if not any(w0) then return(null(0))  else
let w=requisition(w0) then
real_orbits=real_forms_of(d,complex_orbit) then
(,,,P_Y)=d.Q_and_P_Y_matrices[complex_orbit] then
subsets=delete(generate_all_subsets(real_orbits),0) in
for S in subsets do
 let Z=merge_matrices(for i in S do d.Z_matrices[i] od) then
 v=solve(Z,P_Y*w) in
 if any(v) then return(S) fi od;null(0)  fi


set av_from_av_ann_Q_old(KNilpotentData d,int complex_orbit,K_Type_Pol P)=
let K_basis=K_basis_closure(d,complex_orbit) then
w0=vector(K_basis,P) in
if not any(w0) then return(().no_vec) else
let w=requisition(w0) then
(,,Q,P_Y)=d.Q_and_P_Y_matrices[complex_orbit] then
{L=left_inverse(Q) then
v=L*P_Y*w then}
v=P_Y*w then
real_orbits=real_forms_of(d,complex_orbit) then
subspaces=for i in real_orbits do
d.Z_matrices[i] od then
S=summands(v,subspaces) in
if not any(S) then return(().no_vec) else
let rv=for i in requisition(S) do real_orbits[i] od in
prints("AV(p)=real orbits: ",rv);
rv.solution fi fi

set av_from_av_ann_Q(KNilpotentData d,int complex_orbit,Param p)=
av_from_av_ann_Q(d,complex_orbit,character_formula(p)*0)

set av_Q(KNilpotentData d, K_Type_Pol P)=
let (,,j,,,,)=av_ann_Q(d,P) in
av_from_av_ann_Q(d,j,P)

set av_Q(KNilpotentData d, Param p)=
av_Q(d,character_formula(p)*0)

{----------some display functions--------------}

set stringify((int a,int b))="(" + a.to_string + "," + b.to_string + ")"

set display_string(RealNilpotent O)=string:
let (H,x,)=O then
(,k)=%x in "("+H.to_string+",x="+k.to_string+")"

set show(KNilpotentData d)=void:
prints("G=",d.real_form,new_line,"bound=",d.bound,new_line,"v=",d.v);
prints("complex orbits:");
for OC@i in d.complex_orbits do
prints("#",i," ",OC, " ", dim_nilpotent(OC)) od;
prints("matrices attached to complex orbits:");
let header=["#","Y","Q","P_Y"] then
values=
{for i:#d.complex_orbits do}
for i:#(d.Y_matrices) do
let
(,,Y)=d.Y_matrices[i],
Q=d.Q_matrices[i],
P_Y=d.P_Y_matrices[i] in
[i.to_string,shape(Y).stringify,shape(Q).stringify,shape(P_Y).stringify] od in
tabulate(header#values,"llll",1," ");
prints("real orbits:");
for O@i in d.real_orbits do prints("#",i, " ", display_string(O), " ", dimension(O)) od;
prints("matrices attached to real orbits:");
let header=["#","pairs","T","Z"] then
values=
for i:#d.real_orbits do
let shapeT= let (,,T)=d.T_matrices[i] in shape(T) then
shapeZ=shape(d.Z_matrices[i]) then
pairs=#d.pairs[i] in
[i.to_string,pairs.to_string, shapeT.stringify,shapeZ.stringify] od in
tabulate(header#values,"llll",1," ");
prints("sum of columns of Z-matrices: ", sum(for i:#d.real_orbits do let (,n)=shape(d.Z_matrices[i]) in n od));
prints("#K_basis: ", #K_basis(d))

set av_report(KNilpotentData d,[Param] params)=void:
show(d);for i:#params do prints(new_line, "#",i," ", params[i]);av(d,params[i]) od

{real orbits as computed by KNilpotent algorithm}
set KNilpotent_real_orbits(RealForm G,int bound, ratvec v)=
let d0=initialize_KNilpotent(G,bound,v,false) then
d=fill(d0) in d.real_orbits

set KNilpotent_real_orbits(RealForm G,int bound)=KNilpotent_real_orbits(G,bound,rho_check(G))
set KNilpotent_real_orbits(RealForm G)=KNilpotent_real_orbits(G,K_norm(trivial(G)*0)+3)  {in SU(2,1) need +3}

forget db@string




















