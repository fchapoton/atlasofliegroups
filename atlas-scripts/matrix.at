<basic.at

set upper_unitriangular_inverse (mat U) = mat:
   let n=#U then Q=id_mat(n) { is made to satisfy $Q*U=I_n$ below }
in for Uj@j in U
   do Q[j] := for i:j do -sum(for k:j-i from i do Q[i,k]*Uj[k] od) od
     ## Q[j][j:] { retain the final $n-j$ rows of column $j$ of $Q$ }
   od; Q

{ make result of echelon upper triangular using row operations, possibly with
  trailing null rows; return that triangular matrix and row operations matrix
}
set ech_up (mat M, [int] pivot) = (mat,mat):
   let (r,c)=shape(M)
   then R=id_mat(r) { record row operations, held in transposed form }
in for j:c { loop over columns of M as it is being modified in the loop }
   do let col=M[j] then (d,C)=Bezout(col[j:pivot[j]+1]), tM=^M
   then tM_C=tM[j:pivot[j]+1] * C, R_C = R[j:pivot[j]+1] *C
   in M := c^ for i:r do if i<j or i>pivot[j] then tM[i] else tM_C[i-j] fi od
   ;  R := r# for i:r do if i<j or i>pivot[j] then  R[i] else  R_C[i-j] fi od
   ; assert(M[j,j]=d)
   od; (M,^R)

set left_inverse(mat A) = mat: { for injective map to saturated sublattice }
(  let (M,C,pivots,)=echelon(A), c=#A
in if #M<c then error("not injective (rank is ",#M,"<",c,")") fi
;  let (Tri,R)= ech_up(M,pivots)
in if product(Tri.main_diagonal)=1
   then C*upper_unitriangular_inverse(Tri[:c,:])*R[:c,:]
   else error("image is not saturated")
   fi
)

set right_inverse(mat A) = mat: { section of a surjective lattice map A }
(  let (M,C,pivots,)=echelon(^A), c=A.n_rows
in if M.n_rows<c then error("row rank ",M.n_rows," not full (",c,")") fi
;  let (Tri,R)= ech_up(M,pivots)
in if product(Tri.main_diagonal)=1
   then ^(C*upper_unitriangular_inverse(Tri[:c,:])*R[:c,:])
   else error("image is not saturated")
   fi
)

set weak_left_inverse(mat A) = (mat,int): { left inverse after saturation }
(  let (M,C,pivots,)=echelon(A), c=#A
in if #M<c then error("not injective (rank is ",#M,"<",c,")") fi
;  let (Tri,R)= ech_up(M,pivots) then (T1,d)=invert(Tri[:c,:])
in ( C*T1*R[:c,:] , d)
)

set factor_scalar (mat M) = { factor out common divisor } (int,mat):
  let d=gcd(for col in M do gcd(col) od) in (d,if =d then M else M\d fi)


set principal_submatrix(mat M, [int] S)=mat: { choice |S| of rows, columns }
   let m=#S in matrix((m,m), (int i,int j)int: M[S[i],S[j]] )

set main_diagonal_square_block(mat M, int size, int offset) = mat:
  M[ offset:offset+size, offset:offset+size ]
set top_left_square_block(mat M,int size) = mat: M[ :size, :size]

set cokernel(mat M)=^kernel(^M)
set rank(mat A)=let (B,,pivots,)=A.echelon in #pivots

{concatenate matrices with same number of rows}
set merge_matrices([mat] matrices)=mat:
if #matrices=0 then id_mat(0) else
let rv=null(n_columns(matrices[0]),0) in
for M in matrices do rv##:=M od;rv  fi

set string_compact(mat M)=
let A=^M then
size=max(##for col in M do for x:#col do #(col[x].to_string) od od) in 
##for row in A do 
 let row_string=new_line 
  in  for x in row do row_string+:=pad(x.to_string,size+1) od;row_string od

set print_matrix_compact(mat M)=prints(string_compact(M))

{update one entry of a matrix}
set update_matrix_entry(mat M, int i, int j, int value)= mat:
  let row=M[i] in row[j]:=value; M[i]:=row; M

{add an integer to one entry of a matrix}
set add_to_matrix_entry(mat M, int i, int j, int value)= mat:
update_matrix_entry(M,i,j,M[i][j]+value)

set kronecker_product(mat A,mat B)=mat:
let (m,n)=shape(A),
(p,q)=shape(B) in
for i:m*p do
 for j:n*q do
  A[(j)\p,(i)\q]*B[(j)%p,(i)%q] od od