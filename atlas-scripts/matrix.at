<basic.at

set upper_unitriangular_inverse (mat U) = mat:
   let n=#U then Q=id_mat(n) { is made to satisfy $Q*U=I_n$ below }
in for Uj@j in U
   do Q[j] := for i:j do -sum(for k:j-i from i do Q[i,k]*Uj[k] od) od
     ## Q[j][j:] { retain the final $n-j$ rows of column $j$ of $Q$ }
   od; Q

{ make result of echelon upper triangular using row operations, possibly with
  trailing null rows; return that triangular matrix and row operations matrix
}
set ech_up (mat M, [int] pivot) = (mat,mat):
   let (r,c)=shape(M)
   then R=id_mat(r) { record row operations, held in transposed form }
in for j:c { loop over columns of M as it is being modified in the loop }
   do let col=M[j] then (d,C)=Bezout(col[j:pivot[j]+1]), tM=^M
   then tM_C=tM[j:pivot[j]+1] * C, R_C = R[j:pivot[j]+1] *C
   in M := c^ for i:r do if i<j or i>pivot[j] then tM[i] else tM_C[i-j] fi od
   ;  R := r# for i:r do if i<j or i>pivot[j] then  R[i] else  R_C[i-j] fi od
   ; assert(M[j,j]=d)
   od; (M,^R)

set left_inverse(mat A) = mat: { for injective map to saturated sublattice }
(  let (M,C,pivots,)=echelon(A), c=#A
in if #M<c then error("not injective (rank is ",#M,"<",c,")") fi
;  let (Tri,R)= ech_up(M,pivots)
in if product(Tri.main_diagonal)=1
   then C*upper_unitriangular_inverse(Tri[:c,:])*R[:c,:]
   else error("image is not saturated")
   fi
)

set right_inverse(mat A) = mat: { section of a surjective lattice map A }
(  let (M,C,pivots,)=echelon(^A), c=A.n_rows
in if M.n_rows<c then error("row rank ",M.n_rows," not full (",c,")") fi
;  let (Tri,R)= ech_up(M,pivots)
in if product(Tri.main_diagonal)=1
   then ^(C*upper_unitriangular_inverse(Tri[:c,:])*R[:c,:])
   else error("image is not saturated")
   fi
)

set weak_left_inverse(mat A) = (mat,int): { left inverse after saturation }
(  let (M,C,pivots,)=echelon(A), c=#A
in if #M<c then error("not injective (rank is ",#M,"<",c,")") fi
;  let (Tri,R)= ech_up(M,pivots) then (T1,d)=invert(Tri[:c,:])
in ( C*T1*R[:c,:] , d)
)

set factor_scalar (mat M) = { factor out common divisor } (int,mat):
  let d=gcd(for col in M do gcd(col) od) in (d,if =d then M else M\d fi)


set principal_submatrix(mat M, [int] S)=mat: { choice |S| of rows, columns }
   let m=#S in matrix((m,m), (int i,int j)int: M[S[i],S[j]] )

set main_diagonal_square_block(mat M, int size, int offset) = mat:
  M[ offset:offset+size, offset:offset+size ]
set top_left_square_block(mat M,int size) = mat: M[ :size, :size]

set cokernel(mat M)=^kernel(^M)
set rank(mat A)=let (B,,pivots,)=A.echelon in #pivots

{concatenate matrices with same number of rows}
set merge_matrices([mat] matrices)=mat:
if #matrices=0 then id_mat(0) else
let rv=null(n_columns(matrices[0]),0) in
for M in matrices do rv##:=M od;rv  fi

set string_compact(mat M)=
let A=^M then
size=max(##for col in M do for x:#col do #(col[x].to_string) od od) in 
##for row in A do 
 let row_string=new_line 
  in  for x in row do row_string+:=pad(x.to_string,size+1) od;row_string od

set print_matrix_compact(mat M)=prints(string_compact(M))

{update one entry of a matrix}
set update_matrix_entry(mat M, int i, int j, int value)= mat:
  let row=M[i] in row[j]:=value; M[i]:=row; M

{add an integer to one entry of a matrix}
set add_to_matrix_entry(mat M, int i, int j, int value)= mat:
update_matrix_entry(M,i,j,M[i][j]+value)

{   convert LieType to a canonical 8x16 matrix, for testing local isomorphism  }

{convert ABCDEFGT to an integer}
set type_numbers=["A","B","C","D","E","F","G","T"]
set number_of(string type)=int:
assert(#type=1,"not a single character");
first(for i:#type_numbers do type=type_numbers[i] od)

{return a matrix of size 8x16
 each column is a type A=0,B=1,C=2,D=3,E=4,F=5,G=6,T=7
 an entry k in column X/row j means:
  the simple factor Xj occurs k times
  The last column will be [k,0,...,0] where k is the dimension
   of the center <-> k factors of T1
}
set Lie_type_matrix(LieType lt)=mat:
let M=null(16,8) in
for (type,rank) in simple_factors(lt) do
 M:=add_to_matrix_entry(M,number_of(type),rank-1,1) od;
 {last column: torus factor}
 M:=update_matrix_entry(M,7,0,central_torus_rank(lt));M

set Lie_type_matrix(RootDatum rd)=mat:Lie_type_matrix(Lie_type(rd))
{Lie_type_matrix@RealForm is automatic}

{convert from matrix to LieType}
set Lie_type(mat M)=LieType:
assert(shape(M)= (16,8),"Matrix is wrong shape");
let lt=Lie_type("T",0) {empty type} in
 for col: 8 do
  for row: 16 do
   if M[col][row]>0 then
     for i:M[col][row] do lt*:=Lie_type(type_numbers[col],row+1) od
   fi
  od
 od;
 lt

{two complex groups are locally isomorphic iff they have the same Lie_type_matrix}
set is_locally_isomorphic(RootDatum rd_1,RootDatum rd_2)=bool:
Lie_type_matrix(rd_1)=Lie_type_matrix(rd_2)
