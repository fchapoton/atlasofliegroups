<character_tables.at
<matrix.at
<group_operations.at


set character_table_SxS(int n) = character_table:
let ct_0=character_table_S(n) then
    N=ct_0.n_classes then
    order=fac(n)*fac(n),
    partitions_n=partitions(n),
    {
     X={0,1,...,N^2-1}
     Y={(i,j)| 0<=i,j<=N-1}
     f:X->Y, g:Y->X are inverse bijections
     application: N=|S_n|
     }
    f=(int->(int,int)):(int a):(a\N,a%N) then
    g=((int,int)->int):(int a,int b):a*N+b then
    order=ct_0.order^2 then
    class_label=(int->string):(int n):let (i,j)=f(n) in
      ct_0.class_label(i)+":"+ct_0.class_label(j) then
    class_element_order=(int->int):(int n):let (i,j)=f(n) in
     lcm(ct_0.class_element_order(i),ct_0.class_element_order(j)) then
    class_power=((int,int)->int):(int index,int power):
     {index -f-> pair of indices (i,j) ->
                 pair(class_power(i,n), class_power(j,n) ->
	         -g-> single index <=N^2-1}
    let (i,j)=f(index) in g(ct_0.class_power(i,n),ct_0.class_power(j,n)) then
    centralizer_orders=[int]: for n:N^2 do let (i,j)=f(n) in
      ct_0.centralizer_orders[i]*ct_0.centralizer_orders[j] od then
    partitions_and_signs=(int->[(Partition,vec)]):(int n): let (i,j)=f(n) in
     [(partitions_n[i],[]),(partitions_n[j],[])] then
    class_sizes=[int]: for n:N^2 do let (i,j)=f(n) in
      ct_0.class_sizes[i]*ct_0.class_sizes[j] od then
    irreducible_label=(int->string):(int n):let (i,j)=f(n) in
      ct_0.irreducible_label(i)+":"+ct_0.irreducible_label(j) then
    table=kronecker_product(ct_0.table,ct_0.table) in
    ((SL(n)*SL(n)).Lie_type,
    order,
    partitions_and_signs,
    class_label,
    class_element_order,
    class_power,
    centralizer_orders,
    class_sizes,
    irreducible_label,
    {reflection representation is given pair of partitions: [n-1,1],[n-1,1]}
    (^table)[first(for j:N^2 do let pair= partitions_and_signs(j) in  let (P,)=pair[0], (Q,)=pair[1] in P=[n-1,1] and  Q=[n-1,1] od)],
    table
   )
