<knilpotent.at
{ ([RealNilpotentOrbit],[[int]] closures, [[(K_type,ParamPol)]])}
set compute_verbose=true

{convert list of ParamPols to matrix, in terms of basis of Params}
set matrix([ParamPol] list,[Param] basis)=mat:
 for P in list do for Q in basis do split_as_int(P[Q]) od od

{same as previous, using monomials(list) as the basis}
set matrix([ParamPol] list)=mat:matrix(list,monomials(list))

{list of K-types coming from given orbit}
set K_basis(KNilpotentData data, int orbitNumber)=[Param]:
monomials(for (,P) in data.pairs[orbitNumber] do P od)

set K_basis(KNilpotentData data, [int] orbitNumbers)=[Param]:
if #orbitNumbers=0 then [] else
monomials(##for i in orbitNumbers do
  for (,P) in data.pairs[i] do P od od) fi

{list of K-types coming from boundary of given orbit}
set K_basis_boundary(KNilpotentData data, int orbitNumber)=[Param]:
K_basis(data,data.closures[orbitNumber])

{list of K-types coming from closure of given orbit}
set K_basis_closure(KNilpotentData data, int orbitNumber)=[Param]:
K_basis(data,data.closures[orbitNumber]#orbitNumber)

{K-types from all orbits
this should be the same as K_parameter_norm_upto(G,n) where n 
 is the integer used in defining data
}
set K_basis(KNilpotentData data)=[Param]:
K_basis(data, #(#data.orbits))

{list of L\cap K-types from data for given orbit}
set L_cap_K_basis(KNilpotentData d,int orbit_number)=[K_Type]:
for (mu_L,) in d.pairs[orbit_number] do mu_L od

set L_cap_K_basis(KNilpotentData d,[int] orbit_numbers)=[K_Type]:
##for i in orbit_numbers do L_cap_K_basis(d,i) od 

{list of L\cap K-types from data for boundary of given orbit}
set L_cap_K_basis_boundary(KNilpotentData d,int orbit_number)=[K_Type]:
L_cap_K_basis(d,d.closures[orbit_number])

{list of L\cap K-types from data for closure of given orbit}
set L_cap_K_basis_closure(KNilpotentData d,int orbit_number)=[K_Type]:
L_cap_K_basis(d,d.closures[orbit_number]#orbit_number)

{run over all orbits, and for each orbit the 
list of L\cap K-types from that orbit}
set L_cap_K_basis(KNilpotentData d)=
L_cap_K_basis(d,#(#d.orbits))


{image of Phi(data,given orbit)}
set image_Phi(KNilpotentData data, int orbitNumber)=[ParamPol]:
for (,P) in data.pairs[orbitNumber] do P od

set image_Phi(KNilpotentData d, [int] orbitNumbers)=[ParamPol]:
if #orbitNumbers=0 then [] else
##for i in orbitNumbers do image_Phi(d,i) od fi

{image of Phi(data,boundary of given orbit)}
set image_Phi_boundary(KNilpotentData d, int orbitNumber)=[ParamPol]:
if #d.closures[orbitNumber]=0 then [] else
##for i in d.closures[orbitNumber] do image_Phi(d,i) od fi

{image of Phi(data,closure of given orbit)}
set image_Phi_closure(KNilpotentData d, int orbitNumber)=[ParamPol]:
##for i in d.closures[orbitNumber]#orbitNumber do image_Phi(d,i) od

{find K_type mu in list of K_types}
set find([K_Type] list,K_Type mu)=int: first(#list,(int i)bool:list[i]=mu)

{matrix defining a map from L\cap K-types to K-types
rows <-> K-types: from closure of orbit
columns <-> L\cap K-types from orbit itself
each column gives Phi(L\cap K-type)
}
set matrix_of_Phi(KNilpotentData d,int orbit_number)=
let 
L_cap_K_basis=L_cap_K_basis(d,orbit_number) then
K_basis=K_basis_closure(d,orbit_number) then
pairs=d.pairs[orbit_number] then
()=prints("PAIRS:", #pairs) then
rv=null(#K_basis,#L_cap_K_basis) in
if #pairs=0 then (K_basis,L_cap_K_basis, null(#L_cap_K_basis,#K_basis)) else
for (mu_L,Phi) in pairs do
   let (valid,col)=vector(K_basis,Phi) in
   assert(valid,"could not construct column of matrix");
   rv[find(L_cap_K_basis,mu_L)]:=col od ;(K_basis,L_cap_K_basis,rv) fi

set matrix_of_Phi(KNilpotentData d,[int] orbit_numbers)=
let
L_cap_K_basis=L_cap_K_basis(d,orbit_numbers) then
K_basis=K_basis(d,orbit_numbers) in
if #orbit_numbers=0 then (K_basis,L_cap_K_basis,null(#K_basis,#L_cap_K_basis)) else
let rv=
##for i in orbit_numbers do
 let pairs=d.pairs[i] in
 for (mu_L,Phi) in pairs do
   let (valid,col)=vector(K_basis,Phi) in
   assert(valid,"could not construct column of matrix");
   col od od in
if #rv=0 then (K_basis,L_cap_K_basis,null(#K_basis,#L_cap_K_basis)) else (K_basis,L_cap_K_basis,rv) fi
fi



{this one a little different - need basis to include K-types from orbit itself}
set matrix_of_Phi_boundary(KNilpotentData d,int orbit_number)=
let
L_cap_K_basis=L_cap_K_basis(d,d.closures[orbit_number]) then
K_basis=K_basis(d,d.closures[orbit_number]#orbit_number) then
orbit_numbers=d.closures[orbit_number] in
if #orbit_numbers=0 then (K_basis,L_cap_K_basis,null(#K_basis,#L_cap_K_basis)) else
let rv=
##for i in orbit_numbers do
 let pairs=d.pairs[i] in
 for (mu_L,Phi) in pairs do
   let (valid,col)=vector(K_basis,Phi) in
   assert(valid,"could not construct column of matrix");
   col od od in
if #rv=0 then (K_basis,L_cap_K_basis,null(#K_basis,#L_cap_K_basis)) else (K_basis,L_cap_K_basis,rv) fi
fi



{set matrix_of_Phi_boundary(KNilpotentData d,int orbit_number)=
matrix_of_Phi(d,d.closures[orbit_number])}

set matrix_of_Phi_closure(KNilpotentData d,int orbit_number)=
matrix_of_Phi(d,d.closures[orbit_number]#orbit_number)


{Phi matrix for all orbits}
set matrix_of_Phi(KNilpotentData d)=matrix_of_Phi(d,#(#d.orbits))

{
 T: V --> W
    U     U
    X --> Y

 T: V=Z^m --> W=Z^n  T=nxm matrix
 M=nxk matrix, columns span a sublattice Y of W
 Set X=T^{-1}(Y), a sublattice of V
 Fact: X is saturated
 Compute matrix A of size rxm, 
  X = span(columns of A)

algorithm:  
X_Q is spanned by columns of kernel(cokernel(M)*T)
X is the saturation of X_Q
application is below
}
set pullback_sublattice(mat T, mat M)=
saturation(kernel(cokernel(M)*T))

{application of pullback_sublattice}
{
Given list of K_types (all those of norm <=N)
W=W(N) = Z-span of these K_types
O=real orbit -> L ->
V=V(O,N)= Z<L\cap K-types, s.t. Norm(Phi(mu_L))<= N>
Phi: V(O,N) -> W(N)
T: matrix of this map  
V=Z^m, W=Z^n,  T=n\times m matrix
Y=Y(O,N) = Z<Phi(O',mu_{L'}| O' in boundary of O, s.t. norm <= N>\subset W
X(O,N) = Phi^{-1}(Y)
       = Z<virtual L\cap K-types, norm(Phi(*))<= N>
V(O,N)/X(O,N) = a certain space of virtual (L\cap K)^X-modules
(note: this implies V/X is free, i.e. X is saturated)
choose a set of representatives {v}\subset V(O,N) of V(O,N)/X(O,N)
T({v}) is a sublattice of W(O,N)
note: dimension(V(O,N)/X(O,N)) = dimension of image of Phi applied to this orbit
}
{returns: 
K_basis: basis of K_types (up to norm N) (span is W)
L_cap_K_basis: basis of L\cap K-types coming from the orbit
T: matrix of Phi
Y: matrix whose columns span Y=Y(O,N)
X: matrix whose columns span X=X(O,N)
V_mod_X: representatives in V of V/X
then T*V_mod_X gives a subspace of W
T*V_mod_X only well defined modulo Y
dim(T*V_mod_X) =dim(image of Phi applied to this orbit)
}
set compute_L_cap_K_X(KNilpotentData d, int orbit_number)=([Param],[K_Type],mat,mat,mat,mat):
if compute_verbose then prints("compute_L_cap_K_X of orbit", orbit_number) fi;
let (K_basis,L_cap_K_basis,T)=matrix_of_Phi(d,orbit_number) then
()=if compute_verbose then prints("T:", shape(T)) fi then
(,,Y)=matrix_of_Phi_boundary(d,orbit_number) then 
X=pullback_sublattice(T,Y) then 
V_mod_X=free_quotient_lattice_basis(X) in (K_basis,L_cap_K_basis,T,Y,X,V_mod_X)

{same as previous with some printing}
set compute_L_cap_K_X_long(KNilpotentData d, int orbit_number)=([Param],[K_Type],mat,mat,mat,mat):
let  (K_basis,L_cap_K_basis,T,Y,X,V_mod_X)=compute_L_cap_K_X(d,orbit_number) then
Y_plus_V_mod_X=Y##(T*V_mod_X) in
prints(new_line,"dim(V):", n_columns(T),
new_line,
"dim(W): ", n_rows(T),
new_line,
"Y: ", shape(Y),  "  dim(Y): ", rank(Y),
new_line,
"X: ", shape(X),  "  dim(X): ", rank(X),
new_line,
"dim(V/X): ", n_columns(V_mod_X),new_line,
"dim(Y+V/X):", rank(Y_plus_V_mod_X));(K_basis,L_cap_K_basis,T,Y,X,V_mod_X)

{run over all orbits, compute_L_cap_K_X(d,orbit)}
set compute_L_cap_K_X(KNilpotentData d)=[([Param],[K_Type],mat,mat,mat,mat)]:for i:#d.orbits do compute_L_cap_K_X(d,i) od
{
set compute_L_cap_K_X_all_long_old(KNilpotentData d)=
let all=compute_L_cap_K_X_all(d) in 
let (Kbasis,LKbasis,W,,,)=all[0] then
n=n_rows(W) then 
span=null(n,0) in
for i:#all do 
 let (,,T,,,V_mod_X)=all[i] then 
  TV=T*V_mod_X in
  span:=span##TV;prints(i, " ", rank(TV), " ", rank(span)) od;(Kbasis,LKbasis,span)
}



{[int] v is coefficients of [Param] params, return [v[i]*params[i]] (only non-zero terms)}
set express([int] v,[Param] params)=
assert(#v=#params,"size mismatch");
##for i:#v do if v[i]!=0 then [v[i]*params[i]] else [] fi od 

{[int] v is coefficients of [Param] params, return sum v[i]*params[i]}
set expand([int] v,[Param] params, RealForm G)=
if #params=0 then null_module(G) else
let rv=null_module(params[0]) in 
for i:#v do rv+:=v[i]*params[i] od;rv fi



{auxiliary routine, given closure relations [[closures]] for a 
set of orbits, and a subset of the orbits, return the closure relation
restricted to the subset}
set recalculate_closures([int] orbits,[[int]] closures)=
for i in orbits do 
##for j in closures[i] do 
  let f=find(orbits,j) in 
   if f !=-1 then [f] else [] fi od od 

set actual_real_nilpotent_orbits([RealNilpotentOrbit] p_orbits,[[int]] p_closures, int bound, ratvec v)=
let d=populate(bound,p_orbits,p_closures,v) then
rv =
if compute_verbose then prints("computed Knilpotent data") fi;
for i:#p_orbits do let (,,,valid)=in_span(image_Phi_boundary(d,i),functions_on_real_orbit(p_orbits[i])) in valid od then
actual_orbit_numbers=##for a@i in rv {#[bool] is #trues, not length of array}
do if  not rv[i] then [i] else [] fi od then
closures=
{for i in actual_orbit_numbers do 
 ##for j in p_closures[i] do 
  let f=find(actual_orbit_numbers,j) in 
   if f !=-1 then [f] else [] fi od od in }
recalculate_closures(actual_orbit_numbers,p_closures) in
prints(new_line,"Orbits:");
for i in actual_orbit_numbers do prints(p_orbits[i]) od;
prints("Closure relations:");
for a in closures do prints(a) od;
(for i in actual_orbit_numbers do  p_orbits[i] od,closures)

set actual_real_nilpotent_orbits(RealForm G, int bound, ratvec v)=
let (p_orbits,p_closures)=potential_real_nilpotent_orbits_and_closures(G) in
if compute_verbose then
  prints("potential _orbits:");
  for O in p_orbits do prints(O) od;
  prints("closures:");
  for a in p_closures do prints(a) od fi;
  actual_real_nilpotent_orbits(p_orbits,p_closures,bound,v)

set actual_real_nilpotent_orbits(RealForm G, int bound)=
actual_real_nilpotent_orbits(G,bound,rho_check(G))

{for testing only}
{set fake=[false,true,false,false,true,true,false,true,false,false,false,false,true,true,true,false,false,false,true]
set test_actual_real_nilpotent_orbits([RealNilpotentOrbit] p_orbits,[[int]] p_closures, int bound, ratvec v)=
let d=populate(bound,p_orbits,p_closures,v) then
rv =
if compute_verbose then prints("computed Knilpotent data") fi;
{
for i:#p_orbits do let (,,,valid)=in_span(image_Phi_boundary(d,i),functions_on_real_orbit(p_orbits[i])) in valid od
}
for i:#p_orbits do fake[i] od 
then
()=prints("rv=",rv) then
actual_orbit_numbers=##for a@i in rv {#[bool] is #trues, not length of array}
do if  not rv[i] then [i] else [] fi od
then
closures=
for i in actual_orbit_numbers do 
 ##for j in p_closures[i] do 
  let f=find(actual_orbit_numbers,j) in 
   if f !=-1 then [f] else [] fi od od in 
prints(new_line,"Orbits:");
for i in actual_orbit_numbers do prints(p_orbits[i]) od;
prints("Closure relations:");
for a in closures do prints(a) od;
(for i in actual_orbit_numbers do  p_orbits[i] od,closures)
}
set subset(KNilpotentData d, [int] orbits)=KNilpotentData:
let (all_orbits,closures,pairs)=d then
new_orbits=for i in orbits do all_orbits[i] od then
new_pairs =for i in orbits do pairs[i] od then
{recalculate closures}
new_closures = recalculate_closures(orbits,closures) 
in (new_orbits,new_closures,new_pairs)





set TVX_matrix(KNilpotentData d,int orbitNumber,[Param] K_basis)=
let (kbasis,lkbasis,T,V,X,VX)=compute_L_cap_K_X(d,orbitNumber) then
M=for v in T*VX do expand(v,kbasis,d.real_form) od
in matrix(M,K_basis)

set TVX_matrices(KNilpotentData d,[int] orbitNumbers,[Param] K_basis)=[mat]:
for i in orbitNumbers do TVX_matrix(d,i,K_basis) od

set TVX_matrices(KNilpotentData d,[Param] K_basis)=[mat]:
TVX_matrices(d,#(#d.orbits),K_basis)

set TVX_matrices(KNilpotentData d)=[mat]:
TVX_matrices(d,#(#d.orbits),K_basis(d))

set TVX_matrix(KNilpotentData d,[int] orbitNumbers,[Param] K_basis)=
let rv=null(#K_basis,0) in for M in TVX_matrices(d,orbitNumbers,K_basis) do rv##:=M od;rv



set master_matrix(KNilpotentData d,int orbitNumber,[Param] K_basis)=
matrix(image_Phi(d,orbitNumber),K_basis)

set master_matrix(KNilpotentData d,[int] orbitNumbers,[Param] K_basis)=
let rv=null(#K_basis,0) in 
for orbitNumber in orbitNumbers do rv##:=matrix(image_Phi(d,orbitNumber),K_basis) od;rv


set test(KNilpotentData d,[int] orbitNumbers,[Param] K_basis)=
let M=TVX_matrix(d,orbitNumbers,K_basis) then
k=kernel(M) in
for v in k do 
 ##for i:#v do if v[i]!=0 then [K_norm(expand(M[i],K_basis,d.real_form))] else [] fi od od

set basis_up_to([Param] K_basis, int bound)=mat:
let I=id_mat(#K_basis) in
##for i:#K_basis do if K_norm(K_basis[i])>=bound then [I[i]] else [] fi od

set truncate(mat M,[Param] K_basis, int bound)=mat:
let rv=null(#K_basis,0) in
for v in M do 
 if K_norm(expand(v,K_basis,K_basis[0].real_form))<=bound then rv#:=v fi od;rv

set run(KNilpotentData d,[int] orbitNumbers,[Param] K_basis, int bound)=
let M=TVX_matrix(d,orbitNumbers,K_basis) in
for i:bound do rank(kernel(truncate(M,K_basis,i))) od


{display result of compute_L_cap_K_X(d)}
set display(KNilpotentData d,[([Param],[K_Type],mat,mat,mat,mat)] all) =void:
let Ktypes=K_basis(d) then
data=["#","closure","V/X","Y","Y+T(V/X)","sum"]#
for i:#all do 
 let (kbasis,,T,Y,,V_mod_X)=all[i] then 
Y_plus_V_mod_X=Y##(T*V_mod_X) in
[i.to_string,
 d.closures[i].to_string,
 rank(T*V_mod_X).to_string,
 rank(Y).to_string,
 rank(Y##(T*V_mod_X)).to_string,
{ rank(master_matrix(d,#(i+1),Ktypes)).to_string}
 rank(TVX_matrix(d,#(i+1),Ktypes)).to_string
] od in 
prints(new_line,"dimension of space of K-types:", #K_basis(d));
let (,,A)=matrix_of_Phi(d) in prints("dimension of image(Phi): ", rank(A));
prints("Sum of dimensions of V/X:", sum(for (,,,,,V_mod_X) in all do rank(V_mod_X) od ),new_line);
tabulate(data,"llllll",1, " ")

{compute_L_cap_K_X with more output}
{set compute_L_cap_K_X_long(KNilpotentData d,[int] orbits)=void:display(d,compute_L_cap_K_X(d,orbits))}
set compute_L_cap_K_X_long(KNilpotentData d)=void:display(d,compute_L_cap_K_X(d))

{run over a subset of the orbits and compute_L_cap_K_X(d,orbit)}
{useful if running over all orbits is slow, but information from
some of the orbits is desired
[int] orbits should be closed under the closure operation, and 
almost certainly should be of the form [0,1,...,k]
}
set compute_L_cap_K_X(KNilpotentData d,[int] orbits)=compute_L_cap_K_X(subset(d,orbits))
set compute_L_cap_K_X_long(KNilpotentData d,[int] orbits)=compute_L_cap_K_X_long(subset(d,orbits))