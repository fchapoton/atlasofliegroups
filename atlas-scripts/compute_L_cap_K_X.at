<knilpotent.at
<lattice_aux.at

set compute_verbose=false

{need to define *, this should be moved elsewhere}
set *(int c,K_Type mu)=K_Type_Pol:c*parameter(mu)

{find K_type mu in list of K_types, move this also}
set find([K_Type] list,K_Type mu)=int: first(#list,(int i)bool:list[i]=mu)

{given matrix whose rows correspond to K_basis, change basis 
 to one with rows given by K_basis_new (should be a superset of K_basis)
}

{[int] v is coefficients of [K_Type] K_types, return sum v[i]*K_types[i]}
{need G only in the even of no K_types}
set expand([int] v,[K_Type] K_types, RealForm G)=K_Type_Pol:
if #K_types=0 then null_module(G) else
let rv=null_module(parameter(K_types[0])) in 
for i:#v do rv+:=v[i]*K_types[i] od;rv fi

{fails if #K_types=0}
set expand([int] v,[K_Type] K_types)=K_Type_Pol:
expand(v,K_types,K_types[0].real_form)

set change_basis([K_Type] K_basis, [K_Type] K_basis_new,mat M)=mat:
if n_columns(M)=0 then null(#K_basis_new,0) else
for col in M do let 
v=vector(K_basis_new, expand(col,K_basis,K_basis[0].real_form)) in 
assert(any(v),"change_basis failed");requisition(v) od fi



set merge_matrices([mat] matrices)=mat:
if #matrices=0 then id_mat(0) else
let rv=null(n_columns(matrices[0]),0) in
for M in matrices do rv##:=M od;rv fi

set merge_matrices([K_Type] K_basis,[([K_Type],mat)] pairs) =([K_Type],mat):
if #pairs=0 then (K_basis,null(#K_basis,0)) elif
#K_basis=0 then (K_basis,null(0,0)) else 
let M=
##for (basis,T)@j in pairs do
 for v@i in T do
  let w=vector(K_basis,expand(v,basis)) in   
  assert(any(w),"merge_matrices: can't find vector");requisition(w) od od
in if #M=0 then (K_basis,null(#K_basis,0)) else (K_basis, M) fi fi


{basis vector e_i in Z^n}
set e(int i,int n)=vec:id_mat(n)[i]

{sort K_Types uniquely}
set sort_u([K_Type] K_types)=[K_Type]:
if #K_types=0 then [] else
let P=null_module(K_types[0].real_form) in 
for mu in K_types do P+:=parameter(mu) od; 
for p in monomials(P) do K_type(p) od fi

set_type PhiMatrix = ([K_Type],[K_Type],mat)
set_type PhiLattice = ([K_Type] K_basis,mat T,mat Y,mat Z,mat Q)

set T_matrix([K_Type] K_basis,[PhiLattice] lattices,int i)=
let T0=lattices[i].T then 
kbasis=lattices[i].K_basis in change_basis(kbasis,K_basis,T0)

set T_matrices([K_Type] K_basis,[PhiLattice]  lattices,[int] orbits)=
for i in orbits do T_matrix(K_basis,lattices,i) od

set T_matrix([K_Type] K_basis,[PhiLattice]  lattices,[int] orbits)=
merge_matrices(T_matrices(K_basis,lattices,orbits))

set T_matrix([K_Type] K_basis,[PhiLattice]  lattices)=mat:
T_matrix(K_basis,lattices,#(#lattices))

set Y_matrix([K_Type] K_basis,[PhiLattice] lattices,int i)=
let Y0=lattices[i].Y then 
kbasis=lattices[i].K_basis in change_basis(kbasis,K_basis,Y0)

set Y_matrices([K_Type] K_basis,[PhiLattice]  lattices,[int] orbits)=
for i in orbits do Y_matrix(K_basis,lattices,i) od

set Y_matrix([K_Type] K_basis,[PhiLattice]  lattices,[int] orbits)=
merge_matrices(Y_matrices(K_basis,lattices,orbits))

set Q_matrix([K_Type] K_basis,[PhiLattice] lattices,int i)=
let Q0=lattices[i].Q then 
kbasis=lattices[i].K_basis in change_basis(kbasis,K_basis,Q0)



set K_basis([PhiMatrix] phi_matrices,[int] orbit_numbers)=[K_Type]:
if #orbit_numbers=0 then [] else
sort_u(##for i in orbit_numbers do let (P,,)=phi_matrices[i] in  P od) fi

{all orbits}
set K_basis([PhiMatrix] phi_matrices)=[K_Type]:K_basis(phi_matrices,#(#phi_matrices))







{given a matrix M, whose rows correspond to elements of K_basis,
and each column gives a sum of elements of K_basis,
only keep the columns whose K_norm is <=bound}
set truncate_elementary(mat M,[K_Type] K_basis, int bound)=mat:
let rv=null(#K_basis,0) in
for v in M do 
 if K_norm(expand(v,K_basis,K_basis[0].real_form))<=bound then rv#:=v fi od;rv

{given a matrix T, whose rows correspond to elements of K_basis,
and each column gives a sum of elements of K_basis,
give basis whose columns span elements of image(T) of K_norm <= bound
i.e. image(T)\cap (lattices of K_Types of norm <=bound)
this is bigger than truncate_elementary, since it can contain
a linear combinations of rows, each of which has K_norm >bound, 
whose K_norm is <=bound}

set sublattice_by_K_norm(mat T, [K_Type] K_basis,int bound)=mat:
##for i:#K_basis do if K_norm(K_basis[i])<=bound then [e(i,#K_basis)] else [] fi od


set truncate(mat T,[K_Type] K_basis, int bound)=mat:
let L= {sublattice of Z^#K_basis spanned by small terms}
##for i:#K_basis do if K_norm(K_basis[i])<=bound then [e(i,#K_basis)] else [] fi od
in intersection(T,L)

{list of K_Types coming from given orbit}
set K_basis(KNilpotentData data, int orbitNumber)=
if #data.pairs[orbitNumber]=0 then [] else
for Q in
monomials(for (,P) in data.pairs[orbitNumber] do P od)
do K_type(Q) od fi

{list of K_Types coming from given orbits}
set K_basis(KNilpotentData data, [int] orbitNumbers)=
if #orbitNumbers=0 then [] else
for  Q in 
 monomials(##for i in orbitNumbers do for (,P) in data.pairs[i] do P od od) do K_type(Q) od
fi

{K-types from all orbits
this should be the same as K_parameter_norm_upto(G,n) where n 
 is the integer used in defining data
}
set K_basis(KNilpotentData data)=[K_Type]:
K_basis(data, #(#data.orbits))

{list of L\cap K-types from data for given orbit}
set L_cap_K_basis(KNilpotentData d,int orbit_number)=[K_Type]:
for (mu_L,) in d.pairs[orbit_number] do mu_L od

{list of L\cap K-types from data for given orbits}
set L_cap_K_basis(KNilpotentData d,[int] orbit_numbers)=[K_Type]:
##for i in orbit_numbers do L_cap_K_basis(d,i) od 

{matrix defining a map from L\cap K-types to K-types
rows <-> K-types: from orbit itself (NOT closure)
columns <-> L\cap K-types from orbit itself
each column gives Phi(L\cap K-type)
}
set Phi_matrix(KNilpotentData d,int orbit_number)=([K_Type],[K_Type],mat):
let 
L_cap_K_basis=L_cap_K_basis(d,orbit_number) then
{K_basis=K_basis_closure(d,orbit_number) then}
K_basis=K_basis(d,orbit_number) then
pairs=d.pairs[orbit_number] then
{()=prints("PAIRS:", #pairs) then}
rv=null(#K_basis,#L_cap_K_basis) in
if #pairs=0 then (K_basis,L_cap_K_basis, null(#L_cap_K_basis,#K_basis)) else
for (mu_L,Phi) in pairs do
   let col=vector(K_basis,Phi) in
   assert(any(col),"could not construct column of matrix");
   rv[find(L_cap_K_basis,mu_L)]:=requisition(col) od ;(K_basis,L_cap_K_basis,rv) fi

{set of matrices, on for each orbit_number}
set Phi_matrices(KNilpotentData d,[int] orbit_numbers)=[([K_Type],[K_Type],mat)]:
for orbit_number in orbit_numbers do Phi_matrix(d,orbit_number) od

{set of matrices, running over all orbits}
set Phi_matrices(KNilpotentData d)=[([K_Type],[K_Type],mat)]:
Phi_matrices(d,#(#d.orbits))

set Phi_matrix([PhiMatrix] phi_matrices,int i)=let (,,T)=phi_matrices[i] in T

{L\cap K basis coming from triples, from given orbits}
set L_cap_K_basis([PhiMatrix] phi_matrices,[int] orbit_numbers)=[K_Type]:
if #orbit_numbers=0 then [] else
##for i in orbit_numbers do let (,P,)=phi_matrices[i] in  P od fi



{each orbit gives a matrix, with different bases
 combine these into 1 matrix, using a common K_basis
}
set merge_Phi_matrices([K_Type] K_basis,[PhiMatrix] phi_matrices,[int] orbit_numbers)=([K_Type],mat):
if #orbit_numbers=0 then (K_basis,null(#K_basis,0)) else 
merge_matrices(K_basis,for i in orbit_numbers do let (kbasis,,T) = phi_matrices[i] in (kbasis,T)  od) fi

{merge_matrices(K_basis,for (kbasis,,T) in phi_matrices do (kbasis,T) od) fi}

{same as previous, except only keep terms whose K_norm is <= smaller_bound}
set merge_Phi_matrices([K_Type] K_basis,[PhiMatrix] phi_matrices,[int] orbit_numbers, int smaller_bound)=([K_Type],mat):
merge_matrices(K_basis,for i in orbit_numbers do let (kbasis,,T)=phi_matrices[i] in (kbasis,truncate(T,kbasis,smaller_bound)) od)

{matrix coming from all orbits}
set image([PhiMatrix] phi_matrices)=
merge_Phi_matrices(K_basis(phi_matrices),phi_matrices,#(#phi_matrices))

{matrix coming from all orbits, with smaller bound}
set image([PhiMatrix] phi_matrices, int smaller_bound)=
merge_Phi_matrices(K_basis(phi_matrices),phi_matrices,#(#phi_matrices),smaller_bound)




{assume Phi_matrices(d) has been computed
this is of type [([K_Type],[K_Type],mat)] which is the second argument  
}
set compute_L_cap_K_X(KNilpotentData d, [PhiMatrix] phi_matrices,int orbit_number)=
if compute_verbose then prints("compute_L_cap_K_X of orbit ", orbit_number) fi;
let K_basis=K_basis(phi_matrices,d.closures[orbit_number]#orbit_number) {the basis I want to use} then
(,,T0)=phi_matrices[orbit_number] {matrix of T, K_basis from orbit} then
T=change_basis(K_basis(phi_matrices,[orbit_number]),K_basis,T0) then
(,Y)=merge_Phi_matrices(K_basis,phi_matrices,d.closures[orbit_number]) then
Z=intersection(T,Y) in 
{free_quotient_lattice_basis(T,TV_cap_Y)}
(K_basis,T,Y,Z,saturation_quotient_basis(T,Z))

{same as previous but with smaller_bound cutoff}
set compute_L_cap_K_X(KNilpotentData d, [PhiMatrix] phi_matrices,int orbit_number, int smaller_bound)=
if compute_verbose then prints("compute_L_cap_K_X of orbit ", orbit_number) fi;
let K_basis=K_basis(phi_matrices,d.closures[orbit_number]#orbit_number) {the basis I want to use} then
(,,T0)=phi_matrices[orbit_number] {matrix of T, K_basis from orbit} then
T0=change_basis(K_basis(phi_matrices,[orbit_number]),K_basis,T0) then
T=truncate(T0,K_basis,smaller_bound) then
(,Y)=merge_Phi_matrices(K_basis,phi_matrices,d.closures[orbit_number]) then
Z=intersection(T,Y) in 
{free_quotient_lattice_basis(T,TV_cap_Y)}
(K_basis,T,Y,Z,saturation_quotient_basis(T,Z))



{run over all orbits and compute_L_cap_K_X(d,phi_matrices,orbit)}
set compute_L_cap_K_X(KNilpotentData d, [PhiMatrix] phi_matrices)=
for i:#d.orbits do compute_L_cap_K_X(d,phi_matrices,i) od

{same as previous but with smaller_bound cutoff}
set compute_L_cap_K_X_smaller(KNilpotentData d, [PhiMatrix] phi_matrices, int smaller_bound)=
for i:#d.orbits do compute_L_cap_K_X(d,phi_matrices,i,smaller_bound) od

{sum of dimension of the T(V/X) spaces
 goal: choose smaller_bound small enough so that 
 the sum of these dimensions is 
 dimension of image(phi_matrices,G,smaller_bound)
}
set sum_of_dimensions(KNilpotentData d, [PhiMatrix] phi_matrices, int smaller_bound)=
sum(for (,,,,Q) in compute_L_cap_K_X_smaller(d,phi_matrices,smaller_bound) do rank(Q) od)

set test(KNilpotentData d, [PhiMatrix] phi_matrices, int bound)=void:
let sums=for i:bound do sum_of_dimensions(d,phi_matrices,i) od then
dimensions=for i:bound do let (,M)=image(phi_matrices,i) in rank(M) od in
prints("bound:", bound,new_line,
"each line displays:",new_line,
"smaller_bound  sum_of_dimensions  actual_dimension",new_line,
"if sum_of_dimensions=actual_dimension there are no overlaps");
for i:bound do prints(i, " ", sums[i], " ", dimensions[i]) od

set run_all(int bound, [RealNilpotentOrbit] orbits, [[int]] closures, int smaller_bound)=
let d=populate(bound,orbits,closures) then
Phi_matrices=Phi_matrices(d) then
all=compute_L_cap_K_X_smaller(d, Phi_matrices,smaller_bound) in
(d,Phi_matrices,all)

{group real orbits by their complexification, i.e. H}
set group_orbits([RealNilpotentOrbit] orbits)=
let rv=[[int]]:[] in
for (H,x)@j in orbits do
 if #rv=0 then rv#:=[0] else
 let i=find(for j:#rv do let (X,)=orbits[rv[j][0]] in X od,H) in 
  if i=-1 then rv#:=[j] else 
  rv[i]:=rv[i]#j
fi fi od;rv

{set group_orbits([RealNilpotentOrbit] orbits, int n)=[int]:
##for O@i in orbits do if O.H=orbits[n].H then [i] else [] fi od}

set complex_orbit_Phi_matrix([K_Type] K_basis,[RealNilpotentOrbit] orbits, [PhiMatrix] phi_matrices, [[int]] complex_orbits,int complex_orbit)=
merge_Phi_matrices(K_basis,phi_matrices,complex_orbits[complex_orbit])

{
set test_complex_orbit([K_Type] K_basis,[RealNilpotentOrbit] orbits,[PhiLattice]  lattices,int orbit_number,int smaller_bound)=
let orbits=group_orbits(orbits,orbit_number) then
(,Q)=merge_Q_matrices(K_basis,lattices,orbits) then
(,Y)=merge_Y_matrices(K_basis,lattices,orbits) then
rv=rank(intersection(Q,truncate(Y,K_basis,smaller_bound))) in
{prints(rv);}(Q,Y,rv)
}

{set test_complex_orbits([K_Type] K_basis,[RealNilpotentOrbit] orbits,[PhiLattice]  lattices,[int] orbit_numbers,int smaller_bound)=
for i in orbit_numbers do let (Q,Y,error)=test_complex_orbit(K_basis,orbits,lattices,i,smaller_bound) in 
prints("i:",i, "  Q: ", shape(Q), "  Y: ", shape(Y), " error=", error) od
}
{put the Q matrices together into one big matrix, also return a vector indicating
which orbit a given column comes from}
set Q_matrix_old([K_Type] K_basis,[PhiLattice]  lattices)=
let labels=[] then
rv=null(#K_basis,0) in
for i:#lattices do
 let (kbasis,,,,Q)=lattices[i] in
 for w in Q do 
  let v=vector(K_basis,expand(w,kbasis))  in
  assert(any(v),"can't find vector for Q_matrix");
  rv#:=requisition(v); labels#:=i od
od;(rv,labels)

set truncate_plus(mat T,[K_Type] K_basis, int bound)=(mat,mat):
let L= {sublattice of Z^#K_basis spanned by small terms}
##for i:#K_basis do if K_norm(K_basis[i])<=bound then [e(i,#K_basis)] else [] fi od
in intersection_plus(T,L)
{
set convert_Q_basis([K_Type] K_basis, ParamPol P, [PhiLattice]  lattices, int smaller_bound)=
let (Q0,labels)=Q_matrix(K_basis,lattices) then
Q=truncate(Q0,K_basis,smaller_bound) then
v=vector(K_basis,P) in
assert(any(v),"v not found");
(labels,solve(Q,requisition(v))) 


set convert_Q_basis_long([K_Type] K_basis, ParamPol P, [PhiLattice]  lattices, int smaller_bound)=
let (labels,maybe_v)=convert_Q_basis(K_basis,P,lattices,smaller_bound) in
if any(maybe_v) then 
 let v=requisition(maybe_v) in 
 for i:#v do 
  if v[i]!=0 then prints(i, " ", v[i], " ", labels[i]) fi od;(labels,v) 
else prints("No solution");(null(0),null(0)) fi 
}


set check(vec v, [K_Type] K_basis,mat Q)=
for i:#v do if v[i]!=0 then prints(i, " ", v[i], " ", K_norm(expand(Q[i], K_basis))) fi od


set R_matrices([K_Type] K_basis,[PhiLattice]  lattices)=
for (kbasis,,Y0,,Q0) in lattices do 
let Y=change_basis(kbasis,K_basis,Y0) then
Q=change_basis(kbasis,K_basis,Q0) in
left_inverse(Q)*projector_mod_image(Y) od







set leonidas(mat Q, [K_Type] K_basis, vec v, int smaller_bound)=
let (Q1,C1)=image_lattice_plus(Q) then
L=sublattice_by_K_norm(id_mat(#K_basis), K_basis, smaller_bound) then
(Q2,M)=intersection_plus(Q1,L) then 
w=solve(Q2,v) in
if not any(w) then prints("No solution");(vec:[],vec:[]) else
let w=requisition(w) in  
(w, C1*M*w) fi


set group_orbits([RealNilpotentOrbit] orbits, int n)=[int]:
##for O@i in orbits do if O.H=orbits[n].H then [i] else [] fi od

set complex_orbit_Phi_matrix([K_Type] K_basis,[RealNilpotentOrbit] orbits, [PhiMatrix] phi_matrices, int n)=
merge_Phi_matrices(K_basis,phi_matrices,group_orbits(orbits,n))

set T_matrices([K_Type] K_basis,[PhiLattice] lattices)=
for i:#lattices do 
 let kbasis=lattices[i].K_basis then
 T0=lattices[i].T then 
 T=change_basis(kbasis,K_basis,T0) in T od

set complex_orbit_T_matrix([K_Type] K_basis,[PhiLattice]  lattices,[RealNilpotentOrbit] orbits, [[int]] complex_orbits,int complex_orbit)=
let tm=T_matrices(K_basis,lattices) then
real_orbits=complex_orbits[complex_orbit] in
merge_matrices(for i in real_orbits do tm[i] od) 

set complex_orbit_T_matrices([K_Type] K_basis,[PhiLattice]  lattices,[RealNilpotentOrbit] orbits,[[int]] complex_orbits)=
for i:#complex_orbits do complex_orbit_T_matrix(K_basis,lattices,orbits,complex_orbits,i) od

{set Q_matrices_complex([K_Type] K_basis,[PhiLattice]  lattices,[RealNilpotentOrbit] orbits, [int] complex_orbits)=
let qm=Q_matrices(K_basis,lattices) in
for i in complex_orbits do
let orbit_indices=group_orbits(orbits,i) in
let ()=prints("oi:",orbit_indices) in
merge_matrices(for j in orbit_indices do qm[j] od) od}

set Y_projector([K_Type] K_basis,[PhiLattice]  lattices, int real_orbit)=
let (kb,,Y0,,)=lattices[real_orbit] then 
Y=change_basis(kb,K_basis,Y0) in
projector_mod_image(Y)

set Y_projector([K_Type] K_basis,[PhiLattice]  lattices, [[int]] complex_orbits,int complex_orbit)=
Y_projector(K_basis,lattices,complex_orbits[complex_orbit][0])

set Y_projectors([K_Type] K_basis,[PhiLattice]  lattices,[[int]] complex_orbits)=
for i:#complex_orbits do Y_projector(K_basis,lattices,complex_orbits,i) od






set complex_orbit_Q_matrix([K_Type] K_basis,[PhiLattice]  lattices,[RealNilpotentOrbit] orbits, [[int]] complex_orbits,int complex_orbit)=
let T=complex_orbit_T_matrix(K_basis,lattices,orbits,complex_orbits,complex_orbit) then 
real_orbit=complex_orbits[complex_orbit][0] then 
Y=lattices[real_orbit].Y then
Z=intersection(T,Y) in  saturation_quotient_basis(T,Z) 



set complex_orbit_Q_matrices([K_Type] K_basis,[PhiLattice]  lattices,[RealNilpotentOrbit] orbits, [[int]] complex_orbits)=
for i:#complex_orbits do complex_orbit_Q_matrix(K_basis,lattices,orbits,complex_orbits,i) od
 
set big_Q_matrix([K_Type] K_basis,[PhiLattice]  lattices,[RealNilpotentOrbit] orbits, [[int]] complex_orbits)=
merge_matrices(complex_orbit_Q_matrices(K_basis,lattices,orbits,complex_orbits))

set find([K_Type] K_basis,[PhiLattice] lattices,[mat] P_matrices,[RealNilpotentOrbit] orbits,[[int]] complex_orbits,vec v)=
let Q_matrices=complex_orbit_Q_matrices(K_basis,lattices,orbits,complex_orbits) in
for i:#Q_matrices do  solve(Q_matrices[i],P_matrices[i]*v) od

{set try([K_Type] K_basis,[PhiLattice] lattices,[mat] P_matrices,[RealNilpotentOrbit] orbits, [int] complex_orbits,vec v)=set try}




