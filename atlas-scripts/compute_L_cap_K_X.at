<knilpotent.at
<lattice_aux.at

set compute_verbose=false

{need to define *, this should be moved elsewhere}
set *(int c,K_Type mu)=K_Type_Pol:c*parameter(mu)

{find K_type mu in list of K_types, move this also}
set find([K_Type] list,K_Type mu)=int: first(#list,(int i)bool:list[i]=mu)


{sort K_Types uniquely, not used}
set sort_u([K_Type] K_types)=[K_Type]:
if #K_types=0 then [] else
let P=null_module(K_types[0].real_form) in 
for mu in K_types do P+:=parameter(mu) od; 
for p in monomials(P) do K_type(p) od fi

{[int] v is coefficients of [K_Type] K_types, return sum v[i]*K_types[i]}
set expand([int] v,[K_Type] K_types, RealForm G)=K_Type_Pol:
if #K_types=0 then null_module(G) else
let rv=null_module(parameter(K_types[0])) in 
for i:#v do rv+:=v[i]*K_types[i] od;rv fi

{given a matrix M, whose rows correspond to elements of K_basis,
and each column gives a sum of elements of K_basis,
only keep the columns whose K_norm is <=bound}
set truncate(mat M,[K_Type] K_basis, int bound)=mat:
let rv=null(#K_basis,0) in
for v in M do 
 if K_norm(expand(v,K_basis,K_basis[0].real_form))<=bound then rv#:=v fi od;rv


{list of K_Types coming from given orbit}
set K_basis(KNilpotentData data, int orbitNumber)=
for Q in
monomials(for (,P) in data.pairs[orbitNumber] do P od)
do K_type(Q) od

{list of K_Types coming from given orbits}
set K_basis(KNilpotentData data, [int] orbitNumbers)=
if #orbitNumbers=0 then [] else
for  Q in 
 monomials(##for i in orbitNumbers do for (,P) in data.pairs[i] do P od od) do K_type(Q) od
fi

{K-types from all orbits
this should be the same as K_parameter_norm_upto(G,n) where n 
 is the integer used in defining data
}
set K_basis(KNilpotentData data)=[K_Type]:
K_basis(data, #(#data.orbits))

{list of L\cap K-types from data for given orbit}
set L_cap_K_basis(KNilpotentData d,int orbit_number)=[K_Type]:
for (mu_L,) in d.pairs[orbit_number] do mu_L od

{list of L\cap K-types from data for given orbits}
set L_cap_K_basis(KNilpotentData d,[int] orbit_numbers)=[K_Type]:
##for i in orbit_numbers do L_cap_K_basis(d,i) od 

{matrix defining a map from L\cap K-types to K-types
rows <-> K-types: from orbit itself (NOT closure)
columns <-> L\cap K-types from orbit itself
each column gives Phi(L\cap K-type)
}
set Phi_matrix(KNilpotentData d,int orbit_number)=([K_Type],[K_Type],mat):
let 
L_cap_K_basis=L_cap_K_basis(d,orbit_number) then
{K_basis=K_basis_closure(d,orbit_number) then}
K_basis=K_basis(d,orbit_number) then
pairs=d.pairs[orbit_number] then
{()=prints("PAIRS:", #pairs) then}
rv=null(#K_basis,#L_cap_K_basis) in
if #pairs=0 then (K_basis,L_cap_K_basis, null(#L_cap_K_basis,#K_basis)) else
for (mu_L,Phi) in pairs do
   let (valid,col)=vector(K_basis,Phi) in
   assert(valid,"could not construct column of matrix");
   rv[find(L_cap_K_basis,mu_L)]:=col od ;(K_basis,L_cap_K_basis,rv) fi

{set of matrices, on for each orbit_number}
set Phi_matrices(KNilpotentData d,[int] orbit_numbers)=[([K_Type],[K_Type],mat)]:
for orbit_number in orbit_numbers do Phi_matrix(d,orbit_number) od

{set of matrices, running over all orbits}
set Phi_matrices(KNilpotentData d)=[([K_Type],[K_Type],mat)]:
Phi_matrices(d,#(#d.orbits))

{basis of K_Types coming from triples, from given orbits}
set K_basis([([K_Type],[K_Type],mat)] triples,[int] orbit_numbers)=[K_Type]:
if #orbit_numbers=0 then [] else
sort_u(##for i in orbit_numbers do let (P,,)=triples[i] in  P od) fi

{L\cap K basis coming from triples, from given orbits}
set L_cap_K_basis([([K_Type],[K_Type],mat)] triples,[int] orbit_numbers)=[K_Type]:
if #orbit_numbers=0 then [] else
##for i in orbit_numbers do let (,P,)=triples[i] in  P od fi

{each orbit gives a matrix, with different bases
 combine these into 1 matrix, using a common K_basis
}
set combine_Phi_matrices([([K_Type],[K_Type],mat)] triples,[int] orbit_numbers,RealForm G)=mat:
let
K_basis=K_basis(triples,orbit_numbers) then
L_cap_K_basis=L_cap_K_basis(triples,orbit_numbers) in
if #orbit_numbers=0 then null(#K_basis,0) else
##for i in orbit_numbers do {prints("i=",i);}
let (K_basis_orbit,,T)=triples[i] in 
 for col in T do 
{let ()= prints("col=",col) in}
{let ()=prints("expand:",expand(col,K_basis,G)) in}
let (valid,v)=vector(K_basis,expand(col,K_basis_orbit,G)) in 
{ prints("v=",v);}
 assert(valid,"can't find vector");v od od fi

{same as previous, except only keep terms whose K_norm is <= smaller_bound}
set combine_Phi_matrices([([K_Type],[K_Type],mat)] triples,[int] orbit_numbers,RealForm G,int smaller_bound)=mat:
let
K_basis=K_basis(triples,orbit_numbers) then
L_cap_K_basis=L_cap_K_basis(triples,orbit_numbers) in
if #orbit_numbers=0 then null(#K_basis,0) else
let rv=
##for i in orbit_numbers do {prints("i=",i);}
let (K_basis_orbit,,T0)=triples[i] then
 T=truncate(T0,K_basis_orbit,smaller_bound)  in
 for col in T do 
{let ()= prints("col=",col) in}
{let ()=prints("expand:",expand(col,K_basis,G)) in}
let (valid,v)=vector(K_basis,expand(col,K_basis_orbit,G)) in 
{ prints("v=",v);}
 assert(valid,"can't find vector");v od od  in 
{let ()=prints("rv=",rv) in}
if #rv=0 then null(#K_basis,0) else rv fi fi

{matrix of map obtained by running over all orbits, with smaller_bound cutoff}
set image([([K_Type],[K_Type],mat)] triples,RealForm G,int smaller_bound)=mat:
combine_Phi_matrices(triples,#(#triples),G,smaller_bound)


{given matrix whose rows correspond to K_basis, change basis 
 to one with rows given by K_basis_new (should be a superset of K_basis)
}
set change_basis([K_Type] K_basis, [K_Type] K_basis_new,mat M)=mat:
if n_columns(M)=0 then null(#K_basis_new,0) else
for col in M do let (valid,v)=vector(K_basis_new, expand(col,K_basis,K_basis[0].real_form)) in 
assert(valid,"change_basis failed");v od fi

{assume Phi_matrices(d) has been computed
this is of type [([K_Type],[K_Type],mat)] which is the second argument  
}
set compute_L_cap_K_X(KNilpotentData d, [([K_Type],[K_Type],mat)] triples,int orbit_number)=
if compute_verbose then prints("compute_L_cap_K_X of orbit ", orbit_number) fi;
let (,,T0)=triples[orbit_number] {matrix of T, K_basis from orbit} then
Y0=combine_Phi_matrices(triples,d.closures[orbit_number],d.real_form) {matrix of Y, K_basis from boundary only} then
K_basis=K_basis(triples,d.closures[orbit_number]#orbit_number) {the basis I want to use} then
T=change_basis(K_basis(triples,[orbit_number]),K_basis,T0) then
Y=change_basis(K_basis(triples,d.closures[orbit_number]),K_basis,Y0) then
TV_cap_Y=intersection(T,Y) in 
{free_quotient_lattice_basis(T,TV_cap_Y)}
(T,Y,TV_cap_Y,saturation_quotient_basis(T,TV_cap_Y))

{run over all orbits and compute the previous}
set compute_L_cap_K_X(KNilpotentData d, [([K_Type],[K_Type],mat)] triples)=
for i:#d.orbits do compute_L_cap_K_X(d,triples,i) od

{same as previous but with smaller_bound cutoff}
set compute_L_cap_K_X(KNilpotentData d, [([K_Type],[K_Type],mat)] triples,int orbit_number, int smaller_bound)=
if compute_verbose then prints("compute_L_cap_K_X of orbit ", orbit_number) fi;
let (,,T0)=triples[orbit_number] {matrix of T, K_basis from orbit} then
Y0=combine_Phi_matrices(triples,d.closures[orbit_number],d.real_form) {matrix of Y, K_basis from boundary only} then
K_basis=K_basis(triples,d.closures[orbit_number]#orbit_number) {the basis I want to use} then
T=change_basis(K_basis(triples,[orbit_number]),K_basis,T0) then
T1=truncate(T,K_basis,smaller_bound) then
Y=change_basis(K_basis(triples,d.closures[orbit_number]),K_basis,Y0) then
T1_V_cap_Y=intersection(T1,Y) in 
{free_quotient_lattice_basis(T,TV_cap_Y)}
(T1,Y,T1_V_cap_Y,saturation_quotient_basis(T1,T1_V_cap_Y))

{same as previous but with smaller_bound cutoff}
set compute_L_cap_K_X(KNilpotentData d, [([K_Type],[K_Type],mat)] triples, int smaller_bound)=
for i:#d.orbits do compute_L_cap_K_X(d,triples,i,smaller_bound) od

{sum of dimension of the T(V/X) spaces
 goal: choose smaller_bound small enough so that 
 the sum of these dimensions is 
 dimension of image(triples,G,smaller_bound)
}
set sum_of_dimensions(KNilpotentData d, [([K_Type],[K_Type],mat)] triples, int smaller_bound)=
sum(for (,,,Q) in compute_L_cap_K_X(d,triples,smaller_bound) do rank(Q) od)
