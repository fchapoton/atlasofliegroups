<K_types.at  {K_signature_irr}

{some functions related to Frobenius-Schur indicator, 
real/quaternionic indicator, and sign of Hermitian form 
on finite dimensional representation}

set is_self_dual(Param p)=bool:
let lambda=highest_weight_finite_dimensional(fd_only(p)) in
-act(w_long(root_datum(p)),lambda)=lambda

set Frobenius_Schur(Param p)=int:
if is_self_dual(fd_only(p)) then 
let lambda=highest_weight_finite_dimensional(p) in 
(-1)^(rat_as_int(2*lambda*rho_check(real_form(p)))) else 0 fi

set fs(Param p)=int:Frobenius_Schur(fd_only(p))

set is_self_conjugate(Param p)=bool:
let lambda=highest_weight_finite_dimensional(fd_only(p)) in
let G=real_form(p) in 
-distinguished_involution(G)*act(w_long(G),lambda)=lambda

set real_quaternionic(Param p)=int:
if is_self_conjugate(fd_only(p)) then 
let lambda=highest_weight_finite_dimensional(p) then
x_squared=square(x(p)) in (-1)^(rat_as_int(2*x_squared*lambda*fs(p))) else 0 fi

set rq(Param p)=int:real_quaternionic(fd_only(p))

set signature(Param p)=(int,int):
let G=real_form(fd_only(p)) then
height=rat_as_int(2*infinitesimal_character(p)*rho_check(G))  then
(pos,neg)=K_signature_irr(p,height) in
(  sum(for c@p in pos do split_as_int(c*dimension(K_type(p))) od),
sum(for c@p in neg do split_as_int(c*dimension(K_type(p))) od))

set signature_str(Param p)=string:
if not is_hermitian(fd_only(p)) then "*" else 
let (pos,neg)=signature(p)  in 
"(" + int_format(pos) + "," + int_format(neg) + ")"  fi

set fd_report(RealForm G, int k)=void:
let weights=box(k+1, ss_rank(G)) then  {all [a_1,...,a_rank] with 0\le a_i\le k} 
M=ratvecs_as_ratmat(fundamental_weights(G)) in
for mu in weights do 
 let lambda=M*mu in 
  if is_integer(lambda) then 
  let p=finite_dimensional(G,ratvec_as_vec(lambda))
in prints("fund wt: ", mu, "  lambda:", lambda, " dim:", dimension(p), "  self-dual/self-conj.:", is_self_dual(p), "/", is_self_conjugate(p), "    FS/RQ: ", fs(p), "/", rq(p), "  signature: ", signature_str(p)) fi od

