<polynomial.at
<rational_polynomial.at
<sort.at
<ratmat.at

set Cartesian ([int] a, [int] b) = [int]:
    ## for x in a do for y in b do x*y od od

{. divisors of an integer .}
set divisors (int n) = [int]:
   if =n then return [] fi;
   ((2,abs(n)).
    (rec_fun d(int b, int n) [int]:
      if b*b>n then if n=1 then [1] else [1,n] fi
      else let (q,r)=n\%b in
         if !=r then d(b+1,n)
         else let l=[1,b] in
            while =q%b do q\:=b; l:= 1 # (l*b) od
         ;  Cartesian(l,d(b+1,q))
         fi
      fi
    ).sort)

{. Euler totient function .}
set phi (int n) = int:
(  assert(n>0);
   let p=1, b=2 in
   while not (b*b>n)
   do let (q,r)=n\%b in
      if !=r then b+:=1 { |b| is not a divisor, raise it }
      else p*:=b-1
      ;  while =q%b do q\:=b; p*:=b od { move factors |b| from |q| to |p| }
      ;  n:=q
      fi
   od; if n=1 then p else p*(n-1) fi
)

{. n^th Cyclotomic Polynomial .}
set cyclotomic_polynomial (int n) = poly:
   let Phis=[poly]:[], divs=divisors(n)
   then locate (int d) = binary_search_first((int i)bool: divs[i]>=d,0,#divs)
   in
   for d in divs
   do let P=poly: (-1) # null(d-1) # 1 in { X^d - 1 }
      for dd in divisors(d)[:1~] do set(P,):=monic_divide(P,Phis[locate(dd)]) od
   ;  Phis#:=P
   od; Phis~[0]

{.list of integers relatively prime to n.}
set relative_primes(int n) = [int]:
  list ((int i)bool: gcd([i,n])=1 ,n)

{ a can be negative, N must be positive }
{. integer a -> representative 0\le b\le N-1 mod N .}
set mod (int a, int N) = int: assert(N>0,"N<=0"); a%N


{ to_denominator(r,N): integer $a$ such that rational $r$ is congruent to
  $a/N$ modulo 1
  The application is that $\exp(2\pi i r)=\zeta^a$ where $\zeta=\exp(2\pi i/n)$
}
set to_denominator (rat r, int N) = int:
   let (numer,denom)=%(r%1) { reduce modulo 1, then split }
   then (q,r)=N\%denom
   in assert(r=0,"root of unity is not in the specified cyclotomic field");
   q*numer

{ cyclotomic Fields and their elements }

{ represent cyclotomic field by order and minpoly of generating root of 1 }
: cyclotomicField = (int order, poly Phi)

{.construct a cyclotomic field.}
set cyclotomic_field (int n) = cyclotomicField: (n, cyclotomic_polynomial(n))
set CF = cyclotomic_field@int  {abbreviation}

set degree (cyclotomicField F) = int: #F.Phi-1

set = (cyclotomicField E,cyclotomicField F) = bool: F.order=E.order

{. element in a cyclotomic field.}
: cyclotomicFieldElement = (ratvec v,cyclotomicField F)

{.reduce rational polynomial modulo Phi(n).}
set reduce (cyclotomicFieldElement (v,F)) = cyclotomicFieldElement:
   let (,r)=monic_divide(v,F.Phi) in (r,F)

set = (cyclotomicFieldElement(v,F),cyclotomicFieldElement(w,G)) = bool:
   assert(F=G,"cyclotomic fieds differ in comparison");
   let (,r)= monic_divide(ratpoly_sub(v,w),F.Phi) in =r

set cyclotomic_field_element = reduce@(ratvec,cyclotomicField)

{.embed Q in cyclotomic field as (images of) constant polynomials.}
set embed_Q (rat r,cyclotomicField F) = cyclotomicFieldElement:
   cyclotomic_field_element([r],F) { embed $\Q$ }

set one (cyclotomicField F) = cyclotomicFieldElement:  embed_Q(1,F)
set zero (cyclotomicField F) = cyclotomicFieldElement: embed_Q(0,F)

set primitive_root (cyclotomicField F) = cyclotomic_field_element([0,1],F)


{operations on elements of cyclotomic fields}

set + (cyclotomicFieldElement (v,F),cyclotomicFieldElement (w,G)) =
      cyclotomicFieldElement:
   assert(F=G,"cyclotomic fields do not agree"); (ratpoly_plus(v,w),F)
set - (cyclotomicFieldElement (v,F),cyclotomicFieldElement (w,G)) =
      cyclotomicFieldElement:
   assert(F=G,"cyclotomic fields do not agree"); (ratpoly_sub(v,w),F)

set * (cyclotomicFieldElement (v,F),cyclotomicFieldElement (w,G)) =
      cyclotomicFieldElement:
   assert(F=G,"cyclotomic fields do not agree"); reduce(ratpoly_product(v,w),F)

{ positive power (should use repeated squaring; code below will do for now) }
set ^ (cyclotomicFieldElement (v,F),int k) = cyclotomicFieldElement:
   assert(k>=0,"Negative power in cyclotomic field not implemented");
(  if =k then [1]
   else let p=v in
      while >(k-:=1) do set(p,):=reduce(ratpoly_product(p,v),F) od; p
   fi
,  F
)

{ simplified operations }
set - (cyclotomicFieldElement (v,F)) = cyclotomicFieldElement: (-v,F)
set * (rat r, cyclotomicFieldElement (v,F)) = cyclotomicFieldElement: (r*v,F)

{order of element of F, returns -1 if element not of finite order}
set order(cyclotomicFieldElement x)= int:
   let one=x.F.one in
   if x=one then 0
   else 1+first(x.F.order*2,(int i)bool: x^(i+1)=one) { i+1: start search at 1 }
   fi

set is_rational (cyclotomicFieldElement z) = bool: #reduce(z).v<=1
set to_rational (cyclotomicFieldElement z) = rat:
   z:=reduce(z); assert(#z.v<=1,"element is not rational");
   if =#z.v then 0 else z.v[0] fi

set is_integer(cyclotomicFieldElement z) = bool:
   z.is_rational and z.to_rational.is_integer
set to_integer(cyclotomicFieldElement z)=int:
   let q=to_rational(z) in
   assert(q.is_integer,"element is not an integer"); q.rat_as_int

{ embed roots of unity in F }
set exp_1 (rat r,cyclotomicField F) = cyclotomicFieldElement:
   let k=to_denominator(r,F.order) in
   cyclotomic_field_element(null(k)#1,F)

set zeta_power (int k, cyclotomicField F) = cyclotomicFieldElement:
   { first reduce modulo $X^n-1$, then modulo $\Phi(n)$ }
   reduce(null(k%F.order)#1,F)

set * (ratmat M,cyclotomicFieldElement (v,F)) = cyclotomicFieldElement:
   ( M*v , F )

set galois_matrix (int k,cyclotomicField F) = ratmat:
  let d=degree(F) in ratvecs_as_ratmat(for i:d do zeta_power(k*i,F).v od)

set galois_matrices(cyclotomicField F) = [ratmat]:
   for i in relative_primes(F.order) do galois_matrix(i,F) od

set matrix_of_multiplication (cyclotomicFieldElement z) = ratmat:
   for i:degree(z.F) do (z*zeta_power(i,z.F)).v od.ratvecs_as_ratmat

set norm (cyclotomicFieldElement z) = rat: det(matrix_of_multiplication(z))

{two ways of computing inverse of element of cyclotomic field
 it appears the matrix method is better, but we're leaving in both
 options for now}

{.inverse of z=products of nontrivial galois conjugates/norm.}
set inverse_by_norm (cyclotomicFieldElement (,F):z) = cyclotomicFieldElement:
   let w=F.one in z:=reduce(z);
   for A in galois_matrices(F)[1:] do w*:=A*z  od; (/norm(z))*w

{.inverse of z = inverse of (matrix of multipliciation by z) applied to F.one.}
set inverse_by_matrix (cyclotomicFieldElement (,F):z) = cyclotomicFieldElement:
inverse(matrix_of_multiplication(z))*F.one

{use inverse_by_matrix}
{.inverse of element in cyclotomic field.}
set inverse (cyclotomicFieldElement (,F):z) = cyclotomicFieldElement:inverse_by_matrix(z)

{.convert cyclotomic field element to a string for output.}
set to_string (cyclotomicFieldElement z) = string:
  if is_integer(z.v) then stringPoly(ratvec_as_vec(z.v),"x")+" in F("+ (z.F).order+ ")" else
  stringPoly(z.v,"x")+" in F("+ (z.F).order+ ")" fi

{.display cyclotomic field element as polynomial in x.}
set show (cyclotomicFieldElement z) = void: prints(to_string(z))
