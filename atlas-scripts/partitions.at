<basic.at
<combinatorics.at

set_type Partition = [int]   { list of decreasing parts, no trailing zeros }

set fac (int n) = int: let p=1 in for i:n-1 from 2 do p *:=i od; p

set size (Partition P) =int: sum(vec: P)

set hook_length (Partition P, int i, int j) =int:
  let arm = P[i]-j, leg = transpose(P)[j]-i in arm + leg -1

set dim_rep (Partition P) = int: { don't try this for large parititions }
  let dim=fac(size(P)) in
  for i:#P do for j:P[i] do dim \:= hook_length(P,i,j) od od; dim

{ all weak compositions of numbers <=limit into n parts }
set rec_fun compositions_le (int limit, int n) = [[int]]:
  if =n then [[]] { one empty composition (0 parts) }
  else let result = [[int]]: [] in
    for last:limit+1
    do
      for rest in compositions_le(limit-last,n-1) do result #:= rest#last od
    od; result
  fi


set partitions = let p1 = [Partition]: [[1]] in (int n) [Partition]:
  if n<2
  then if n.< then [] elif n.= then [[]] else p1 fi
  else let parts=p1 { working copy, partitions of |k<=n|, now |k=1| } in
    for :n-1
    do parts := ## { concatenate 2 or 1 contributions from each next loop body }
      for p in parts
      do let last=p~[0] in
         if #p=1 or p~[1]>last { then we can increase the final part |last| }
         then [p#1,let pp=p in pp~[0]:=last+1; pp]
         else [p#1]
         fi
      od
    od; parts
  fi
