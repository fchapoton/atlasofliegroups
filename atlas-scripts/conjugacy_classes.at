<W_orbit.at { for generate_W@RootDatum }
<elliptic_aux.at
<Levi_class.at
<make_levi.at

set_type ConjugacyClass = (ComplexLevi Levi, WeylElt w)
{ComplexLevi:(rd,rd_L)
 w is a WeylElt for rd_L
 the labelling of the roots of rd_L is unrelated to those of rd,
 the roots of rd_L are labelled 0..,ss_rank(L)-1
}

set complex_Levi_root_numbers(ComplexLevi L)=[int]:
let (rd,rd_L)=L in 
for i:ss_rank(rd_L) do 
 let j=find(simple_roots(rd), simple_roots(rd_L)[i]) in 
 let k=find(simple_coroots(rd), simple_coroots(rd_L)[i]) in 
 assert(j=k and j!=-1,"roots/coroots of L are not a proper subset of those for G");j od
 

set root_datum(ConjugacyClass C)=RootDatum: C.Levi.rd
set root_datum_Levi(ConjugacyClass C)=RootDatum: C.Levi.rd_Levi
{C.Levi: complexLevi (rd,rd_L)
 C.root_datum: root datum of G
 C.root_datum_Levi: root datum of L
 C.w: WeylElt for L
}

{promote w\in W_L to w_G}
set W_elt(ConjugacyClass C)=WeylElt:
let rd=C.root_datum then
rd_L=C.root_datum_Levi then
numbers=complex_Levi_root_numbers(C.Levi) in
id_W(rd)##replace(numbers,C.w.word)

set conjugacy_classes_by_Levi(RootDatum rd)=[(ComplexLevi,WeylElt)]:
let levis=Levi_classes(rd) in 
{##([((rd,rd),id_W(rd))]#}
##for L in levis do 
 for w in elliptic(L.rd_Levi) do (L,w) od od


set conjugacy_classes(RootDatum rd)=[WeylElt]:
let levis=Levi_classes(rd) in 
##for L in levis do 
 for w in elliptic(L.rd_Levi) do W_elt(L,w) od od

set is_elliptic_conjugate(WeylElt x,WeylElt y)=bool:
assert(x.root_datum=y.root_datum,"Weyl elements are for different root data");
assert(is_elliptic(x) and is_elliptic(y),"Weyl element is not elliptic");
char_poly(matrix(x))=char_poly(matrix(y))

set is_conjugate(WeylElt x,WeylElt y)=bool:
assert(x.root_datum=y.root_datum,"Weyl elements are for different root data");
let ((,L),(,M))=(Levi_of_w(x),Levi_of_w(y)) in 
if is_conjugate(x.root_datum, L,M) then 
char_poly(matrix(x))=char_poly(matrix(y)) else false fi

set conjugacy_class(WeylElt x, [ConjugacyClass] classes)=WeylElt:W_elt(classes[first(for C in classes do is_conjugate(x,C.W_elt) od)])
set conjugacy_class(WeylElt x, [WeylElt] classes)=WeylElt:classes[first(for w in classes do is_conjugate(x,w) od)]

set conjugacy_class_by_Levi(WeylElt x, [ConjugacyClass] classes)=classes[first(for C in classes do is_conjugate(x,C.W_elt) od)]

set conjugacy_class(WeylElt w)=conjugacy_class(w,conjugacy_classes(w.root_datum))

set conjugacy_class_by_Levi(WeylElt w)=conjugacy_class_by_Levi(w,conjugacy_classes_by_Levi(w.root_datum))