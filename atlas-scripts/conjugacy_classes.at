<W_orbit.at { for generate_W@RootDatum }
<elliptic.at
<parabolics.at { for |ComplexLevi| type }
<Levi_class.at
<subalgebra.at
<tabulate.at

set_type ConjugacyClass = (ComplexLevi Levi, WeylElt w)
{ComplexLevi:(rd,rd_L)
 w is a WeylElt for rd_L
 the labelling of the roots of rd_L is unrelated to those of rd,
 the roots of rd_L are labelled 0..,semisimple_rank(L)-1
}

set complex_Levi_root_numbers (ComplexLevi L) = [int]:
  let (rd,rd_L)=L in
  for i:semisimple_rank(rd_L)
  do let j=find(simple_roots(rd),simple_roots(rd_L)[i])
     in assert(j.>= and j=find(simple_coroots(rd), simple_coroots(rd_L)[i])
              ,"roots/coroots of L are not a proper subset of those for G")
  ;  j
  od


set root_datum (ConjugacyClass C) = RootDatum: C.Levi.rd
set root_datum_Levi (ConjugacyClass C) = RootDatum: C.Levi.rd_Levi
{C.Levi: complexLevi (rd,rd_L)
 C.root_datum: root datum of G
 C.root_datum_Levi: root datum of L
 C.w: WeylElt for L
}

{promote w\in W_L to w_G}
set W_elt (ConjugacyClass C) = WeylElt:
  let rd=C.root_datum , rd_L=C.root_datum_Levi
  , numbers=complex_Levi_root_numbers(C.Levi)
  in W_elt(rd,replace(numbers,C.w.word))

set conjugacy_classes_by_Levi (RootDatum rd) = [(ComplexLevi,WeylElt)]:
##for L in Levi_classes(rd) do for w in elliptic(L.rd_Levi) do (L,w) od od


set conjugacy_classes (RootDatum rd) = [WeylElt]:
##for L in Levi_classes(rd) do for w in elliptic(L.rd_Levi) do W_elt(L,w) od od

set is_elliptic_conjugate (WeylElt x,WeylElt y) = bool:
  assert(x.root_datum=y.root_datum,"Weyl elements are for different root data");
  assert(is_elliptic(x) and is_elliptic(y),"Weyl element is not elliptic");
  char_poly(matrix(x))=char_poly(matrix(y))

set is_conjugate(WeylElt x,WeylElt y) = bool:
  assert(x.root_datum=y.root_datum,"Weyl elements are for different root data");
  let ((,L),(,M))=(Levi_of_w(x),Levi_of_w(y)) in
  is_conjugate(x.root_datum, L,M) and char_poly(matrix(x))=char_poly(matrix(y))

set conjugacy_class (WeylElt x, [ConjugacyClass] classes) = WeylElt:
  W_elt(classes[first(for C in classes do is_conjugate(x,C.W_elt) od)])
set conjugacy_class (WeylElt x, [WeylElt] classes) = WeylElt:
  classes[first(for w in classes do is_conjugate(x,w) od)]

set conjugacy_class_by_Levi (WeylElt x, [ConjugacyClass] classes) =
    ConjugacyClass:
  classes[first(for C in classes do is_conjugate(x,C.W_elt) od)]

set conjugacy_class (WeylElt w) =
  conjugacy_class(w,conjugacy_classes(w.root_datum))

set conjugacy_class_by_Levi (WeylElt w) =
  conjugacy_class_by_Levi(w,conjugacy_classes_by_Levi(w.root_datum))

set test_conjugacy_class([WeylElt] C, int j)=
for i:#C do if is_conjugate(C[i],C[j]) then prints(i, " ", C[i]) fi od

set test_conjugacy_classes([WeylElt] C)=
let test=for i:#C do
    let sum=sum(for j:#C do if is_conjugate(C[i],C[j]) then 1 else 0 fi od) in 
    if sum !=1 then prints("i ", i, " ", sum) fi;
sum od in test=for i:#test do 1 od

set chop_string(int n,string s)=string:
let S=for i:#s do s[i] od in ##S[n:]

set print_conjugacy_classes([WeylElt] C)=void:
let data=["order","length","Levi"]#for w in C do let (,L)=Levi_of_w(w)  in [int_format(order(w)), int_format(length(w)),chop_string(9,to_string(Lie_type(L)))] od
in tabulate(data,"right",2," ")

set print_conjugacy_classes(RootDatum rd)=void:print_conjugacy_classes(conjugacy_classes(rd))
