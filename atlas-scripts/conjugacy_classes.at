<W_orbit.at { for generate_W@RootDatum }
<elliptic_aux.at
<parabolics.at { for |ComplexLevi| type }
<Levi_class.at

set_type ConjugacyClass = (ComplexLevi Levi, WeylElt w)
{ComplexLevi:(rd,rd_L)
 w is a WeylElt for rd_L
 the labelling of the roots of rd_L is unrelated to those of rd,
 the roots of rd_L are labelled 0..,semisimple_rank(L)-1
}

set complex_Levi_root_numbers (ComplexLevi L) = [int]:
  let (rd,rd_L)=L in
  for i:semisimple_rank(rd_L)
  do let j=find(simple_roots(rd),simple_roots(rd_L)[i])
     in assert(j.>= and j=find(simple_coroots(rd), simple_coroots(rd_L)[i])
              ,"roots/coroots of L are not a proper subset of those for G")
  ;  j
  od


set root_datum (ConjugacyClass C) = RootDatum: C.Levi.rd
set root_datum_Levi (ConjugacyClass C) = RootDatum: C.Levi.rd_Levi
{C.Levi: complexLevi (rd,rd_L)
 C.root_datum: root datum of G
 C.root_datum_Levi: root datum of L
 C.w: WeylElt for L
}

{promote w\in W_L to w_G}
set W_elt (ConjugacyClass C) = WeylElt:
  let rd=C.root_datum , rd_L=C.root_datum_Levi
  , numbers=complex_Levi_root_numbers(C.Levi)
  in W_elt(rd,replace(numbers,C.w.word))

set conjugacy_classes_by_Levi (RootDatum rd) = [(ComplexLevi,WeylElt)]:
##for L in Levi_classes(rd) do for w in elliptic(L.rd_Levi) do (L,w) od od


set conjugacy_classes (RootDatum rd) = [WeylElt]:
##for L in Levi_classes(rd) do for w in elliptic(L.rd_Levi) do W_elt(L,w) od od

{C.Levi: ComplexLevi
 C.Levi.root_datum=C.root_datum: root datum of ambient group G
 C.Levi.complex_Levi: root datum of Levi L
 C.w_Levi: WeylElt for Levi L
 C.W_elt_Levi: WeylElt for G
}


{
 set G=Sp(10,R)
 set rd=root_datum(G)
 set L=complex_Levi(rd,[0,1,2,5])
 set w_L=W_elt(L.rd_Levi,[0,1,2])
 set C=ConjugacyClass:(L,w_L)
}

{set W_elt(ConjugacyClass C)=WeylElt:
 id_W(C.Levi.root_datum)##C.w_Levi.word
}

{ comment out remainder of file

{ compute conjugacy class of w, inspired by cross_W_orbit.at

  conjugacy_class_extra returns (words, class), where class is the conjugacy
  class as list of elements, and for each i one has
  words[i]*x*words[i]^{-1}=class[i]
}
set conjugacy_class_extra (WeylElt x) = ([WeylElt]{transport},[WeylElt]{orbit}):
  let rd=x.root_datum then gens=rd.W_gens
  then orbit= [x], ws = [id_W(rd)], done=0
  then absent (WeylElt w) = bool: none(#orbit,(int i)bool:orbit[i]=w)
  in
  while done<#orbit
  do
    let w = ws[done], a=orbit[done] in done+:=1
  ; for s in gens
    do let b= s*a*s in
      if absent(b) then ws #:= s*w; orbit #:= b fi
    od
  od; (ws,orbit)

set conjugacy_class (WeylElt w) = [WeylElt]:
  let (,orbit)=conjugacy_class_extra(w) in orbit


set conjugacy_classes (RootDatum rd) = [[WeylElt]]:
  let W = generate_W(rd), result =[[WeylElt]]:[] in
  for w in W
  do if none(#result,(int i)bool: let ri=result[i] in any(#ri,(int j):ri[j]=w))
     then result #:= conjugacy_class(w)
     ; prints("C:", w, " ", #result~[0])
     fi
  od; result

set shortest_length(WeylElt w)=min(for y in conjugacy_class(w) do length(y) od)
}
