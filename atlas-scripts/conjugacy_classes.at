<W_orbit.at { for generate_W@RootDatum }

{ compute conjugacy class of w, inspired by cross_W_orbit.at

  conjugacy_class_extra returns (words, class), where class is the conjugacy
  class as list of elements, and for each i one has
  words[i]*x*words[i]^{-1}=class[i]
}
set conjugacy_class_extra (WeylElt x) = ([WeylElt]{transport},[WeylElt]{orbit}):
  let rd=x.root_datum then gens=rd.W_gens
  then orbit= [x], ws = [id_W(rd)], done=0
  then absent (WeylElt w) = bool: none(#orbit,(int i)bool:orbit[i]=w)
  in
  while done<#orbit
  do
    let w = ws[done], a=orbit[done] in done+:=1
  ; for s in gens
    do let b= s*a*s in
      if absent(b) then ws #:= s*w; orbit #:= b fi
    od
  od; (ws,orbit)

set conjugacy_class (WeylElt w) = [WeylElt]:
  let (,orbit)=conjugacy_class_extra(w) in orbit


set conjugacy_classes (RootDatum rd) = [[WeylElt]]:
  let W = generate_W(rd), result =[[WeylElt]]:[] in
  for w in W
  do if none(#result,(int i)bool: let ri=result[i] in any(#ri,(int j):ri[j]=w))
     then result #:= conjugacy_class(w)
     ; prints("C:", w, " ", #result~[0])
     fi
  od; result









