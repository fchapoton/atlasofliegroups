<basic.at
<combinatorics.at
<tabulate.at
<W_characters.at
<simple_factors.at

{define sum and product of [int] corresponding to direct
sum and tensor product of characters}
set sum([int] v,[int] w)=
assert(#v=#w,"not same size");for i:#v do v[i]+w[i] od

set product([int] v,[int] w)=
assert(#v=#w,"not same size");for i:#v do v[i]*w[i] od
set tensor=product@([int],[int])

set tensor_power([int] v,int power)=[int]: for x in v do x^power od

set Cartesian_power([int] x,int n)=[int]:  for v in x do n*v od

{ Character table structure for Weyl groups (integer valued characters) }

{ The structure below was inspired by the way GAP represents character tables }

set_type
[ CharacterTable =
  (LieType lie_type
  , int order { of the finite group }
  {conjugacy classes}
  , int n_classes  { number of conjugacy classes}
  , (int ->[(Partition,vec)]) partitions_and_signs  {simple classical groups only}
  , (int->string) class_label {derived from partitions_and_signs in classical case}
  , (int ->WeylElt) class_rep     {gives element of W representating class_label(i)}
  , (int->int) class_order
  , (int,int->int) class_power   {(i,j) -> class_of(i^th class to the j^power)}
  , [int] centralizer_orders
  , [int] class_sizes
  {irreducible characters}
  , (int->string) irreducible_label
  , mat table { by row=character }
  )
]

{summary:
CharacterTable=(
lie_type,              LieType
order,                 int
n_classes,             int
partitions_and_signs,  {int->[(Partition,vec)]}
class_label,           {int->string}
class_rep,             {int->WeylElt}
class_order,           {int->int}  
class_power,	       {(int,int)->int}
cenetralizer_orders,   {[int]}
class_sizes,           {[int]}
irreducible_label,     {int->string}
table)
}

set root_datum (CharacterTable ct) = RootDatum:ct.class_rep(0).root_datum { at least one class exists }
set rank(CharacterTable t)=t.lie_type.rank
set dimension (CharacterTable t) = (int i) int: t.table[i,0]
set class_reps(CharacterTable ct)=[WeylElt]: for i:ct.n_classes do ct.class_rep(i) od
set class_index(CharacterTable ct)=(WeylElt -> int): (WeylElt w):
 first(ct.n_classes,(int i): is_conjugate(ct.class_reps[i],w))
set centralizer_order(CharacterTable ct)=(int->int):(int i): ct.centralizer_orders[i]
set class_size(CharacterTable ct)=(int->int):(int i): ct.class_sizes[i]
set character(CharacterTable t)=(int->[int]):(int i):(^t.table)[i]
set characters(CharacterTable ct)=[[int]]: ^ct.table
set inner(CharacterTable ct)=(([int],[int])->int): ([int] x,[int] y):
  assert(#x=ct.n_classes and #y=ct.n_classes,"Wrong sizes");
  let sizes=for i:ct.n_classes do ct.class_size(i) od then
  nW=ct.order then
    s = for size@i in sizes do size*x[i]*y[i] od.sum then (q,r)=s \% nW in
    if =r then q else error("Non integer inner product ",s/nW) fi
set norm2(CharacterTable ct)=([int]->int): ([int] x):ct.inner(x,x)
set sum(CharacterTable ct)=(([int],[int])->[int]): ([int] x,[int] y):
   for xi@i in x do xi+y[i] od
set product(CharacterTable ct)=(([int],[int])->[int]):([int] x,[int] y):
   for xi@i in x do xi*y[i] od
set power_map(CharacterTable ct)=(int -> [int]):
(int j): let w=ct.class_rep(j) in for i:w.order do ct.class_index(w^i) od

set trivial(CharacterTable ct)=[int]: for :ct.n_classes do 1 od
set sign(CharacterTable ct)=[int]: for w in ct.class_reps do minus_1^w.length od  {sgn}
set reflection(CharacterTable ct)=[int]:for w in ct.class_reps do w.matrix.trace od    {reflection}

{tensor product of two rows of character table}
set tensor(CharacterTable t)=(int,int->[int]):(int i,int j):
product(t.character(i),t.character(j))
set tensor_power(CharacterTable t)=(int,int->[int]):(int i,int power):
for x in t.character(i) do x^power od

set Cartesian_power(CharacterTable ct)=([int],int->[int]):([int] x,int n): assert(#x=ct.n_classes,"Wrong size"); for v in x do n*v od

set scalar_product (CharacterTable ct) = (int i0, int i1) rat:
   let tab=ct.table in
   for j: ct.n_classes do tab[i0,j]*tab[i1,j]*ct.class_size(j) od.sum/ct.order

{different name for use with [int],[int] arguments}
set inner_product(CharacterTable ct)=(([int],[int])->int):([int] v,[int] w):
rat_as_int(sum(for i:ct.n_classes do v[i]*w[i]*ct.class_size(i) od)/ct.order)

set check_orthogonality (CharacterTable ct) = bool:
   let n=ct.n_classes, dot=ct.scalar_product in
   for i:n do for j:n do dot(i,j) = #(i=j) od.all od.all

set show_classes(CharacterTable ct)=void:
tabulate(
 ["class","order","|cent|","class_size"]# for i:#ct.table do
[ct.class_label(i),ct.class_order(i).to_string, ct.centralizer_order(i).to_string,ct.class_size(i).to_string] od)

set show_reps(CharacterTable ct)=void:
tabulate(
["rep name","dimension","character"]#
for i:ct.n_classes do
[ct.irreducible_label(i),ct.dimension(i).to_string,ct.character(i).to_string] od)

set decompose(CharacterTable ct)=(vec->vec):(vec v):
for i:#ct.table do ct.inner_product(v,ct.character(i)) od

{set W_class_table(CharacterTable ct)=WeylClassTable:W_class_table(simply_connected(ct.lie_type))}

{now for the individual types}

{  type A }

{ get an actual WeylElt from a partition <-> conjugacy class in W}
set conjugacy_class_S(Partition P)=
assert(is_positive(P), "P is not a parition (has non-positive entries)");
if #P=0 then id_W(trivial_group)  {special case}
else
 {P=[a_1,...,a_r]
 construct the simple roots and coroots of GL(a_1)x...xGL(a_r)
 algorithm: P->v=(1,...,1,2,..,2,...,r,...,r)
 #of terms i is a_i
 then take the simple roots of GL(n) (n=\sum a_i) orthogonal to v
 }
 let n=sum(P) then
 (GL_roots,GL_coroots)=
  let v=##
   for i:#P do
    for j:P[i] do i+1
   od
  od
  then
  roots=##for alpha in GL(#v).simple_roots do
   if alpha*v=0 then [alpha] else [] fi od
  in (roots,roots)
then sub_rd=root_datum(GL_roots,GL_coroots,n) then
  w_sub=sub_rd.coxeter_element in
  W_elt(SL(n+1),w_sub.matrix)
fi

set character_table_S(int n) = CharacterTable:
  let order=n.fac, partitions_n = partitions(n) then
  ncc=#partitions_n
  then index = index_partition(partitions_n)
  , centralizer_orders= for i:ncc do cycle_centralizer_order(partitions_n[i]) od
  , class_or_irrep_string (int j) = string: partitions_n[j].to_string
  , class_reps=for i:ncc do conjugacy_class_S(partitions_n[i]) od 
  , table=#partitions_n ^ { gather rows of this size: }
    for lambda in partitions_n
    do for cycles in partitions_n do Murnaghan_Nakayama(lambda,cycles) od od
in
  (Lie_type(SL(n))  {lie_type}
  , order            {order}
  , ncc              {n_classes}
  , (int j) [(Partition,vec)]: [(partitions_n[j],vec:[])] {partitions_and_signs}
  , class_or_irrep_string  {class_label}
  , (int i) WeylElt: class_reps[i]   {class_rep}
  , (int j) int: partitions_n[j].cycle_type_order  {class_order}
  , (int j, int p) int: cycle_power(partitions_n[j],p).index  {class_power}
  , centralizer_orders  {centralizer_orders}
  , for i:ncc do  order\centralizer_orders[i] od  {class_sizes}
  , class_or_irrep_string   {irreducible_label}
  , table
  )

set character_table_A(int n) = CharacterTable:character_table_S(n+1)

set sign_string (bool s) = string: if s then "-" else "+" fi
set parts_string (Partition lambda) = string: lambda.to_string[1:1~]
set cycles_string ([int,bool] cycles) = string:
(  "["
   ##
 ##for (l,s)@pos in cycles
   do if =pos then l.to_string##s.sign_string
      else "," ##  l.to_string##s.sign_string
      fi
   od
 ##
   "]"
)

{     type C     }

{get actual conjugacy class representatives, i.e. elements of W(C_n),
 from pairs of partitions
pair of partitions (P,Q) of total size n -> conjugacy class in W(C_n)
P=(a_1,...,a_r) -> coxeter element of Sp(2a_1)x...xSp(2a_r)
Q=(b_1,...,b_s) -> coxeter element of GL(b_1)x...xGL(b_s)
}
set conjugacy_class_C(Partition P,Partition Q)=
assert(is_positive(P), "P is not a parition (has non-positive entries)");
assert(is_positive(Q), "Q is not a parition (has non-positive entries)");
if #P+#Q=0 then id_W(trivial_group)  {special case}
else
 {first, given a single partition P=(a_1,...,a_r)
 construct the simple roots and coroots of GL(a_1)x...xGL(a_r)
 algorithm: P->v=(1,...,1,2,..,2,...,r,...,r)
 #of terms i is a_i
 then take the simple roots of GL(n) (n=\sum a_i) orthogonal to v
 }
 let (GL_roots,GL_coroots)=
  let partition=P##Q then
  v=##
   for i:#partition do
    for j:partition[i] do i+1
   od
  od
  then
{  ()=prints("v=",v) then}
  roots=##for alpha in GL(#v).simple_roots do
   if alpha*v=0 then [alpha] else [] fi od
  in (roots,roots)
 then
 {next, add single 2e_i term to simple roots of each GL factor from P
 corresponding e_i term to simple coroots}
 n=sum(P)+sum(Q) then
 long_roots=[vec]: for i:#P do 2*e(n,sum(for k:i+1 do P[k] od)-1) od then
 short_coroots=[vec]: for i:#P do e(n,sum(for k:i+1 do P[k] od)-1) od 
 in
{ let ()=prints("GL_roots:",GL_roots,new_line,"long:roots",long_roots,new_line,"GL_coroots:",GL_coroots,new_line,"short_coroots",short_coroots) in}
 let sub_rd=root_datum(GL_roots##long_roots,GL_coroots##short_coroots,n) then
  w_sub=sub_rd.coxeter_element in
  W_elt(Sp(2*n),w_sub.matrix)
fi

set character_table_C(int n) = CharacterTable:
let order=n.fac*2^n, pairs = partition_pairs(n)
  then cycles = for pair in pairs do pair.cycles od
  then ncc=#cycles then
  index = index_signed_cycles(cycles,#(#cycles))
  , centralizer_orders = for type in cycles do type.cycle_centralizer_order od
  , sign(bool s) = string: if s then "-" else "+" fi
in
  (Lie_type(Sp(2*n))    {lie_type}  
  , order    {order (of W)}
  , ncc      {n_classes}
  , (int j) [(Partition,vec)]: [([],[])] {do this later}  {partitions_and_signs}
  , (int j) string: { class_label } cycles[j].cycles_string  {class_label}
  , (int j) WeylElt: conjugacy_class_C(pairs[j])  {class_rep}
  , (int j) int: cycles[j].cycle_type_order       {class_order}
  , (int j, int p) int: cycle_power(cycles[j],p).index   {class_power}
  , centralizer_orders   {class}
  , for co in centralizer_orders do order\co od    {class_sizes}
  , (int i) string: pairs[i].cycles.to_string { irreducible representation label }  {irreducible label}
  , ncc ^ { gather rows of this size: }
    for pair in pairs
    do for cycle_type in cycles do hyperoctahedral_character(pair,cycle_type) od
    od
  )




{
set character_table_D(int n) = CharacterTable:
( let order=n.fac*2^(n-1)
  , irred = Dn_irreducibles(n)
  , class = Dn_classes(n)
  , unsplits = [[int,bool]]:[], splits = [Partition]: []
  then unsplit_indices =
   ##for c@i in class
     do case c | cycles.unsplit_class: unsplits #:= cycles; [i] | else [] esac
     od
  , split_indices =
   ##for c@i in class
     do case c
        | (alpha,neg).split_class: if neg then [] else splits #:= alpha; [i] fi
        | else []
        esac
     od
  then index_unsplit = index_signed_cycles(unsplits,unsplit_indices)
  , index_split = index_partition(splits) { |splits| is born in sorted order }
  then index(Dn_class C) = int:
     case C
     | cycles.unsplit_class: cycles.index_unsplit
     | (alpha,neg).split_class: split_indices[alpha.index_split]+#neg
     esac
  , centralizer_orders = for C in class do C.centralizer_order od
  , sign(bool s) = string: if s then "-" else "+" fi
in
  ( Lie_type(SO(2*n))
  , order
  , (int j) [(Partition,vec)]: [([],[])] {do this later}
  , (int j) string: { class_label }
    case class[j]
    | cycles.unsplit_class: cycles.cycles_string
    | (alpha,s).split_class: alpha.to_string ## sign(s)
    esac
  , (int j) int: class[j].cycle_type_order
  , (int j, int p) int: cycle_power(class[j],p).index
  , centralizer_orders
  , for co in centralizer_orders do order\co od
  , (int i) string: { irreducible representation label }
    case irred[i]
    | (lambda,mu).unsplit_irr: { here we keep the stored order of partitions }
      "{" ## lambda.parts_string ## " | " ## mu.parts_string ## "}"
    | (mu,s).split_irr:
      "{" ## mu.parts_string ## " | " ## mu.parts_string ## "}" ## s.sign_string
    esac
  , [int]:[] {reflection character, do this later}
  ,[WeylElt]:[]
  , #class ^ { gather rows of this size: }
    for chi in irred do for C in class do Dn_character(chi,C) od od
  )
)



}



{copied from W_characters.at}

{ Adams's operation (not Jeff's): evaluate character at class of $w^n$ }
set Adams (CharacterTable tab) = ([int]char, int n) [int]:
   for i:tab.n_classes do char[tab.class_power(i,n)] od

{ symmetric power of a character }
set sym_power (CharacterTable tab) = ([int]char, int n) [int]:
{ with $h_k$ symmetric, $p_k$ Adams, use $kh_k=\sum_{i=0}{k-1} h_ip_{k-i}$ }
   let { define two local tables of characters, to be expanded in loop }
     p = { "power sum polynomials", results of Adams operations } [[int]]: [ ]
         { since there is no $p_0$, the $k$-the Adams operation gives the entry
           |p[k-1|, but never mind since we will always reverse-index |p| }
   , h = { "complete homogeneous polynomials", symmetric powers } [tab.trivial]
   , Adams = tab.Adams { shorthand }
in for k:n from 1
   do p #:= Adams(char,k) { expand }
   ;  let sum=p~[0]
   in for i:k-1 from 1 do sum:=tab.sum(sum,tensor(h[i],p~[i])) od
   ; h #:= for s in sum do s\k od { expand table by |sum\k| }
   od; h[n] { last symmetric power is the one we want }

set sym_power_reflection(CharacterTable ct)=(int->[int]):
(int n):ct.sym_power(ct.reflection,n)

{ exterior power of a character }
set ext_power (CharacterTable tab) = ([int]char, int n) [int]:
{ with $e_k$ ext, $p_k$, use $ke_k=\sum_{i=0}{k-1}(-1)^{k-i-1} e_ip_{k-i}$ }
   let { define two local tables of characters, to be expanded in loop }
    sp = { "signed power sum polynomials", $(-1)^{i-1}p_i$ } [[int]]: [ ]
         { since there is no $p_0$, the $k$-the Adams operation gives the entry
           |p[k-1|, but never mind since we will always reverse-index |p| }
   , e = { "elementary symmetric polynomials", exterior powers } [tab.trivial]
   , Adams = tab.Adams { shorthand }
in for k:n from 1
   do sp #:= Cartesian_power(Adams(char,k),minus_1^(k-1)) { expand }
   ;  let sum=sp~[0]
   in for i:k-1 from 1 do sum:=tab.sum(sum,tensor(e[i],sp~[i])) od
   ; e #:= for s in sum do s\k od { expand table by |sum\k| }
   od; e[n] { last symmetric power is the one we want }


{find j so that
 s_long=ct.class_representatives()[j]
 in one root length case all roots are long
}
set index_long_reflection(CharacterTable ct)=int:
let rd=ct.root_datum in
first(for i:ct.n_classes do 
 let w=ct.class_rep(i) in
  length(w)=1  and is_long(rd,let j=w.word[0] in rd.simple_roots[j]) od)

{returns -1 if one root length}
set index_short_reflection(CharacterTable ct)=int:
let rd=ct.root_datum in
first(for i:ct.n_classes do 
 let w=ct.class_rep(i) in
  length(w)=1  and is_short(rd,let j=w.word[0] in rd.simple_roots[j]) od)

set signature(CharacterTable ct,[int] char)=[int]:
let i_long=ct.index_long_reflection then
i_short=ct.index_short_reflection in
if i_short!=-1 then [char[0],char[i_long],char[i_short]] else [char[0],char[i_long]] fi

set signature(CharacterTable ct)=([int] ->[int]):([int] char):signature(ct,char)