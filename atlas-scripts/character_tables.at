<basic.at
<combinatorics.at
<tabulate.at
<W_characters.at
<simple_factors.at

{define sum and product of [int] corresponding to direct
sum and tensor product of characters}
set sum([int] v,[int] w)=
assert(#v=#w,"not same size");for i:#v do v[i]+w[i] od

set product([int] v,[int] w)=
assert(#v=#w,"not same size");for i:#v do v[i]*w[i] od
set tensor=product@([int],[int])

set tensor_power([int] v,int power)=[int]: for x in v do x^power od

set Cartesian_power([int] x,int n)=[int]:  for v in x do n*v od

{ Character table structure for Weyl groups (integer valued characters) }

{ The structure below was inspired by the way GAP represents character tables }

set_type
[ CharacterTable =
  (LieType lie_type
  , int order { of the finite group }
  {conjugacy classes}
  , int n_classes  { number of conjugacy classes}
  , (int ->[(Partition,vec)]) partitions_and_signs  {simple classical groups only}
  , (int->string) class_label {derived from partitions_and_signs in classical case}
  , (int ->WeylElt) class_rep     {gives element of W representating class_label(i)}
  , (int->int) class_order
  , (int,int->int) class_power   {(i,j) -> class_of(i^th class to the j^power)}
  , [int] centralizer_orders
  , [int] class_sizes
  {irreducible characters}
  , (int->string) irreducible_label
  , [[int]] sym_powers_reflection
  , [int] degrees
  , mat table { by row=character }
  )
]

{summary:
CharacterTable=(
lie_type,              LieType
order,                 int
n_classes,             int
partitions_and_signs,  {int->[(Partition,vec)]}
class_label,           {int->string}
class_rep,             {int->WeylElt}
class_order,           {int->int}  
class_power,	       {(int,int)->int}
cenetralizer_orders,   {[int]}
class_sizes,           {[int]}
irreducible_label,     {int->string}
sym_powers_reflection  {[[int]]}
degrees		       {[int]}
table)
}

set root_datum (CharacterTable ct) = RootDatum:ct.class_rep(0).root_datum { at least one class exists }
set rank(CharacterTable t)=t.lie_type.rank
set dimension (CharacterTable t) = (int i) int: t.table[i,0]
set class_reps(CharacterTable ct)=[WeylElt]: for i:ct.n_classes do ct.class_rep(i) od
set class_index(CharacterTable ct)=(WeylElt -> int): (WeylElt w):
 first(ct.n_classes,(int i): is_conjugate(ct.class_reps[i],w))
set centralizer_order(CharacterTable ct)=(int->int):(int i): ct.centralizer_orders[i]
set class_size(CharacterTable ct)=(int->int):(int i): ct.class_sizes[i]
set character(CharacterTable t)=(int->[int]):(int i):(^t.table)[i]
set characters(CharacterTable ct)=[[int]]: ^ct.table
set inner(CharacterTable ct)=(([int],[int])->int): ([int] x,[int] y):
  assert(#x=ct.n_classes and #y=ct.n_classes,"Wrong sizes");
  let sizes=for i:ct.n_classes do ct.class_size(i) od then
  nW=ct.order then
    s = for size@i in sizes do size*x[i]*y[i] od.sum then (q,r)=s \% nW in
    if =r then q else error("Non integer inner product ",s/nW) fi
set norm2(CharacterTable ct)=([int]->int): ([int] x):ct.inner(x,x)
set sum(CharacterTable ct)=(([int],[int])->[int]): ([int] x,[int] y):
   for xi@i in x do xi+y[i] od
set product(CharacterTable ct)=(([int],[int])->[int]):([int] x,[int] y):
   for xi@i in x do xi*y[i] od
set power_map(CharacterTable ct)=(int -> [int]):
(int j): let w=ct.class_rep(j) in for i:w.order do ct.class_index(w^i) od


set trivial(CharacterTable ct)=[int]: for :ct.n_classes do 1 od
set sign(CharacterTable ct)=[int]: for w in ct.class_reps do minus_1^w.length od  {sgn}
set reflection(CharacterTable ct)=[int]:for w in ct.class_reps do w.matrix.trace od    {reflection}
{set sym_powers_reflection(CharacterTable ct)=[[int]]:[]}
 {store empty list by default
  see the function sym_power_reflection@CharacterTable below:
  the first time it is called it fills sym_powers_reflection
 }

{tensor product of two rows of character table}
set tensor(CharacterTable t)=(int,int->[int]):(int i,int j):
product(t.character(i),t.character(j))
set tensor_power(CharacterTable t)=(int,int->[int]):(int i,int power):
for x in t.character(i) do x^power od

set Cartesian_power(CharacterTable ct)=([int],int->[int]):([int] x,int n): assert(#x=ct.n_classes,"Wrong size"); for v in x do n*v od

set scalar_product (CharacterTable ct) = (int i0, int i1) rat:
   let tab=ct.table in
   for j: ct.n_classes do tab[i0,j]*tab[i1,j]*ct.class_size(j) od.sum/ct.order

{different name for use with [int],[int] arguments}
set inner_product(CharacterTable ct)=(([int],[int])->int):([int] v,[int] w):
rat_as_int(sum(for i:ct.n_classes do v[i]*w[i]*ct.class_size(i) od)/ct.order)

set check_orthogonality (CharacterTable ct) = bool:
   let n=ct.n_classes, dot=ct.scalar_product in
   for i:n do for j:n do dot(i,j) = #(i=j) od.all od.all

set show_classes(CharacterTable ct)=void:
tabulate(
 ["class","order","|cent|","class_size"]# for i:#ct.table do
[ct.class_label(i),ct.class_order(i).to_string, ct.centralizer_order(i).to_string,ct.class_size(i).to_string] od)

{miscellaneous functions}

{find j so that
 s_long=ct.class_representatives()[j]
 in one root length case all roots are long
}
set index_long_reflection(CharacterTable ct)=int:
let rd=ct.root_datum in
first(for i:ct.n_classes do 
 let w=ct.class_rep(i) in
  length(w)=1  and is_long(rd,let j=w.word[0] in rd.simple_roots[j]) od)

{returns -1 if one root length}
set index_short_reflection(CharacterTable ct)=int:
let rd=ct.root_datum in
first(for i:ct.n_classes do 
 let w=ct.class_rep(i) in
  length(w)=1  and is_short(rd,let j=w.word[0] in rd.simple_roots[j]) od)

set signature(CharacterTable ct,[int] char)=[int]:
let i_long=ct.index_long_reflection then
i_short=ct.index_short_reflection in
if i_short!=-1 then [char[0],char[i_long],char[i_short]] else [char[0],char[i_long]] fi

set signature(CharacterTable ct)=([int] ->[int]):([int] char):signature(ct,char)
set show_reps(CharacterTable ct)=void:
tabulate(
["character","signature", "name"] #
for i:ct.n_classes do
[ct.character(i).to_string,
ct.signature(ct.character(i)).to_string,
ct.irreducible_label(i)] od)

set decompose(CharacterTable ct)=(vec->vec):(vec v):
for i:#ct.table do ct.inner_product(v,ct.character(i)) od

set permute_classes(CharacterTable ct,(int->int) f)=CharacterTable:
let
centralizer_orders=for i:ct.n_classes do ct.centralizer_orders[f(i)] od then
class_sizes=for i:ct.n_classes do ct.class_sizes[f(i)] od in
(ct.lie_type,
ct.order,
ct.n_classes,
(int i):ct.partitions_and_signs(f(i)),
(int i):ct.class_label(f(i)),
(int i):ct.class_rep(f(i)),
(int i):ct.class_order(f(i)),
(int i, int j):ct.class_power(f(i),j),
centralizer_orders,
class_sizes,
ct.irreducible_label,
for i:ct.n_classes do ct.sym_powers_reflection[f(i)] od,
ct.degrees,
for col@i in ct.table do ct.table[f(i)] od
)

set permute_classes(CharacterTable ct,[int] permutation)=CharacterTable:
let f(int i)=permutation[i] in permute_classes(ct,f)
