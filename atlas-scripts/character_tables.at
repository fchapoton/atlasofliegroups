<basic.at
<combinatorics.at
<tabulate.at
<W_characters.at

{ Character table structure for Weyl groups (integer valued characters) }

{ The structure below was inspired by the way GAP represents character tables }

set_type
[ character_table =
  ( LieType lie_type
  , int order { of the finite group }
  , (int -> Partition) class_partition {only in type A; want partition itself not just string}
  , (int->string) class_label
  , (int->int) class_element_order
  , (int,int->int) class_power
  , [int] centralizer_orders
  , [int] class_sizes
  , (int->string) irreducible_label
  , mat table { by row=character }
  )
]

set rank(character_table t)=t.lie_type.rank
set n_classes (character_table t) = int: #t.class_sizes
set irrep_dimension (character_table t) = (int i) int: t.table[i,0]
set character(character_table t)=(int->[int]):(int i):(^t.table)[i]

set scalar_product (character_table ct) = (int i0, int i1) rat:
   let tab=ct.table in
   for j: ct.n_classes do tab[i0,j]*tab[i1,j]*ct.class_sizes[j] od.sum/ct.order

set check_orthogonality (character_table ct) = bool:
   let n=ct.n_classes, dot=ct.scalar_product in
   for i:n do for j:n do dot(i,j) = #(i=j) od.all od.all
{
set reflection(character_table ct)=[int]:
for w in ct.class_reps do w.matrix.trace od
}
set show_classes(character_table ct)=void:
tabulate(
 ["class","order","|cent|","class_size"]# for i:#ct.table do
[ct.class_label(i),ct.class_element_order(i).to_string, ct.centralizer_orders[i].to_string,ct.class_sizes[i].to_string] od)

set show_reps(character_table ct)=void:
tabulate(
["rep name","dimension","character"]#
for i:ct.n_classes do
[ct.irreducible_label(i),ct.irrep_dimension(i).to_string,ct.character(i).to_string] od)

set inner_product(character_table ct)=((vec,vec)->int):(vec v,vec w):
rat_as_int(sum(for i:ct.n_classes do v[i]*w[i]*ct.class_sizes[i] od)/ct.order)

set decompose(character_table ct)=(vec->vec):(vec v):
for i:#ct.table do ct.inner_product(v,ct.character(i)) od

set W_class_table(character_table ct)=WeylClassTable:W_class_table(simply_connected(ct.lie_type))

set character_table_S(int n) = character_table:
  let order=n.fac, partitions_n = partitions(n)
  then index = index_partition(partitions_n)
  , c_orders=for lambda in partitions_n do cycle_centralizer_order(lambda) od
  , class_or_irrep_string (int j) = string: partitions_n[j].to_string
in
  ( Lie_type(SL(n))
  , order
  , (int j) Partition: partitions_n[j]
  , class_or_irrep_string
  , (int j) int: partitions_n[j].cycle_type_order
  , (int j, int p) int: cycle_power(partitions_n[j],p).index
  , c_orders
  , for co in c_orders do order\co od
  , class_or_irrep_string
  , #partitions_n ^ { gather rows of this size: }
    for lambda in partitions_n
    do for cycles in partitions_n do Murnaghan_Nakayama(lambda,cycles) od
    od
  )

set character_table_A(int n) = character_table:character_table_S(n+1)

set sign_string (bool s) = string: if s then "-" else "+" fi
set parts_string (Partition lambda) = string: lambda.to_string[1:1~]
set cycles_string ([int,bool] cycles) = string:
(  "["
   ##
 ##for (l,s)@pos in cycles
   do if =pos then l.to_string##s.sign_string
      else "," ##  l.to_string##s.sign_string
      fi
   od
 ##
   "]"
)

set character_table_H(int n) = character_table:
  let order=n.fac*2^n, irred = partition_pairs(n)
  then class = for pair in irred do pair.cycles od
  then index = index_signed_cycles(class,#(#class))
  , c_orders = for type in class do type.cycle_centralizer_order od
  , sign(bool s) = string: if s then "-" else "+" fi
in
  ( Lie_type(Sp(2*n))
  , order
  , (int j) Partition:[] {only used in type A}
  , (int j) string: { class_label } class[j].cycles_string
  , (int j) int: class[j].cycle_type_order
  , (int j, int p) int: cycle_power(class[j],p).index
  , c_orders
  , for co in c_orders do order\co od
  , (int i) string: { irreducible representation label }
    let (mu,lambda)=irred[i] { mu for the sign character} in
       "{" ## lambda.parts_string ## " | " ## mu.parts_string ## "}"
  , #class ^ { gather rows of this size: }
    for pair in irred
    do for cycle_type in class do hyperoctahedral_character(pair,cycle_type) od
    od
  )

set character_table_D(int n) = character_table:
( let order=n.fac*2^(n-1)
  , irred = Dn_irreducibles(n)
  , class = Dn_classes(n)
  , unsplits = [[int,bool]]:[], splits = [Partition]: []
  then unsplit_indices =
   ##for c@i in class
     do case c | cycles.unsplit_class: unsplits #:= cycles; [i] | else [] esac
     od
  , split_indices =
   ##for c@i in class
     do case c
        | (alpha,neg).split_class: if neg then [] else splits #:= alpha; [i] fi
        | else []
        esac
     od
  then index_unsplit = index_signed_cycles(unsplits,unsplit_indices)
  , index_split = index_partition(splits) { |splits| is born in sorted order }
  then index(Dn_class C) = int:
     case C
     | cycles.unsplit_class: cycles.index_unsplit
     | (alpha,neg).split_class: split_indices[alpha.index_split]+#neg
     esac
  , c_orders = for C in class do C.centralizer_order od
  , sign(bool s) = string: if s then "-" else "+" fi
in
  ( Lie_type(SO(2*n))
  , order
  , (int j) Partition:[] {only used in type A}
  , (int j) string: { class_label }
    case class[j]
    | cycles.unsplit_class: cycles.cycles_string
    | (alpha,s).split_class: alpha.to_string ## sign(s)
    esac
  , (int j) int: class[j].cycle_type_order
  , (int j, int p) int: cycle_power(class[j],p).index
  , c_orders
  , for co in c_orders do order\co od
  , (int i) string: { irreducible representation label }
    case irred[i]
    | (lambda,mu).unsplit_irr: { here we keep the stored order of partitions }
      "{" ## lambda.parts_string ## " | " ## mu.parts_string ## "}"
    | (mu,s).split_irr:
      "{" ## mu.parts_string ## " | " ## mu.parts_string ## "}" ## s.sign_string
    esac
  , #class ^ { gather rows of this size: }
    for chi in irred do for C in class do Dn_character(chi,C) od od
  )
)
