<basic.at
<combinatorics.at { for inverse of permutation }
<classical_W_classes_and_reps.at
<nilpotent_orbits.at
<isomorphism.at
{including fake degree}

set ct_verbose=false

{define sum and product of [int] corresponding to direct
sum and tensor product of characters}
set sum([int] v,[int] w)=
assert(#v=#w,"not same size");for i:#v do v[i]+w[i] od

set product([int] v,[int] w)=
assert(#v=#w,"not same size");for i:#v do v[i]*w[i] od
set tensor=product@([int],[int])

set tensor_power([int] v,int power)=[int]: for x in v do x^power od

set Cartesian_power([int] x,int n)=[int]:  for v in x do n*v od

{ Character table structure for Weyl groups (integer valued characters) }

{ The structure below was inspired by the way GAP represents character tables }

set_type
[ CharacterTable =
  ( WeylClassTable class_table
  , int order { of the finite group }
  , (int->int) to_class_table
  , (int->int) from_class_table
  {conjugacy classes}
  , int n_classes  { number of conjugacy classes}
  , (int ->classical_class) classes
  , (int->string) class_label {derived from partitions in classical case}
  , [WeylElt] class_reps  { should be made function } {list of class reps }
  {  , (int ->WeylElt) class_rep     {used to be the (primary) projector, making it a (secondary) function}}
  , (int->int) class_order
  , (int,int->int) class_power   {(i,j) -> class_of(i^th class to the j^power)}
  , [int] centralizer_orders { should be made function }
  , [int] class_sizes { should be made function }
  {irreducible characters}
  , (int->classical_irrep) classical_reps
  , (int->string) irreducible_label
  , [[int]] sym_powers_reflection { should be made function }
  , [int] degrees { should be made function }
  , [int] fake_degrees { should be made function }
  , mat table { should be made function } { by row=character }
  )
]


set character_table ( WeylClassTable Wct
    		    , [WeylElt,classical_class,string] class_reps
		    , [classical_irrep,string,[int]] chars
		    ) =  CharacterTable:
let    rd  = Wct.root_datum
then order = rd.order_W { recomputed; fix |WeylClassTable| to provide it }
,    n     = Wct.n_classes
then class_map = [int]:
      assert(#class_reps=n,"There should be "+n+" class representatives")
    ; assert(#chars=n,"There should be "+n+" irreducible characters")
    ; for i:n do Wct.class_of(let (w,,)=class_reps[i] in w) od
then inv_map = inverse(class_map)
, c_size(int i) = Wct.class_sizes()[class_map[i]]
, rearrange([int] val) = [int]: for i:n do val[class_map[i]] od
then irreps = [classical_irrep]: for (ci,,) in chars do ci od
, labels = [string]: for (,s,) in chars do s od
, character_table = mat: n^for (,,char) in chars do char od { |char| is a row }
, degrees = [int]:
  for i:n
  do
    let char = let (,,ch)=chars[i] in for j:n do ch[inv_map[j]] od in
    first(rd.nr_of_posroots+1
         ,(int k) bool: !=Wct.inner(char,Wct.sym_power_refl(k)))
  od
in
( { class_table } WeylClassTable: Wct
, { order } int: order
, { to_class_table } (int i) int: class_map[i]
, { from_class_table } (int j)int: inv_map[j]
  {conjugacy classes}
, { n_classes } int: n
, { classes } (int i)classical_class: let (,cc,)=class_reps[i] in cc
, { class_label } (int i)string: let (,,cl)=class_reps[i] in cl
, { class_reps } [WeylElt]: for (w,,) in class_reps do w od
{ , { class_rep } (int i)WeylElt: let (w,,)=class_reps[i] in w }
, { class_order } (int i) int: let (w,,) = class_reps[i] in order(w)
, { class_power } (int i,int pow)int: inv_map[Wct.class_power(class_map[i],pow)]
, { centralizer_orders} [int]: for i:n do order\c_size(i) od
, { class_sizes } [int]: for i:n do c_size(i) od
{irreducible characters}
, { classical_reps } (int i)classical_irrep: irreps[i]
, { irreducible_label } (int i)string: labels[i]
, { sym_powers_reflection } [[int]]:
  for k:rd.nr_of_posroots+1 do rearrange(Wct.sym_power_refl(k)) od
, { degrees } [int]: degrees
, { fake_degrees} [int]: [] { to be set afterwards }
, { table } mat: character_table
)

set character_table ( RootDatum rd
		    , [WeylElt,classical_class,string] class_reps
		    , [classical_irrep,string,[int]] chars
		    ) =  CharacterTable:
    character_table ( W_class_table(rd), class_reps, chars )

{ A valid character table that can be used to initialise local variables }
set !trivial_character_table = CharacterTable:
   let Wct = W_class_table(adjoint("")), id(int i)=int: i
   then e=id_W(Wct.root_datum)
in (Wct,1,id,id
   ,1,(int i)classical_class: null_class()
   ,(int i):"e",[e],(int i):1,(int i,int k)int:0,[1],[1]
   ,(int i)classical_irrep: null_irrep(),(int i):"triv",[[1]],[0],[0],[[1]]
   )

{root datum of CharacterTable is (semisimple) simply connected}
set root_datum (CharacterTable ct) = RootDatum: ct.class_table.root_datum

set rank(CharacterTable ct) = ct.root_datum.rank

set class_representatives = class_reps@CharacterTable {synonym}
set class_rep(CharacterTable ct,int i) = WeylElt: ct.class_reps[i]
set class_rep(CharacterTable ct) = (int->WeylElt): (int i):ct.class_reps[i]
set class_of(CharacterTable ct) = (WeylElt w) int:
   ct.from_class_table(ct.class_table.class_of(w))

set import(CharacterTable ct) = ([int] char) [int]:
   for i:ct.n_classes do char[ct.from_class_table(i)] od
set export(CharacterTable ct) = ([int] char) [int]:
   for i:ct.n_classes do char[ct.to_class_table(i)] od

set character_value(CharacterTable ct, int class) = (int i) int:
  ct.table[i,class]

set id_class(CharacterTable ct) = ct.class_of(ct.root_datum.id_W)
set dimension (CharacterTable ct) = (int i) int: ct.table[i,ct.id_class]


set centralizer_order(CharacterTable ct) = (int i) int: ct.centralizer_orders[i]
set class_size(CharacterTable ct) = (int i) int: ct.class_sizes[i]
set character(CharacterTable t) = (int i) [int]: row(t.table,i)
set characters(CharacterTable ct)=[[int]]: rows(ct.table)

set character_index(CharacterTable ct) = ([int] char) int:
  first(ct.n_classes,(int i): ct.characters[i]=char)
set index(CharacterTable ct,vec char) = int: ct.character_index(char)

set inner(CharacterTable ct) = ([int] x,[int] y) int:
   assert(#x=ct.n_classes and #y=ct.n_classes,"Wrong sizes");
   ct.class_table.inner(ct.import(x),ct.import(y))

set norm2(CharacterTable ct)= ([int] x)int: ct.inner(x,x)

set degree(CharacterTable ct) = (int i)int: ct.degrees[i] { actually fake deg }

set sum(CharacterTable ct) = ([int],[int]->[int]):
   ct.class_table.direct_sum { no need to import/export here }

set product(CharacterTable ct) = (([int],[int])->[int]):
   ct.class_table.tensor { no need to import/export }

set power_map(CharacterTable ct) = (int i) [int]: { powers of class |i| }
   let ii = ct.to_class_table(i), Wct=ct.class_table
   , order = ct.class_rep(i).order { or |Wct.class_representatives()[ii].order }
   in for k: order do ct.from_class_table(Wct.class_power(ii,k)) od

set degree(CharacterTable ct) = (int i): ct.degrees[i]

set trivial(CharacterTable ct) = [int]: ct.class_table.trivial{.(ct.export)}
set sign(CharacterTable ct) = [int]: ct.export(ct.class_table.sign)
set reflection (CharacterTable ct) = [int]: ct.export(ct.class_table.reflection)

{tensor_sign: [int] -> [int]}
set tensor_sign(CharacterTable ct) = ([int]->[int]):
   let sign=ct.sign in ([int] char): tensor(sign,char) { "free" |tensor| above }
set tensor_sign(CharacterTable ct,[int] char) = [int]: ct.tensor_sign(char)

{tensor_sgn: int->int}
set tensor_sign_index(CharacterTable ct) = (int->int):
   let ts = ct.tensor_sign in
   (int index) int: ct.character_index(ts(ct.character(index)))
set tensor_sign_index(CharacterTable ct, int index) = int:
   ct.tensor_sign_index(index)


{tensor product of two rows of character table}
set tensor(CharacterTable t) = (int i,int j)[int]:
   product(t.character(i),t.character(j)) { "free" |product| = |tensor| above }
set tensor_power(CharacterTable t) = (int i,int k)[int]:
   tensor_power(t.character(i),k)

set Cartesian_power(CharacterTable ct) = ([int] x,int n)[int]:
   assert(#x=ct.n_classes,"Wrong size"); for v in x do n*v od

set scalar_product (CharacterTable ct) = (int i0, int i1) int:
   ct.inner(ct.character(i0),ct.character(i1))

{different name for use with [int],[int] arguments}
set inner_product = (CharacterTable->([int],[int]->int)):
   inner@CharacterTable { we already had that function }

set check_orthogonality (CharacterTable ct) = bool:
   let n=ct.n_classes in matrix((n,n),ct.scalar_product) = id_mat(n)

{ The following few functions assume |ct| has a simple root datum }

{ find index j of the conjugacy class of a long root reflection, or -1 if none }
set index_long_reflection(CharacterTable ct) = int:
   let rd=ct.root_datum
   then inx = first(rd.semisimple_rank,(int i)bool: is_long_root(rd,i))
in if inx.< then { there is no long root } minus_1
   else ct.class_of(W_elt(rd,[inx]))
   fi

set index_short_reflection(CharacterTable ct) = int:
   let rd=ct.root_datum
   then inx = first(rd.semisimple_rank,(int i)bool: not is_long_root(rd,i))
in ct.class_of(W_elt(rd,[inx]))

{ character values at two or three special elements:
  identity, long root reflection, and if different short root reflection }
set signature(CharacterTable ct,[int] char) = [int]:
   let i_long=ct.index_long_reflection, i_short=ct.index_short_reflection
in if i_long.< then { single root length } [char[ct.id_class],char[i_short]]
   else [char[ct.id_class],char[i_long],char[i_short]]
   fi

set signature(CharacterTable ct) = ([int] char)[int]: signature(ct,char)

set decompose(CharacterTable ct) = (vec v)[int]:
   for i:#ct.table do ct.inner_product(v,ct.character(i)) od


{copied (and modified) from W_characters.at}

{ Adams's operation (not Jeff's): evaluate character at class of $w^n$ }
set Adams (CharacterTable tab) = ([int]char, int n) [int]:
   for i:tab.n_classes do char[tab.class_power(i,n)] od

{ symmetric power of a character }
set sym_power (CharacterTable tab) = ([int]char, int n) [int]:
{ with $h_k$ symmetric, $p_k$ Adams, use $kh_k=\sum_{i=0}{k-1} h_ip_{k-i}$ }
   let { define two local tables of characters, to be expanded in loop }
     p = { "power sum polynomials", results of Adams operations } [[int]]: [ ]
         { since there is no $p_0$, the $k$-the Adams operation gives the entry
           |p[k-1|, but never mind since we will always reverse-index |p| }
   , h = { "complete homogeneous polynomials", symmetric powers } [tab.trivial]
   , Adams = tab.Adams { shorthand }
in for k:n from 1
   do p #:= Adams(char,k) { expand }
   ;  let sum=p~[0]
   in for i:k-1 from 1 do sum:=tab.sum(sum,tensor(h[i],p~[i])) od
   ; h #:= for s in sum do s\k od { expand table by |sum\k| }
   od; h[n] { last symmetric power is the one we want }


set sym_power_reflection(CharacterTable ct)=(int->[int]):(int i):
  ct.sym_powers_reflection[i] { used precomputed value }


{ exterior power of a character }
set ext_power (CharacterTable tab) = ([int]char, int n) [int]:
{ with $e_k$ ext, $p_k$, use $ke_k=\sum_{i=0}{k-1}(-1)^{k-i-1} e_ip_{k-i}$ }
   let { define two local tables of characters, to be expanded in loop }
    sp = { "signed power sum polynomials", $(-1)^{i-1}p_i$ } [[int]]: [ ]
         { since there is no $p_0$, the $k$-the Adams operation gives the entry
           |p[k-1|, but never mind since we will always reverse-index |p| }
   , e = { "elementary symmetric polynomials", exterior powers } [tab.trivial]
   , Adams = tab.Adams { shorthand }
in for k:n from 1
   do sp #:= Cartesian_power(Adams(char,k),minus_1^(k-1)) { expand }
   ;  let sum=sp~[0]
   in for i:k-1 from 1 do sum:=tab.sum(sum,tensor(e[i],sp~[i])) od
   ; e #:= for s in sum do s\k od { expand table by |sum\k| }
   od; e[n] { last symmetric power is the one we want }


{   -----character calculations------}
{copied (and modified) from W_reps.at}

{. matrix of inner products of characters of representations .}
set matrix_of_inner_products (CharacterTable tab,[[int]] characters) = mat:
  let n=#characters, imp = for chi in characters do tab.import(chi) od
  in matrix((n,n),(int i,int j): tab.class_table.inner(imp[i],imp[j]))


{mults is a vector of multiplicities of the irreducible characters,
return a list (without multiplicities) of the irreducible characters
of smallest degree occuring}
set smallest_degree_summands(CharacterTable ct,[int] mults) = [int]:
   let degrees = for m@j in mults do if m.> then [ct.degree(j)] else [] fi od.##
in if =#degrees then [] { no multiplicities, empty result }
   else let min = min(degrees)
   in for m@j in mults do if m.> and ct.degree(j)=min then [j] else [] fi od.##
   fi

{  representations of W; copied (and modified) from W_reps.at}

{ data type for representation of W
  operators[i] is the matrix of the action of simple generator #i
}
set_type W_rep = (int dimension, [mat] operators)

{ matrix of pi(w) }
set operator (W_rep rep, WeylElt w) = mat:
   product(rep.dimension,for s in w.word ~do rep.operators[s] od)

set operator (W_rep pi) = (WeylElt -> mat):
  (WeylElt w) mat: operator(pi,w)

{ trivial representation of W }
set trivial_W (RootDatum rd) = W_rep:
  (1,for i:semisimple_rank(rd) do id_mat(1) od)

{ Compute characters of W-representations on cells, as obtained from W_cells
  also induced characters from Levi subgroups, and the Steinberg character
}

{character of pi}
set character(CharacterTable ct, W_rep pi) = [int]:
  for w in ct.class_reps do trace(pi.operator(w)) od

{ isomorphism test using the character }
set is_isomorphic (CharacterTable tab, W_rep pi, W_rep sigma) = bool:
  all(tab.n_classes
     ,(int i): let w = tab.class_reps[i] in
               trace(pi.operator(w))=trace(sigma.operator(w))
     )

{ inner product of rational characters }
set inner_no_test(CharacterTable ct) = ([int] x,[int] y) rat:
  assert(#x=ct.n_classes and #y=ct.n_classes,"Wrong sizes");
  let sizes=for i:ct.n_classes do ct.class_size(i) od then
  nW=ct.order then
    s = for size@i in sizes do size*x[i]*y[i] od.sum in s/nW


set show_classes(CharacterTable ct) = void:
tabulate (
   ["i"
   ,"order"
   ,"class_size"
   ,"|cent|"
   ,"sgn(w)"
   ,"chi_ref(w))"
   ,"name"
   ]
#  for i:#ct.table
   do [i.to_string
      ,ct.class_order(i).to_string
      ,ct.class_size(i).to_string
      , ct.centralizer_order(i).to_string
      ,ct.sign[i].to_string
      ,ct.reflection[i].to_string
      ,ct.class_label(i)
      ]
   od
)

set show_classes_long(CharacterTable ct) = void:
tabulate (
    ["i"
    ,"order"
    ,"class_size"
    ,"|cent|"
    ,"sgn(w)"
    ,"chi_ref(w))"
    ,"name"
    ,"rep"
    ]
#  for i:#ct.table
   do [i.to_string
      ,ct.class_order(i).to_string
      ,ct.class_size(i).to_string
      , ct.centralizer_order(i).to_string
      ,ct.sign[i].to_string
      ,ct.reflection[i].to_string
      ,ct.class_label(i)
      ,ct.class_rep(i).to_string
      ]
   od
)

set show_reps(CharacterTable ct) = void:
let id_class=ct.id_class in
tabulate (
   ["i"
   ,"dim"
   , "deg"
   ,"fdeg"
   ,"name"
   ]
#  for i:ct.n_classes
   do [i.to_string
      ,character_value(ct,id_class)(i).to_string
      ,ct.degree(i).to_string
      ,if #ct.fake_degrees>0 then ct.fake_degrees[i].to_string else "" fi
      ,ct.irreducible_label(i).to_string
      ]
   od
)

set show(CharacterTable ct) = void:
   prints("Classes:"); ct.show_classes;
   prints("Representations:"); ct.show_reps

set show_long(CharacterTable ct) = void:
   prints("Classes:"); ct.show_classes_long;
   prints("Representations:"); ct.show_reps

set show_very_long(CharacterTable ct) = void:
   prints("Classes:"); ct.show_classes_long;
   prints("Representations:"); ct.show_reps;
   prints("Character Table:"); prints(ct.table)

set view_multiplicities (CharacterTable ct,vec v {multiplicities}) = void:
   let table =
      for mult@i in v
      do if mult>0 else []
	 then
	 [  [i.to_string
	    ,mult.to_string
	    ,ct.dimension(i).to_string
	    ,ct.degrees[i].to_string
	    ,if #(ct.fake_degrees)>0 then ct.fake_degrees[i].to_string else "" fi
	    ]
	 ]
	 fi
      od.##
 in tabulate(["#","mult","dim","deg","fdeg"]#table)

set view_char(CharacterTable ct,vec character) = void:
   view_multiplicities(ct,ct.decompose(character))

set view_char(CharacterTable ct) = (vec v)void: view_char(ct,v)
