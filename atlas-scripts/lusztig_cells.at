{the Lusztig map goes from triples (O,x,xi) to W^
 this file implements an algorithm (conjectural)
 to implement this when xi=1
 the set obtained for fixed O^v, running over x,
 is a Lusztig (left) cell
}
<basic.at
<coherent_characters.at
<truncated_induction.at
<isomorphism_W.at
<generic_degrees.at

{sigma_Lusztig (used to be sigma_L, the new name is better
sigma_Lusztig(O,x) is a of a representation of W(G)
conjecturally it is the same as
Lusztig(O,x,1) as defined in the Orange book

G G, O = special orbit for G, x\in A-bar(O)
M=M(A-bar(O)): pairs defined by Lusztig
xi an irreducible representation of Cent_{A-bar(O)}(x)
(O,x,xi)  -- Lusztig -->  W(G)^

generalization of Springer map

(O,1,1) -> Springer(O)  Springer corresdponence for G
        -> Springer(O)\otimes sign \in W(G)^
	-> W(G)^ via the isomorphism W(G)\simeq W(G)

More general case:
(O,x,1)  -> L_x=Cent_{G}(x)^0
	   -> O_L_x (same H)
	   -> Springer(O_L_x)\otimes sgn in W(L_x)^   [NOT the same as Sommers: Springer(dual(O_L_x)]
	   -> sigma_Lusztig_x\in W(L_x) via W(L_x)\simeq W(L_x_v)
	   -> [no: truncated induction from W(L_x) to W(G)]
           -> induce to W(G) and keep the term(s) with the same degree as
	      sigma_Lusztig(O,1,1)

Note: this O_L_x might not be special, so Springer(dual(orbit)) \ne Springer(orbit)*sign

Non-trivial \xi not yet considered

Example: O=0-orbit, x=1
L_x_v=G_v, O_L_x_v=0-orbit of G
Springer(O_L_x_v)=sign of W(G^)
\otimes sgn=trivial of
}

set sigma_Lusztig_verbose=true

{main algorithm for computing sigma_Lusztig, this won't usually be called by the user
 M is a pseudo-Levi
 H_M is (the ss element of) an orbit for M
 exp(2pi i y) is an element of center of M^0
 typically (M,H_M,y) are provided by component_datum@ComplexNilpotent
}
{arguments:
 G given group with its coordinate, need this to compute roots of L in G
 G.ct is needed to compute truncated induction/exchange_long_short
 L.st is needed to compute Springer(O_L)  (L=centralizer of y)
 O: given orbit on the dual side
 M: pseudo-Levi in which exp(2\pi iy) is central
  (this isn't really needed but is helpful information)
 H_M: semisimple element for orbit of M
 y: x=exp(2\pi iy)
 note that L depends on y
}

{-------------------------------------------------------------------}
{modify to work on the group side:
generalization of Springer map

(O,1,1) -> Springer(O)  Springer correspondence for G  (Springer(0)=sign/Springer(principal)=trivial)

General case:
(O,x,1)  -> L_x=Cent_{G}(x)^0
	 -> O_L_x (same H)
	 -> Springer(O_L_x) in W(L_x)^
	 -> induce from W(L_x) to W(G)
	 -> keep term(s) with generic degree: generic_degree(Springer(O))
}

{returns [(int,int)] = [(index,multiplicity)]
 usually [(j,1)]: meaning only character #j appears with multiplicity 1
 rarely  [(j,1),(k,1)...] : several characters appear with multiplicity 1
 occasionally []: empty
 so far never see mult>0
}


{this used to be called _no_dual, now the default}
set sigma_Lusztig \
  ( RootDatum G
  , SpringerTable st_G
  , ComplexNilpotent O
  , RootDatum M
  , vec H_M
  ,ratvec y) = [int]:
begin
  if sigma_Lusztig_verbose
  then prints(new_line
       , "Computing sigma_Lusztig: ",new_line
       , "O=", O.diagram,new_line
       , "G=", G,new_line
       , "st_G: ", st_G.root_datum, new_line
       , "M=", M, new_line
       , "H_M=",H_M,new_line
       ,"y=", y)
  fi
; let ct_G=st_G.character_table in
  if y.is_integer
  then  {L=G, don't need induction}
    if sigma_Lusztig_verbose then prints("y is integer, no induction")  fi;
    let sigma = int: st_G.springer(O)
    then ()=
       if sigma_Lusztig_verbose then prints("sigma (no induction): ", sigma) fi
    in [sigma] { return singleton }
  else  {need induction; compute L, sigma_Lusztig}
    if sigma_Lusztig_verbose then prints("need induction: ")  fi;
    let L = RootDatum: centralizer(G,y)
    then H_L=dominant(H_M,L)
    then O_L=ComplexNilpotent:(L,(),H_L)
    then ()=
      if sigma_Lusztig_verbose
      then prints
           ( "L=", L,new_line
           , "H_L=", H_L,new_line
	   , "O_L:", O_L.H, " ", O_L.diagram)
      fi
    then roots_L = for alpha in L.simple_roots do root_index(G,alpha) od
    then
 {avoid computing L.springer_table if orbit_L =0 or principal, only need L.character_table}
      sigma_Lusztig= [int]:
        if O_L=L.zero_orbit        then L.character_table.sign
        elif O_L=L.principal_orbit then L.character_table.trivial
        else  {not 0 or principal orbit: need to compute L.springer_table}
          if sigma_Lusztig_verbose then prints(("computing st_L:") ) fi;
          let st_L=L.springer_table
          then () =
            if sigma_Lusztig_verbose
            then prints
	      ("done computing L.springer_table (not including generic degree)" )
            fi
{         ; update_generic_degrees(st_L.ct,L.split_form)
          ; if sigma_Lusztig_verbose
	    then prints("done updating generic degrees for L") fi }
          then sigma_Lusztig_0=st_L.springer(O_L)
	  then char=st_L.ct.characters[sigma_Lusztig_0]
	  in if sigma_Lusztig_verbose then prints("sigma_Lusztig: ", char) fi
	  ; { sigma_Lusztig=} char
        fi  {now have sigma_Lusztig=character of L}{end if O_L=L.zero_orbit}
    then ()= {next: induce sigma_Lusztig}
       if sigma_Lusztig_verbose
       then prints("inducing character from L:", L,new_line
       	    	  , "roots_L: ", roots_L, new_line
		  , "sigma_Lusztig: ", sigma_Lusztig)
       fi
    then ind=induce_character(G,ct_G,roots_L,sigma_Lusztig)
    then ()=
      if sigma_Lusztig_verbose
      then prints("finished inducing character from L:", L, new_line
	            , "ind=(2)" , ind)
	 ; ct_G.view_char(ind)
      fi
    then ind_decomposed=ct_G.decompose(ind)
    then springer_O=st_G.springer(O)
    then desired_generic_degree = st_G.ct.generic_degree(springer_O)
    then () =
      if sigma_Lusztig_verbose
      then prints("getting desired generic degree: ", new_line
		 , "O=",O.diagram, new_line
		 , "springer(O): ", springer_O, new_line
		 , "sigma_Lusztig for generic degree: ", sigma_Lusztig, new_line
		 ,"desired_generic_degree: ", desired_generic_degree)
      fi
    then
      char_indices=[int]:
        for i:#ind_decomposed
        do if (ind_decomposed[i]>0 and
               (not ct_G.has_generic_degree(i)
	        or ct_G.generic_degree(i)=desired_generic_degree
	       )
	      )
	   then
       {probably never happens: correct generic degree and mult >1. If so print loud WARNING}
       	     if ind_decomposed[i]>1
	     then prints("WARNING: multiplicity >1: "
	     	        , new_line, "i=", i
			, " mult= ",ind_decomposed[i],new_line
			, "ind_decomposed=",ind_decomposed)
	     fi
           ;    [i]
	   else []
	   fi
        od.##
    in char_indices
  fi  {end if y.is_integer}
end


{run over all ratvecs from component_representatives(orbit)}
set lusztig_cell \
  ( RootDatum G
  , SpringerTable st_G
  , ComplexNilpotent O
  ) = [[int]]:
  for (M,H_M,y) in component_representatives_plus(O)
  do
    if sigma_Lusztig_verbose
    then prints("computing sigma_L for M=", M, new_line
    	       ,"H_M=",H_M,new_line
	       , "y=", y)
    fi
  ; sigma_Lusztig(G,st_G,O,M,H_M,y)
  od.sort_u

{a shorthand, handy but inefficient}
set lusztig_cell(RootDatum G,ComplexNilpotent O)=[[int]]:
  lusztig_cell(G,springer_table(G),O)
