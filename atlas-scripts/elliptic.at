<coxeter.at
<simple_factors.at
<groups.at
<partitions.at
<Weylgroup.at
<ellipticExceptional.at {tables of elliptic classes}

set elliptic_debug=true

{ all cross concatenations, example:
  product_of_two_lists ([[1,2],[3,4]],[[5,6],[1,1]])=
  [[ 1, 2, 5, 6 ],[ 1, 2, 1, 1 ],[ 3, 4, 5, 6 ],[ 3, 4, 1, 1 ]]
}
set product_of_two_lists ([[int]] a,[[int]] b) = [[int]]:
##for x in a do for y in b do x##y od od

{example:
a=[[1,2],[3,4]]
b=[[5],[6,7]]
c=[[8,9,10],[11]]
product_of_lists ([a,b,c])=
[  1,  2,  5,  8,  9, 10 ]
[  1,  2,  5, 11 ]
[  1,  2,  6,  7,  8,  9, 10 ]
[  1,  2,  6,  7, 11 ]
[  3,  4,  5,  8,  9, 10 ]
[  3,  4,  5, 11 ]
[  3,  4,  6,  7,  8,  9, 10 ]
[  3,  4,  6,  7, 11 ]
}
set product_of_lists ([ [[int]] ] lists) = [[int]]:
  let result = [[int]] : [ [] ] in
  for list in lists do result:=product_of_two_lists(result,list) od; result

{set_type Partition = [int]}

{ replace each entry j of list_in with new_numbers[j]
  example: replace([5,8,3],[0,1,2,0,0,2]) = [5,8,3,5,5,3] }
set replace ([int] values, [int] indices) = [int]:
  for index in indices do values[index] od
set replace ([int] values, [[int]] list_of_indices) = [[int]]:
  for indices in list_of_indices do replace(values,indices) od

{elliptic conjugacy classes of Weyl groups, classical and exceptional}

set is_simple(RootDatum rd) = #%Lie_type(rd)=1

{   elliptic conjugacy classes in classical groups  }

{ elliptic element in type B_n associated to a partition of n}
{ this is Cox(a_1)x...xCox(a_m) }
set elliptic_B (Partition P) = WeylElt:
  let M=block_matrix(for part in P do matrix(coxeter_element(SO(2*part+1))) od)
  in {prints(M);} W_elt(SO(2*sum(P)+1),M)

{ elliptic element in type C_n associated to a partition of n }
{ this is Cox(a_1)x...xCox(a_m) }
set elliptic_C (Partition P) = WeylElt:
  let M=block_matrix(for part in P do matrix(coxeter_element(Sp(2*part))) od)
  in {prints(M);} W_elt(Sp(2*sum(P)),M)

{ elliptic element in type D_n associated to a partition of n
  with an even number of parts; get it from B_n
}
set elliptic_D (Partition P) = WeylElt:
  assert(is_even(#P),"Partition in type D must have an even # of parts");
  let n=sum(P) in W_elt(SO(2*n),matrix(elliptic_B(P)))

{ elliptic class in classical group, given by partition }
set elliptic (RootDatum rd,Partition P) = WeylElt:
  assert(is_simple(rd), "Root Datum is not simple");
  let (type,rank)=(%Lie_type(rd))[0] in
  if type = "A"
  then assert(P=[rank+1],"Invalid element in type A"); coxeter_element(rd)
  elif type="B"
  then assert(rank=sum(P),"rank does not match Partition"); elliptic_B(P)
  elif type="C"
  then assert(rank=sum(P),"rank does not match Partition"); elliptic_C(P)
  elif type="D"
  then assert(rank=sum(P),"rank does not match Partition"); elliptic_D(P)
  else error("Root Datum is not classical")
  fi

{ all elliptic classes in classical case, obtained by running over partitions }
set partitions_even_number_parts (int n) = [[int]]:
##for P in partitions(n) do if is_even(#P) then [P] else [] fi od

{ representatives of elliptic conjugacy classes in type A
  just the Coxeter element }
set elliptic_A (int n) = [WeylElt]: [coxeter_element(SL(n+1))]

{ representatives of elliptic conjugacy classes in type B/C
  parametrized by partitions of n }
set elliptic_B (int n) = [WeylElt]: for P in partitions(n) do elliptic_B(P) od
set elliptic_C (int n) = [WeylElt]: for P in partitions(n) do elliptic_C(P) od

{ representatives of elliptic conjugacy classes in type D
  paraemtrized by partitions of n with an even number of parts }
set elliptic_D (int n) = [WeylElt]:
  for P in partitions_even_number_parts(n) do elliptic_D(P) od

{elliptic classes in any simple root datum, classical (above)
 or from a table in ellipticExceptional.at
}
set elliptic_simple_bourbaki (RootDatum rd) = [WeylElt]:
  assert(is_simple(rd),"Root Datum is not simple");
  let (type,rank)=(%Lie_type(rd))[0] in
  if type="A" then elliptic_A(rank)
  elif type="B" then elliptic_B(rank)
  elif type="C" then elliptic_C(rank)
  elif type="D" then elliptic_D(rank)
  elif type="G" then elliptic_G2
  elif type="F" then elliptic_F4
  elif type="E" then
       if rank=6 then elliptic_E6
       elif rank=7 then elliptic_E7
       elif rank=8 then elliptic_E8
       else error("Invalid Root Datum")
       fi
  else error("Invalid Root Datum")
  fi

{ elliptic classes in any simple root datum
  use |Cartan_matrix_type| to convert numbering to Bourbaki }
set elliptic_simple(RootDatum rd)=[WeylElt]:
let ell_bourbaki=elliptic_simple_bourbaki(rd) then
(,perm)=Cartan_matrix_type(Cartan_matrix(rd)) in
for w in ell_bourbaki do let
w_new=id_W(rd)##replace(perm,w.word) in
if elliptic_debug then is_elliptic(w_new) fi;w_new od


{elliptic elements of a RootDatum, not necessarily simple
 use simple_factors to construct simple factors
 (root_numbering,factors)=simple_factors(rd)
 construct elliptic elements of each simple factor using elliptic_simple
 use root_numbering to convert from numbering for simple factor (starting at 0)
  to actual numbering the RootDatum
}
set elliptic(RootDatum root_datum)=[WeylElt]:
if ss_rank(root_datum)=0 then [WeylElt]:[id_W(root_datum)] else
let (root_numbering,factors)=simple_factors(root_datum) in
for v in product_of_lists(
for i:#factors do
  let  rd=factors[i] then
  new_numbers=root_numbering[i] in
  {new_numbers gives change of numbering from each simple factor of rd to rd}
   for w in elliptic_simple(rd) do
     let r=replace(new_numbers,w.word) in
     let w_new=id_W(root_datum)##r in
{     prints("w_new=",w_new, " ", length(w_new)," ", order(w_new));}     r od od)
do   id_W(root_datum)##v  od fi
