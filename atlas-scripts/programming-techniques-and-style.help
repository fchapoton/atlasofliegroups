The purpose of this file is to collect guidelines for efficient and readable
programming in the atlas programming language (called "axis"). It assumes you
are familiar with the basics of the language (which for now are explained in the
file atlas.help, though in the future that should be split into an introduction
to the atlas program and a languge reference for axis), so this is not an
introduction to programming; rather it is about improving your programming.



* Using value gathering loops.

One of the most useful features of the axis language is that any loop will by
default produce a row value, with one entry for each time the loop has been
executed (only if the loop is in void context, for instance if it is followed by
a semicolon, then value gathering is not performed). This is a particularly
efficient way of building row values, compared to building up a values by
repeatedly extending a value being built up in a variable, because the system
can handle allocating the storage needed for the whole row just once, rather
than at every extension. Unless you need access to previous components of a row
value while it is being built up, the option to use a loop to build the value is
likely to be both easier and more efficient than using a local variable.

However it often happens that not all executions of the loop body contribute
exactly one component to a loop value; for instance they might only do so when
some condition inside the loop body is met. Or maybe some instances of the loop
body want to contribute more than one componenent value. In such cases, one can
use the trick of having the loop body itself return a row value, which could in
different branches be a 1-element or 0-element list, or a multi-element list.
Then the type of the loop body is some [T] rather than T, and the entire loop
will return type [[T]], which can then be flattened to [T] (concatenating all
the inner sublists to a single list) by using the generic ## operator (which one
could according to taste write either as "##for ... od" or as "for ... od.##").


* Using local recursive functions to reduce the amount of arguments needed.

If you find that in a recursive function you are passing one or more arguments
unchanged in every recursive call, know that recursive function can be defined
locally inside another function (or indeed inside any programming construction),
so instead of making your globally defined function recursive, it is possible to
define a recursive function locally within a globally defined one, and it can
access any of the arguments or local identifiers of the outer function, which
will always refer to the same instance, independently of the recursion depth.

* Turning tail recursion into loops.

In case of recursive functions where each recursive call is the last thing done
in the function body (typically in the branch of an |if| or |case| expression)
and hence directly provides the return value for the function (such recursions
are called tail recursions), one can usually get the same effect with a loop.
The argument (pack) of the recursive function could then be held in local
variables, initialised according to the arguments of the initial call of the
recursive function; the loop has a terminating condition taken from the
terminating branch of the recursive function, and other branches (those that do
a recursive call) are handled in the loop body, and modify the local variables
according to the changes to the argumnets in the recursive call with respect to
the originals. With respect to the recursive solution, the iterative one can be
a bit more efficient, but more importantly it expresses the logic more clearly.

Here is an example: suppose we want to map KGB elements to a KGB element in the
fundamental fiber, by applying descending Cayley transforms or cross actions.
The following recursive function achieves this

set fundamental (KGBElt x) = KGBElt:
   let s=first(x.root_datum.semisimple_rank,(int s):is_strict_descent(s,x)) in
   if s<0 { no strict descents, terminating case } then x
   elif is_real(s,x) then fundamental(Cayley(s,x))
   else assert(is_complex(s,x)); fundamental(cross(s,x))
   fi

and the following non recursive function applies the same logic

set fundamental (KGBElt x) = KGBElt:
   { use x as local variable. modifying it in a loop }
   while { there exist strict descents }
     let s=first(x.root_datum.semisimple_rank,(int s):is_strict_descent(s,x))
   in s>=0 { was a descent found? }
   do if is_real(s,x) then x:=Cayley(s,x)
      else assert(is_complex(s,x)); x:=cross(s,x)
      fi
   od; x { once no descents are found any more, just return |x| }
