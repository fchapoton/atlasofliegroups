<basic.at     { for *@(Param,rat) }
<hermitian.at { for hermitian_form_irreducible }
<center.at    {for compact_coradical_basis}
{<K_highest_weights.at}

{Recall from standardrepk.h:
Normal: $\<\alpha^\vee(1+\theta),\lambda>\geq0$ when $\alpha$ simple,
complex, and orthogonal to sums of positive imaginary resp. real roots.
}
set RC_simple(KGBElt x)=[int]:
##for alpha@i in x.root_datum.simple_roots do
let alpha_check=x.root_datum.simple_coroots[i] in
  if is_complex(i,x) 
   and =alpha_check*rho_i(x) 
   and =alpha_check*rho_r(x)
 then [i] 
 else [] 
 fi 
od 

{return (true,-1) if normal, otherwise (false,j) where
 j is in RC_simple(x) and 
 <p.lambda,simple_coroots[j]><0
}
set is_normal(Param p)=(bool,int):
assert(=p.nu,"nu\ne 0");
let rd=p.root_datum then
RC_simple=RC_simple(x(p)) then
index=first(#RC_simple,(int i)bool:rd.simple_roots[RC_simple[i]]*p.lambda<0) in (index = -1,index)

set sort_by_height (ParamPol P) = [(Split,Param)]:
  sort_by_height(for c@p in P do (c,p) od)

set branch_std = (Param, int-> ParamPol): branch@(Param,int) { built-in }

set branch_std = (ParamPol ,int -> ParamPol): branch@(ParamPol,int) { built-in }

set branch_irr (Param p, int bound) = ParamPol:
  branch_std(character_formula(p),bound)

set branch_irr (ParamPol P,int bound) = ParamPol:
  let sum=0*P in for c@p in P do sum +:= c*branch_irr(p,bound) od; sum

{ multiplicity of K-type p_K in standard module p }
set mult_std (Param p_K,Param p) = int:
  split_as_int(branch_std(p,height(p_K))[p_K])

{ multiplicity of K-type p_K in irreducible module p }
set mult_irr (Param p_K,Param p) = int:
  split_as_int(branch_irr(p,height(p_K))[p_K])

set mult_std(Param p_K, ParamPol P) = Split:
  sum(for c@p in P do c*mult_std(p_K,p) od)
set mult_irr(Param p_K, ParamPol P) = Split:
  sum(for c@p in P do c*mult_irr(p_K,p) od)

set K_signature_irr (Param p,int bound) = (ParamPol,ParamPol):
  let form=hermitian_form_irreducible(p) in
  ( branch_std(int_part(form),bound) , branch_std(s_part(form),bound) )

set signed_mult (Param p_K,Param p) = (int,int):
  let (P,Q)=K_signature_irr(p,height(p_K)) in
   ( split_as_int(branch_std(P,height(p_K))[p_K])
   , split_as_int(branch_std(Q,height(p_K))[p_K])
   )

