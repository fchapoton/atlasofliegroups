{see K_parameters.at}

<basic.at     { for *@(Param,rat) }
<hermitian.at { for hermitian_form_irreducible }
<K_highest_weights.at

set int_part (KTypePol P) = KTypePol:
   P.null_K_module + for c@t in P do (c.int_part,t) od
set s_part (KTypePol P) = KTypePol:
   P.null_K_module + for c@t in P do (c.s_part,t) od

set branch_std = (KTypePol,int->KTypePol): branch@(KTypePol,int) { built-in }
set branch_std (KType t, int cut_off) = KTypePol: branch_std(KTypePol:t,cut_off)
set branch_std (ParamPol P, int bound) = KTypePol: branch(K_type_pol(P),bound)

set branch_irr (Param p, int bound) = KTypePol:
  branch_std(K_type_pol(character_formula(p)),bound)

set branch_irr (ParamPol P,int bound) = KTypePol:
  branch_std(K_type_pol(character_formula(P)),bound)

{ multiplicity of K-type p_K in standard module p }
set mult_std (KType p_K,KTypePol P) = int:
  (branch_std(P,height(p_K))[p_K]).int_part

{ multiplicity of K-type p_K in irreducible module p }
set mult_irr (KType p_K,ParamPol P) = int:
  (branch_irr(P,height(p_K))[p_K]).int_part

set K_signature_irr (Param p,int bound) = (KTypePol,KTypePol):
  let b=branch(hermitian_form_irreducible(p).K_type_pol,bound) in
  (int_part(b),s_part(b) )

set signed_mult (KType p_K,Param p) = (int,int):
  let (P,Q)=K_signature_irr(p,height(p_K)) in (P[p_K].int_part,Q[p_K].int_part)

{ this should be modified to print all LKTs }
set print_K_types (ParamPol P) = void:
  for c@p in P
  do let mu=highest_weight_one(LKT(p)) in
    prints(split_as_int(c), " ", fundamental_weight_coordinates (mu)
          , " ", dimension(mu), " ", length(mu))
  od

set print_K_types (ParamPol P, KGBElt x_K) = void:
  for c@p in P
  do let mu=highest_weight_one(LKT(p),x_K) in
    prints(split_as_int(c), " ", fundamental_weight_coordinates (mu)
          , " ", dimension(mu), " ", length(mu))
  od
