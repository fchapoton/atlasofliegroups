{ this file, together with convert_c_form.at, should replace herm.at}

<basic.at
<convert_c_form.at
<ext_deform.at { we need this for general $\delta$, full_deform@(Param,mat) }

set hf_debug=false { for printing of mu's in hermitian_form_irreducible_long }

{.c-invariant form on standard module.}
set c_form_std = (Param->ParamPol): { never involves |twisted_full_deform| }
  full_deform@Param { built-in }

set twisted_c_form_std = (Param->ParamPol): { c-form on extended group }
  twisted_full_deform@Param { built-in }

{ with explicit |delta|, call |full_deform@(Param,mat)| from ext_deform.at }
set twisted_c_form_std = (Param,mat->ParamPol): { c-form delta-extended group }
  twisted_full_deform@(Param,mat) { this one is from ext_deform.at }

{    c_form on irreducible representations   }

{.c-invariant form on irreducible module in terms of standardrepks.}
set c_form_irreducible (Param p) = ParamPol:
( let ori_nr_p = orientation_nr(p), P = null_module(real_form(p)) in
  for c@q in KL_sum_at_s(p)
  do P +:= c*orientation_nr_term(ori_nr_p,q)*c_form_std(q) od
; P
)

{ same as |c_form_irreducible|, but also return a second component that
  exposes the linear combination of contributions from standard representations
  that produced the result (parameter, coefficient, c_form on ths standard)

  formulas: write
    J(y)  =sum_x               (-1)^{ell(x)-ell(y)}P(x,y)(q=1)I(x)
  then
    J(y)_c=sum_x (-1)^{on(x,y)}(-1)^{ell(x)-ell(y)}P(x,y)(q=s)I(x)_c
  where
    P(x,y) is a cumulated KL polynomial
    (-1)^{ell(x)-ell(y)}P(x,y) is given by signed_KL_col(y)[i] with
    indices[i]=x on(x,y)=orientation number given by orientation_nr_term()
    I(x)_c given as combination of standards x' with nu(x')=0 by c_form_std(x)
  algorithm: compute the sum for J(y)_c, using signed_KL_col and c_form_std
}
{.c-form on an irreducible, with extra output.}
set c_form_irreducible_long (Param p) =
    (ParamPol,[(Param,Split,ParamPol)],ParamPol):
( let P = null_module(real_form(p)), ori_nr_p = orientation_nr(p)
  then formula=KL_sum_at_s(p)
  then standards = { list contributions; meanwhile compute |P| }
    for c@q in formula
    do
      let form_on_standard = c_form_std(q)
      ,   factor           = c*orientation_nr_term(ori_nr_p,q)
      in P +:= factor*form_on_standard
    ; (q,factor,form_on_standard)
    od
  in (formula,standards,P)
)

{    twisted_c_form_irreducible and its variants   }

{ The functions below implement the algorithm from Vogan in email 9/22/16
  (but the starting formula was changed since then):
  * for each delta-fixed term q add c_form_std(q,delta) (fully twisted-deformed)
  * for each pair {q,delta(q)} add q*0 (deformation to nu=0 of q).
  For second kind it it convenient to add q*0 and delta(q)*0 separately
  and at the end divide the sum of such contributions by 2.
}

{ starting formula in the c-form calculation: J(p)_c=\sum w(q)I(q)_c
  no deformation, but include orientation numbers; unfixed terms not yet halved
}
set twisted_c_form_irreducible_as_sum_of_standards (Param p) = ParamPol:
( let G=p.real_form, ori_nr_p = orientation_nr(p) in
  null_module(G) +
  for c@q in (1+s)*KL_sum_at_s(p) + (1-s)*twisted_KL_sum_at_s(p)
  do
  ( if twist(q)=q then half(c) else c fi * orientation_nr_term(ori_nr_p,q)
  , q
  )
  od
)

{ basic version of twisted_c_form_irreducible, for the inner class involution
  start with formula from c_form_irreducible_twisted_as_sum_of_standards
  replace each delta-fixed I(q)_c with twisted_full_deform(q)
  replace each pair of delta-interchanged I(q)_c with q*0
  this is the formula which can then be converted to give the Hermitian form
}

{.twisted c-invariant form on an irreducible in terms of standardrepks.}
set twisted_c_form_irreducible (Param p) = ParamPol:
( let G=p.real_form
  then fixed_terms = null_module(G), unfixed_terms = null_module(G)
  in
  for c@q in twisted_c_form_irreducible_as_sum_of_standards(p)
  do
    if twist(q)=q
    then { fixed under the inner class twist }
      fixed_terms +:= c*twisted_full_deform(q)
    else { now |1+s| divides |c|, which justifies not using |scale_extended|: }
      unfixed_terms +:= c*(q*0) { postpone halving here }
    fi
  od
; fixed_terms + half(unfixed_terms)
)

{.c_form_irrecible with extra information.}
set twisted_c_form_irreducible_long (Param p) =
    (ParamPol,[(Param,Split,ParamPol)],ParamPol):
assert(twist(p)=p,"parameter is not fixed by inner class involution");
( let G=p.real_form, terms=[(Param,Split,ParamPol)]: []
  , start = twisted_c_form_irreducible_as_sum_of_standards(p)
  then fixed_terms = null_module(G), unfixed_terms = null_module(G)
  in
  for c@q in start
  do
    if twist(q)=q
    then
      let contrib=c*twisted_full_deform(q) in
      (fixed_terms+:=contrib, terms#:=(q,c,contrib))
    else
      { now |1+s| devides |c|, which justifies not using |scale_extended|: }
      let contrib=c*(q*0) in
      (unfixed_terms+:=contrib, terms#:=(q,c,contrib))
    fi
  od
; ( start, terms, fixed_terms + half(unfixed_terms) )
)

{ print versions }

set print_twisted_c_form_irreducible_long (Param p) = void:
  let (formula,terms,answer)=twisted_c_form_irreducible_long(p)
  , done = { to suppress one of every delta-orbit, we collect seen terms }
    null_module(p)
  in
  prints(new_line,new_line
        ,"(twisted) c-form on irreducible in terms of standards:",new_line
       ,formula.pol_format,new_line);
  for (p,coeff,P) in terms
  do
    if done[twist(p)]=0
    then done+:=p { record to suppress printing |twist(p)| later }
    ; prints("coeff*form on standard: ", new_line
            ,coeff.split_format,"*",p,":",new_line
	    ,"fully deformed",new_line, (coeff*P).pol_format, new_line)
    fi
  od;
  prints("c-form on irreducible module p=",p,":",new_line
        ,answer.pol_format, "purity=", purity(answer))

{ analyse }

{ print only terms with "mixed" coefficient (a+bs), i.e., both a,b\ne 0 }
set mixed (Split w)= bool: not w.is_pure
set mixed_terms (ParamPol P) = ParamPol:
  0*P + ## for w@p in P do if w.mixed then [(w,p)] else [] fi od
set analyse (ParamPol P) = void:
  prints("Mixed terms:",P.mixed_terms.pol_format)

{  Hermitian forms  }

{.Hermitian dual.}
set hermitian_dual (Param p) = Param: normal(twist(p))

{.whether J(p) admits an invariant Hermitian form.}
set is_hermitian (Param p) = bool: equivalent(twist(p),p) { compares |normal|s }

set check_hermitian (Param p, bool irreducible) = void:
  if not p.is_hermitian
  then error(if irreducible then "Irreducible" else "Standard" fi
            ," module does not admit any invariant Hermitian form")
  fi

{ Unlike the c-invariant forms, Hermitian forms need a choice of normalization }

set hermitian_form_std (Param p,Param p0) = ParamPol:
  let c_invariant_form =
    if is_equal_rank(real_form(p))
    then c_form_std(p)
    else check_hermitian(p,false); twisted_c_form_std(p)
    fi
  in convert_cform_hermitian(c_invariant_form,p0)

{.Hermitian form on a standard module, canonical normalization.}
set hermitian_form_std (Param p) = ParamPol:
  if is_equal_rank(real_form(p))
  then c_form_std(p)
  else check_hermitian(p,false); twisted_c_form_std(p)
  fi. convert_cform_hermitian

set hermitian_form_irreducible (Param p,Param p0) = ParamPol:
  let c_invariant_form =
    if is_equal_rank(real_form(p)) { then avoid twisted version, for speed }
    then c_form_irreducible(p)
    else check_hermitian(p,true); twisted_c_form_irreducible(p)
    fi
  in convert_cform_hermitian(c_invariant_form,p0)

set hermitian_form_irreducible (Param p) = ParamPol:
  if is_equal_rank(real_form(p))
  then c_form_irreducible(p) { not twisted, in equal rank case this is faster }
  else check_hermitian(p,true); twisted_c_form_irreducible(p)
  fi.convert_cform_hermitian

set hermitian_form_irreducible_long (Param p, Param p0) =
    (ParamPol,[(Param,Split,ParamPol)],ParamPol):
  { here we just use |twisted_c_form_irreducible| in all cases }
  check_hermitian(p,true);
  let (formula,terms,cform) = twisted_c_form_irreducible_long(p)
  then converted_terms=
    for (q,z,P) in terms do (q,z,convert_cform_hermitian(cform,p0)) od
  in (formula,converted_terms,convert_cform_hermitian(cform,p0))

{. Hermitian form on an irreducible, with extra information.}
set hermitian_form_irreducible_long (Param p) =
    (ParamPol,[(Param,Split,ParamPol)],ParamPol):
  assert(is_hermitian(p)
        ,"Irreducible module does not admit any invariant Hermitian form");
  hermitian_form_irreducible_long(p,twisted_c_form_irreducible(p).last_param)

{ nice output of hermitian_form_irreducible }
set print_hermitian_form_irreducible (Param p,mat delta,Param p0) = void:
  hermitian_form_irreducible(p,p0).pol_format.prints

{.print Hermitian form on irreducible, plus extra information.}
set print_hermitian_form_irreducible_long (Param p,Param p0) = void:
  let (formula,terms,answer)=hermitian_form_irreducible_long(p,p0) in
  prints(new_line,new_line
        ,"(twisted) c-form on irreducible in terms of standards:", new_line
        , formula,new_line);
  for (p,coeff,P) in terms
  do prints("coeff*form on standard: ", new_line
           ,coeff.split_format,"*",p,":",new_line
	   ,"fully deformed",new_line, (coeff*P).pol_format, new_line)
  od;
  prints("Hermitian form on irreducible module p=",p,":",new_line
        ,answer.pol_format, "purity=", purity(answer))

{ nice output of Hermitian forms on list of parameters }
set print_hermitian_form_irreducible ([Param] P,mat delta,Param p0) = void:
  for p in P
  do prints(new_line,"Hermitian form on irreducible: ",p)
  ; print_hermitian_form_irreducible(p,delta,p0)
  od

{ nice output of hermitian_form_irreducible }
set print_hermitian_form_irreducible (Param p,Param p0) = void:
  hermitian_form_irreducible(p,p0).pol_format.prints

{ nice output of Hermitian forms on list of parameters }
set print_hermitian_form_irreducible ([Param] P,Param p0) = void:
  for p in P
  do prints(new_line,"Hermitian form on irreducible: ",p)
  ; print_hermitian_form_irreducible(p,p0)
  od

{   unitarity and weak unitarity tests }

{ assuming P is the ParamPol of the Hermitian
  form on an irreducible, is_unitary(P) tests
  if it is unitary: <=> every Split coefficient is real,
  or every Split coefficient is nonreal
}
set is_unitary = (ParamPol->bool): is_pure@ParamPol  { from basic.at }

{ compute Hermitian form on p, and report if it is unitary }
set is_unitary (Param p) = bool:
  p.is_hermitian and hermitian_form_irreducible(p).is_unitary

set print_is_unitary (Param p) = void:
  if p.is_hermitian
  then let hf=hermitian_form_irreducible(p) in
    if hf.is_unitary
    then prints("Unitary")
    else let (real,nonreal,mixed)=purity(hf) in
      prints("Non-Unitary",new_line
	    , real, " real terms", new_line
	    , nonreal," nonreal terms", new_line
	    , mixed, " mixed terms")
    fi
  else prints("Irreducible module does not admit any invariant Hermitian form")
  fi

{ no mixed terms }
set is_weakly_unitary (ParamPol P) = bool:
  let (,,mixed)=purity(P) in mixed=0

{ compute Hermitian form on p, and report if it is weakly unitary }
set is_weakly_unitary (Param p) = bool:
  let G=real_form(p) in
  if is_equal_rank(G)
  then is_weakly_unitary(c_form_irreducible(p))
  else is_weakly_unitary(twisted_c_form_irreducible(p))
  fi

{ for "big" versions: see extParamPol.at }

set test_line (Param p) = void:
( let (x,lambda_minus_rho,gamma) = %p
  , points=reducibility_points(p)
  ,   ipoints=integrality_points(root_datum(p),2*nu(p))
  in prints("testing line through ", p)
; prints("reducibility points: ",points)
; prints("integrality points (for 2*nu): ",ipoints)
; if #points=0
  then prints("entire line is irreducible and unitary"
             ,if is_final(p*0) then "" else " (nu=0 is not final)" fi)
  else points:=(0/1)#points { tack on initial zero }
  ; if not points[#points-1]=1/1 then points:=points#(1/1) fi
  ; for i:#points-1 from 1
    do
      let t=(points[i]+points[i-1])/2
      then q=param(x,lambda_minus_rho,gamma*t)         { mid point interval }
      ,    r=param(x,lambda_minus_rho,gamma*points[i]) { end point interval }
      in prints(nu(p)*t,": ", is_unitary(q))
      ;  prints(nu(p)*points[i],": ", is_unitary(r))
    od
  fi
)

set weak_test (Param p) = bool:
  let formula=twisted_c_form_irreducible(p)
  , bad=null_module(real_form(p))
  in
  for w@p in formula do if not is_pure(w) then bad+:=w*p fi od;
  if #bad=0 then prints("number of terms: ", #formula); true
  else prints("number of terms: ", #formula,new_line,"bad terms:", bad ); false
  fi

set strong_test (Param p,mat delta)=bool:
  let formula=hermitian_form_irreducible(p)
  , bad=null_module(real_form(p))
  in
  for w@p in formula do if not w.is_pure then bad+:=w*p fi od;
  if #bad=0 then prints("number of terms: ", #formula);true
  else prints("number of terms: ", #formula,new_line,"bad terms:", bad );false
  fi
