{ KL stuff, including character formulas and composition series
  This implementation seeks to avoid using KL_block, and instead uses
  KL_sum_at_s, as this function stores earlier results
  Also (compared to old implementation) no regular/singular case distinction
}

<basic.at
<polynomial.at { defines types poly, poly_mat }
set nice_string(Split s)=string:
let (a,b)=%s in
if b=0 then a.to_string
elif a=0 then
 if b>1 then b.to_string + "s"
 elif b=1 then "+s"
 elif b=-1  then "-s" 
 else a.to_string + "-" + abs(b).to_string + "s"
 fi
else
 if b>1 then a.to_string +  "+" + b.to_string + "s"
 elif b=1 then a.to_string +  "+s"
 elif b=-1 then a.to_string + "-s" 
 else a.to_string + "-" + abs(b).to_string + "s"
fi
fi

set print_with_length(ParamPol P)=void:
for (c,p) in %P do prints(c.nice_string, "*"  , p, " ", p.length) od

{
  Basic object: column of KL matrix (P-matrix), of polynomials evaluted as s,
  which by setting s=1 gives formula for irreducible as sum of standards

  main functions:

  character_formula(p): irreducible(p) as sum of standards
  composition_series(p): standard(p) as sum of irreducibles

  signed_KL_mat_at_1(p): signed P-matrix evaluated at 1 (integral matrix)
  KL_inverse_mat_at_1(p): Q-matrix evaluated at 1 (integral matrix)

  also
    print_character_formula,print_composition_series
}

{ ------------------------------------------------------------------- }

set character_formula (Param p) = ParamPol: s_to_1(KL_sum_at_s(p))
set character_formula (ParamPol P)=ParamPol:
let result=null_module(P) in
for c@p in P do result+:=c*character_formula(p) od;result

{ ------------------------------------------------------------------- }

{ composition series }

set composition_series (ParamPol P) = ParamPol:
( let acc = ParamPol: P, result = null_module(P) in
  while !=acc { non null module }
  do let (coef,final):term=first_term(acc) in
    result +:= term; acc -:= coef*character_formula(final)
  od
; result
)

set composition_series (Param p) = ParamPol:
composition_series(ParamPol:p)

set composition_series_verbose(ParamPol P)= ParamPol:
let result=null_module(P) in
for i:#P do 
 let (c,p)=(%P)[i] then
 ()=prints("length of p: ", length(p)) then
 result_new =result+c*composition_series(p) in
 result:=result_new; 
 if i<#P-1 then
  let next_length=length(monomials(P)[i]) in
  {the next line is for debugging, comment it out}
{  prints(new_line,"----------------------",new_line,"all terms: ", result);}
  let ()=prints("terms of length >= ", next_length,":") in
  for (d,q) in %result do
   if length(q)>=next_length then prints(d.nice_string, "*", q, " ", q.length) fi
  od
 fi
od;result

set composition_series_verbose(ParamPol P)= ParamPol:
let result=null_module(P) then
max=max(for p in monomials(P) do length(p) od) in
for L:max+1 downto 0 do
 let ()=prints("Length: ", L) then
 result_new=null_module(P) then
 ()=for (c,p) in %P do
     if length(p)=L then result_new +:=c*composition_series(p)  fi
    od in
{    ()=prints("OK") in}
    result:=result+result_new;
    prints("terms in result of length ", L, ":");
    for (c,p) in %result do if length(p)=L then prints(c.nice_string, "*",p, " ", p.length) fi od
od;
prints("result:");print_with_length(result);
result

set tabulate_at_1 ([Param] block, (Param->ParamPol) f) = mat:
  for y in block { y determines a column of the result }
  do let fy=f(y) in for x in block do s_to_1(fy[x]) od
  od

set signed_KL_mat_at_1(Param p) = mat:
( KL_sum_at_s(p) {dummy call to ensure internal tables are filled }
; tabulate_at_1(partial_block(p), character_formula@Param)
)

set KL_inverse_mat_at_1(Param p) = mat:
( KL_sum_at_s(p) {dummy call to ensure internal tables are filled }
; tabulate_at_1(partial_block(p), composition_series@Param)
)

{ versions that do the whole block rather than a partial block }
set full_signed_KL_mat_at_1(Param p) = mat:
  tabulate_at_1(block_of(p),character_formula@Param)
set full_KL_inverse_mat_at_1(Param p) = mat:
  tabulate_at_1(block_of(p),composition_series@Param)


set print_formatted (ParamPol P) = void:
  for w@p in P do prints(split_format(w),"*",p) od

set print_character_formula (Param p) = void:
  print_formatted(character_formula(p))

set print_composition_series(Param p) = void:
  print_formatted(composition_series(p))
