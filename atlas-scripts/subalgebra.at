<basic.at
<W_orbit.at

{ subalgebra(rd,roots):
  roots are assumed to be the set of roots of a reductive subalgebra
  containing H
  (otherwise an error)
  let twochocheck=compute sum of positive coroots
  simple roots are those with inner product 2 with this
  then construct a RootDatum: root_datum(simple_roots,simple_coroots)

  Function take [vec] argument |roots|, which may be empty; always convert them
  explictly to a mstrix |rd.rank#roots|, as implicit fails when |roots| empty.
}
set subalgebra (RootDatum rd, [vec] roots) = (bool,RootDatum):
  let rk = rank(rd)
  then posroots = columns_with(is_positive_root(rd),rk#roots)
  in
  if 2*#posroots != #roots {should be same number of positive, negative roots}
  then (false,rd)
  else
    let tworhocheck = sum(rk # for v in posroots do coroot(rd,v)  od)
    then simple_roots= mat: { compute the purported simple roots }
      columns_with((vec v):v*tworhocheck=2,posroots)
    in
    if #roots>0 and #simple_roots=0 then (false,rd)
    else let simple_coroots = mat: { corresponding coroots }
             rk # for v in simple_roots do coroot(rd,v) od
      then subrd = root_datum(simple_roots,simple_coroots)
      in ( { whether } nr_of_posroots(subrd) = #posroots, subrd)
    fi
  fi

{mat k: columns span a subspace U of X_*
 construct RootDatum of Levi given by roots vanishing on U}
set Levi_of_subspace (RootDatum rd, mat k) = (bool,RootDatum):
  let levi_roots=[vec]: ##for a in roots(rd) do if =a*k then [a] else [] fi od
  in subalgebra(rd,levi_roots)

{matrix of elements of X^*}
set Levi_of_dual_subspace(RootDatum rd, mat k) = (bool,RootDatum):
  let levi_roots=
    ##for a in roots(rd) do if =coroot(rd,a)*k then [a] else [] fi od
  in subalgebra(rd,levi_roots)

{Levi subgroup defined by a group element: Levi of the dual subspace
 w acts on X^*, U=kernel(w-1) \subset X^*, want roots alpha such that alpha^v
 vanishes on U this is the Cartan if and only if w is elliptic}
set Levi_of_w (WeylElt w) = (bool,RootDatum):
  Levi_of_dual_subspace(w.root_datum,eigen_lattice(matrix(w),1))

{Levi subalgebra defined by weight in QX^*}
set Levi_of_weight (RootDatum rd,ratvec v) = (bool,RootDatum):
  Levi_of_dual_subspace(rd,mat:[numer(v)])

{Levi subalgebra defined by weight in QX_*}
set Levi_of_coweight(RootDatum rd,ratvec v) = (bool,RootDatum):
  Levi_of_subspace(rd,mat:[numer(v)])

{  normalizer of a set of roots }

{w in subgroup of W such that w permutes set_of_roots}
set normalizer([WeylElt] subset_of_W,[vec] set_of_roots)= [WeylElt]:
  ##for w in subset_of_W
    do if all(for v in set_of_roots do find(set_of_roots,w*v)!=-1 od)
       then [w] else [] fi
    od

{w in W such that w permutes set_of_roots}
set normalizer (RootDatum rd,[vec] set_of_roots) = [WeylElt]:
  normalizer(W(rd),set_of_roots)
{for testing}
set stabilizer_elementary (RootDatum rd, ratvec gamma) = [WeylElt]:
  ##(for w in W(rd) do if w*gamma=gamma then [w] else  [] fi od)

{ subalgebra orthgonal to a set of roots}
set orthogonal_subalgebra (RootDatum rd, [vec] S) = (bool,RootDatum):
   let S_mat = mat: rank(rd)#S
   then roots = [vec]:
     ##for a_v in coroots(rd) do if =a_v*S_mat then [root(rd,a_v)] else [] fi od
   in subalgebra(rd,roots)

{ subalgebra orthogonal to a Levi }
set orthogonal_subalgebra(RootDatum rd, RootDatum rd_L)=(bool,RootDatum):
let S=simple_roots(rd_L) in orthogonal_subalgebra(rd,S)

