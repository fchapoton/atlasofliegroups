<cyclotomic.at
<tabulate.at

set_type CyclotomicVec = [CyclotomicFieldElement] { sublists are matrix rows, not columns! }
set_type CyclotomicMat = [[CyclotomicFieldElement]] { sublists are matrix rows, not columns! }

set F(CyclotomicMat M)=CyclotomicField:M[0][0].F
{redefine show more concisely}
set to_string (CyclotomicFieldElement z) = string:
   if z=z.F.zero then "0" else to_rat_poly(z.v,"x").to_string fi


{.display cyclotomic field element as polynomial in x.}
set show (CyclotomicFieldElement z) = void: prints(to_string(z))

set show(CyclotomicVec v)=void:
let rv="(" in for i:#v-1 do  rv+:=v[i].to_string+"," od;
rv+:=v[#v-1].to_string+")";
prints(rv)


{			  Cyclotomic vectors				}

set =(CyclotomicVec v,CyclotomicVec w)=bool:
all(for i:#v do v[i]=w[i] od)

set F(CyclotomicVec v)=CyclotomicField:v[0].F

set =(CyclotomicVec v)=bool:all(for i:#v do v[i]=v.F.zero od)


set +(CyclotomicVec v,CyclotomicVec w)=CyclotomicVec:
assert(#v=#w,"Cyclotomic vectors not the same length");
for i:#v do v[i]+w[i] od 



set *(CyclotomicFieldElement z,CyclotomicVec v)=CyclotomicVec:
for a in v do z*a od
set -(CyclotomicVec v)=CyclotomicVec:(-v[0].F.one)*v
set -(CyclotomicVec v,CyclotomicVec w)=CyclotomicVec:v+(-w)

{include F in case of vectors of length 0}
set dot_product(CyclotomicVec v,CyclotomicVec w,CyclotomicField F)=CyclotomicFieldElement:
  let sum=F.zero in for p@i in v do sum +:= p*w[i] od; sum

{will fail if vector has length 0}
set dot_product(CyclotomicVec v,CyclotomicVec w)=CyclotomicFieldElement:
  dot_product(v,w,v[0].F)

set cyclotomic_vector(ratvec v,CyclotomicField F)=CyclotomicVec:
for a in v do embed_Q(a,F) od

set dot_product(ratvec v,CyclotomicVec w)=CyclotomicFieldElement:
dot_product(cyclotomic_vector(v,w.F),w)

set null(int n,CyclotomicField F)=CyclotomicVec:for i:n do F.zero od

set bar(CyclotomicVec v)=CyclotomicVec:for z in v do bar(z) od
set is_real(CyclotomicVec v)=bool:v=bar(v)

{			  Cyclotomic matrices				}

set shape (CyclotomicMat M) = (int,int): if =#M then (0,0) else (#M,#M[0]) fi
set n_rows(CyclotomicMat M)=let (a,)=shape(M) in a
set n_columns(CyclotomicMat M)=let (,b)=shape(M) in b
set =(CyclotomicMat M,CyclotomicMat N)=bool:
 shape(M)=shape(N) and all(for i:n_rows(M) do M[i]=N[i] od)

set =(CyclotomicMat M)=bool:all(for i:n_rows(M) do =M[i] od)

set + (CyclotomicMat M,CyclotomicMat N)=CyclotomicMat:
assert(M.shape=N.shape,"Cyclotomic matrices not the same shape");
for i:#M do M[i]+N[i] od

set -(CyclotomicMat M) = CyclotomicMat: for row in M do for p in row do -p od od
set - (CyclotomicMat M,CyclotomicMat N)=CyclotomicMat:M+(-N)

set show(CyclotomicMat M)=
let table=
for row in M do
 for a in row do a.to_string od od
then column_specifier="l"*#M[0]
in tabulate(table,column_specifier,2," ")

set transpose(CyclotomicMat M)=CyclotomicMat: { sublists must be of equal length }
  let n=#M in
  if n=0 then M { not much we can do for an empty list }
  else for j:#M[0] do for i:n do M[i][j] od od
  fi

set *(CyclotomicMat A,CyclotomicMat B) = CyclotomicMat:
  let n=#A, B_tr=transpose(B) { best to rearrange B once and for all }
  then m=#B_tr { number of rows of B_tr, or columns of B, and of result }
  in for i:n do for j:m do dot_product(A[i],B_tr[j]) od od

set *(CyclotomicMat M,CyclotomicVec v)=CyclotomicVec:
 for i:#M[0] do let s=v[0].F.zero in for Mj@j in M do s+:=Mj[i]*v[j] od; s od

set cyclotomic_matrix([[rat]] M,CyclotomicField F)=CyclotomicMat:
for row in M do cyclotomic_vector(row,F) od

set diagonal_mat(CyclotomicVec v)=CyclotomicMat:
for i:#v do
 for j:#v do
  if i=j then v[i] else v.F.zero fi
 od
od

set scalar_mat(CyclotomicFieldElement z,int n)=CyclotomicMat:
diagonal_mat(for i:n do z od)

set +(CyclotomicMat M,CyclotomicFieldElement z)=CyclotomicMat:
assert(n_rows(M)=n_columns(M),"Cycltomic matrix is not square");
M+scalar_mat(z,n_rows(M))

set -(CyclotomicMat M,CyclotomicFieldElement z)=CyclotomicMat:
M+scalar_mat(-z,n_rows(M))

set scalar_mat(rat r,int n,CyclotomicField F)=CyclotomicMat:
scalar_mat(embed_Q(r,F),n)

set id_mat(int n,CyclotomicField F)=CyclotomicMat:
scalar_mat(1,n,F)

set *(CyclotomicFieldElement z,CyclotomicMat M)=CyclotomicMat:
scalar_mat(z,n_rows(M))*M

set *(rat r,CyclotomicMat M)=CyclotomicMat:
scalar_mat(r,n_rows(M),M.F)*M

set null(int m,int n,CyclotomicField F)=CyclotomicMat:
for i:m do null(n,F) od


