<basic.at
<combinatorics.at
<W_characters.at
<character_tables.at

{ orbit sizes on roots; these characterise conjugacy classes for W(E6) }
set class_signature (WeylElt w) = Partition:
   let rd=root_datum(w)
in for c in root_orbits(w) do #c od.sort_to_partition

set class_table_E6(RootDatum rd) = WeylClassTable:
   let classes = [WeylElt]: assert(#test_simple_type("E",rd)=6,"Not E6")
	       ; conjugacy_class_reps(rd)
   then sigs = [Partition]: for w in classes do class_signature(w) od
   , leq = leq_equal_sum_partitions@(Partition,Partition)
   then N=51840 { order_W("E6") }
   ,  lookup = (Partition->int):
      let ranked = sort(#sigs,(int i,int j)bool: leq(sigs[i],sigs[j]))
      then list = for i in ranked do sigs[i] od { |sigs| sorted by |leq| }
      in (Partition sig) int: { index in |sigs| where one finds |sig| }
         ranked[binary_search_first((int i)bool: leq(sig,list[i]), 0,#list)]
in W_class_table ( rd
		 , classes
		 , (int i) int: N\centralizer_order(classes[i])
		 , (WeylElt w) int: lookup(class_signature(w))
		 , (int i,int k) int: lookup(cycle_power(sigs[i],k))
		 )

{ compute class table once, on demand the first time it is needed }
set class_table_E6 = (->WeylClassTable):
   let Wct= W_class_table(adjoint("")) { placeholder |WeylClassTable| value }
in @: { function with no arguments }
   if =Wct.root_datum.rank { whether this is the first time we are called }
   then Wct:=class_table_E6(simply_connected("E6")) else Wct
   fi

{from Magma}
set !e6_table = [vec]: { characters, with conjugacy classes in Magma order }
[[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]           { trivial }
,[1,-1,1,1,-1,1,1,1,1,-1,-1,1,1,1,1,-1,1,-1,1,-1,-1,1,-1,-1,1] { sign }
,[6,4,-2,2,0,-3,3,0,2,-2,2,0,1,1,1,1,-2,-2,-1,0,0,0,-1,1,-1]   { reflection }
,[6,-4,-2,2,0,-3,3,0,2,2,-2,0,1,1,1,-1,-2,2,-1,0,0,0,1,-1,-1]
,[10,0,-6,2,0,1,-2,4,2,0,0,-2,0,-3,0,0,0,0,2,0,0,1,0,0,-1]
,[15,-5,7,3,-1,-3,0,3,-1,-3,1,1,0,1,-2,-2,1,1,0,-1,1,0,0,0,-1]
,[15,-5,-1,-1,3,6,3,0,3,-1,-1,-1,0,2,-1,1,2,-2,-1,0,1,0,0,-1,0]
,[15,5,7,3,1,-3,0,3,-1,3,-1,1,0,1,-2,2,1,-1,0,1,-1,0,0,0,-1]
,[15,5,-1,-1,-3,6,3,0,3,1,1,-1,0,2,-1,-1,2,2,-1,0,-1,0,0,1,0]
,[20,10,4,4,2,2,5,-1,0,2,2,0,0,-2,1,1,1,1,1,-1,0,-1,0,-1,0]
,[20,-10,4,4,-2,2,5,-1,0,-2,-2,0,0,-2,1,-1,1,-1,1,1,0,-1,0,1,0]
,[20,0,4,-4,0,-7,2,2,4,0,0,0,0,1,-2,0,-2,0,2,0,0,-1,0,0,1]
,[24,4,8,0,4,6,0,3,0,0,0,0,-1,2,2,-2,-1,1,0,1,0,0,-1,0,0]
,[24,-4,8,0,-4,6,0,3,0,0,0,0,-1,2,2,2,-1,-1,0,-1,0,0,1,0,0]
,[30,-10,-10,2,2,3,3,3,-2,4,0,0,0,-1,-1,-1,-1,-1,-1,-1,0,0,0,1,1]
,[30,10,-10,2,-2,3,3,3,-2,-4,0,0,0,-1,-1,1,-1,1,-1,1,0,0,0,-1,1]
,[60,10,-4,4,2,6,-3,-3,0,-2,-2,0,0,2,-1,1,-1,1,1,-1,0,0,0,1,0]
,[60,-10,-4,4,-2,6,-3,-3,0,2,2,0,0,2,-1,-1,-1,-1,1,1,0,0,0,-1,0]
,[60,0,12,4,0,-3,-6,0,4,0,0,0,0,-3,0,0,0,0,-2,0,0,0,0,0,1]
,[64,16,0,0,0,-8,4,-2,0,0,0,0,-1,0,0,-2,0,-2,0,0,0,1,1,0,0]
,[64,-16,0,0,0,-8,4,-2,0,0,0,0,-1,0,0,2,0,2,0,0,0,1,-1,0,0]
,[80,0,-16,0,0,-10,-4,2,0,0,0,0,0,2,2,0,2,0,0,0,0,-1,0,0,0]
,[81,9,9,-3,-3,0,0,0,-3,3,-1,-1,1,0,0,0,0,0,0,0,1,0,-1,0,0]
,[81,-9,9,-3,3,0,0,0,-3,-3,1,-1,1,0,0,0,0,0,0,0,-1,0,1,0,0]
,[90,0,-6,-6,0,9,0,0,2,0,0,2,0,-3,0,0,0,0,0,0,0,0,0,0,-1]
]


{ some stuff to figure out in what order Magma has listed classes }

{from magma} { orders, then class sizes, of conjugacy classes in magma order }

set e6_sgn_index=1
set e6_reflection_index=2

set e6_profile = mat: { 4*25 matrix with unique columns, characterising a class }
   let e6_orders_sizes = mat:
	[1, 2, 2,  2,  2, 3,  3,  3,  4,  4,   4,   4,   5
                     ,  6,   6,   6,   6,   6,   6,   6,   8,   9,  10,  12,  12
	|1,36,45,270,540,80,240,480,540,540,1620,3240,5184
		     ,720,1440,1440,1440,1440,2160,4320,6480,5760,5184,4320,4320
	]
   , sgn_index=1
   , reflection_index=2
in e6_orders_sizes ^ ^[e6_table[sgn_index],e6_table[reflection_index]]

set Magma_reorder_E6 = (->[int]): { map Magma to |class_table_E6| class nrs }
   let perm =[int]: [] { placeholder, awaiting constrution }
in @:
   if =#perm else perm { used previously computed value if present }
   then
      let Wct = class_table_E6()
      then Wct_prof = mat: { with shape (4,25) }
	 let reps=Wct.class_representatives(), sizes=Wct.class_sizes() in
	 4 # for j:Wct.n_classes
	     do [reps[j].order, sizes[j], Wct.sign[j], Wct.reflection[j] ]
	     od
      then profile_ranked = [int]: { columns |e6_profile| ranked |lex_lesseq| }
	 sort(#e6_profile
	     ,(int i,int j)bool: lex_lesseq(e6_profile[i],e6_profile[j]))
      , Wct_ranked = { columns of |Wct_prof| ranked by |lex_lesseq| }
	 sort(#Wct_prof,(int i,int j): lex_lesseq(Wct_prof[i],Wct_prof[j]))
      then ranking = [int]:  { ranking[j]|: Magma class |j| rank }
         inverse(profile_ranked)
      in perm:=compose_permutations(Wct_ranked,ranking)
   fi

set Magma_class_reps_E6() = [WeylElt]: { class representatives in Magma order }
   let reps = class_table_E6().class_representatives() in
   for j in Magma_reorder_E6() do reps[j] od

set E6_name(vec chi) = string:
   let Wct = class_table_E6(), psi = null(#chi)
   then degree = { first reorder |chi| for |Wct| into |psi| }
      for j@i in Magma_reorder_E6() do psi[j]:=chi[i] od { inverse reordering }
   ;  first(class_table_E6().root_datum.nr_of_posroots+1
           ,(int k) bool: Wct.inner(psi,Wct.sym_power_refl(k)).>
	   )
in to_string("irrep(dim:",psi[0],",deg:",degree,")")

set character_table_E6() = CharacterTable:
   let classes = [WeylElt,classical_class,string]:
      for w@j in Magma_class_reps_E6()
      do (w,null_class(),class_signature(w).compressed_string)
      od
   ,  irreps = [classical_irrep,string,[int]]:
      for line@i in e6_table
      do (null_irrep()
         ,case i in "trivial", "sign", "reflection" else E6_name(line) esac
	 ,line
	 )
      od
   in character_table(class_table_E6(),classes,irreps)
