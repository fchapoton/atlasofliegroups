<basic.at
<polynomial.at { for |poly_plus@(vec,vec)| and friends, |i_poly_mat| type }
<ext_deform.at { for |cook_KL_block@([Param],,,,,)| }

{
process output of KL_block or ext_KL_block to give ([Param],int,poly_mat,vec),
the third entry is the matrix of polynomials
}

{ use old output of |KL_block| to prepare block, signed KL matrix, and stops }
set cook_KL_block ( [Param] B, int entry_elem
                  , mat KL, [i_poly] polys, vec stops
                  , vec surv, mat contrib) =
  ([Param],int,i_poly_mat,vec): { singular block, z0, signed P matrix, lengths }
  let n_surv=#surv, tr_KL=^KL, len = from_stops(stops)
  then cooked_P_mat = i_poly_mat:
     for si@i in surv
     do let lsi=len(si), scalars=null(0) { nonzero factors from |contrib| }
        then condensed = mat: { selected rows of KL contributing for i }
           n_columns(KL) { size of individual rows } ^
           for k:n_columns(contrib)
           do if =contrib[i,k] then []
              else scalars#:=contrib[i,k]; [tr_KL[k]]
              fi
           od.##
     in for sj in surv
        do strip(scalars*
           for ind in condensed[sj] { expand column of indices into polynomials }
           do if ind<0 then -polys[-ind] else polys[ind] fi
	   od.stack_rows) * minus_1^(len(sj)-lsi)
        od
     od
  , get_index (int z) = int: binary_search_first((int i):surv[i]>=z,0,n_surv)
  in ( for i in surv do B[i] od { condensed block }
     , get_index(entry_elem) { convert index of seeding element }
     , cooked_P_mat
     , for s in stops do get_index(s) od { convert stops to condensed block }
     )

{ use output of |dual_KL_block| to prepare block, KL Q-matrix, and stops }
set cook_dual_KL_block ( [Param] B, int entry_elem
		       , mat KL, [i_poly] polys, vec stops, vec surv) =
  ([Param],int,i_poly_mat,vec): { singular block, z0, signed P matrix, lengths }
  let nB=#B, n_surv=#surv
  then cooked_Q_mat = i_poly_mat:
    for si in surv do for sj in surv do let ind = KL[si,sj] in
      if ind<0 then -polys[-ind] else polys[ind] fi { |i_poly| entry }
    od od
  , get_index (int z) = int: binary_search_first((int i):surv[i]>=z,0,n_surv)
  in ( for si in surv do B[si] od { extracted block }
     , get_index(entry_elem) { convert index of seeding element }
     , cooked_Q_mat
     , for s in stops do get_index(s) od { convert stops to extracted block }
     )

set reverse (i_poly_mat Q) = i_poly_mat:
  for i:#Q ~do for Qj in Q ~do Qj[i] od od

{ define the P,P_signed and Q polynomials
  P,P_signed,Q matrices of polynomials in q
  upper triangular if B is in standard (increasing) order
  P_signed: positive/negative integer coefficients
  P: non-negative integer coefficients
  Q: non-negative integer coefficients, inverse of P_signed
  P_signed(1) is the multiplicity of a standard module in an irreducible
    (character formula)
  Q(1) is the multiplicity of an irreducible module in a standard module
}

set eval (i_poly_mat M, int k) = mat:
  matrix (shape(M), (int i,int j)int: eval(M[i][j], k))

{ map from index in B1 to matching index in B2, and whether it's well defined }
set permutation ([Param] B1, [Param] B2) = ([int],bool):
( if =#B2 then []
  else let P = s*B2[0] { nonzero term but with zero int_part| } +
               for q@i in B2 do (i,q) od in { tag each Param with its index }
  for p in B1 do let c=P[p] in if =c then return ([],false) else c.int_part fi od
  fi
, true
)

set KL_P_polynomials (Param p) = i_poly_mat:
  let (,,P,polys)=KL_block(p) in
  for row in ^P do for entry in row do polys[entry] od od

set KL_P_polynomials_at_minus_one (Param p) = mat:
  eval(KL_P_polynomials(p),minus_1)

set KL_P_signed_polynomials (Param p) = i_poly_mat:
  let (block,,P,polys)=KL_block(p) in
  for row@i in ^P do for entry@j in row
  do minus_1^(block[j].length-block[i].length)*polys[entry] od od

set KL_P_signed_polynomials_at_minus_one (Param p) = mat:
  eval(KL_P_signed_polynomials(p),minus_1)

set KL_P_polynomials([Param] B)=i_poly_mat:
  let (block,,P,polys)=KL_block(B[0])
  then (perm,valid)=permutation(B,block), n=#block
  in assert(valid,"given [Param] B does not agree with block_of B[0]");
    for i:n do for j:n do polys[P[perm[i],perm[j]]] od od

set KL_P_polynomials_at_minus_one ([Param] B) = mat:
  eval(KL_P_polynomials(B),minus_1)

set KL_P_signed_polynomials ([Param] B) = i_poly_mat:
  let (block,,P,polys)=KL_block(B[0])
  then (perm,valid)=permutation(B,block), n=#block
  in assert(valid,"given [Param] B does not agree with block_of B[0]");
    for i:n do for j:n do
      minus_1^(block[j].length-block[i].length)* polys[P[perm[i],perm[j]]]
    od od

set KL_P_signed_polynomials_at_minus_one ([Param] B) = mat:
  eval(KL_P_signed_polynomials(B),minus_1)

{*DEFINE* the Q-polynomials as inverse of the signed P-matrix}
{see dual.at for a different approach}

set KL_Q_polynomials (Param p) = i_poly_mat:
  upper_unitriangular_inverse (KL_P_signed_polynomials(p))
set KL_Q_polynomials ([Param] B) = i_poly_mat:
  upper_unitriangular_inverse (KL_P_signed_polynomials(B))

{                     twisted versions                                   }

set final_subset ([Param] B) = [Param]:
  ## for p in B do if is_final(p) then [p] else [] fi od

{ this is KL_block@(Param,mat), the twisted analogue of KL_block@Param
  Marc called this of ext_KL_block@(Param,mat); the 'ext' is superflous since it
  is implied by the presence of |delta|, and therefore not used here
}
set KL_block (Param p, mat delta) = { emulate built-in KL_block }
    ([Param],int,mat,[vec],vec,vec,mat):
{ let (regular_extblock,,,) = extended_block(p,delta) {this sometimes fails,
  if block has no fixed elements(?), move it later} }
  let (KL_mat,polys,stops) = raw_ext_KL(p,delta) in
  if shape(KL_mat)=(0,0) then return ([],-1,null(0,0),[],[],[],null(0,0)) fi;
  let (regular_extblock,,,) = extended_block(p,delta)
  , (KL_mat,polys,stops) = raw_ext_KL(p,delta)
  , survivors = vec: [] then
    final_subset=final_subset(regular_extblock)
  then columns = [vec]:
    for q@j in regular_extblock
    do let Q = finalize_extended(q,delta) in
      if #Q=1 and
         (let r=monomials(Q)[0] in r.x=q.x and r.lambda=q.lambda and r.nu=q.nu)
      then survivors #:= j
      fi { gather those expanding to themselves }
    ; vec: { value of loop body }
      for i in regular_extblock
      do if find(final_subset,i).>= then Q[i].s_to_minus_1 else 0 fi od
    od
  , reg_size = #regular_extblock
  in
{  let ()=prints("survivors:", survivors, "  reg_size:", reg_size) in
  let ()=prints("columns:", #columns, " ", columns) in }
  ( regular_extblock, first(reg_size,(int i):regular_extblock[i]=p)
  , KL_mat,polys,stops
  , survivors
  , matrix((#survivors,reg_size) { slice out the surviving rows: }
{      ,(int i,int j) int:prints("i,j:", i, ",", j); columns[j][survivors[i]] }
          ,(int i,int j) int: columns[survivors[i]][j]
          )
  )

set KL_P_polynomials (Param p, mat delta) = i_poly_mat:
  let (block,,P,)=cook_KL_block(KL_block(p,delta))
  in
  for row@i in P
  do let len_i=length(block[i]) in
    for entry@j in row
    do minus_1^(length(block[j])-len_i)*entry { undo signs }
    od
  od

set KL_P_polynomials_at_minus_one (Param p, mat delta) = mat:
  eval(KL_P_polynomials(p,delta),minus_1)

set KL_P_polynomials ([Param] B_fixed, mat delta) = i_poly_mat:
  assert(all(for p in B_fixed do is_fixed(delta,p) od)
        ,"not all parameters in B_fixed are fixed");
  if #B_fixed=0 then return zero_poly_matrix(0) fi;
  let (block,,P,)=cook_KL_block(KL_block(B_fixed[0],delta))
  then (perm,valid)=permutation(B_fixed,block), n=#block
  in assert(valid,"given [Param] B does not agree with block_of B[0]");
  for i:n
  do let len_i=length(B_fixed[i]), row=P[perm[i]] in
    for j:n
    do minus_1^(length(B_fixed[j])-len_i) { undo signs } * row[perm[j]]
    od
  od

set KL_P_polynomials_at_minus_one ([Param] B_fixed, mat delta) = mat:
  eval(KL_P_polynomials(B_fixed,delta),minus_1)

set KL_P_signed_polynomials (Param p, mat delta) = i_poly_mat:
  let (,,P,)=cook_KL_block(KL_block(p,delta)) in P

set KL_P_signed_polynomials_at_minus_one (Param p, mat delta) = mat:
  eval(KL_P_signed_polynomials(p,delta),minus_1)

set KL_P_signed_polynomials([Param] B, mat delta) = i_poly_mat:
  assert(all(for p in B do is_fixed(delta,p) od)
        ,"not all parameters in B_fixed are fixed");
  if #B=0 then return zero_poly_matrix(0) fi;
  let (block,,P,polys)=cook_KL_block(KL_block(B[0],delta))
  then (perm,valid)=permutation(B,block), n=#block
  in assert(valid,"given [Param] B does not agree with block_of B[0]");
  for i:n do let row=P[perm[i]] in for j:n  do row[perm[j]] od od

set KL_P_signed_polynomials_at_minus_one([Param] B, mat delta) = mat:
  eval(KL_P_signed_polynomials(B,delta),minus_1)

{*DEFINE* the Q-polynomials as inverse of the signed P-matrix}
{see dual.at for a different approach}

set KL_Q_polynomials (Param p, mat delta) = i_poly_mat:
  upper_unitriangular_inverse (KL_P_signed_polynomials(p,delta))
set KL_Q_polynomials ([Param] B, mat delta) = i_poly_mat:
  upper_unitriangular_inverse (KL_P_signed_polynomials(B,delta))
