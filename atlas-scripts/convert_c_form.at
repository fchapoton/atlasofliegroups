<basic.at
<extended.at { for E@(mat,Param) }

{ commands for converting from c-form to hermitian-form}
{ Compute (lambda+rho) restricted to torus T }

{ lambda\in X^*+rho =>
    one can define a parameter with this lambda, as p=param(x,lambda-rho,0)
  then infinitesimal_character(p)=(1+theta)*lambda/2
  which is lambda restricted to T-tilde
  apply this with lambda itself returns (1+theta)*lambda/2  (on T-tilde)
  apply this with lambda=rho,   returns (1+theta)*rho/2     (on T-tilde)
  then the sum is (1+theta)(lambda+rho)/2 on T
}
set lambda_plus_rho_res_T (KGBElt x,ratvec lambda) = ratvec:
  (1+x.involution)*(lambda+rho(x.root_datum))/2

{ mu(p) is the value of the lowest K-type of p, evaluated at x(p) }
{ formula: mu(p) = < torus_factor(x)+rho^\vee , (1+theta_x)(lambda+rho)/2 > }
set mu (Param p) = rat:
  (p.x.torus_factor+p.real_form.rho_check) * lambda_plus_rho_res_T(p.x,p.lambda)

{  converting to Hermitian forms in unequal rank case  }

{ assumption: theta=involution(x) commutes with delta and x has no complex
  descents (this holds for x=x(p) when p is finalized parameter with nu(p)=0)
  Then the set of positive real roots is delta-invariant; the following
  function computes the number of unordered pairs $P=\{ alpha,delta(alpha) \}$
  with alpha a positive real real and < alpha^vee , delta*alpha > = 0,
  whose parity gives sign of delta acting on Wedge^top(positive real roots).
  Each orthogonal pair $P$ contributes $-1$ to sign, others contribute nothing:
    if <alpha^vee,delta*alpha> = -1, contributes 1 by computation in SL(3,R):
      -1 from pair is cancelled by -1 from action on
      [X_alpha,X_delta(alpha)=X_{alpha+delta(alpha)}
    if delta(alpha)=alpha, contributes 1 by reduction to simple case,
  note: every really-simple root (simple among real roots) is actualy simple
}
set number_real_orthogonal_pairs (KGBElt x, mat delta) = int:
  let rd=x.root_datum, theta=x.involution in
  assert(delta*theta=theta*delta
        ,"Cartan involution does not commute with delta");
  assert(no_Cminus_roots(x)
        , "Not defined unless all complex roots are type C+");
  for alpha in real_posroots(rd,theta)
  do int:
    let pairing=coroot(rd,alpha)*delta*alpha in
    assert(=pairing or pairing=-1 or pairing=2 { since we paired \emph{roots} }
          ,"invalid pairing of root and coroot");
    #=pairing { count zero pairings }
  od.sum.half { compensate for each pair being counted twice }

{ this is a temporary correction of the incorrect dim_u_cap_p }

set DIM_u_cap_p(KGBElt x) = int:
  let sum=0/1 in
  for alpha in posroots(root_datum(x)) do
    if is_complex(alpha,x) then sum +:= 1/2
    elif is_noncompact_imaginary(alpha,x) then sum+:=1
    fi
  od; rat_as_int(sum)


{ function |mu| below was intially described in Vogan in email of Oct 25, 2016
  with subject: mu(p); it has been significantly modified since
  It is a sum of rational terms, for which eventually differences (which should
  be integer) will serve as exponents of |s|, therefore interpreted modulo 2
  To facilitate analysis of the terms |mu_terms| returns them as a list of 3
}

set mu_terms  (Param p,mat delta) = [rat]:
  assert(=nu(p),"nu(p)!=0");
  let E=E(delta,p), x=x(p) then g_l=E.g-E.l
  in
  [ { lambda_rho_term = } (g_l-rho_check_r(x))*(E.lambda_rho)
  , { tau_term        = } (E.l*(delta-1)*E.tau)/2
  , { dim_term        = } DIM_u_cap_p(x)
 { , { scalar_term     = } {number_real_orthogonal_pairs(x,delta)} 0 }
    { new_term used to be |g_l*rho_r(x)*2| before it fell out of grace }
 { , { brand_new_term  = } {(E.t*rho_r(x))/2}{ also fell out of grace } 0 }
  ] { the sum of these will be interpreted modulo 2/1 }


set mu (Param p,mat delta) = rat: sum(mu_terms(p,delta))

set print_mu (Param p) = void:
  let terms=mu_terms(p,p.real_form.distinguished_involution) in
  prints(p, "    ", 1 , "     ", "  ", terms[0], "  ", terms[1]
        , "     ", terms[2], {"     ", terms[3], "     "
        ,   terms[4], "   ",}   sum(terms))

set print_mus (ParamPol P) = void:
  let delta=real_form(P).distinguished_involution
  then mu_0=mu(last_param(P),delta)
  in
  prints("columns are:", new_line
        , "coeff*p           lambda_rho term    tau  term      " ##
          "  dim term    "{     #real_pairs} ##  {" brand new term" ##}
          "  sum  s^sum*coeff", new_line);
  for c@p in P
  do let terms=mu_terms(p,delta) in let ep=E(delta,p) then mu=sum(terms) in
    prints(c,"*", p, "     ", "  ", terms[0], "  ", terms[1], "     "
          , terms[2], "     "{, terms[3], "     ", terms[4], "   "}, mu
          , "  ", c*s^(rat_as_int(mu-mu_0)));
	  prints({"    gamma = ",ep.gamma,} "  lambda_rho =  ",ep.lambda_rho
                , "  tau = ",ep.tau
                , "  g - l - rho_check_r = ", ep.g - ep.l - rho_check_r(ep.x)
                , new_line)
  od

{ParamPol is assumed to be the formula for the (twisted) c-form of a representation}
{.convert (twisted) c-form on ParamPol to hermitian form, requires p0 for normalization.}
set convert_cform_hermitian (ParamPol P, Param p0)= ParamPol:
  if =#P then P  
  else let a_mu = mu(p0,real_form(P).distinguished_involution) 
    then delta=real_form(p0).distinguished_involution 
    then result = P.real_form.null_module +
         for w@p in P do (w*s^(mu(p,delta)-a_mu).rat_as_int,p) od in result fi

{use last_param(P) for p0}
set convert_cform_hermitian (ParamPol P)= ParamPol:
  if =#P then P else convert_cform_hermitian(P,last_param(P)) fi

