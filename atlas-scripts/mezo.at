set mezo_verbose=true

set b(Param p)=
let rd=p.root_datum then
theta=p.x.involution then
gamma=p.infinitesimal_character in
##for alpha in rd.posroots do
 let alpha_check=coroot(rd,alpha) in
 prints(alpha_check, " ", is_integer(alpha_check*gamma), " ", is_positive_root(rd,theta*alpha_check));
 if not is_integer(alpha_check*gamma) and  is_positive_root(rd,theta*alpha_check) then [alpha_check] else [] fi od

set l(Param p)=
let rd=p.root_datum then
G=p.real_form then
gamma=p.infinitesimal_character then
rd_int=integrality_datum(rd,gamma) then
theta=p.x.involution then
split_rank=p.x.Cartan_class.split_rank then
constant=split_rank(G.fundamental_Cartan) then
roots=##for alpha in rd_int.posroots do
 if is_negative_root(rd_int,theta*alpha) then [alpha] else [] fi od
in (#roots,split_rank,constant, rat_as_int((#roots+split_rank-constant)/2))

set delta_l_int_long(Param p,mat delta)=(int,int,int,rat):
if not is_fixed(delta,p) then (-1,-1,-1,-1) else
let rd=p.root_datum then
G=p.real_form then
ic=inner_class(rd,delta) then
rd_H_check=K_0(ic.quasicompact_form).root_datum then
rd_H=dual(rd_H_check) then
H=rd_H.split_form then
{()=prints("H=",H) then}
x_G=KGB(G,0) then
{proj_H=cocharacter_lattice_K(ic) then}
proj_H=projection_to_K_matrix(x_G) then
G=p.real_form then
gamma=p.infinitesimal_character then
{()=prints("p=",p) then}
{()=prints("proj_H:",proj_H) then}
{()=prints("gamma:", gamma) then}
gamma_H=proj_H*gamma then
{()=prints("gamma:H=",gamma_H) then}
theta=p.x.involution then
theta_H=proj_H*theta*right_inverse(proj_H) then
{()=prints("theta_H:", theta_H) then}
compact_rank_H=#kernel(theta_H-1) then
constant=split_rank(H.fundamental_Cartan) then
roots=##for alpha in rd_H.posroots do
 if is_positive_root(rd_H,theta_H*alpha) then [alpha] else [] fi od
in (#roots,compact_rank_H,constant, (#roots+compact_rank_H-constant)/2)
fi

set delta_l_int(Param p,mat delta)=int:
let (,,,x)=delta_l_int_long(p,delta) in rat_as_int(x)

set test_delta_length_int(RealForm G)=void:
{G should be GL(n,R)}
let delta=G.distinguished_involution in
prints("G=",G);
prints("testing delta_length_int, all reps with infchar=rho");
prints("-1 means the representation is not delta=fixed",new_line);
void:for p in all_parameters_gamma(G,rho(G)) do prints(p, " ", delta_l_int_long(p,delta), " ", delta_l_int(p,delta))
od

{preliminary non-integral version,
not correct:

set delta_l(Param p,mat delta)=
if not is_fixed(delta,p) then (-1,-1,-1,-1) else
let rd=p.root_datum then
ic=inner_class(rd,delta) then
K=K_0(ic.quasicompact_form) then
x=KGB(K,0) then
proj_K=projection_to_K_matrix(x) then
G=p.real_form then
gamma=p.infinitesimal_character then
gamma_K=proj_K*gamma then
rd_delta=K.root_datum then
rd_int_delta=integrality_datum(rd_delta,gamma_K) then
theta=p.x.involution then
theta_delta=proj_K*theta*right_inverse(proj_K) then
split_rank=p.x.Cartan_class.split_rank then
constant=split_rank(K.fundamental_Cartan) then
roots=##for alpha in rd_int_delta.posroots do
 if is_negative_root(rd_int_delta,theta*alpha) then [alpha] else [] fi od
in (#roots,split_rank,constant, rat_as_int((#roots+split_rank-constant)/2))
fi
}


set extended_composition_series (Param p,[Param] B,mat delta) =
   let (I_delta,g,complete_indices,delta_action)=tabulate_indices(B,delta)
   then index=find(complete_indices,(find(B,p),1))
   then Q=big_KL_Q_polynomials(B,delta)
in ##for i:#complete_indices
   do let f=Q[i][index] in
      if #f>0 then [(complete_indices[i],f)] else [] fi od

{multiplicty of pi_generic^+ (extended parameter)
in extended standard parameter(p)^+
}
set ext_mult_generic(Param p,[Param] B,mat delta)=int:
if  not is_fixed(delta,p) then
if mezo_verbose then  prints("parameter is not fixed:") fi;0 else
let ((a,b),c)=extended_composition_series(p,B,delta)[0] in
if mezo_verbose then
 (prints("p: ",p);
 prints("p_0: ", B[0]);
 prints("sign: ", b); 
 prints("multplicity: ",c))
fi;
b*evaluate_at_1(c)
fi

set ext_mult_generic(Param p,mat delta)=
let B=singular_block_of(p) in ext_mult_generic(p,B,delta)

set test_conjecture_A_2([Param] B,mat delta)=
   let (I_delta,g,complete_indices,delta_action)=tabulate_indices(B,delta) then
    Q=KL_Q_polynomials(B,delta) then
    B_fixed=##for p in B do if is_fixed(delta,p) then [p] else [] fi od in
    for p@index in B_fixed do
{    let index=find(B,p) then } let
    p_0=B[0] then
    length_p=length(p) then
    length_p_0=length(p_0) then
    delta_length_p=delta_l_int(p,delta) then
    delta_length_p_0=delta_l_int(p_0,delta) then
    length_exponent=length_p-delta_length_p+length_p_0-delta_length_p_0 then
    f=Q[0][index] then
    c=evaluate_at_1(f) in
    if mezo_verbose then
     prints("---------------------",new_line,"p=",p);
     prints("index=",index);
     prints("f=",poly_format(f,"q"));
     prints("mult=",c);
     prints("lengths: [", length_p, " ", delta_length_p, " ", length_p_0, " ", delta_length_p_0,"]");
     prints("c: ", c);
     prints("length exponent: ", length_exponent);
     prints("test: ", c=(-1)^length_exponent)
     fi;
    c=(-1)^length_exponent
  od
