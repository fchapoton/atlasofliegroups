{conjecture (in some cases) about the size of the weak
unipotent Arthur packet for a split group. The statement
of a more general conjecture is not precisely known}

<weak_packets.at
<nilpotent_centralizer.at


{------------include information about dual_Aq cells  ------}

{this applies to output of weak_packet(...) or each entry
of output of weak_packets(...)
returns true if each cell which occurs satisfies is_dual_Aq(cell)}
set packets_disjoint( ([([Param],[WCell])],[(int,int,Param)]) blocks_and_cells_and_packet)=
let (bc,packet)=blocks_and_cells_and_packet then
blocks=blocks(packet) then
cells=cells(packet) then
m=mult(packet) in
all(##for b in blocks do
 ##for c in cells do
  let (params,cells)=bc[b] in
  if m(b,c)!=0 then [is_dual_Aq(params,cells[c])] else [] fi
 od
od
)

{dual nilpotents with A(O)=1}
set simply_connected_dual_orbits(RootDatum rd)=[ComplexNilpotent]:
##for O in rd.dual_orbits do
if #O.component_datum.orders=1 then [O] else [] fi od

{if A(O^vee)=1 and all Arthur packets for O^vee are disjoint
then there is a guess for the size of the weak packet of O^vee
based just conjugacy classes of elements of H=Cent(O^vee)
of order 1 or 2
see notesOnUnipotentParameters.pdf in Dropbox
return value:
(int a,[int] v ,int c)
a=#conjugacy classes of H), if it isn't 1 we don't care
v=data for computing the guess
c=guess for order of Pi(Psi)
this is only reasonable if A(O^vee)=1 (which is included in the output)
and the packets for O^vee are disjoint (which is not, since this depends
on actually computing the weak packet
}
set number_unipotents_guess(ComplexNilpotent O_check)=
let H=centralizer(O_check) then
real_forms=real_forms(compact_form(H)) then
strong_real_forms=strong_real_forms_same_type(compact_form(H))
{this is conjugacy classes x with x^2=1} then
my_real_forms=for i in strong_real_forms do real_forms[i] od
{list of corresponding real forms, with multiplicity} then
rv=for X in my_real_forms do  2^components_rank(X)
{order of component group of Cent_H(x)} od in
(#O_check.component_datum.orders,rv,sum(rv))

{test the conjectural formula for order of Pi(Psi) is correct}
set test_conjecture([([([Param],[WCell])],[(int,int,Param)])] wp,RealForm G)=
let orbits=simply_connected_dual_orbits(G) in
for O_check@i in orbits do
let weak_packet=wp[i] then
is_disjoint=packets_disjoint(weak_packet) then
number_unipotents=let (,x)=weak_packet in #x then
(A,data, guess)=number_unipotents_guess(O_check) then
rv=if not is_disjoint then 0 elif number_unipotents=guess then 1 else -1 fi
in
(A,data,guess,number_unipotents,is_disjoint,rv) od

set test_conjecture_report([([([Param],[WCell])],[(int,int,Param)])] wp,RealForm G)=
{assuming: wp is for simply_connected_dual_orbits(G)}
let tc=test_conjecture(wp,G) in
prints("Testing conjecture about size of weak Arthur packets for ",new_line, " ",G,new_line,
"i:  number of orbit (with A(O)=1)",new_line,
"data: combinatorial data derived from the orbit",new_line,
"guess: conjectural size of weak Arthur packet",new_line,
"actual: size of weak Arthur packet",new_line,
"A: A(O), if it isn't 1 the conjecture doesn't apply",new_line,
"disjoint: Arthur packets are disjoint, if false the conjecture doesn't apply",new_line,
"conjecture: validity for given orbit");
prints(new_line,"Orbits for G with A(O)=1:");
show_nilpotent_orbits(simply_connected_dual_orbits(G));
prints();
tabulate(["i","data","guess","actual","A","disjoint","conjecture"] #
 for (a,data,guess,number,id,rv)@i in tc do
 [i.to_string,data.to_string,guess.to_string,number.to_string,a.to_string,id.to_string,
 if rv=1 then "true" elif rv=-1 then "false" else "N/A" fi] od);
 prints("-------------------------------------------------------------")

set test_conjecture_report(RealForm G)=void:
test_conjecture_report(weak_packets(simply_connected_dual_orbits(G),G),G)

set test_conjecture_report([RealForm] groups)=void:
for G in groups do
 let wp=weak_packets(simply_connected_dual_orbits(G),G) in
 test_conjecture_report(wp,G)
od

set weak_packet_report(RealForm G,bool conjecture)=[([([Param],[WCell])],[(int,int,Param)])]:
let wp=weak_packets(G) in
prints(new_line,"===============================================================================");
let orbits=G.dual_orbits in
show_nilpotent_orbits(orbits);prints();
show_short(wp);
show(wp);
show_long(wp);
if conjecture then
 let wp_sc = ##for weakpacket@i in wp do
 let O=orbits[i] in  if #O.component_datum.orders=1 then [weakpacket] else [] fi od in
test_conjecture_report(wp_sc,G) fi;
prints(export(parameters(wp)));
wp

set weak_packet_report_ind(RealForm G,bool conjecture)=[([([Param],[WCell])],[(int,int,Param)])]:
let wp=weak_packets(G) then
ind=induced_unipotents(G) in
prints(new_line,"===============================================================================");
let orbits=G.dual_orbits in
show_nilpotent_orbits(orbits);prints();
show_short(wp);
show(wp);
show_long(wp,ind);
if conjecture then
 let wp_sc = ##for weakpacket@i in wp do
 let O=orbits[i] in  if #O.component_datum.orders=1 then [weakpacket] else [] fi od in
test_conjecture_report(wp_sc,G) fi;
prints(export(parameters(wp)));
wp