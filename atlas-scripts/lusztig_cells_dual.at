{Lusztig only: old version, on dual side}
set sigma_lusztig_dual(RootDatum G,CharacterTable ct_G,SpringerTable st_G_v,ComplexNilpotent O_v,RootDatum M_v,vec H_M_v,ratvec y)=
{variant: add center of M_v to y}
let ()=if sigma_lusztig_verbose then
   prints(new_line,"-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",new_line,"Computing sigma_lusztig_dual: ",new_line,"O_v=", O_v.diagram,new_line,
   "G=", G,new_line, "st_G_v: ", st_G_v.root_datum, new_line,"M_v=", M_v, new_line, "H_M_v=",H_M_v,new_line,"y=", y) fi
in if y.is_integer then  {L_v=G_v, L=G, don't need induction}
 let ()=if sigma_lusztig_verbose then prints("y is integer, no induction")  fi then
 sigma_v=st_G_v.ct.characters[st_G_v.springer(O_v)] then
 ()=if sigma_lusztig_verbose then prints("sigma_v (no induction): ", sigma_v) fi  then
 sigma= exchange_long_short(ct_G,st_G_v.ct.tensor_sign(sigma_v)) then
 ()=if sigma_lusztig_verbose then prints("exchange/tensor sign: ", sigma) fi in
 [ct_G.character_index(sigma)]
else  {need induction; compute L, sigma_lusztig_dual, truncated_induce}
 let ()=if sigma_lusztig_verbose then prints("need induction: ")  fi in
 let G_v=O_v.root_datum then
 ()=if sigma_lusztig_verbose then prints(("y=",y) ) fi then
 L_v=centralizer(G_v,y) then
 ()=if sigma_lusztig_verbose then prints(("L_v=",L_v, new_line, "G_v=", G_v) ) fi then
 {O_M_v=ComplexNilpotent:(M_v,(),H_M_v) -> saturation -> O_L_v
  O_L_v has the same H=H_M_v, but made L_v-dominant}
 H_L_v=dominant(H_M_v,L_v) then
 O_L_v=ComplexNilpotent:(L_v,(),H_L_v) then
 ()=if sigma_lusztig_verbose
   then prints(("L_v=", L_v,new_line,"H_L_v=", H_L_v,new_line,"O_L_v:", O_L_v.H, " ", O_L_v.diagram) ) fi then
 L=dual(L_v) then
 roots_L=for alpha in L.simple_roots do find(G.roots,alpha) od then
 {avoid computing L.springer_table if orbit_L =0 or principal, only need L.character_table}
 sigma_lusztig=
 if O_L_v=L_v.zero_orbit then prints("zero orbit");   L.character_table.trivial
 elif O_L_v=L_v.principal_orbit then L.character_table.sign
 else  {not 0 or principal orbit: need to compute L.springer_table}
  let ()=if sigma_lusztig_verbose then prints(("computing st_L_v:") ) fi then
  st_L_v=L_v.springer_table then
  ()=if sigma_lusztig_verbose then prints(("done computing L_v.springer_table (not including generic degree)") ) fi then
{ st_L_v=update_generic_degrees(L_v.split_form,st_L_v_0) then 
  ()=if sigma_lusztig_verbose then prints("done updating fake degrees for L_v_0") fi then }
  sigma_lusztig_v=st_L_v.springer(O_L_v) then
  char=st_L_v.ct.characters[sigma_lusztig_v] then
  sigma_lusztig_0=st_L_v.ct.tensor_sign(char) then
  ex=exchange_long_short(L_v.character_table,sigma_lusztig_0) in
  let ()=if sigma_lusztig_verbose then prints("sigma_lusztig_v: ", sigma_lusztig_v, new_line, "char: ", char, new_line, "sigma_lusztig_0: ", sigma_lusztig_0, new_line,
  "ex: ", ex) fi in ex
 fi  {end if O_L_v=L_v.zero_orbit} then
 {now induce sigma_lusztig}
 { ()=    assert(#(ct_G.generic_degrees)>0,"need to compute fake degrees for ct_G (ct:=update_generic_degrees(G,ct) or st:=update_generic_degrees(G,st)") then }
 {maybe need fake degrees for st_G_v}
{ ()=    assert(#(st_G_v.generic_degrees)>0,"need to compute fake degrees for st_G_v (ct:=update_generic_degrees(G,ct) or st:=update_generic_degrees(G,st)") then}
  degree_function(int j)=ct_G.generic_degree(j) then
  ()=if sigma_lusztig_verbose then prints("inducing character from L:", L) fi then
  ind=induce_character(G,ct_G,roots_L,sigma_lusztig) then
    ()=if sigma_lusztig_verbose then prints("finished inducing character from L:", L) fi then
{  char_indices=truncate_induce_character(G,ct_G,roots_L,sigma_lusztig_dual,degree_function) then}
{ in F4, trying variants:}
  ind_decomposed=ct_G.decompose(ind) then
  desired_generic_degree ={ st_G_v.ct.degrees[st_G_v.springer(O_v)] then}
   let  sigma_v_0_index=st_G_v.springer(O_v) then
   sigma_0_index= exchange_long_short_index(ct_G,st_G_v.ct.tensor_sign_index(sigma_v_0_index)) in
   sigma_0_index then
  ()=if sigma_lusztig_verbose then prints("desired_generic_degree: ", desired_generic_degree) fi then
  char_indices=[int]:
     ##for i:#ind_decomposed do
       if (ind_decomposed[i]>0 and ct_G.has_generic_degree(i) and ct_G.generic_degree(i)=desired_generic_degree) then [i]  else [] fi od then
{     if      (ind_decomposed[i]>0 and ct.generic_degrees[i]=desired_generic_degree) then [i] else [int]:[] fi od }
  ()=if sigma_lusztig_verbose then  prints("O_v: ", O_v.diagram, new_line,"L_v: ", L_v,new_line,"O_L_v: ", O_L_v.diagram,new_line,"sigma_lusztig: ", sigma_lusztig,new_line);
    prints("induced char: ", ind,new_line, "decomposition(1):", ct_G.decompose(ind));ct_G.view_char(ind);
    prints("minimal degree terms in induced: ", char_indices) fi then
 ()=if sigma_lusztig_verbose then prints("truncated induce (sigma_lusztig): ", "G=",G,new_line,"roots_L: ", roots_L, " sigma_lusztig=", sigma_lusztig) fi then
  char_index=   if =#char_indices then -1
    else
     let char_L_0=ct_G.characters[char_indices[0]] then
     ()=if sigma_lusztig_verbose then prints("character of L: ", char_indices[0], new_line, char_L_0) fi in
     ct_G.character_index(char_L_0)
    fi
  in if sigma_lusztig_verbose then prints("char_index=", char_index) fi;char_indices
fi  {end if y.is_integer}


{run over all ratvecs from component_representatives(orbit)}
set lusztig_cell_dual(RootDatum G,CharacterTable ct_G,SpringerTable st_G_v,ComplexNilpotent O_v)=
{prints("sigma_lusztig_dual for: ", O_v,"  ", O_v.diagram,new_line, " st_G_v:",st_G_v.root_datum);}
{sort_u: avoid duplicates from A-bar(O_v)\ne A(O_v)}
sort_u(for (M_v,H_M_v,y) in component_representatives_plus(O_v) do
 let ()=if sigma_lusztig_verbose then prints("computing sigma_lusztig_dual for M_v=", M_v, new_line,"H_M_v=",H_M_v,new_line, "y=", y)  fi in
    {let ()=if sigma_lusztig_verbose then prints("calling sigma_lusztig_dual(x):", new_line,"G: ", G, new_line,"O_v: ", O_v.diagram, " ", O_v.dim_nilpotent,
   "st:", st_G_v.root_datum, new_line,"M_v: ", M_v, new_line, "H_M_v", H_M_v, new_line, "y: ", y) fi in}
 sigma_lusztig_dual(G,ct_G,st_G_v,O_v,M_v,H_M_v,y) od)


set lusztig_cells_dual(RootDatum G,CharacterTable ct_G,SpringerTable st_G_v,[ComplexNilpotent] dual_orbits)=
for orbit_v in G.dual_orbits do
 for (M_v,H_M_v,y) in component_representatives_plus(orbit_v) do
   let j_values=sigma_lusztig_dual(G,ct_G,st_G_v,orbit_v,M_v,H_M_v,y) in
  (orbit_v,M_v,H_M_v,y,j_values)
 od
od

set lusztig_cells_dual_plus(RootDatum G,CharacterTable ct_G,SpringerTable st_G_v,[ComplexNilpotent] dual_orbits)=
for orbit@counter in dual_orbits do
let ()=if sigma_lusztig_verbose then prints("loop in lusztig_cells_dual_plus, dual_orbit=", orbit.diagram) fi in
let basis=orbit.Bala_Carter_Levi.radical_basis in
 let variants=if =#basis then [null(G.rank)] else all_sums(basis) fi in
 ##for (M,H_M,y) in component_representatives_plus(orbit) do
   for v in variants do
     let ()=if sigma_lusztig_verbose then prints("y=", y, new_line, "v=",v/2) fi  in
     let ()=if sigma_lusztig_verbose then prints("lusztig_cell_plus", new_line, "orbit: ", orbit.diagram,
     basis, new_line,"M=", M, new_line,"H_M=",H_M,new_line, "y=", y)  fi in
     let j_values=sigma_lusztig_dual(G,ct_G,st_G_v,orbit,M,H_M,y+v/2)
 in (orbit,M,H_M,y,v/2,j_values)
od
 od od

set show_lusztig_cells_dual(RootDatum G,CharacterTable ct_G,SpringerTable st_G_v,[ComplexNilpotent] dual_orbits)=void:
let all=lusztig_cells_dual(G,ct_G,st_G_v,dual_orbits) then
table_header=["O","dim","i","rd_int","M_v","H_M_v","v","L_v","sigma(s)","dim","deg","gdeg","char=ct.characters[sigma[0]]"] then
table=
##for i:#all do 
 let data=all[i] in
 for j:#data do
  let (orbit_v,M_v,H_M_v,y,j_values)=data[j] in
  if =#j_values then
   [[orbit_v.diagram.to_string,
    orbit_v.dim_nilpotent.to_string,
    i.to_string,
    integrality_datum(orbit_v).nice_format,
    M_v.nice_format,
    H_M_v.compact_ratvec,
    y.compact_ratvec,
    centralizer(G,y).nice_format,
    "sigma=[]",
    "x",
    "x",
    "x",
    "x"
   ]]
  else
   for k in j_values do
   [orbit_v.diagram.to_string,
    orbit_v.dim_nilpotent.to_string,
    i.to_string,
    integrality_datum(orbit_v).nice_format,
    M_v.nice_format,
    H_M_v.compact_ratvec,
    y.compact_ratvec,
    centralizer(G,y).nice_format,
    "sigma=" +
     if #j_values=1 then k.to_string else
     j_values.to_string + ":" + k.to_string
    fi,
    dimension(st_G_v.ct,k).to_string,
    st_G_v.ct.degrees[k].to_string,
    if st_G_v.ct.has_generic_degree(k) then st_G_v.ct.generic_degree(k).to_string else "*" fi ,
    st_G_v.ct.character(k).to_string
   ]
   od {for k in j_values}
   fi
   od  {/for i:#data}
 od {for orbit_v}
in {table=[[string]]}
tabulate(
["O","dim","i","rd_int","M_v","H_M_v","v","L_v","sigma","dim","deg","gdeg","char"]#
##table)

set show_lusztig_cells_dual(RealForm G)=
let ct_G=character_table(G) then
()=update_generic_degrees(ct_G,G) then
st_G_v=G.dual.springer_table in
show_lusztig_cells_dual(G,ct_G,st_G_v,G.dual.orbits)

set show_lusztig_cells_dual_plus(RootDatum G,CharacterTable ct_G,SpringerTable st_G,[ComplexNilpotent] dual_orbits)=
prints("G=", G.nice_format, new_line, "#dual_orbits: ", #dual_orbits);
let all_data=lusztig_cells_dual_plus(G,ct_G,st_G,dual_orbits)     {[[(M,H_M,y,j_values)]]} then
table_header=["O","dim","i","rd_int","M","H_M","v","L","sigma(s)","dim","deg","gdeg","char=ct.characters[sigma[0]]"] then
table=
##for i:#all_data do
 let data=all_data[i] in
 for j:#data do
  let (orbit,M,H_M,y,v,j_values)=data[j] in
  if =#j_values then
   [[orbit.diagram.to_string,
    orbit.dim_nilpotent.to_string,
    i.to_string,
    integrality_datum(orbit).nice_format,
    M.nice_format,
    H_M.compact_ratvec,
    y.compact_ratvec,
    v.compact_ratvec,
    centralizer(G,y).nice_format,
    "sigma=[]",
    "x",
    "x",
    "x",
    "x"
   ]]
  else
   for k in j_values do
   [orbit.diagram.to_string,
    orbit.dim_nilpotent.to_string,
    i.to_string,
    integrality_datum(orbit).nice_format,
    M.nice_format,
    H_M.compact_ratvec,
    y.compact_ratvec,
    v.compact_ratvec,
    centralizer(G,y).nice_format,
    "sigma=" +
     if #j_values=1 then k.to_string else
     j_values.to_string + ":" + k.to_string
    fi,
    dimension(st_G.ct,k).to_string,
    st_G.ct.degrees[k].to_string,
    st_G.ct.generic_degree(k).to_string,
    st_G.ct.character(k).to_string
   ]
   od {for k in j_values}
   fi
   od  {/for i:#data}
 od {for orbit}
in {table=[[string]]}
tabulate(
["O","dim","i","rd_int","M","H_M","y","v","L","sigma","dim","deg","fdeg","char"]#
##table)







{
{
{show lusztig cells, running over given list of dual nilpotents}
{old version, dual side}
set show_lusztig_cells_dual(RootDatum G,CharacterTable ct_G,SpringerTable st_G_v,[ComplexNilpotent] dual_orbits)=void:
prints("G=", G.nice_format, new_line, "#orbits: ", #dual_orbits);
tabulate(
["O^v","dim","i","rd_int","M","H_M","v","L","sigma","dim","deg","gdeg","char"]#
##for O_v@counter in dual_orbits do
  let ()=  if sigma_lusztig_verbose then prints(new_line, "------------------------------------------------------------",new_line,
  "orbit #",counter,": ", O_v.root_datum.nice_format,
        " H=", O_v.H, new_line,"diagram=", O_v.diagram,new_line, "normalized diagram=", O_v.diagram_normalized) fi 
	in
  let data=
  for (M_v,H_M_v,y) in component_representatives_plus(O_v) do
    let j=sigma_lusztig_dual(G,ct_G,st_G_v,O_v,M_v,H_M_v,y) in  (M_v,H_M_v,y,j)
  od
  in
  for i:#data do
   let (M_v,H_M_v,y,j)=data[i] then
   sigma=
    if j=-1 then [] else ct_G.characters[j] fi in
   [O_v.diagram.to_string,
    O_v.dim_nilpotent.to_string,
    i.to_string,
    integrality_datum(O_v).nice_format,
    M_v.nice_format,
    H_M_v.compact_ratvec,
    y.compact_ratvec,
    centralizer(G,y).nice_format,
    "sigma="+j.to_string,
    if j=-1 then "x" else dimension(ct_G,j).to_string fi,
    if j=-1 then "x"  else ct_G.degrees[j].to_string fi,
    if j=-1 then "x"
     { elif #ct_G.generic_degrees>0 then ct_G.generic_degrees[j].to_string }
else ct_G.generic_degree(j).to_string
{     else "x"} fi,
    sigma.to_string]
  od  {/for i:#data}
 od {for O_v})



set show_lusztig_cell_dual(RootDatum G,CharacterTable ct_G,SpringerTable st_G_v,ComplexNilpotent dual_orbit)=void:
 show_lusztig_cells_dual(G,ct_G,st_G_v,[dual_orbit])
set show_lusztig_cell_dual(RootDatum G, CharacterTable ct_G,ComplexNilpotent O_v)=void:show_lusztig_cell_dual(G,ct_G,G.dual.springer_table,O_v)
set show_lusztig_cell_dual(RootDatum G, ComplexNilpotent O_v)=void:show_lusztig_cell_dual(G,G.character_table,G.dual.springer_table,O_v)
set show_lusztig_cell_dual(ComplexNilpotent O_v)=void:show_lusztig_cell_dual(O_v.root_datum.dual,O_v)
set show_lusztig_cells_dual(RootDatum G,CharacterTable ct)=void:show_lusztig_cells_dual(G,ct,G.dual.springer_table,G.dual_orbits)

set show_lusztig_cells_dual(RealForm G)=void:
let st=G.springer_table in
update_generic_degrees(st.ct,G);
show_lusztig_cells_dual(G,st.ct,G.dual.springer_table,
   for O in st.orbits do let O_dual=st.dual_map(O) in orbit_by_diagram(G.dual,O_dual.diagram_normalized) od)

set show_lusztig_cells_dual(RootDatum G,SpringerTable st_G,SpringerTable st_G_v)=void:
show_lusztig_cells_dual(G,st_G.ct,st_G_v,
for O in st_G.special_orbits do let O_dual=st_G.dual_map(O) in orbit_by_diagram(G.dual,O_dual.diagram_normalized)
od)


{for convenience:}
{set init(RootDatum G)=(CharacterTable,SpringerTable,[ComplexNilpotent]):
let ct_0=G.character_table then
st_v_0=G.dual.springer_table then
ct=update_generic_degrees(G.split_form,ct_0) then
st_v=update_generic_degrees(G.dual.split_form,st_v_0) then
orbits=st_v.special_orbits in (ct,st_v,orbits)}
{
set dual_special_orbits_indexed(RootDatum G,SpringerTable st_G_v)=([int],[ComplexNilpotent]):
special_orbits_indexed(G.dual,st_G_v)
set dual_special_orbits_indexed(RootDatum G)=([int],[ComplexNilpotent]):dual_special_orbits_indexed(G,G.dual.springer_table)
set dual_special_orbits(RootDatum G,SpringerTable st_G_v)=[ComplexNilpotent]:special_orbits(G.dual,st_G_v)
set dual_special_orbits(RootDatum G)=[ComplexNilpotent]:dual_special_orbits(G,G.dual.springer_table)
}
}






