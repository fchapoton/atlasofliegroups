<basic.at
<W_characters.at

{ Compute characters of W-representations on cells, as obtained from W_cells
  also induced characters from Levi subgroups, and the Steinberg character
}

{ Type definitions that facilitate handling output from W_cells }
set_type
[ WCell = ([int] labels, WGraph graph)
, WGraph = [WNode]
, WNode = ([int] tau,[int,int] out_list)
]

{ Description of the cell representation taken from messages/wcells.help

  The Weyl group representation attached to the cell may be described as
  follows. It has a Z basis {L_j} indexed by the cell elements j. If
  root i is in the tau invariant for element j, then

  s_i(L_j) = -L_j.

  If i is not in the tau invariant, then

  s_i(L_j) = L_j + sum_{elements k, i in tau(k)} m_{kj} * L_k.

  where m_{kj} denotes the multiplicity of the edge from k to j.
  That is, m*L_k appears in the sum here if i is in the tau-invariant of
  L_k, and the pair (j,m) appears in the list for row k.

  ([224,247,250,253,256],
  [([0,1,2],[(1,1)]),
  ([0,1,3],[(0,1),(3,1),(4,1)]),
  ([1,2,3],[(3,1)]),([0,2,3],
  [(1,1),(2,1)]),([0,1,2],[(1,1)])])

  0[224]: {1,2,3} --> 1
  1[247]: {1,2,4} --> 0,3,4
  2[250]: {2,3,4} --> 3
  3[253]: {1,3,4} --> 1,2
  4[256]: {1,2,3} --> 1
}

{ matrix of action of of i^th simple reflection on a cell
  a cell is: ([int],[([int],[(int,int)])]) cell,int i)
  as described in the W_cells command in atlas-functions.help}

{. matrix of action of i^th simple reflection on a cell .}
set cell_action (WCell (,graph),int s) = mat:
   let n=#graph then I=id_mat(n)
in n ^ { matrix is given by rows of length n }
   for node@i in graph
   do let row = I[i] { row value for the case that s not in tau invariant } in
      if is_member(node.tau)(s)
      then row[i]:=-1
      ; for (j,mu) in node.out_list
        do if not is_member(graph[j].tau)(s) then row[j]:=mu fi
        od
      fi
   ;  row
   od


{. matrix of action of product of simple reflections on a cell .}
set cell_action (WCell cell,[int] w) = mat:
  let n=#cell.graph in
  if =#w then id_mat(n)
  else let result=cell_action(cell,w~[0]) in
     for i:#w-1 from 1 do result:=cell_action(cell,w~[i])*result od; result
  fi

{. matrix of action of WeylElt on a cell .}
set cell_action(WCell cell,WeylElt w) = mat: cell_action(cell,w.word)

{set data=([WeylElt],[int]):(conjugacy_classes(rd),sizes_of_conjugacy_classes(*))
 pass this to avoid recomputing it }

{. character of representation of W on cell .}
set cell_character (WeylClassTable ct,WCell cell) = [int]:
  for w in ct.class_representatives() do trace(cell_action(cell,w)) od

{. list of characters of representation on list of cells .}
set cell_characters (WeylClassTable ct,[WCell] cells) = [[int]]:
  for cell in cells do cell_character(ct, cell) od

{. matrix of inner products of characters of cell representations .}
set matrix_of_inner_products (WeylClassTable ct,[[int]] characters) = mat:
  let n=#characters
  in matrix((n,n),(int i,int j): ct.inner(characters[i],characters[j]))

set cells_table (WeylClassTable ct,[WCell] cells) = mat:
  matrix_of_inner_products(ct,cell_characters(ct,cells))

set cells_table_augmented (WeylClassTable ct, [WCell] cells) = mat:
  let characters =
    cell_characters(ct,cells) ## [ ct.trivial, ct.sign, ct.reflection ]
  in matrix_of_inner_products(ct,characters)

{. promote w in W(Levi) to W(G) }
set promote (WeylClassTable ct, WeylElt w_L) = WeylElt:
  W_elt(ct.root_datum, matrix(w_L))

{ induction from a Levi factor

  L is a Levi in G, |pi_L| is a class function on W(L)
  we want to compute the class function pi_G=ind_L^G(pi_L) on W(G)

  formula: if C is a conjugacy class for G
  pi_G(C) = |W(G)| / (|W(L)|*|C|)) * \sum |C_j| pi_L(C_j)
  where the sum runs over the W(L)-conjugacy classes in C\cap W(L) (this follows
  from Frobenius reciprocity, pairing pi_L with the indicator function for C)

  In other words the value of |pi_L| on each class C_j in W(L) contributes to
  the induced character value only at the class C of W(G) containing it, and for
  this contribution its character value is multiplied by [W(G):W(L)] * |C|/|C_j|

  algorithm: initialize the result to be the 0-character
  run over conjugacy class representatives in L
  for each conjugacy class representative w_L compute  w_G = class_of (w_L,G)
  and add to the character value at (the class) w_G the  value:
  pi_L(w_L) * index(W(G):W(L))*|conjugacy class of w_L|/|conjugacy class of w|
  The factor by which pi_L(w_L) is mulitplied is integer, as it is the index of
  the centraliser subgroup of w_L in W_L inside its centraliser subgroup of w_G
}

set induce_character(WeylClassTable ct_G,WeylClassTable ct_L,[int] pi_L)= [int]:
   let rd_G= ct_G.root_datum, rd_L=ct_L.root_datum
   then index = rat_as_int(order_W(rd_G)/order_W(rd_L))
   , classes_G=ct_G.class_representatives()  {[WeylElt]}
   , classes_L=ct_L.class_representatives()  {[WeylElt]}
   then values_G= [int]: for c in classes_G do 0 od
   , sizes_G = ct_G.class_sizes()
   , sizes_L = ct_L.class_sizes()
in for w_L@i in classes_L
   do let w_G=conjugacy_class_rep(promote(ct_G,w_L))
      then { j=number(w_G,classes_G) in}
           j=ct_G.class_of(w_G)
   in  values_G[j] +:= pi_L[i] * (index * sizes_L[i]/sizes_G[j]).rat_as_int
   od; for v in values_G do v.rat_as_int od

{the sign representation occurs in S^(nr_of_posroots)(reflection),
and this is the maximum}
{. smallest k so that pi occurs in S^k(reflection) .}
set first_occurrence (WeylClassTable ct, vec character) = int:
  let ref=ct.reflection, rd=ct.root_datum in
  first(nr_of_posroots(rd)+1,
        (int k) bool: ct.inner(character,ct.sym_power(ref,k))!=0 )

{ the Steinberg character (mainly for testing)}

{all 2^n standard Levis }
set standard_Levis (RootDatum rd) = [RootDatum]:
  for S in power_set(rd.all_simples) do Levi_datum(rd,S) od

{alternating sum, over all standard Levis, of induced from trivial
 should equal the sign character (it it does not, this function fails) }
set Steinberg_character(RootDatum rd)=
  let ct_G=W_class_table(rd)
  then result =
     for L in standard_Levis(rd)
     do let ct_L=W_class_table(L) in
        minus_1^semisimple_rank(L) * induce_character(ct_G,ct_L,ct_L.trivial)
     od
     .sum
  in assert(result=ct_G.sign); result
