<Weylgroup.at {for make_no_Cminus}

{----------------norm of K-types------------------}

set make_no_Cminus (K_Type p) = K_type(make_no_Cminus(parameter(p)))

{ K_norm@(ratvec,K_Type) is closely related to height@Param,
  see down a few lines
  There is no dependency on the ratvec argument, but this might be added back
}
set K_norm (ratvec _) = (K_Type->int): (K_Type(x,lambda)):
  let mu=(1+involution(x))*lambda, result=rat:0 in
  for alpha_v in poscoroots(root_datum(x)) do  result+:=abs(alpha_v*mu) od;
  rat_as_int(result/2)

set K_norm (ratvec v,K_Type p) = int: K_norm(v)(p)
set K_norm (ratvec v,Param p) =  int: K_norm(v)(K_type(p))
{ also define K_norm(v) of the (Split,Param) term of a ParamPol }
set K_norm (ratvec v,Split s,K_Type p)=int: K_norm(v)(p)
set K_norm (ratvec v,Split s,Param p)=int:  K_norm(v)(K_type(p))

{ height(Param->int) is defined, indepdent of nu,
  K_norm(Kparam->int) is essentially (height@Param)/2
  precisely: K_norm(K_Type kp)=height(parameter(kp))/2
}
set K_norm (K_Type p) =int: K_norm(rho_check(real_form(x(p))))(p)
set K_norm (Param p)  =int: K_norm(K_type(p))
set K_norm (Split s,K_Type p) = int: K_norm(p)

{
set K_norm (ratvec v) = (ParamPol->int):
  (ParamPol P): int
    let result=0 in
    for p in monomials(P)
    do let m=K_norm(v)(K_type(p)) in
      if m>result then result:=m fi
    od; result
}

{ K_norm of P is the max of K_norm(terms) }
set K_norms (ratvec v) = let norm=K_norm(v) in (K_Type_Pol P) [int]:
  for @p in P do norm(K_type(p)) od

set K_norms (K_Type_Pol P) = [int]: K_norms(rho_check(real_form(P))) (P)

set K_norm (ratvec v,K_Type_Pol P) = int: let norms=K_norms(v) in
  if =P then 0 else max(norms(P)) fi

set K_norm (K_Type_Pol P) =int: K_norm(rho_check(real_form(P)),P)

set leading_terms (ratvec v) = let norm=K_norm(v) in (K_Type_Pol P): K_Type_Pol:
  let max=K_norm(v,P), result=null_module(real_form(P)) in
  for c@p in P do if norm(K_type(p))=max then result+:=c*p fi od; result

set all_K_norms (ratvec v) = let norm=K_norm(v) in (K_Type_Pol P) [int]:
  sort(for c@p in P do norm(K_type(p)) od)

set all_K_norms(K_Type_Pol P) = [int]: all_K_norms(rho_check(real_form(P))) (P)

{ sort [K_Type] by K_norm(v) }
set sort_by_K_norm (ratvec v) = ([K_Type] -> [K_Type]): sort_by(K_norm(v))

set sort_K_Type_Pol_by_K_norm (ratvec v) = let norm=K_norm(v) in
  ([(Split,K_Type)] -> [(Split,K_Type)]): sort_by((Split s,K_Type p):norm(p))

set sort_by_K_norm = ([K_Type] -> [K_Type]): sort_by( K_norm@K_Type )
set sort_by_K_norm = ([(Split,K_Type)] -> [(Split,K_Type)]):
  sort_by( K_norm@(Split,K_Type) )

set print_by_K_norm (ratvec v) = let norm=K_norm(v) in (K_Type_Pol P) void:
  let result=sort_K_Type_Pol_by_K_norm(v)(for c@p in P do (c,K_type(p)) od)
  in for (c,p) in result do prints(split_as_int(c),"*",p," ", K_norm(v)(p)) od

set print_by_K_norm (ratvec v,K_Type_Pol P) = void: print_by_K_norm(v)(P)

set print_by_K_norm (K_Type_Pol P) = void:
  print_by_K_norm(rho_check(real_form(P)),P)

set leading_terms (K_Type_Pol P) = K_Type_Pol:
  leading_terms(rho_check(real_form(P)))(P)
