/*
  This is interactive_lattice.cpp

  Copyright (C) 2004,2005 Fokko du Cloux
  part of the Atlas of Reductive Lie Groups

  For license information see the LICENSE file
*/

#include "interactive_lattice.h"

#include <iostream>
#include <sstream>

#include "arithmetic.h"
#include "input.h"
#include "interactive.h"
#include "lattice.h"
#include "ioutils.h"
#include "prerootdata.h"
#include "smithnormal.h"
#include "topology.h"

/*****************************************************************************

 This module deals with functions specific to the user choosing a sublattice.

******************************************************************************/

namespace atlas {

namespace {

  enum GeneratorError { NoError=0, FormatError, BadDenominator,
			NegDenominator, TooFew };

  GeneratorError checkGenerator(input::InputBuffer& buf, size_t& i,
				latticetypes::LatticeCoeff& d,
				const latticetypes::CoeffList& u);

  void makeOrthogonal(latticetypes::LatticeMatrix&, latticetypes::CoeffList&,
		      const latticetypes::RatWeightList&, size_t);

  std::ostream& printCenter(std::ostream&, const latticetypes::CoeffList&);

  latticetypes::RatWeight readGenerator(size_t n_gen,
					latticetypes::LatticeCoeff d,
					input::InputBuffer& buf);

  input::HistoryBuffer kernelgen_input_buffer;
}

/*****************************************************************************

        Chapter I -- Functions declared in interactive_lattice.h

******************************************************************************/

namespace interactive_lattice {

/*
  In this function, |b| holds a Smith basis of the weight lattice w.r.t. the
  root lattice. In this basis, we have marked the indices where the quotient
  is not zero; |lb| holds a basis of the
  subgroup generated by this subset of |b|, which is Smith w.r.t. the
  purported group lattice; |linvf| holds the corresponding invariant factors.

  Then we replace the part of b corresponding to these indices, by the
  Smith basis thus constructed; this now is a Smith basis of the weight
  lattice w.r.t. the group lattice.

  Finally, we multiply the elements of by their invariant factors, so as
  to get a basis of the group lattice.
*/

void adjustBasis(latticetypes::WeightList& b,
		 const latticetypes::CoeffList& invf,
		 const latticetypes::WeightList& lb,
		 const latticetypes::CoeffList& linvf)

{
  // adjust invariant factors, and replace the elements in b corresponding
  // to lb by the elements of lb scaled by corresponding invariant factor

  for (size_t i=0,j=0; j<invf.size(); ++j)
    if (invf[j] != 1)
    {
      b[j] = lb[i]*linvf[i];
      ++i;
    }
}

/*! \brief
  Gets the generators of X/Q, where Q is the root lattice, from the user.

  It throws an InputError if the interaction with the user does not conclude
  successfully. In that case, d_rwl is not modified.
*/
int getGenerators(latticetypes::RatWeightList& d_rwl,
		  const latticetypes::CoeffList& u)
  throw(error::InputError)
{
  latticetypes::RatWeightList rwl;

  std::string genString;
  interactive::common_input() >> genString;

  if (genString.find("sc") == 0) // match must be a start of string
    return 1; // code for simply connected
  if (genString.find("ad") == 0)
    return 2; // code for adjoint

  std::cout
    << "elements of finite order in the center of the simply connected group:"
    << std::endl;

  printCenter(std::cout,u) << std::endl;

  std::cout << "enter kernel generators, one per line" << std::endl;
  std::cout << "(ad for adjoint, ? to abort):"
	    << std::endl;

  {
    input::InputBuffer& ib=kernelgen_input_buffer;

    while (true) {
      ib.getline(std::cin,"");
      if (hasQuestionMark(ib))
	throw error::InputError();
      genString.clear();
      ib >> genString;
      if (genString.empty()) // done
	break;
      if (genString.find("sc") == 0)
	return 1; // code for simply connected
      if (genString.find("ad") == 0)
	return 2; // code for adjoint

      ib.reset();
      size_t i;
      latticetypes::LatticeCoeff d;
      switch (checkGenerator(ib,i,d,u))
      {
      case NoError:
	break;
      case FormatError:
	std::cerr << "bad format in entry #" << i+1
		  << " (should be of the form a/";
	if (u[i])
	  std::cerr << u[i] << ")" << std::endl;
	else
	  std::cerr << "b, b > 0)" << std::endl;
	std::cerr << "bad input line --- ignored" << std::endl;
	continue;
      case BadDenominator:
	std::cerr << "denominator in entry #" << i+1
		  << " should be " << u[i] << std::endl
		  << "bad input line --- ignored" << std::endl;
	continue;
      case NegDenominator:
	std::cerr << "denominator in entry #" << i+1
		  << " should be positive" << std::endl
		  << "bad input line --- ignored" << std::endl;
	continue;
      case TooFew:
	std::cerr << "too few valid entries" << std::endl
		  << "bad input line --- ignored" << std::endl;
	continue;
      }
      rwl.push_back(readGenerator(u.size(),d,ib));
    }
  }

  d_rwl.swap(rwl);
  return 0; // "normal" exit
}

/*
  Gets the lattice interactively from the user.

  This works as follows. Initially, |root_lattice_basis| is a Smith normal
  basis of the root lattice w.r.t. the weight lattice (or more precisely, a
  concatenation of one such basis for each factor in the complex Lie type),
  and |root_invf| holds the corresponding invariant factors. Guided (only) by
  the non-unit values among those factors, the user has to specify "kernel
  generators" (in |getGenerators|) which are rational coweights; this
  implicitly specifies a full rank (and therefore finite index) sublattice of
  weights taking integral values on all those coweights, which sublattice
  contains the root lattice (by limitation of the choice of the generators).

  Generators for the nontrivial part of this sublattice are computed by
  |makeOrthogonal| into |q| and |orth_invf|; more precisely, the columns of
  |q| form a Smith basis, in the space generated by those elements of
  |root_lattice_basis| that are not in the root lattice, for its intersection
  with the integrality sublattice, and |orth_invf| gives the factors by which
  each basis vector must be multiplied in order to be in the sublattice.

  To get from this a real sublattice basis, we select in |lb| the elements of
  |root_lattice_basis| mentioned above, take linear combination as specified
  by |q|, and then in |adjustBasis| merge their multiples by the corresponding
  |orth_invf| with the remaining elements of |root_lattice_basis|.

  This function may throws an |InputError| if the interaction with the user
  fails. In that case the arguments are not modified. Also, if the user
  prefers answering "ad" or "sc" rather than giving any generators, we pass
  this considtion as a return code without modifying anything.
*/
int getLattice(const latticetypes::CoeffList& root_invf,
	       latticetypes::WeightList& root_lattice_basis)
  throw(error::InputError)
{
  latticetypes::Weight u;
  getUniversal(u,root_invf);  // collect non-unit invariant factors into |u|

  // get generators of character group

  latticetypes::RatWeightList rwl;  // generator list
  int code=getGenerators(rwl,u);    // input any generators of size |u.size()|
                                    // might throw an InputError

  if (code>0)
    return code; // bypass computation if user typed "sc" or "ad"

  // make basis elements corresponding to those central elements

  latticetypes::LatticeMatrix q;
  latticetypes::CoeffList orth_invf;
  makeOrthogonal(q,orth_invf,rwl,u.size());

  latticetypes::WeightList lb;
  localBasis(lb,root_lattice_basis,root_invf);

  // convert |lb| according to |q|
  latticetypes::LatticeMatrix m(lb); m *= q;
  matrix::columnVectors(lb,m); // redefine |lb| as converted columns

  // make actual basis

  adjustBasis(root_lattice_basis,root_invf,lb,orth_invf);
  return 0; // normal exit
}

/*
  Extracts from invf the coefficients that are not one; these will define
  the fundamental group of the adjoint group, as a product of cyclic groups
  (not necessarily canonically normalized.)
*/
void getUniversal(latticetypes::CoeffList& u,
		  const latticetypes::CoeffList& invf)
{
  u.clear();

  for (size_t i=0; i<invf.size(); ++i) {
    if (invf[i] != 1)
      u.push_back(invf[i]);
  }
}


/*
  Extracts from b the part corresponding to non-1 terms in invf.
*/
void localBasis(latticetypes::WeightList& lb,
		const latticetypes::WeightList& b,
		const latticetypes::CoeffList& invf)
{
  for (size_t i=0; i<invf.size(); ++i)
    if (invf[i] != 1)
      lb.push_back(b[i]);
}


} // namespace interactive_lattice

/*****************************************************************************

        Chapter II -- Functions local to interactive_lattice.cpp

******************************************************************************/

namespace {

/*
  Synposis: checks if buf contains data compatible with u.

  Precondition: buf should contain a comma-separated list, with one entry for
  each member of u (extra entries are ignored). The entries should be of the
  form a/b, with b = u[i] if u[i] > 0, or with arbitrary b>0 otherwise.

  Explanation: the element a/b (with b = u[i] if u[i] > 0) represents the
  element exp(2i.pi.a/b) in a one-dimensional torus factor.

  In case of success, the l.c.m. of the various b's and u[i]'s is put in |d|.
  In case of failure, the entry number where the error occurs is put in |r|.

  NOTE: no overflow checking is done on d.
*/
GeneratorError checkGenerator(input::InputBuffer& buf, size_t& r,
			      latticetypes::LatticeCoeff& d,
			      const latticetypes::CoeffList& u)
{
  std::streampos pos = buf.tellg();
  unsigned long lc = 1;

  for (size_t i=0; i<u.size(); ++i) {

    if (buf.peek() == EOF) {
      buf.reset(pos);
      return TooFew;
    }

    latticetypes::LatticeCoeff a;
    buf >> a;
    char x=0;
    buf >> x;
    if (x != '/') {
      r = i;
      buf.reset(pos);
      return FormatError;
    }

    latticetypes::LatticeCoeff b = 0;
    buf >> b;

    // check denominator
    if (u[i] == 0) {
      if (b <= 0) { // negative denominator error
	r = i;
	buf.reset(pos);
	return NegDenominator;
      }
    } else if (b != u[i]) { // bad denominator error
      r = i;
      buf.reset(pos);
      return BadDenominator;
    }

    // update lowest common denominator
    if (a)
      lc = arithmetic::lcm(lc,b);

    if (i+1<u.size()) { // next non-white character should be a comma
      char x = 0;
      buf >> x;
      if (x != ',') {
	buf.reset(pos);
	return TooFew;
      }
    }
  }

  buf.reset(pos);
  d = lc;

  return NoError;
}


/*
  Synopsis: puts in q the matrix of a Smith basis for the lattice orthogonal
  to d_rwl, and in invf the corresponding invariant factors.

  Precondition: each of the elements of d_rwl has size r.

  Explanation: here the elements of d_rwl are interpreted as elements of finite
  order in the torus (more precisely, the order divides the denominator.) So
  "orthogonal" means sending the rational vector to an integer.

  Algorithm: reduce all the vectors to a common denominator d; then we have
  the problem of finding a basis for the lattice that takes a given bunch
  of vectors into d.Z. Find a Smith normal basis for the bunch; this reduces
  to the case where the given vectors are multiples of some of the basis
  vectors, so the condition is a congruence condition on the corresponding
  coordinates. Example: if we reduce to 2e_1, 3e_2, and d = 6, we get that
  lambda_1 must be multiple of 3, lambda_2 multiple of 2.

  NOTE: this is a sloppy implementation; we don't worry about overflow.
*/
void makeOrthogonal(latticetypes::LatticeMatrix& q,
		    latticetypes::CoeffList& invf,
		    const latticetypes::RatWeightList& d_rwl, size_t r)
{
  // reduce to same denominator
  latticetypes::RatWeightList rwl = lattice::toCommonDenominator(d_rwl);

  // make matrix of numerator vectors
  latticetypes::LatticeMatrix m = lattice::numeratorMatrix(rwl);

  // smith-normalize
  latticetypes::WeightList b;
  matrix::initBasis(b,r);

  latticetypes::CoeffList linvf;
  smithnormal::smithNormal(linvf,b.begin(),m);

  // write matrix
  q = latticetypes::LatticeMatrix(b).inverse().transposed();

  // write invariant factors of orthogonal lattice
  invf.resize(b.size(),1UL);

  if (rwl.size()>0)
  {
    unsigned long d = rwl[0].denominator();
    for (size_t i=0; i<linvf.size(); ++i)
      invf[i] = d/arithmetic::gcd(linvf[i],d);
  }
}


/*
  Synposis: prints the center of the simply connected group.

  Precondition: u contains the necessary data: the orders of a natural set of
  generators for the center of the derived group, and a zero for each torus
  factor.
*/
std::ostream& printCenter(std::ostream& strm, const latticetypes::CoeffList& u)
{
  for (size_t i=0; i<u.size(); ++i)
  {
    if (u[i])
      strm << "Z/" << u[i];
    else
      strm << "Q/Z";
    if (i<u.size()-1)
      strm << ".";
  }

  return strm;
}


/*!
  \brief: returns generator from |buf|, with |n_gen| entries, denominator |d|

*/
latticetypes::RatWeight readGenerator(size_t n_gen,
                                      latticetypes::LatticeCoeff d,
				      input::InputBuffer& buf)
{
  latticetypes::LatticeElt numer(n_gen);
  char dummy; // bit bucket for separator characters
  latticetypes::LatticeCoeff b;
  for (size_t i=0; i<n_gen; ++i)
  {
    buf >> numer[i] >> dummy >> b >> dummy;// read fraction, skipping "/", ","
    numer[i] *= d/b; // because denominators are forced to |d|
  }
  return latticetypes::RatWeight(numer,d);
}

} // |namespace|

} // |namespace atlas|
