/*
  This is interactive_lattice.cpp

  Copyright (C) 2004,2005 Fokko du Cloux
  part of the Atlas of Reductive Lie Groups

  For license information see the LICENSE file
*/

#include "interactive_lattice.h"

#include <iostream>
#include <sstream>

#include "arithmetic.h"
#include "input.h"
#include "interactive.h"
#include "lattice.h"
#include "ioutils.h"
#include "prerootdata.h"
#include "smithnormal.h"
#include "topology.h"

/*****************************************************************************

 This module deals with functions specific to the user choosing a sublattice.

******************************************************************************/

namespace atlas {

namespace {

  enum GeneratorError { NoError = 0, FormatError, BadDenominator,
			NegDenominator, TooFew };

  GeneratorError checkGenerator(input::InputBuffer&, size_t&,
				latticetypes::LatticeCoeff&,
				const latticetypes::CoeffList&);

  void makeOrthogonal(latticetypes::LatticeMatrix&, latticetypes::CoeffList&,
		      const latticetypes::RatWeightList&, size_t);

  std::ostream& printCenter(std::ostream&, const latticetypes::CoeffList&);

  void readGenerator(latticetypes::RatWeight&,
		     const latticetypes::CoeffList& u,
		     input::InputBuffer&);

  input::HistoryBuffer kernelgen_input_buffer;
}

/*****************************************************************************

        Chapter I -- Functions declared in interactive_lattice.h

******************************************************************************/

namespace interactive_lattice {

/*
  In this function, |b| holds a Smith basis of the weight lattice w.r.t. the
  root lattice. In this basis, we have marked the indices where the quotient
  is not zero; |lb| holds a basis of the
  subgroup generated by this subset of |b|, which is Smith w.r.t. the
  purported group lattice; |linvf| holds the corresponding invariant factors.

  Then we replace the part of b corresponding to these indices, by the
  Smith basis thus constructed; this now is a Smith basis of the weight
  lattice w.r.t. the group lattice.

  Finally, we multiply the elements of by their invariant factors, so as
  to get a basis of the group lattice.
*/

void adjustBasis(latticetypes::WeightList& b, latticetypes::CoeffList& invf,
		 const latticetypes::WeightList& lb,
		 const latticetypes::CoeffList& linvf)

{
  // replace the elements in b corresponding to lb by the elements of lb;
  // also adjust invariant factors
  size_t i = 0;

  for (size_t j = 0; j < invf.size(); ++j)
    if (invf[j] != 1) {
      const latticetypes::Weight& v = lb[i];
      b[j] = v;
      invf[j] = linvf[i];
      ++i;
    }

  // scale b to the lattice basis

  for (size_t j = 0; j < invf.size(); ++j)
    if (invf[j] != 1) {
      latticetypes::LatticeCoeff a = invf[j];
      b[j] *= a;
    }

  return;
}

/*! \brief
  Gets the generators of X/Q, where Q is the root lattice, from the user.

  It throws an InputError if the interaction with the user does not conclude
  successfully. In that case, d_gl is not modified.
*/
void getGenerators(latticetypes::RatWeightList& d_rwl,
		   const latticetypes::CoeffList& u)
  throw(error::InputError)
{
  latticetypes::RatWeightList rwl;

  std::string genString;
  interactive::common_input() >> genString;

  if (genString.find("sc") == 0)
    goto simplyconnected;
  if (genString.find("ad") == 0)
    goto adjoint;

  if (topology::isTrivial(u))
    goto simplyconnected;

  std::cout
    << "elements of finite order in the center of the simply connected group:"
    << std::endl;

  printCenter(std::cout,u) << std::endl;

  std::cout << "enter kernel generators, one per line" << std::endl;
  std::cout << "(ad for adjoint, ? to abort):"
	    << std::endl;

  {
    input::InputBuffer& ib=kernelgen_input_buffer;

    while (true) {
      ib.getline(std::cin,"");
      if (hasQuestionMark(ib))
	throw error::InputError();
      genString.clear();
      ib >> genString;
      if (genString.empty()) // done
	break;
      if (genString.find("sc") == 0)
	goto simplyconnected;
      if (genString.find("ad") == 0)
	goto adjoint;
      ib.reset();
      size_t j;
      latticetypes::LatticeCoeff d;
      switch (checkGenerator(ib,j,d,u)) {
      case NoError:
	break;
      case FormatError:
	std::cerr << "bad format in entry #" << j+1
		  << " (should be of the form a/";
	if (u[j])
	  std::cerr << u[j] << ")" << std::endl;
	else
	  std::cerr << "b, b > 0)" << std::endl;
	std::cerr << "bad input line --- ignored" << std::endl;
	continue;
      case BadDenominator:
	std::cerr << "denominator in entry #" << j+1
		  << " should be " << u[j] << std::endl
		  << "bad input line --- ignored" << std::endl;
	continue;
      case NegDenominator:
	std::cerr << "denominator in entry #" << j+1
		  << " should be positive" << std::endl
		  << "bad input line --- ignored" << std::endl;
	continue;
      case TooFew:
	std::cerr << "too few valid entries" << std::endl
		  << "bad input line --- ignored" << std::endl;
	continue;
      }
      rwl.push_back(latticetypes::RatWeight(u.size(),d));
      readGenerator(rwl.back(),u,ib);
    }
  }

  goto finish;

 adjoint: // return the full center of the _derived_ group
  // put in rwl a list of ratvectors of 0/1's
  rwl.assign(u.size(),
	     latticetypes::RatWeight
	       (latticetypes::Weight(u.size(), latticetypes::ZeroCoeff),
		latticetypes::OneCoeff));

  for (size_t j = 0; j < rwl.size(); ++j)
    if (u[j]) {
      rwl[j].numerator()[j] = 1;
      rwl[j].denominator() = u[j];
    }

  goto finish;

 simplyconnected: // return the empty list
  rwl.clear();

  goto finish;

 finish:
  d_rwl.swap(rwl);
}

void getLattice(latticetypes::CoeffList& invf, latticetypes::WeightList& b)
  throw(error::InputError)

/*
  Gets the lattice interactively from the user.

  This works as follows. Initially, b is a Smith normal basis of the root
  lattice w.r.t. the weight lattice (or more precisely, a concatenation of
  one such basis for each factor in the complex Lie type); invf is the
  corresponding invariant factor type. Adding one free generator for each
  torus factor (corresponding to zeroes in invf), we get a decomposition
  of the weight lattice modulo the root lattice, as a direct product of
  finite cyclic and infinite cyclic groups. The user has to specify a group
  of finite index of this quotient, in terms of generators.

  Adding the generators of the root lattice, we then get generators for the
  group lattice. Applying Smith normal form again, we can get a basis for the
  group lattice, and the invariant factors w.r.t. the weight lattice. We only
  need to modify the basis vectors that have a non-zero image in the quotient.

  Then the appropriate elements of this final Smith normal basis are multiplied
  by the corresponding invariant factor, to get a basis of the group lattice.

  Throws an InputError if the interaction with the user fails. In that case,
  b and invf are not modified.
*/

{
  latticetypes::Weight u;
  getUniversal(u,invf);  // collect non-unit invariant factors into |u|

  // get generators of character group

  latticetypes::RatWeightList rwl;  // generator list
  getGenerators(rwl,u);      // input any generators of size |u.size()|
                             // might throw an InputError

  // make basis elements corresponding to those central elements

  latticetypes::LatticeMatrix q;
  latticetypes::CoeffList linvf;
  makeOrthogonal(q,linvf,rwl,u.size());

  latticetypes::WeightList lb;
  localBasis(lb,b,invf);

  latticetypes::LatticeMatrix m(lb);
  m *= q;
  for (size_t j = 0; j < lb.size(); ++j)
    m.column(lb[j],j);

  // make actual basis

  adjustBasis(b,invf,lb,linvf);
}

/*
  Extracts from invf the coefficients that are not one; these will define
  the fundamental group of the adjoint group, as a product of cyclic groups
  (not necessarily canonically normalized.)
*/
void getUniversal(latticetypes::CoeffList& u,
		  const latticetypes::CoeffList& invf)
{
  u.clear();

  for (size_t j = 0; j < invf.size(); ++j) {
    if (invf[j] != 1)
      u.push_back(invf[j]);
  }
}


/*
  Extracts from b the part corresponding to non-1 terms in invf.
*/
void localBasis(latticetypes::WeightList& lb,
		const latticetypes::WeightList& b,
		const latticetypes::CoeffList& invf)
{
  for (size_t j = 0; j < invf.size(); ++j)
    if (invf[j] != 1)
      lb.push_back(b[j]);

  return;
}


/*
  The Lie type is defined as a sequence of simple and torus factors inside
  lt. This function constructs a "blockwise smith normal" basis for the
  root lattice inside the weight lattice (i.e., it does just that for each
  semisimple block, and returns the canonical basis for the torus blocks.)

  The purpose of doing this blockwise instead of globally is to permit a
  better reading of the quotient group : this will be presented as a sequence
  of factors, corresponding to each simple block.

  Of course, it is still assumed that the caller is a "savvy" user, and knows
  that some blocks will not contribute (because the adjoint group is simply
  connected), and that blocks D_n, n even, contribute _two_ factors Z_2.
  Torus blocks T_n contribute n factors Z (this will be reflected in the
  "missing" invariant factors.)
*/
void smithBasis(latticetypes::CoeffList& invf, latticetypes::WeightList& b,
		const lietype::LieType& lt)
{
  // smith-normalize for each simple factor

  matrix::initBasis(b,lietype::rank(lt));
  latticetypes::WeightList::iterator bp = b.begin();

  for (size_t j = 0; j < lt.size(); ++j) {

    size_t r = lietype::rank(lt[j]);

    if (lietype::type(lt[j]) == 'T') { // torus type
      invf.insert(invf.end(),r,latticetypes::ZeroCoeff);
      bp += r;
      continue;
    }

    latticetypes::LatticeMatrix ms;
    prerootdata::cartanMatrix(ms,lt[j]);
    ms.transpose();
    smithnormal::smithNormal(invf,bp,ms);

    if (lietype::type(lt[j]) == 'D' and (lietype::rank(lt[j])&1UL) == 0) {
      //make a small adjustment
      bp[r-2] += bp[r-1];
    }

    bp += r;

  }
}

} // namespace interactive_lattice

/*****************************************************************************

        Chapter II -- Functions local to interactive_lattice.cpp

******************************************************************************/

namespace {

/*
  Synposis: checks if buf contains data compatible with u.

  Precondition: buf should contain a comma-separated list, with one entry for
  each member of u (extra entries are ignored). The entries should be of the
  form a/b, where b = u[j] if u[j] > 0, b > 0 arbitrary otherwise.

  Explanation: the element a/b (with b = u[j] if u[j] > 0) represents the
  element exp(2i.pi.a/b) in a one-dimensional torus factor.

  In case of failure, the entry number where the rank occurs is put in r. In
  case of success, the l.c.m. of the various b's and u[j]'s is put in d.

  NOTE: no overflow checking is done on d.
*/
GeneratorError checkGenerator(input::InputBuffer& buf, size_t& r,
			      latticetypes::LatticeCoeff& d,
			      const latticetypes::CoeffList& u)
{
  std::streampos pos = buf.tellg();
  unsigned long lc = 1;

  for (size_t j = 0; j < u.size(); ++j) {

    if (buf.peek() == EOF) {
      buf.reset(pos);
      return TooFew;
    }

    latticetypes::LatticeCoeff a;
    buf >> a;
    char x = 0;
    buf >> x;
    if (x != '/') {
      r = j;
      buf.reset(pos);
      return FormatError;
    }

    latticetypes::LatticeCoeff b = 0;
    buf >> b;

    // check denominator
    if (u[j] == 0) {
      if (b <= 0) { // negative denominator error
	r = j;
	buf.reset(pos);
	return NegDenominator;
      }
    } else if (b != u[j]) { // bad denominator error
      r = j;
      buf.reset(pos);
      return BadDenominator;
    }

    // update lowest common denominator
    if (a)
      lc = arithmetic::lcm(lc,b);

    if (j+1 < u.size()) { // next non-white character should be a comma
      char x = 0;
      buf >> x;
      if (x != ',') {
	buf.reset(pos);
	return TooFew;
      }
    }
  }

  buf.reset(pos);
  d = lc;

  return NoError;
}


/*
  Synopsis: puts in q the matrix of a Smith basis for the lattice orthogonal
  to d_rwl, and in invf the corresponding invariant factors.

  Precondition: r is the dimension of the elements of d_rwl.

  Explanation: here the elements of d_rwl are interpreted as elements of finite
  order in the torus (more precisely, the order divides the denominator.) So
  "orthogonal" means sending the rational vector to an integer.

  Algorithm: reduce all the vectors to a common denominator d; then we have
  the problem of finding a basis for the lattice that takes a given bunch
  of vectors into d.Z. Find a Smith normal basis for the bunch; this reduces
  to the case where the given vectors are multiples of some of the basis
  vectors, so the condition is a congruence condition on the corresponding
  coordinates. Example: if we reduce to 2e_1, 3e_2, and d = 6, we get that
  lambda_1 must be multiple of 3, lambda_2 multiple of 2.

  NOTE: this is a sloppy implementation; we don't worry about overflow.
*/
void makeOrthogonal(latticetypes::LatticeMatrix& q,
		    latticetypes::CoeffList& invf,
		    const latticetypes::RatWeightList& d_rwl, size_t r)
{
  // reduce to same denominator
  latticetypes::RatWeightList rwl;
  lattice::toCommonDenominator(rwl,d_rwl);

  // make matrix of numerator vectors
  latticetypes::LatticeMatrix m;
  lattice::numeratorMatrix(m,rwl);

  // smith-normalize
  latticetypes::WeightList b;
  matrix::initBasis(b,r);

  latticetypes::CoeffList linvf;
  smithnormal::smithNormal(linvf,b.begin(),m);

  // write matrix
  q = latticetypes::LatticeMatrix(b).inverse().transposed();

  // write invariant factors of orthogonal lattice
  invf.resize(b.size(),1UL);

  if (rwl.size()) {
    unsigned long d = rwl[0].denominator();
    for (size_t j = 0; j < linvf.size(); ++j) {
      unsigned long c = linvf[j];
      c = arithmetic::gcd(c,d);
      invf[j] = d/c;
    }
  }
}


/*
  Synposis: prints the sencter of the simply connected group.

  Precondition: u contains the necessary data: the orders of a natural set of
  generators for the center of the derived group, and a zero for each torus
  factor.
*/
std::ostream& printCenter(std::ostream& strm, const latticetypes::CoeffList& u)
{
  for (size_t j = 0; j < u.size(); ++j) {
    if (u[j]) {
      strm << "Z/";
      strm << u[j];
    } else {
      strm << "Q/Z";
    }
    if (j < u.size()-1)
      strm << ".";
  }

  return strm;
}


/*
  Synopsis: reads a generator from buf to v.

  Precondition: checkGenerator returns NoError on buf; v has been initialized
  with the correct denominator, as provided by checkGenerator;
*/
void readGenerator(latticetypes::RatWeight& v,
		   const latticetypes::CoeffList& u,
		   input::InputBuffer& buf)
{
  latticetypes::LatticeCoeff d = v.denominator();

  for (size_t j = 0; j < v.size(); ++j) {

    latticetypes::LatticeCoeff a = 0;
    buf >> a;

    char x;
    buf >> x; // get rid of / sign

    latticetypes::LatticeCoeff b;
    buf >> b;
    v.numerator()[j] = d/b;
    v.numerator()[j] *= a;

    buf >> x; // get rid of the comma-separator
  }
}

}

}
