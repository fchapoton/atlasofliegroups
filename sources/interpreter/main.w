@* Main program. This file defines a small main program to test the parser
under development. It is written in \Cpp, but is it mainly concerned with
interfacing to the parser that is generated by~\.{bison}, and which is
therefore written in~\Cee. For this reason we make very limited use of
namespaces: we only use the anonymous namespace for data local to this file.
Any calls to \Cpp-code will use explicit namespace resolution.

@c

@< Declaration of interface to the parser @>@;
namespace
{ @< Definition of keywords @>@;
  @< Static data @>@;
}@;
@< Definition of wrapper functions @>@;
@< Main program @>

@ Since the file \.{parser.y} declares \.{\%pure-parser} and \.{\%locations},
the prototype of the lexical analyser (wrapper) function |yylex| is the one
below. Curiously, the program~\.{bison} does not write this prototype to
\.{parser.tab.h}, but it does write the definitions of the types |YYSTYPE| and
|YYLTYPE| there; these require that \.{parsetree.h} be included first. We also
declare ``{\tt\%parse-param \char`\{} |int* verbosity, expr* parsed_expr@;|
{\tt\char`\}}'' in~\.{parser.y}, so that the parser itself, |yyparse|, takes
an integer pointer as parameter, which it uses to signal requested
termination, and a pointer to an expression, in which it writes the result of
parsing. Since these functions form the interface to the parser written
in~\Cee, we must declare these definitions |extern "C"@;|.

@h "parsetree.h"
@h "parser.tab.h"

@< Declaration of interface to the parser @>=

extern "C"
{ int yylex (YYSTYPE *, YYLTYPE *);
@/int yyparse( expr* parsed_expr, int* verbosity );
}

@ Here is an array that declares the keywords that the lexical scanner is to
recognise, terminated by a null pointer. Currently the lexical analyser adds
the offset of the keyword in this list to |QUIT|, so the recognition depends
on the fact that |"quit"| is the first keyword, and that they are listed below
in the same order as in the \.{\%token} declaration in \.{parser.y}.

@< Definition of keywords @>=

const char* keywords[] =
 {"quit","true","false","quiet","verbose","whattype","printall",NULL};

@ Our lexical analyser is defined as a class, which we shall instantiate in
the main program. In order for the lexical analyser wrapper function to access
it, we need to install static pointer to it.

@h "buffer.h"
@h "lexer.h"

@< Static data @>=

atlas::interpreter::Lexical_analyser* lex;
atlas::interpreter::BufferedInput* main_input_buffer;

@ Here are the wrapper function for the lexical analyser and the error
reporting function, which are necessary because the parser cannot directly
call a class method.

@< Definition of wrapper functions @>=

extern "C"
int yylex(YYSTYPE *valp, YYLTYPE *locp)
@+{@; return lex->get_token(valp,locp); }
@)
extern "C"
void yyerror (YYLTYPE* locp, expr* parsed_expr,int* verbosity,char const *s)
{ main_input_buffer->show_range(std::cerr,
   locp->first_line, locp->first_column,
   locp->last_line,  locp->last_column);
  std::cerr << s << std::endl;
}


@ In our main program we first sign on to the history library, then allocate
the necessary objects to install the lexical scanner, and then in a loop call
the parser until it sets |verbosity<0|, which is done upon seeing the \.{quit}
command. We call the |reset| method of the lexical scanner before calling the
parser, which will discard any input that is left be a possible previous
erroneous input (it also already fetches a new line of input, but that is not
the point here; this would happen anyway upon the first call of |yylex| by the
parser).

@h <iostream>
@h <readline/readline.h>
@h <readline/history.h>
@h <stdexcept>
@h "evaluator.h"
@h "built-in-types.h"
@h "constants.h"
@< Main program @>=

int main()
{ using namespace std; using namespace atlas::interpreter;
  @< Initialise various parts of the program @>
  cout << "Enter expressions:\n";
  while ( cin.good() )
  { ana.reset(); // make sure lexical analyser gets a new line
    expr expression;
    if (yyparse(&expression,&verbosity))
      continue; // syntax error or non-expression
    if (verbosity<0) break; // \.{quit} command
    if (verbosity==1)
      cout << "Expression before type analysis: " << expression << endl;
    @< Analyse types and then evaluate and print, or catch runtime or other
       errors @>
  }
  clear_history();
  // clean up (presumably disposes of the lines stored in history)
  cout << "Bye.\n";
}

@ If a type error is detected by |analyse_types|, then it will have signalled
it and thrown a |runtime_error|; if that happens |type_OK| will remain |false|
and the runtime error is silently caught. If the result is an empty tuple, we
suppress printing if the uninteresting value.

@< Analyse types and then evaluate and print... @>=
{ bool type_OK=false;
  try
  { type_ptr type=analyse_types(expression);
    type_OK=true;
    if (verbosity==1)
      cout << "Type found: " << *type << endl @|
	<< "Expression after type analysis: " << expression << endl;
    value_ptr v=evaluate(expression);
    static type_declarator empty=*make_type("()").release();
    if (*type!=empty) cout << "Value: " << *v << endl;
    destroy_expr(expression); delete v;
  }
  catch (runtime_error& err)
  { if (type_OK) cerr << "Runtime error: ";
    cerr << err.what() << ", evaluation aborted.\n";
    clear_execution_stack();
  }
  catch (logic_error& err)
  { cerr << "Unexpected error: " << err.what() << ", evaluation aborted.\n";
    clear_execution_stack();
  }
  catch (exception& err)
  { cerr << err.what() << ", evaluation aborted.\n";
    clear_execution_stack();
  }
}

@
@< Initialise various parts of the program @>=
  using_history();
  rl_completion_entry_function = id_completion_func; // set up input completion

@)atlas::constants::initConstants();
@/BufferedInput input_buffer("expr> ",readline,add_history);
  main_input_buffer= &input_buffer;
@/Hash_table hash; main_hash_table= &hash;
@/Lexical_analyser ana(input_buffer,hash,keywords); lex=&ana;
@/Id_table main_table; @+ global_id_table=&main_table;

@)initialise_evaluator(); initialise_builtin_types();

@* Index.
