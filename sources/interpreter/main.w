@* Main program. This file defines a small main program to test the parser
under development. It is written in \Cpp, but is it mainly concerned with
interfacing to the parser that is generated by~\.{bison}, and which is
therefore written in~\Cee. For this reason we make very limited use of
namespaces: we only use the anonymous namespace for data local to this file.
Any calls to \Cpp-code will use explicit namespace resolution.

@c

@< Declaration of interface to the parser @>@;
namespace
{ @< Definition of keywords @>@;
  @< Static data @>@;
}@;
@< Definition of wrapper functions @>@;
@< Main program @>

@ Since the file \.{parser.y} declares \.{\%pure-parser} and \.{\%locations},
the prototype of the lexical analyser (wrapper) function |yylex| is the one
below. Curiously, the program~\.{bison} does not write this prototype to
\.{parser.tab.h}, but it does write the definitions of the types |YYSTYPE| and
|YYLTYPE| there; these require that \.{parsetree.h} be included first. We also
declare ``{\tt\%parse-param \char`\{} |int* running, expr* parsed_expr@;|
{\tt\char`\}}'' in~\.{parser.y}, so that the parser itself, |yyparse|, takes
an integer pointer as parameter, which it uses to signal requested
termination, and a pointer to an expression, in which it writes the result of
parsing. Since these functions form the interface to the parser written
in~\Cee, we must declare these definitions |extern "C"@;|.

@h "parsetree.h"
@h "parser.tab.h"

@< Declaration of interface to the parser @>=

extern "C"
{ int yylex (YYSTYPE *, YYLTYPE *);
@/int yyparse( expr* parsed_expr, int* running );
}

@ Here is an array that declares the keywords that the lexical scanner is to
recognise, terminated by a null pointer. Currently the lexical analyser adds
the offset of the keyword in this list to |QUIT|, so the recognition depends
on the fact that |"quit"| is the first keyword, and that they are listed below
in the same order as in the \.{\%token} declaration in \.{parser.y}.

@< Definition of keywords @>=

const char* keywords[] = {"quit","true","false","quiet","verbose",NULL};

@ Our lexical analyser is defined as a class, which we shall instantiate in
the main program. In order for the lexical analyser wrapper function to access
it, we need to install static pointer to it.

@h "buffer.h"
@h "lexer.h"

@< Static data @>=

atlas::interpreter::Lexical_analyser* lex;
atlas::interpreter::BufferedInput* main_input_buffer;

@ Here are the wrapper function for the lexical analyser and the error
reporting function, which are necessary because the parser cannot directly
call a class method.

@< Definition of wrapper functions @>=

extern "C"
int yylex(YYSTYPE *valp, YYLTYPE *locp)
@+{@; return lex->get_token(valp,locp); }
@)
extern "C"
void yyerror (YYLTYPE* locp, expr* parsed_expr, int* running,char const *s)
{ main_input_buffer->show_range(std::cerr,
   locp->first_line, locp->first_column,
   locp->last_line,  locp->last_column);
  std::cerr << s << std::endl;
}


@ In our main program we first sign on to the history library, then allocate
the necessary objects to install the lexical scanner, and then in a loop call
the parser until it sets |running=0|, which is done upon seeing the \.{quit}
command. We call the |reset| method of the lexical scanner before calling the
parser, which will discard any input that is left be a possible previous
erroneous input (it also already fetches a new line of input, but that is not
the point here; this would happen anyway upon the first call of |yylex| by the
parser).

@h <iostream>
@h <readline/readline.h>
@h <readline/history.h>
@h <stdexcept>
@h "evaluator.h"
@h "built-in-types.h"
@h "constants.h"
@< Main program @>=

int main()
{ using namespace std; using namespace atlas::interpreter;
  @< Initialise various parts of the program @>
  cout << "Enter expressions:\n";
  int running=0; // $-1$: quit, $0$: quiet, $1$: verbose
  expr expression;
  while ( cin.good() )
  { ana.reset();
    if (yyparse(&expression,&running))
      continue; // syntax error or non-expression
    if (running<0) break; // \.{quit} command
    if (running==1)
      cout << "Expression before type analysis: " << expression << endl;
    bool type_OK=false;
    try
    { type_ptr type=analyse_types(expression);
      type_OK=true; 
      if (running==1)
	cout << "Type found: " << *type << endl
          << "Expression after type analysis: " << expression << endl;
      value_ptr v=evaluate(expression);
      cout << "Value: " << *v << endl;
      destroy_expr(expression); delete v;
    }
    catch (runtime_error& err)
    { if (type_OK) cerr << "Runtime error: ";
      cerr << err.what() << ", evaluation aborted.\n";
      clear_execution_stack();
    }
    catch (logic_error& err)
    { cerr << "Unexpected error: " << err.what() << ", evaluation aborted.\n";
      clear_execution_stack();
    }
    catch (exception& err)
    { cerr << err.what() << ", evaluation aborted.\n";
      clear_execution_stack();
    }
  }
  clear_history();
  // clean up (presumably disposes of the lines stored in history)
  cout << "Bye.\n";
}

@
@< Initialise various parts of the program @>=
  using_history();
  rl_completion_entry_function = id_completion_func; // set up input completion

@)atlas::constants::initConstants();
@/BufferedInput input_buffer("expr> ",readline,add_history);
  main_input_buffer= &input_buffer;
@/Hash_table hash; main_hash_table= &hash;
@/Lexical_analyser ana(input_buffer,hash,keywords); lex=&ana;
@/Id_table main_table; @+ global_id_table=&main_table;

@)initialise_evaluator(); initialise_builtin_types();

@* Index.
