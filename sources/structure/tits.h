/*!
\file
\brief Class definitions and function declarations for the classes
TitsGroup and TitsElt.
*/
/*
  This is tits.h

  Copyright (C) 2004,2005 Fokko du Cloux
  part of the Atlas of Reductive Lie Groups

  See file main.cpp for full copyright notice
*/

#ifndef TITS_H  /* guard against multiple inclusions */
#define TITS_H

#include "tits_fwd.h"

#include "rootdata_fwd.h"

#include "bitvector.h"
#include "constants.h"
#include "latticetypes.h"
#include "weyl.h"

namespace atlas {

/******** type declarations *************************************************/

namespace tits {

  /*!
\brief Element of (Z/2Z)^n, representing an element of T(2).

  The cocharacter lattice of T is always identified with Z^n; applying a
  cocharacter to -1 identifies the group T(2) of elements of order 2
  with (Z/2Z)^n.
  */
  typedef latticetypes::SmallBitVector TorusPart;

  /*!
\brief Square matrix of elements of Z/2Z, representing an endomorphism of T(2).
  */
  typedef latticetypes::BinaryMap TorusMatrix;

}

/******** function declarations *********************************************/

namespace tits {

  weyl::Twist makeTwist(const latticetypes::LatticeMatrix&,
			const rootdata::RootDatum&);

}

/******** type definitions **************************************************/

namespace tits {

  /*!
\brief Represents an element of a Tits group.

An element is always written $w.t$, with $w$ the canonical representative
in the Tits group of a Weyl group element $w$ and \f$t \in T(2)\f$.
  */
class TitsElt {

 private:
  /*!
\brief Canonical Weyl part of the Tits group element.

If the Weyl group element $w$ has a reduced decomposition $s_1,...,s_r$, then
the canonical representative is the product of the corresponding Tits group
elements \f$\sigma_1,...,\sigma_r\f$. Because the \f$\sigma_i\f$ satisfy the braid
relations, this canonical representative is independent of the choice of
reduced decomposition.
  */
  weyl::WeylElt d_w;

  /*!
\brief Factor in T(2) of the Tits group element.
  */
  TorusPart d_t;

 public:

// constructors and destructors

/*!
\brief Constructs the identity element in the group; n should equal the rank
*/
  explicit TitsElt(size_t n) : d_w(weyl::WeylElt()), d_t(n) {}

  /*!
\brief Constructs the canonical representative of the Weyl element w in the
  Tits group, while n should equal the rank. The field d_t is set to n bits 0.
  */
  TitsElt(const weyl::WeylElt& w, size_t n) : d_w(w), d_t(n) {}

// copy and assignment can be left to their defaults

// accessors
  bool operator< (const TitsElt& a) const {
    return d_w != a.d_w ? d_w < a.d_w : d_t < a.d_t ;
  }

  bool operator== (const TitsElt& a) const {
    return d_w == a.d_w and d_t == a.d_t;
  }

  bool operator!= (const TitsElt& a) const {
    return d_w != a.d_w or d_t != a.d_t;
  }

  /*!
\brief Factor in T(2) of the Tits group element.
  */
  const TorusPart& t() const {
    return d_t;
  }

  /*!
\brief Canonical Weyl part of the Tits group element.
  */
  const weyl::WeylElt& w() const {
    return d_w;
  }

  /*!
\brief twisted involution represented by canonical Weyl part
  */
  const weyl::TwistedInvolution tw() const {
    return weyl::TwistedInvolution(d_w);
  }

// manipulators

  /*!
\brief Multiplies the Tits group element on the right by x in T(2).
  */
  TitsElt& operator+= (const TorusPart& x) {
    d_t += x;
    return *this;
  }

  /*!
\brief Factor in T(2) of the Tits group element.
  */
  TorusPart& t() {
    return d_t;
  }

  /*!
\brief projection (mod torus) of the Tits group element into the Weyl group
  */
  weyl::WeylElt& w() {
    return d_w;
  }

};

/*!
\brief Represents a finite subgroup of the normalizer in G of the Cartan T.

  We use a slight variant of the Tits group (also called extended Weyl
  group) as defined in J. Tits, J. of Algebra 4 (1966), pp. 96-116.

  The slight variant is that we include all elements of order two in the
  torus, instead of just the subgroup generated by the \f$m_\alpha\f$ (denoted
  \f$h_\alpha\f$ in Tits' paper.) Tits' original group may be defined by
  generators \f$\sigma_\alpha\f$ for \f$\alpha\f$ simple, subject to the braid
  relations and to \f$\sigma_\alpha^2= m_\alpha\f$; to get our group we just add a
  basis of elements of $T(2)$ as additional generators, and express the
  \f$m_\alpha\f$ in this basis.

  On a practical level, because the \f$\sigma_\alpha\f$ satisfy the braid
  relations, any element of the Weyl group has a canonical lifting in the Tits
  group; so we may uniquely represent any element of the Tits group as a pair
  $(w,t)$, with \f$t \in T(2)\f$ and \f$w \in W\f$. The multiplication rules have to
  be thoroughly changed, though, to take into account the new relations.

  We have not tried to be optimally efficient here, as it is not expected that
  Tits computations will be significant computationally.

  Note on independence of choices: given a root \f$\alpha\f$ of $T$ in $G$, the
  corresponding homomorphism \f$\phi_\alpha\f$ from $SL(2)$ to $G$ is defined only
  up to conjugation by $T$. This means that the generator \f$\sigma_\alpha\f$ of
  the Tits group appears to be defined only up to multiplication by the image
  of the coroot \f$\alpha^\vee\f$. But we are fixing a pinning, which means in
  particular that the maps \f$\phi_\alpha\f$ for \f$\alpha\f$ simple are canonically
  defined (by the requirement that the standard pinning of $SL(2)$ be carried
  to the pinning for $G$). This means that the generator \f$\sigma_\alpha\f$
  (still for \f$\alpha\f$ simple) is canonically defined.
*/
class TitsGroup {

 private:

/*! \brief Permutation of the simple generators \f$\sigma_\alpha\f$ of the Tits
   group given by the involution \f$\delta\f$.

This is an array of |unsigned char| (labelling the generators), of size
|RANK_MAX|, giving the permutation of the generators induced by \f$\delta\f$.
  */
  weyl::Twist d_twist;

  /*!
\brief Pointer to the underlying Weyl group.
  */
  weyl::WeylGroup* d_weyl; // the underlying Weyl group

  /*!
\brief Dimension of the Cartan T.
  */
  size_t d_rank;

  /*!
\brief List of the images in character lattice mod 2 of the simple roots.

Regarded as elements of order two in the dual torus \f$T^\vee\f$, these are
the elements \f$m_\alpha^\vee\f$.
  */
std::vector<TorusPart> d_simpleRoot;

  /*!
\brief List of the elements \f$m_\alpha\f$ (for \f$\alpha\f$ simple) in $T(2)$.
  */
  std::vector<TorusPart> d_simpleCoroot;

  /*!
\brief Transpose of the reduction mod 2 of the matrix of the defining
involution of the inner class.

Gives the action of the involution \f$\delta\f$ on $T(2)$, for computing in
the \f$\delta\f$ coset of the Tits group.

This data member is currently unsued, but the correct value available for
future use in methods [MvL 19 June 2007]
  */
  TorusMatrix d_involution;


// copy and assignment
// reserve and implement when necessary
  TitsGroup(const TitsGroup&);
  TitsGroup& operator= (const TitsGroup&);

 public:

// constructors and destructors
  TitsGroup()
    : d_twist(0)
    , d_weyl(NULL)
    , d_rank(0)
    {}

  TitsGroup(const rootdata::RootDatum&, const latticetypes::LatticeMatrix&);

  ~TitsGroup();

// accessors
/*!
\brief Conjugate the TitsElt |a| by \f$\sigma_\alpha\f$, where \f$\alpha\f$ is
 simple root \#|s|.

Note that the inverse of the generator \f$\sigma_\alpha\f$ is
\f$\sigma_\alpha.m_\alpha\f$.
*/
  void conjugate(TitsElt& a, weyl::Generator s) const {

    leftMult(a,s);
    mult(a,s); a += d_simpleCoroot[s];
  }

/*!
\brief Conjugate \f$t\in T(2)\subset Tits\f$ by the inverse $w^{-1}$

Note: this is not in any way the inverse of the previous method.
*/
  void invConjugate(TorusPart& t, const weyl::WeylElt& w) const;

  void leftMult(TitsElt&, weyl::Generator) const;

  /*!
\brief Length of the underlying Weyl group element.
  */
  unsigned long length(const TitsElt& a) const {
    return d_weyl->length(a.w());
  }

  void mult(TitsElt&, weyl::Generator) const;

  void mult(TitsElt&, const TitsElt&) const;

  /*!
\brief Rank of the underlying group.
  */
  const size_t rank() const {
    return d_rank;
  }

  /*!
\brief Applies to the element x of T(2) simple reflection s.

The reflection must be given its _outer_numbering (the Bourbaki one),
not the internal renumbering used by weylGroup.
  */
  void reflection(TorusPart& x, weyl::Generator s) const {
/*
  note: s must be an _outer_ generator
*/
    if (bitvector::scalarProduct(x,d_simpleRoot[s]))
      x += d_simpleCoroot[s];
  }

  /*!
\brief Element m_\alpha of T(2) for simple coroot \#j.
  */
  const TorusPart& simpleCoroot(size_t j) const {
    return d_simpleCoroot[j];
  }

  /*!
\brief Image in the character lattice mod 2 of simple root \#j.
  */
  const TorusPart& simpleRoot(size_t j) const {
    return d_simpleRoot[j];
  }

  /*!
\brief Action of the defining involution of the inner class on simple
generator \#j.
  */
  size_t twist(size_t j) const {
    return d_twist[j];
  }

  /*!
\brief Twisted conjugates the TitsElt a by the generator for simple
root \#s.

This corresponds to conjugation of the coset a.delta, with delta the
defining involution of the inner class.  Note that the inverse of the
generator \sigma_\alpha is \sigma_\alpha.m_\alpha.
  */
  void twistedConjugate(TitsElt& a, weyl::Generator s) const {
/*
  note: in the Tits group s^{-1} is s.m_s!
*/
    leftMult(a,s);
    mult(a,d_twist[s]); a += d_simpleCoroot[d_twist[s]];
  }

  const weyl::WeylGroup& weylGroup() const {
    return *d_weyl;
  }

// manipulators
  void swap(TitsGroup&);
};

}

}

#endif
