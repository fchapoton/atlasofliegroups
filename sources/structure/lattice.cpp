/*!
\file
\brief Implementation for namespace lattice.

  This module defines some more general lattice
  functions, less simple than what is defined in latticetypes.cpp.
*/
/*
  This is lattice.cpp.

  Copyright (C) 2004,2005 Fokko du Cloux
  part of the Atlas of Reductive Lie Groups

  For license information see the LICENSE file
*/

#include "latticetypes.h"

#include "arithmetic.h"
#include "smithnormal.h"

/*****************************************************************************

  This module defines some more general lattice functions, less simple than
  what is defined in latticetypes.cpp.

******************************************************************************/

namespace atlas {

  /*!
  \brief Functions for working with lattices.

  This namespace defines some more general lattice functions, less simple than
  what is defined in latticetypes.cpp. It includes change of basis functions,
  reduction modulo two, and calculating the orthogonal of a sublattice.
  */
namespace lattice {

  using namespace latticetypes;

}

/*****************************************************************************

        Chapter I -- Functions declared in lattice.h

  This section defines the following functions :

    - perp(WeightList&, const WeightList&): determines the orthogonal of
      a sublattice;

******************************************************************************/

namespace lattice {

void numeratorMatrix(latticetypes::LatticeMatrix& q,
		     const latticetypes::RatWeightList& rwl)

/*!
  Synopsis: puts in q the matrix whose columns are the numerator vectors of
  rwl.

  Precondition: the vectors in rwl all have the same dimension.
*/

{
  if (rwl.empty()) {
    q.resize(0,0);
    return;
  }

  q.resize(rwl[0].size(),rwl.size());

  for (size_t j = 0; j < q.numColumns(); ++j)
    for (size_t i = 0; i < q.numRows(); ++i)
      q(i,j) = rwl[j].numerator()[i];

  return;
}

void perp(WeightList& b1, const WeightList& b2, size_t r)

/*!
  This function puts in b1 a basis of the orthogonal of the sublattice
  generated by b2 in Z^r. The algorithm is simple : find a Smith normal basis
  for b2; then the last elements of the dual basis generate the orthogonal.
*/

{
  using namespace smithnormal;

  if (b2.size() == 0) {
    initBasis(b1,r);
    return;
  }

  CoeffList inv_factor;
  WeightList sb;
  initBasis(sb,r);

  smithNormal(inv_factor,sb.begin(),b2);

  // inverse transpose to get dual base change

  LatticeMatrix sq=LatticeMatrix(sb).inverse().transposed();

  // take last vectors

  LatticeElt v(r);

  for (size_t j = inv_factor.size(); j < sq.numColumns(); ++j) {
    sq.column(v,j);
    b1.push_back(v);
  }

  return;
}

void toCommonDenominator(latticetypes::RatWeightList& dest,
			 const latticetypes::RatWeightList& source)

/*!
  Synopsis: puts in dest the vectors equivalent to those in source, but
  reduced to the smallest common denominator.

  More precisely, we use as denominator the l.c.m. of the denominators in
  source.
*/

{
  using namespace arithmetic;

  // find denominator
  unsigned long d = 1;

  for (size_t j = 0; j < source.size(); ++j)
    d = lcm(d,source[j].denominator());

  // rewrite vectors
  dest.resize(source.size());

  for (size_t j = 0; j < source.size(); ++j) {
    unsigned long c = d/source[j].denominator();
    dest[j].numerator() = source[j].numerator();
    dest[j].numerator() *= c;
    dest[j].denominator() = d;
  }

  return;
}

}

}
