/*!
\file
\brief Implementation for namespace lattice.

  This module defines some more general lattice
  functions, less simple than what is defined in latticetypes.cpp.
*/
/*
  This is lattice.cpp.

  Copyright (C) 2004,2005 Fokko du Cloux
  part of the Atlas of Reductive Lie Groups

  For license information see the LICENSE file
*/

#include "latticetypes.h"

#include "arithmetic.h"
#include "smithnormal.h"

/*****************************************************************************

  This module defines some more general lattice functions, less simple than
  what is defined in latticetypes.cpp.

******************************************************************************/

namespace atlas {

  /*!
  \brief Functions for working with lattices.

  This namespace defines some more general lattice functions, less simple than
  what is defined in latticetypes.cpp. It includes change of basis functions,
  reduction modulo two, and calculating the orthogonal of a sublattice.
  */

/*****************************************************************************

        Chapter I -- Functions declared in lattice.h

******************************************************************************/

namespace lattice {


/*!
  Synopsis: puts in q the matrix whose columns are the numerator vectors of
  rwl.

  Precondition: the vectors in rwl all have the same dimension.
*/
void numeratorMatrix(latticetypes::LatticeMatrix& q,
		     const latticetypes::RatWeightList& rwl)
{
  if (rwl.empty()) {
    q.resize(0,0);
    return;
  }

  q.resize(rwl[0].size(),rwl.size());

  for (size_t j = 0; j < q.numColumns(); ++j)
    for (size_t i = 0; i < q.numRows(); ++i)
      q(i,j) = rwl[j].numerator()[i];
}


/*!
  This function puts in b1 a basis of the orthogonal of the sublattice
  generated by b2 in Z^r. The algorithm is simple : find a Smith normal basis
  for b2; then the last elements of the dual basis generate the orthogonal.
*/
void perp(latticetypes::WeightList& b1,
	  const latticetypes::WeightList& b2,
	  size_t r)
{
  if (b2.size() == 0)
  {
    matrix::initBasis(b1,r);
    return;
  }

  latticetypes::CoeffList inv_factor;
  latticetypes::WeightList sb;
  matrix::initBasis(sb,r);

  smithnormal::smithNormal(inv_factor,sb.begin(),b2);

  // inverse transpose to get dual base change

  latticetypes::LatticeMatrix sq =
    latticetypes::LatticeMatrix(sb).inverse().transposed();

  // take last vectors
  for (size_t j=inv_factor.size(); j<sq.numColumns(); ++j)
    b1.push_back(sq.column(j));
}

void toCommonDenominator(latticetypes::RatWeightList& dest,
			 const latticetypes::RatWeightList& source)

/*!
  Synopsis: puts in dest the vectors equivalent to those in source, but
  reduced to the smallest common denominator.

  More precisely, we use as denominator the l.c.m. of the denominators in
  source.
*/

{
  // find denominator
  unsigned long d = 1;

  for (size_t j = 0; j < source.size(); ++j)
    d = arithmetic::lcm(d,source[j].denominator());

  // rewrite vectors
  dest.resize(source.size());

  for (size_t j = 0; j < source.size(); ++j)
  {
    unsigned long c = d/source[j].denominator();
    dest[j].numerator() = source[j].numerator();
    dest[j].numerator() *= c;
    dest[j].denominator() = d;
  }
}

}

}
