/*!
\file
\brief Implementation for namespace lattice.

  This module defines some more general lattice
  functions, less simple than what is defined in latticetypes.cpp.
*/
/*
  This is lattice.cpp.

  Copyright (C) 2004,2005 Fokko du Cloux
  part of the Atlas of Reductive Lie Groups

  For license information see the LICENSE file
*/

#include "latticetypes.h"

#include "arithmetic.h"
#include "smithnormal.h"

/*****************************************************************************

  This module defines some more general lattice functions, less simple than
  what is defined in latticetypes.cpp.

******************************************************************************/

namespace atlas {

  /*!
  \brief Functions for working with lattices.

  This namespace defines some more general lattice functions, less simple than
  what is defined in latticetypes.cpp. It includes change of basis functions,
  reduction modulo two, and calculating the orthogonal of a sublattice.
  */

/*****************************************************************************

        Chapter I -- Functions declared in lattice.h

******************************************************************************/

namespace lattice {


/*!
  \brief Returns the matrix whose columns are the numerator vectors of |rwl|.

  Precondition: the vectors in rwl all have the same dimension.
*/
latticetypes::LatticeMatrix
numeratorMatrix(const latticetypes::RatWeightList& rwl)
{
  latticetypes::LatticeMatrix result
    (rwl.size()==0 ? 0 : rwl[0].size(),rwl.size());

  for (size_t j = 0; j<rwl.size(); ++j)
    result.set_column(j,rwl[j].numerator());

  return result;
}


/*! \brief
  Returns a basis of the orthogonal of the sublattice generated by b in Z^r.

  Algorithm: find a Smith normal basis for |b|; then the final elements of the
  dual basis, without corresponding invariant factors, generate the result.

  Precondition: the vectors in |b| all have the rank |r|.
*/
latticetypes::WeightList perp(const latticetypes::WeightList& b, size_t r)
{
  latticetypes::LatticeMatrix M(b,r); // this is what we really needed

  latticetypes::WeightList basis; matrix::initBasis(basis,r);

  latticetypes::CoeffList inv_factor;
  smithnormal::smithNormal(inv_factor,basis.begin(),M);

  // inverse transpose to get dual base change
  latticetypes::LatticeMatrix sq =
    latticetypes::LatticeMatrix(basis,r).inverse().transposed();

  // take last vectors
  latticetypes::WeightList result;
  for (size_t j=inv_factor.size(); j<sq.numColumns(); ++j)
    result.push_back(sq.column(j));

  return result;
}


/*! \brief Returns the vectors equivalent to those in |l|, but written with
  the smallest common denominator (assuming the |l[i]| were reduced).

  More precisely, we use as denominator the l.c.m. of the denominators in |l|.
*/
latticetypes::RatWeightList toCommonDenominator
(const latticetypes::RatWeightList& l)
{
  // find denominator
  unsigned long d = 1;

  for (size_t j = 0; j<l.size(); ++j)
    d = arithmetic::lcm(d,l[j].denominator());

  latticetypes::RatWeightList result; result.reserve(l.size());

  for (size_t j = 0; j < l.size(); ++j)
    result.push_back(latticetypes::RatWeight
      (l[j].numerator()*(d/l[j].denominator()),d));

  return result;
}

} // |namespace lattice|

} // |namespace atlas|
