/*!
\file
\brief Implementation for namespace lattice.

  This module defines some more general lattice
  functions, less simple than what is defined in latticetypes.cpp.
*/
/*
  This is lattice.cpp.

  Copyright (C) 2004,2005 Fokko du Cloux
  part of the Atlas of Reductive Lie Groups

  For license information see the LICENSE file
*/

#include "latticetypes.h"

#include "arithmetic.h"
#include "smithnormal.h"

/*****************************************************************************

  This module defines some more general lattice functions, less simple than
  what is defined in latticetypes.cpp.

******************************************************************************/

namespace atlas {

  /*!
  \brief Functions for working with lattices.

  This namespace defines some more general lattice functions, less simple than
  what is defined in latticetypes.cpp. It includes change of basis functions,
  reduction modulo two, and calculating the orthogonal of a sublattice.
  */

/*****************************************************************************

        Chapter I -- Functions declared in lattice.h

******************************************************************************/

namespace lattice {

/*!
  In this template, we assume that |I|, and |O| are respectively random
  access input and output iterator types for type |Weight|, and that
  |[firstb,lastb[| holds a new $\Q$-basis for the lattice, in particular that
  |lastb-firstb| is equal to the size of the |Weight|s.

  As we iterate from |first| to |last|, we write the vectors in the
  new basis (this is supposed to be possible) and output the result to |O|.

  Doing the base change amounts to applying the inverse of |b|'s matrix.

  NOTE: we don't assume that |[firstb, lastb[| is necessarily a $\Z$-basis of
  the current lattice, only that it is a basis of a full rank sublattice
  containing the vectors in the input range; the new coordinates will then be
  integers. Users should be aware of the "full rank" condition; without it the
  specification still makes sense, but the implementation will fail.
*/
template<typename I, typename O>
  void baseChange(I first, I last, O out, I firstb, I lastb)
{
  latticetypes::LatticeCoeff d;
  latticetypes::LatticeMatrix q =
    latticetypes::LatticeMatrix(firstb,lastb,lastb-firstb,tags::IteratorTag())
    .inverse(d);

  while (first!=last)
  {
    *out = (q.apply(*first)/=d);
    ++out, ++first;
  }
}

/*!
  This (unsused) template function is like |baseChange|, but goes from weights
  expressed in terms of |[firstb, lastb[| to ones expressed in terms of the
  original basis. This is easier, as we don't have to invert the matrix!
*/
template<typename I, typename O>
  void inverseBaseChange(I first, I last, O out, I firstb, I lastb)
{
  latticetypes::LatticeMatrix q(firstb,lastb,lastb-firstb,tags::IteratorTag());

  while (first!= last)
  {
    *out = q.apply(*first);
    ++out, ++first;
  }
}


/*! \brief
  Returns a basis of the orthogonal of the sublattice generated by b in Z^r.

  Algorithm: find a Smith normal basis for |b|; then the final elements of the
  dual basis, without corresponding invariant factors, generate the result.

  Precondition: the vectors in |b| all have the rank |r|.
*/
latticetypes::WeightList perp(const latticetypes::WeightList& b, size_t r)
{
  latticetypes::LatticeMatrix M(b,r); // this is what we really needed

  latticetypes::WeightList basis; matrix::initBasis(basis,r);

  latticetypes::CoeffList inv_factor;
  smithnormal::smithNormal(inv_factor,basis.begin(),M);

  // inverse transpose to get dual base change
  latticetypes::LatticeMatrix sq =
    latticetypes::LatticeMatrix(basis,r).inverse().transposed();

  // take last vectors
  latticetypes::WeightList result;
  for (size_t j=inv_factor.size(); j<sq.numColumns(); ++j)
    result.push_back(sq.column(j));

  return result;
}


template
void baseChange
  (latticetypes::WeightList::iterator,
   latticetypes::WeightList::iterator,
   std::back_insert_iterator<latticetypes::WeightList>,
   latticetypes::WeightList::iterator,
   latticetypes::WeightList::iterator);


} // |namespace lattice|

} // |namespace atlas|
