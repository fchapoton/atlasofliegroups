/*!
\file
  \brief Implementation of the RootDatum class.

  What we call a root datum in this program is what is usually called
  a based root datum.

  The root datum defines the complex reductive group entirely.

  Another non-trivial issue is how to get a group interactively from the
  user. Actually this is perhaps a bit overstated here; in fact, when the
  program functions as a library, the interaction with the user will be
  relegated to some higher-up interface; in practice it is likely that
  the data will usually be read from a file. The main issue is to define
  the character lattice of the torus.

  In the interactive approach, we start from the abstract real lie
  type, and (implicitly) associate to it the direct product of the
  simply connected semisimple factor, and the torus as it is
  given. The user is presented with the torsion subgroup Z_tor of the
  center, written as a factor of Q/Z for each torus factor, and a
  finite abelian group for each simple factor.  The user must then
  choose generators of a finite subgroup of Z_tor; this subgroup
  corresponds to a sublattice of finite index in the character
  lattice, containing the root lattice. From this sublattice the
  actual root datum is constructed.
*/
/*
  This is rootdata.cpp.

  Copyright (C) 2004,2005 Fokko du Cloux
  part of the Atlas of Reductive Lie Groups

  For license information see the LICENSE file
*/

#include "rootdata.h"

#include <cassert>
#include <deque>
#include <set>

#include "dynkin.h"
#include "lattice.h"
#include "partition.h"
#include "prerootdata.h"
#include "smithnormal.h"

/*****************************************************************************

  This module contains the implementation of the RootDatum class. What we
  call a root datum in this program is what is usually called a based root
  datum.

  The root datum defines the complex reductive group entirely.

  Another non-trivial issue is how to get a group interactively from the
  user. Actually this is perhaps a bit overstated here; in fact, when the
  program functions as a library, the interaction with the user will be
  relegated to some higher-up interface; in practice it is likely that
  the data will usually be read from a file. The main issue is to define
  the character lattice of the torus.

  In the interactive approach, we start from the abstract real lie
  type, and (implicitly) associate to it the direct product of the
  simply connected semisimple factor, and the torus as it is
  given. The user is presented with the torsion subgroup Z_tor of the
  center, written as a factor of Q/Z for each torus factor, and a
  finite abelian group for each simple factor.  The user must then
  choose generators of a finite subgroup of Z_tor; this subgroup
  corresponds to a sublattice of finite index in the character
  lattice, containing the root lattice. From this sublattice the
  actual root datum is constructed.

  [DV: An earlier version of this class included the inner class of
  real groups, which is to say an involutive automorphism of the based
  root datum.  As an artifact of that, the user interaction acquires
  the involutive automorphism before the subgroup of Z_tor, and
  insists that the subgroup of Z_tor be preserved by this involution.]

******************************************************************************/

namespace atlas {


/*****************************************************************************

        Chapter I -- The RootDatum class

  The root datum class will be one of the central classes in the program.

  A based root datum is a quadruple (X,X^,D,D^), where X and X^ are lattices
  dual to each other, and D is a basis for a root system in X, D^ the dual
  basis of the dual root system (more precisely, D and D^ willl be bases
  for root systems in the sub-lattices they generate.)

  The fundamental lattice X~ that we will work in is the character lattice of
  a group G~ x T, where G~ is a simply connected semisimple group, and T
  a torus; our complex reductive group G will be a finite
  quotient of this. More precisely, let Q be the subgroup of our lattice
  generated by D; then the character lattice X of G may be any sublattice of
  full rank of our fundamental lattice containing Q.

******************************************************************************/

namespace rootdata {

RootDatum::RootDatum(const prerootdata::PreRootDatum& prd)
  : d_rank(prd.rank())
  , d_semisimpleRank(prd.roots().size())
  , d_roots(prd.roots()) // temporarily set roots to \emph{simple} roots
  , d_coroots(prd.coroots()) // same for coroots
  , weight_numer(), coweight_numer()
  , d_radicalBasis(), d_coradicalBasis()
  , d_rootPermutation() // size will be |numPosRoots()| times |numRoots()|
  , descent_set() // size will be |numRoots()|
  , d_2rho(prd.rank(),0)
  , d_dual_2rho(prd.rank(),0)
  , Cartan_denom()
  , d_status()
{
  // fill in the weights and coweights

  latticetypes::LatticeMatrix tc(d_semisimpleRank); // transpose Cartan matrix

  for (size_t j = 0; j < d_semisimpleRank; ++j)
    for (size_t i = 0; i < d_semisimpleRank; ++i)
      tc(j,i) = d_roots[i].scalarProduct(d_coroots[j]);

  tc.invert(Cartan_denom); // this inverse matrix will serve twice!

  // the simple weights are given by the matrix Q.tC^{-1}, where Q is the
  // matrix of the simple roots, tC the transpose Cartan matrix
  latticetypes::LatticeMatrix q(d_roots);
  latticetypes::LatticeMatrix qc(d_coroots);
  q *= tc;
  tc.transpose(); // now we have the non-transposed Cartan matrix
  qc *= tc;

  matrix::columnVectors(weight_numer,q);
  matrix::columnVectors(coweight_numer,qc);

  // get basis of co-radical character lattice
  if (d_semisimpleRank < d_rank)
  {
    lattice::perp(d_coradicalBasis,d_coroots,d_rank);
    lattice::perp(d_radicalBasis,d_roots,d_rank);
  }

  latticetypes::WeightList pos_roots, pos_coroots;

  // generate systems of positive roots and coroots
  fill_positives(pos_roots,pos_coroots); // also sets |d_2rho|, |d_dual_2rho|

  // find permutation ordering roots by height, and simple roots in order
  std::vector<size_t> reorder= sort_roots(pos_roots,coweight_numer);

  for (size_t i=0; i<d_semisimpleRank; ++i)
    assert(pos_roots[reorder[i]]==d_roots[i]); // check position simple roots

  const size_t half=pos_roots.size();
  const size_t whole=2*half;
  d_roots.clear(); d_roots.reserve(whole);
  d_coroots.clear(); d_coroots.reserve(whole);

  // enter negative roots first, from most negative to negative simples
  for (size_t i=half; i-->0; )
  {
    d_roots.push_back(pos_roots[reorder[i]]);     d_roots.back().negate();
    d_coroots.push_back(pos_coroots[reorder[i]]); d_coroots.back().negate();
  }

  // then the positive roots in order as given by |reorder|
  for (size_t i=0; i<half; ++i)
  {
    d_roots.push_back(pos_roots[reorder[i]]);
    d_coroots.push_back(pos_coroots[reorder[i]]);
  }

  d_rootPermutation.resize(half,setutils::Permutation(whole));
  descent_set.resize(whole);

  // first fill in the simple root permutations and descent sets
  for (size_t i=0; i<d_semisimpleRank; ++i)
    for (RootNbr alpha=0; alpha<whole; ++alpha)
    {
      RootNbr beta = rootNbr(simpleReflection(root(alpha),i));
      assert(beta<whole); // some root must be found
      d_rootPermutation[i][alpha] = beta;
      descent_set[alpha].set(i,beta<alpha);
      assert(not descent_set[beta].test(i)); // as |beta>alpha| not yet done
    }

  // extend permutations to all positive roots by conjugation from lower root
  for (size_t alpha=half+d_semisimpleRank; alpha<whole; ++alpha)
  {
    size_t i=descent_set[alpha].firstBit();
    assert(i<d_semisimpleRank);
    setutils::Permutation& alpha_perm=d_rootPermutation[alpha-half];
    alpha_perm=d_rootPermutation[i];
    d_rootPermutation[d_rootPermutation[i][alpha]-half].left_mult(alpha_perm);
    d_rootPermutation[i].left_mult(alpha_perm);
  }
  // fill in the status

  fillStatus();
}



/*!
\brief Constructs the root system dual to the given one.

  Since we do not use distinct types for weights and coweights, we can proceed
  by interchanging roots and coroots. The ordering of the roots corresponds to
  that of the original root datum (root |i| of the dual datum is coroot |i| of
  the orginal datum; this is not the ordering that would have been used in a
  freshly constructed root datum), but users should \emph{not} depend on this.
*/
RootDatum::RootDatum(const RootDatum& rd, tags::DualTag)
  : d_rank(rd.d_rank)
  , d_semisimpleRank(rd.d_semisimpleRank)
  , d_roots(rd.d_coroots)
  , d_coroots(rd.d_roots)
  , weight_numer(rd.coweight_numer)
  , coweight_numer(rd.weight_numer)
  , d_radicalBasis(rd.d_coradicalBasis)
  , d_coradicalBasis(rd.d_radicalBasis)
  , d_rootPermutation(rd.d_rootPermutation) // root permutation is the same
  , descent_set(rd.descent_set) // and therefore descent set as well
  , d_2rho(rd.d_dual_2rho)
  , d_dual_2rho(rd.d_2rho)
  , Cartan_denom(rd.Cartan_denom)
  , d_status()
{
  // fill in the status

  fillStatus();

  assert(d_status[IsAdjoint] == rd.d_status[IsSimplyConnected]);
  assert(d_status[IsSimplyConnected] == rd.d_status[IsAdjoint]);
}

RootDatum::~RootDatum()

{}

/******** accessors **********************************************************/

latticetypes::Weight RootDatum::inSimpleRoots(RootNbr n) const
{
  latticetypes::Weight result(d_semisimpleRank);
  for (size_t i = 0; i<d_semisimpleRank; ++i)
    result[i] = root(n).scalarProduct(coweight_numer[i])/Cartan_denom;
  return result;
}

latticetypes::Weight RootDatum::inSimpleCoroots(RootNbr n) const
{
  latticetypes::Weight result(d_semisimpleRank);
  for (size_t i = 0; i<d_semisimpleRank; ++i)
    result[i] = coroot(n).scalarProduct(weight_numer[i])/Cartan_denom;
  return result;
}

/*!
\brief Returns the permutation of the roots induced by |q|.

  Precondition: |q| permutes the roots;
*/
setutils::Permutation
  RootDatum::rootPermutation(const LT::LatticeMatrix& q) const
{
  setutils::Permutation result(numRoots());

  for (RootNbr alpha=0; alpha<numRoots(); ++alpha)
  {
    result[alpha] = rootNbr(q.apply(root(alpha)));
    assert(result[alpha]<numRoots()); // image by |q| must be some root
  }

  return result;
}

// extend diagram automorphism to permutation of all roots
setutils::Permutation
  RootDatum::root_permutation(const setutils::Permutation& twist) const
{
  assert(twist.size()==semisimpleRank());
  setutils::Permutation result(numRoots());

  // copy twist for simple roots
  for (size_t i=0; i<twist.size(); ++i)
    result[simpleRootNbr(i)]=simpleRootNbr(twist[i]);

  // extend to positive roots
  for (size_t alpha=endSimpleRoot()-beginRoot(); alpha<numRoots(); ++alpha)
  {
    size_t i=descents(alpha).firstBit();
    assert(i<semisimpleRank());
    assert(isPosRoot(simple_reflected_root(alpha,i)));
    assert(simple_reflected_root(alpha,i)<alpha); // result is already defined
    result[alpha] =
      simple_reflected_root(result[simple_reflected_root(alpha,i)],twist[i]);
  }

  // finally extend to negative roots, using symmetry of root permutation
  for (size_t alpha=0; alpha<numPosRoots(); ++alpha) // |alpha| negative root
    result[alpha]=rootMinus(result[rootMinus(alpha)]);

  return result;
}

// more generally extend any root datum automorphism from simple to all roots
setutils::Permutation
  RootDatum::extend_to_roots(const std::vector<RootNbr>& simple_image) const
{
  assert(simple_image.size()==semisimpleRank());
  setutils::Permutation result(numRoots());

  std::vector<const setutils::Permutation*> image_reflection;

  // prepare permutations for reflections for roots in |simple_image|
  image_reflection.reserve(semisimpleRank());
  for (size_t i=0; i<semisimpleRank(); ++i)
    image_reflection.push_back(&root_permutation(simple_image[i]));

  // copy images of simple roots
  for (size_t i=0; i<semisimpleRank(); ++i)
    result[simpleRootNbr(i)]=simple_image[i];

  // extend to positive roots
  for (size_t alpha=numPosRoots()+semisimpleRank(); alpha<numRoots(); ++alpha)
  {
    size_t i=descents(alpha).firstBit();
    assert(i<semisimpleRank());
    assert(isPosRoot(simple_reflected_root(alpha,i)));
    assert(simple_reflected_root(alpha,i)<alpha); // result is already defined
    result[alpha] =
      (*image_reflection[i])[result[simple_reflected_root(alpha,i)]];
  }

  // finally extend to negative roots, using symmetry of root permutation
  for (size_t alpha=0; alpha<numPosRoots(); ++alpha) // |alpha| negative root
    result[alpha]=rootMinus(result[rootMinus(alpha)]);

  return result;
}


/*!
\brief Returns the reflection for root \#alpha.

  NOTE: this is not intended for heavy use. If that is envisioned, it would be
  better to construct the matrices once and for all and return const
  references.
*/
latticetypes::LatticeMatrix RootDatum::rootReflection(RootNbr alpha) const
{
  latticetypes:: LatticeMatrix result;
  matrix::identityMatrix(result,d_rank);

/*
  result -=
    matrix::column_matrix(root(alpha)) * matrix::row_matrix(coroot(alpha));
*/

  const Root& root = d_roots[alpha];
  const Root& coroot = d_coroots[alpha];

  for (size_t i=0; i<d_rank; ++i)
    for (size_t j=0; j<d_rank; ++j)
      result(i,j) -= root[i]*coroot[j];

  return result;
}

weyl::WeylWord RootDatum::reflectionWord(RootNbr alpha) const
{
  return toPositive(reflection(twoRho(),alpha),*this);
}


latticetypes::LatticeMatrix RootDatum::cartanMatrix() const
{
  size_t r = semisimpleRank();

  latticetypes::LatticeMatrix result(r,r);

  for (size_t j = 0; j < r; ++j)
    for (size_t i = 0; i < r; ++i)
      result(i,j) = cartan(i,j);

  return result;
}


/*!
\brief Returns the Cartan matrix of the root subsystem with basis |rb|.
*/
LT::LatticeMatrix RootDatum::cartanMatrix(const RootList& rb) const
{
  size_t r = rb.size();

  latticetypes::LatticeMatrix result(r,r);

  for (size_t i=0; i<r; ++i)
    for (size_t j=0; j<r; ++j)
      result(i,j) = root(rb[i]).scalarProduct(coroot(rb[j]));

  return result;
}

/*!\brief
  Returns the expression of $q^{-1}$ as a product of simple reflections.

  Precondition: $q$ gives the action on the weight lattice of some Weyl group
  element

  Algorithm: apply $q$ to |twoRho|, then use |toPositive| to find a Weyl
  word making it dominant again, which by assumption expresses $q^{-1}$.
*/
weyl::WeylWord RootDatum::word_of_inverse_matrix
  (const latticetypes::LatticeMatrix& q) const
{
  return toPositive(q.apply(twoRho()),*this);
}

/*!
\brief Returns the sum of the positive roots in rl.

  Precondition: rl holds the roots in a sub-rootsystem of the root system of
  rd;
*/
latticetypes::Weight RootDatum::twoRho(const RootList& rl) const
{
  latticetypes::Weight result(rank(),0);

  for (size_t i = 0; i < rl.size(); ++i)
    if (isPosRoot(rl[i]))
      result += root(rl[i]);

  return result;
}

/*!
\brief Returns the sum of the positive roots in rs.

  Precondition: rs holds the roots in a sub-rootsystem of the root system of
  rd;
*/
latticetypes::Weight RootDatum::twoRho(const RootSet& rs) const
{
  latticetypes::Weight result(rank(),0);

  for (RootSet::iterator i = rs.begin(); i(); ++i)
    if (isPosRoot(*i))
      result += root(*i);

  return result;
}


/*!
  \brief Returns the canonical basis (set of simple roots) of |rl|, which
  should hold all roots (or positive roots) of a root subsystem of |rd|

  Forwarded to the RootSet version. Therefore the order of the roots in |rl|
  is ignored! The roots of |rb| are by order of occurrence in |rd.roots()|
*/
RootList RootDatum::simpleBasis(const RootList& rl) const
{
  RootSet rs(numRoots()); rs.insert(rl.begin(),rl.end());
  return simpleBasis(rs);
}

/*!
  \brief Returns the canonical basis (set of simple roots) of |rs|, which
  should hold all roots (or positive roots) of a root subsystem of |rd|

  Algorithm: compute the sum of the positive roots in |rs|; extract the
  roots whose scalar product with that sum is 2.
*/
RootList RootDatum::simpleBasis(RootSet rs) const
{
  // compute sum of positive roots
  latticetypes::Weight rho2=twoRho(rs);

  RootList result;

  for (RootSet::iterator i = rs.begin(); i(); ++i)
    if (scalarProduct(rho2,*i) == 2) result.push_back(*i);

  return result;
}

/*!
\brief Tells if a+b is a root.

  Precondition: a and b are roots;
*/
bool RootDatum::sumIsRoot(const latticetypes::Weight& a,
			  const latticetypes::Weight& b) const
{
  latticetypes::Weight v = a;
  v += b;
  return isRoot(v);
}

RootList RootDatum::high_roots() const
{
  RootList h;
  for (RootNbr alpha=0; alpha<numPosRoots(); ++alpha)
    if (descents(alpha).none())
      h.push_back(rootMinus(alpha));

  return h;
}


/******** manipulators *******************************************************/

void RootDatum::swap(RootDatum& other)
{
  std::swap(d_rank,other.d_rank);
  std::swap(d_semisimpleRank,other.d_semisimpleRank);
  d_roots.swap(other.d_roots);
  d_coroots.swap(other.d_coroots);
  weight_numer.swap(other.weight_numer);
  coweight_numer.swap(other.coweight_numer);
  d_radicalBasis.swap(other.d_radicalBasis);
  d_coradicalBasis.swap(other.d_coradicalBasis);
  d_rootPermutation.swap(other.d_rootPermutation),
  descent_set.swap(other.descent_set),
  d_2rho.swap(other.d_2rho);
  d_dual_2rho.swap(other.d_dual_2rho);
  std::swap(Cartan_denom,other.Cartan_denom);
  d_status.swap(other.d_status);
}

/******** private member functions ******************************************/

void RootDatum::fillStatus()

/*!
\brief Fills in the status of the rootdatum.
*/

{
  using namespace latticetypes;
  using namespace matrix;
  using namespace smithnormal;
  using namespace tags;

  LatticeMatrix q(beginSimpleRoot(),endSimpleRoot(),IteratorTag());

  WeightList b;
  CoeffList invf;

  initBasis(b,d_rank);
  smithNormal(invf,b.begin(),q);

  d_status.set(IsAdjoint);

  for (size_t i = 0; i < invf.size(); ++i)
    if (invf[i] != 1) {
      d_status.reset(IsAdjoint);
      break;
    }

  LatticeMatrix qd(beginSimpleCoroot(),endSimpleCoroot(),IteratorTag());

  initBasis(b,d_rank);
  invf.clear();
  smithNormal(invf,b.begin(),qd);

  d_status.set(IsSimplyConnected);

  for (size_t i = 0; i < invf.size(); ++i)
    if (invf[i] != 1) {
      d_status.reset(IsSimplyConnected);
      break;
    }
}

} // namespace rootdata

/*****************************************************************************

        Chapter II -- Functions declared in rootdata.h

  This section defines the following functions, which were declared in
  rootdata.h :

******************************************************************************/

namespace rootdata {


/*!
\brief Puts in c the Cartan matrix of the root datum
*/
void cartanMatrix(latticetypes::LatticeMatrix& c, const RootDatum& rd)
{
  size_t r = rd.semisimpleRank();

  c.resize(r,r,0);

  for (size_t i=0; i<r; ++i)
    for (size_t j= 0; j<r; ++j)
      c(i,j) = rd.cartan(i,j);
}


/*!
\brief Puts in c the Cartan matrix of the root basis rb.

  Precondition: rb contains a basis of a root subsystem of that of rd.
*/
void cartanMatrix(latticetypes::LatticeMatrix& c, const RootList& rb,
		  const RootDatum& rd)
{
  c=rd.cartanMatrix(rb);
}


/*!
\brief Returns matrix of dual involution of the one given by |i|

  Precondition: |q| is an involution of |rd| as a _based_ root datum

  Postcondition: |di| is an involution of the dual based root datum

  Formula: $(w_0^t)(-q^t) = (-q.w_0)^t$

  In other words, to |-i| we apply the (longest) Weyl group element $w_0$
  making the image of the dominant chamber dominant again, then transpose

  Since $-w_0$ is central in the group of based root datum automorphisms, it
  doesn't matter whether one multiplies by $w_0$ on the left or on the right
*/

LT::LatticeMatrix dualBasedInvolution
  (const LT::LatticeMatrix& q, const RootDatum& rd)
{
  LT::LatticeMatrix di=q;
  weyl::WeylWord ww=toPositive(-rd.twoRho(),rd);
  for (size_t i=0; i<ww.size(); ++i)
    di *= rd.rootReflection(rd.simpleRootNbr(ww[i]));

  return di.negative_transposed();
}

/*!
\brief puts in lt the Lie type of the root system spanned by rb.

  Precondition: rb contains a basis of a sub-rootsystem of the root system of
  rd.
*/
void lieType(lietype::LieType& lt, const RootList& rb, const RootDatum& rd)
{
  using namespace dynkin;
  using namespace latticetypes;

  LatticeMatrix cm;
  cartanMatrix(cm,rb,rd);
  dynkin::lieType(lt,cm);
}



/*!
\brief Puts in orth the elements of rs which are orthogonal to all
  elements of rl.
*/
void makeOrthogonal(RootList& orth, const RootList& rl, const RootList& rs,
		    const RootDatum& rd)
{
  orth.resize(0);

  for (unsigned long i = 0; i < rs.size(); ++i) {
    for (unsigned long j = 0; j < rl.size(); ++j)
      if (!rd.isOrthogonal(rs[i],rl[j])) // rs[i] is not orthogonal to rl
	goto not_orthogonal;
    orth.push_back(rs[i]);
  not_orthogonal:
    continue;
  }
}

/*!
\brief Puts in rb the canonical basis (set of simple roots) of rl.

  Precondition: rl holds the roots in a sub-root system of rd;

  Forwarded to the RootSet version. Therefore the order of the roots in |rl|
  is ignored! The roots of |rb| are by order of occurrence in |rd.roots()|
*/
void rootBasis(RootList& rb, const RootList& rl, const RootDatum& rd)
{
  RootSet rs(rd.numRoots());
  rs.insert(rl.begin(),rl.end());
  rootBasis(rb,rs,rd);
}


/*!
\brief puts in rb the canonical basis (set of simple roots) of rs.

  Precondition: rs holds the roots in a sub-root system of rd;

  Algorithm: compute the sum of the positive roots in rs; extract the
  positive roots whose scalar product with that sum is 2.
*/
void rootBasis(RootList& rb, RootSet rs, const RootDatum& rd)
{
  rs &= rd.posRootSet();

  // compute sum of positive roots

  latticetypes::Weight twoRho(rd.rank(),0);

  for (RootSet::iterator i = rs.begin(); i(); ++i)
    twoRho += rd.root(*i);

  rb.clear();

  for (RootSet::iterator i = rs.begin(); i(); ++i)
    if (rd.scalarProduct(twoRho,*i) == 2)
      rb.push_back(*i);
}



/*!
\brief Makes rl into a strongly orthogonal system.

  Precondition: rl is a set of pairwise orthogonal roots;

  Algorithm: for i,j in rl, the sum can be a root iff i,j span a subsystem
  of type B2, and are short there; we can then replace i and j by their sum
  and difference. Note that this will not create new bad pairs, as bad pairs
  are made up of short roots.
*/
void strongOrthogonalize(RootList& rl, const RootDatum& rd)
{
  for (size_t j = 0; j < rl.size(); ++j)
    for (size_t i = 0; i < j; ++i)
      if (rd.sumIsRoot(rl[i],rl[j]))
      {
	latticetypes::Weight v = rd.root(rl[i]);
	v += rd.root(rl[j]);
	latticetypes::Weight w = rd.root(rl[i]);
	w -= rd.root(rl[j]);
	rl[i] = rd.rootNbr(v);
	rl[j] = rd.rootNbr(w);
      }
}


/*!
\brief Transforms q into w.q, where w is the unique element such that
  w.q fixes the positive Weyl chamber.

  Note that wq is then automatically an involution, permuting the simple roots
*/

void toDistinguished(latticetypes::LatticeMatrix& q, const RootDatum& rd)
{
  latticetypes::Weight v(rd.rank());
  q.apply(v,rd.twoRho());

  weyl::WeylWord ww=toPositive(v,rd);

  latticetypes::LatticeMatrix p;
  toMatrix(p,ww,rd);

  p *= q;
  q.swap(p);
}


/*!
\brief Writes in q the matrix represented by ww.

  NOTE: not intended for heavy use. If that were the case, it would be better
  to use the decomposition of ww into pieces, and multiply those together.
  However, that would be for the ComplexGroup to do, as it is it that has
  access to both the Weyl group and the root datum.
*/
void toMatrix(latticetypes::LatticeMatrix& q, const weyl::WeylWord& ww,
	      const RootDatum& rd)
{
  identityMatrix(q,rd.rank());

  for (size_t i = 0; i < ww.size(); ++i)
    q *= rd.rootReflection(rd.simpleRootNbr(ww[i]));
}

/*!
\brief Writes in q the matrix represented by rl (the product of the
  root reflections for the various roots in rl.)

  NOTE: the products are written in the same order as the appearance of
  the roots in rl. In practice this will be used for sequences of orthogonal
  roots, so that the order doesn't matter.
*/

void toMatrix(latticetypes::LatticeMatrix& q,
	      const RootList& rl,
	      const RootDatum& rd)

{
  identityMatrix(q,rd.rank());
  for (size_t i = 0; i < rl.size(); ++i)
    q *= rd.rootReflection(rl[i]);
}


/*!\brief
  Returns a reduced expression of the shortest |w| making |w.v| dominant

  Algorithm: the greedy algorithm -- if v is not positive, there is a
  simple coroot alpha^v such that <v,alpha^v> is < 0; then s_alpha.v takes
  v closer to the dominant chamber.
*/
weyl::WeylWord toPositive(latticetypes::Weight v, const RootDatum& rd)
{
  weyl::WeylWord result;

  size_t j;
  do
    for (j=0; j<rd.semisimpleRank(); ++j)
      if (v.scalarProduct(rd.simpleCoroot(j)) < 0)
      {
	result.push_back(j);
	rd.simpleReflect(v,j);
	break;
      }
  while (j<rd.semisimpleRank());

  // reverse result (action is from right to left)
  std::reverse(result.begin(),result.end());
  return result;
}

} // namespace rootdata

/*****************************************************************************

                Chapter III -- Auxiliary methods.

******************************************************************************/

namespace rootdata {


/*!
\brief Fills in the list rl of all the positive roots in the system, and the
  list crl of all the co-roots.

  Begins with the data of the root-basis rb and the co-root basis crb. The
  idea is to start out from rb, and then saturate through successive
  applications of simple reflections.

  The main problem is not to loose track of the root/co-root relationship.
  We want it to be so that the coroot of rl[j] is crl[j]. This is why we
  work with root/co-root _pairs_
*/
void RootDatum::fill_positives(latticetypes::WeightList& rl,
			       latticetypes::WeightList& crl)
{
  typedef std::pair<latticetypes::Weight,latticetypes::Weight> RP;

  std::set<RP> roots;
  std::deque<RP> new_roots;

  // initialize roots and new_roots with simple pairs
  // at this point the simple roots are available in |d_roots| and |d_coroots|
  for (size_t i=0; i<semisimpleRank(); ++i)
  {
    new_roots.push_back(make_pair(d_roots[i],d_coroots[i]));
    roots.insert(new_roots.back());
  }

  // construct positive root list

  while (not new_roots.empty())
  {
    const RP& rp = new_roots.front();
    for (size_t j = 0; j < semisimpleRank(); ++j)
      if (rp.first.scalarProduct(coroot(j))<0) // avoid going negative
      {
	assert(rp.second.scalarProduct(root(j))<0); // symmetric relation
	RP rp_new = rp;
	// simple-relflect by |j|; |simpleReflect| method is not yet ready
	reflect(rp_new.first,j);    // currently root |j| is simple root |j|
	coreflect(rp_new.second,j); // and likewise for coroot |j|
	if (roots.insert(rp_new).second) // then we found a new root
	  new_roots.push_back(rp_new);
      }
    new_roots.pop_front();
  }

  rl.clear(); rl.reserve(roots.size());
  crl.clear(); crl.reserve(roots.size());

  /* now write to the output parameters, compute |d_2rho| and |d_dual_2rho| */
  for (std::set<RP>::iterator rpi = roots.begin(); rpi != roots.end(); ++rpi)
  {
    rl.push_back(rpi->first);
    crl.push_back(rpi->second);
    d_2rho += rpi->first;
    d_dual_2rho += rpi->second;
  }

} // |fill_positives|

// a class for making a compare object for indices, backwards lexicographic
class weight_compare
{
  const std::vector<latticetypes::Weight>& alpha; // weights being compared
  std::vector<latticetypes::Weight> phi; // coweights by increasing priority

public:
  weight_compare(const std::vector<latticetypes::Weight>& roots,
		 const std::vector<latticetypes::Weight>& f)
    : alpha(roots), phi(f) {}

  void add_coweight(const latticetypes::Weight& f) { phi.push_back(f); }

  bool operator() (size_t i, size_t j)
  {
    latticetypes::LatticeCoeff x,y;
    for (size_t k=phi.size(); k-->0; )
      if ((x=phi[k].scalarProduct(alpha[i]))!=
	  (y=phi[k].scalarProduct(alpha[j])))
	return x<y;

    return false; // weights compare equal under all coweights
  }
}; // |class weight_compare|


/*!
\brief  Sorts roots by height, then lexicographic by backwards root coordinates
*/
std::vector<size_t>
RootDatum::sort_roots(const latticetypes::WeightList& roots,
		      const latticetypes::WeightList& simple_coweights) const
{
  std::vector<size_t> permutation(roots.size());
  if (permutation.empty())
    return permutation; // avoid any fuss for pure tori

  for (size_t i=0; i<permutation.size(); ++i)
    permutation[i]=i;

  // sort by root coordinates, backwards (so simple roots are in order)
  weight_compare comp(roots,simple_coweights);
  comp.add_coweight(d_dual_2rho); // height dominates individual coweights

  // sort indices so that simple roots come first, in order
  std::stable_sort(permutation.begin(),permutation.end(),comp);

  return permutation;
} // |sort_roots|


} // |namespace rootdata|

} // |namespace atlas|
