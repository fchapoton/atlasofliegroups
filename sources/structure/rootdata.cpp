/*!
\file
  \brief Implementation of the RootDatum class.

  What we call a root datum in this program is what is usually called
  a based root datum.

  The root datum defines the complex reductive group entirely.

  Another non-trivial issue is how to get a group interactively from the
  user. Actually this is perhaps a bit overstated here; in fact, when the
  program functions as a library, the interaction with the user will be
  relegated to some higher-up interface; in practice it is likely that
  the data will usually be read from a file. The main issue is to define
  the character lattice of the torus.

  In the interactive approach, we start from the abstract real lie
  type, and (implicitly) associate to it the direct product of the
  simply connected semisimple factor, and the torus as it is
  given. The user is presented with the torsion subgroup Z_tor of the
  center, written as a factor of Q/Z for each torus factor, and a
  finite abelian group for each simple factor.  The user must then
  choose generators of a finite subgroup of Z_tor; this subgroup
  corresponds to a sublattice of finite index in the character
  lattice, containing the root lattice. From this sublattice the
  actual root datum is constructed.
*/
/*
  This is rootdata.cpp.

  Copyright (C) 2004,2005 Fokko du Cloux
  part of the Atlas of Reductive Lie Groups

  For license information see the LICENSE file
*/

#include "rootdata.h"

#include <cassert>
#include <deque>
#include <set>

#include "dynkin.h"
#include "lattice.h"
#include "partition.h"
#include "prerootdata.h"
#include "smithnormal.h"

/*****************************************************************************

  This module contains the implementation of the RootDatum class. What we
  call a root datum in this program is what is usually called a based root
  datum.

  The root datum defines the complex reductive group entirely.

  Another non-trivial issue is how to get a group interactively from the
  user. Actually this is perhaps a bit overstated here; in fact, when the
  program functions as a library, the interaction with the user will be
  relegated to some higher-up interface; in practice it is likely that
  the data will usually be read from a file. The main issue is to define
  the character lattice of the torus.

  In the interactive approach, we start from the abstract real lie
  type, and (implicitly) associate to it the direct product of the
  simply connected semisimple factor, and the torus as it is
  given. The user is presented with the torsion subgroup Z_tor of the
  center, written as a factor of Q/Z for each torus factor, and a
  finite abelian group for each simple factor.  The user must then
  choose generators of a finite subgroup of Z_tor; this subgroup
  corresponds to a sublattice of finite index in the character
  lattice, containing the root lattice. From this sublattice the
  actual root datum is constructed.

  [DV: An earlier version of this class included the inner class of
  real groups, which is to say an involutive automorphism of the based
  root datum.  As an artifact of that, the user interaction acquires
  the involutive automorphism before the subgroup of Z_tor, and
  insists that the subgroup of Z_tor be preserved by this involution.]

******************************************************************************/

namespace atlas {


/*****************************************************************************

        Chapter I -- The RootDatum class

  The root datum class will be one of the central classes in the program.

  A based root datum is a quadruple (X,X^,D,D^), where X and X^ are lattices
  dual to each other, and D is a basis for a root system in X, D^ the dual
  basis of the dual root system (more precisely, D and D^ willl be bases
  for root systems in the sub-lattices they generate.)

  The fundamental lattice X~ that we will work in is the character lattice of
  a group G~ x T, where G~ is a simply connected semisimple group, and T
  a torus; our complex reductive group G will be a finite
  quotient of this. More precisely, let Q be the subgroup of our lattice
  generated by D; then the character lattice X of G may be any sublattice of
  full rank of our fundamental lattice containing Q.

******************************************************************************/

namespace rootdata {

RootDatum::RootDatum(const prerootdata::PreRootDatum& prd)
  : d_rank(prd.rank())
  , d_roots(prd.roots()) // temporarily set roots to \emph{simple} roots
  , d_coroots(prd.coroots()) // same for coroots
  , d_2rho(prd.rank(),0)
  , d_dual_2rho(prd.rank(),0)
{
  d_semisimpleRank = d_roots.size();

  // get basis of co-radical character lattice

  if (d_semisimpleRank < d_rank) {
    lattice::perp(d_coradicalBasis,d_coroots,d_rank);
    lattice::perp(d_radicalBasis,d_roots,d_rank);
  }
  // fill in the weights and coweights

  latticetypes::LatticeMatrix tc(d_semisimpleRank); // transpose Cartan matrix

  for (size_t j = 0; j < d_semisimpleRank; ++j)
    for (size_t i = 0; i < d_semisimpleRank; ++i)
      tc(j,i) = d_roots[i].scalarProduct(d_coroots[j]);

  latticetypes::LatticeCoeff d;
  tc.invert(d); // this inverse matrix will serve twice!

  // the simple weights are given by the matrix Q.tC^{-1}, where Q is the
  // matrix of the simple roots, tC the transpose Cartan matrix
  latticetypes::LatticeMatrix q(d_roots);
  q *= tc;

  for (size_t j = 0; j < d_semisimpleRank; ++j) {
    latticetypes::Weight v;
    q.column(v,j);
    d_weights.push_back(latticetypes::RatWeight(v,d));
  }

  latticetypes::WeightList simple_coweight(d_semisimpleRank); // without denom

  // do the same for coweights
  tc.transpose(); // now we have the non-transposed Cartan matrix
  latticetypes::LatticeMatrix qc(d_coroots);
  qc *= tc;

  for (size_t j = 0; j < d_semisimpleRank; ++j)
  {
    qc.column(simple_coweight[j],j);
    d_coweights.push_back(latticetypes::RatWeight(simple_coweight[j],d));
  }

  latticetypes::WeightList pos_roots, pos_coroots;

  // generate systems of positive roots and coroots
  fill_positives(pos_roots,pos_coroots); // also sets |d_2rho|, |d_dual_2rho|

  // find permutation ordering roots by height, and simple roots in order
  std::vector<size_t> reorder= sort_roots(pos_roots,simple_coweight);

  for (size_t i=0; i<d_semisimpleRank; ++i)
    assert(pos_roots[reorder[i]]==d_roots[i]); // check position simple roots

  const size_t half=pos_roots.size();
  d_roots.clear(); d_roots.reserve(2*half);
  d_coroots.clear(); d_coroots.reserve(2*half);

  // enter negative roots first, from most negative to negative simples
  for (size_t i=half; i-->0; )
  {
    d_roots.push_back(pos_roots[reorder[i]]);     d_roots.back().negate();
    d_coroots.push_back(pos_coroots[reorder[i]]); d_coroots.back().negate();
  }

  // then the positive roots in order as given by |reorder|
  for (size_t i=0; i<half; ++i)
  {
    d_roots.push_back(pos_roots[reorder[i]]);
    d_coroots.push_back(pos_coroots[reorder[i]]);
  }

  // fill in the simple root permutations
  d_rootPermutation.reserve(d_semisimpleRank);

  for (size_t j = 0; j < d_semisimpleRank; ++j) {
    d_rootPermutation.push_back(setutils::Permutation(numRoots()));
    setutils::Permutation& rp = d_rootPermutation.back();
    for (size_t i = 0; i < numRoots(); ++i) {
      latticetypes::Weight v = d_roots[i];
      simpleReflect(v,j);
      rp[i] = rootNbr(v);
    }
  }


  // fill in the status

  fillStatus();
}



/*!
\brief Constructs the root system dual to the given one.

  Since we do not use distnct types for weights and coweights, we can proceed
  by essentially interchanging roots and coroots. The numbering of the roots
  correspond to that of the original root datum (root |i| of the dual datum is
  coroot |i| of the orginal datum), but users should \emph{not} depend on this.
*/
RootDatum::RootDatum(const RootDatum& rd, tags::DualTag)
  :d_rank(rd.d_rank)
  ,d_semisimpleRank(rd.d_semisimpleRank)
  ,d_roots(rd.d_coroots)
  ,d_coroots(rd.d_roots)
  ,d_weights(rd.d_coweights)
  ,d_coweights(rd.d_weights)
  ,d_radicalBasis(rd.d_coradicalBasis)
  ,d_coradicalBasis(rd.d_radicalBasis)
  ,d_rootPermutation(rd.d_rootPermutation) // root permutation is the same
  ,d_2rho(rd.d_dual_2rho)
  ,d_dual_2rho(rd.d_2rho)
{
  // fill in the status

  fillStatus();

  assert(d_status[IsAdjoint] == rd.d_status[IsSimplyConnected]);
  assert(d_status[IsSimplyConnected] == rd.d_status[IsAdjoint]);
}

RootDatum::~RootDatum()

{}

/******** accessors **********************************************************/

latticetypes::Weight RootDatum::inSimpleRoots(RootNbr n) const
{
  latticetypes::Weight r=root(n); // on chosen lattice basis
  latticetypes::Weight result(d_semisimpleRank);
  for (size_t i = 0; i<d_semisimpleRank; ++i)
    result[i] = d_coweights[i].scalarProduct(r);
  return result;
}

/*!
\brief Returns the permutation of the roots induced by p.

  Precondition: p permutes the roots;
*/
setutils::Permutation
  RootDatum::rootPermutation(const LT::LatticeMatrix& q) const

{
  setutils::Permutation result(numRoots());

  for (size_t j = 0; j < numRoots(); ++j) {
    Root r(rank()); q.apply(r,root(j));
    result[j] = rootNbr(r);
  }

  return result;
}

/*!
\brief  Applies to v the reflection about root number r.

In other words, v is transformed into v - <v,alpha_r^vee>alpha_r
*/
void RootDatum::reflect(latticetypes::Weight& v, RootNbr r) const
{
  latticetypes::LatticeCoeff a = v.scalarProduct(d_coroots[r]);
  latticetypes::Weight m = d_roots[r];
  m *= a;
  v -= m;
}

/*!
\brief  Applies to the coweight |v| the reflection about coroot number |j|.

In other words, v is transformed into v - <alpha_j,v>alpha_j^vee.
*/
void RootDatum::coreflect(latticetypes::Weight& v, RootNbr j) const
{
  LT::LatticeCoeff a = v.scalarProduct(d_roots[j]);
  LT::Weight m = d_coroots[j];
  m *= a;
  v -= m;
}

/*!
\brief Puts in q the reflection for root \#r.

  NOTE: this is not intended for heavy use. If that is envisioned, it would be
  better to construct the matrices once and for all and return const
  references.
*/
void RootDatum::rootReflection(latticetypes::LatticeMatrix& q, RootNbr r) const
{
  q.resize(d_rank,d_rank);

  const Root& root = d_roots[r];
  const Root& coroot = d_coroots[r];

  for (size_t j = 0; j < d_rank; ++j)
    for (size_t i = 0; i < d_rank; ++i)
      q(i,j) = -root[i]*coroot[j];

  for (size_t i = 0; i < d_rank; ++i)
    q(i,i) += 1;
}

latticetypes::LatticeMatrix RootDatum::rootReflection(RootNbr r) const
{
 latticetypes:: LatticeMatrix result; rootReflection(result,r);
  return result;
}

// this is a non-destructive version of |toWeylWord| below for reflections
weyl::WeylWord RootDatum::reflectionWord(RootNbr r) const
{
  latticetypes::Weight v = twoRho(); reflect(v,r);

  weyl::WeylWord ww; toPositive(ww,v,*this); return ww;
}


latticetypes::LatticeMatrix RootDatum::cartanMatrix() const
{
  size_t r = semisimpleRank();

  latticetypes::LatticeMatrix result(r,r);

  for (size_t j = 0; j < r; ++j)
    for (size_t i = 0; i < r; ++i)
      result(i,j) = cartan(i,j);

  return result;
}


/*!
\brief Returns the Cartan matrix of the root subsystem with basis |rb|.
*/
LT::LatticeMatrix RootDatum::cartanMatrix(const RootList& rb) const
{
  size_t r = rb.size();

  latticetypes::LatticeMatrix result(r,r);

  for (size_t j = 0; j < r; ++j)
    for (size_t i = 0; i < r; ++i)
      result(i,j) = root(rb[i]).scalarProduct(coroot(rb[j]));

  return result;
}

/*!
\brief Returns the expression of $q^{-1}$ as a product of simple
  reflections.

  Precondition: $q$ gives the action on the weight lattice of some Weyl group
  element

  Algorithm: apply $q$ to |twoRho|, then use |toPositive| to find a Weyl
  word making it dominant again, which by assumption expresses $q^{-1}$.
*/
weyl::WeylWord RootDatum::word_of_inverse_matrix
  (const latticetypes::LatticeMatrix& q) const
{
  latticetypes::Weight v(rank()); q.apply(v,twoRho());

  weyl::WeylWord ww; toPositive(ww,v,*this); return ww;
}

/*!
\brief Returns the sum of the positive roots in rl.

  Precondition: rl holds the roots in a sub-rootsystem of the root system of
  rd;
*/
latticetypes::Weight RootDatum::twoRho(const RootList& rl) const
{
  latticetypes::Weight result(rank(),0);

  for (size_t j = 0; j < rl.size(); ++j)
    if (isPosRoot(rl[j]))
      result += root(rl[j]);

  return result;
}

/*!
\brief Returns the sum of the positive roots in rs.

  Precondition: rs holds the roots in a sub-rootsystem of the root system of
  rd;
*/
latticetypes::Weight RootDatum::twoRho(const RootSet& rs) const
{
  latticetypes::Weight result(rank(),0);

  for (RootSet::iterator i = rs.begin(); i(); ++i)
    if (isPosRoot(*i))
      result += root(*i);

  return result;
}


/*!
  \brief Returns the canonical basis (set of simple roots) of |rl|, which
  should hold all roots (or positive roots) of a root subsystem of |rd|

  Forwarded to the RootSet version. Therefore the order of the roots in |rl|
  is ignored! The roots of |rb| are by order of occurrence in |rd.roots()|
*/
RootList RootDatum::simpleBasis(const RootList& rl) const
{
  RootSet rs(numRoots()); rs.insert(rl.begin(),rl.end());
  return simpleBasis(rs);
}

/*!
  \brief Returns the canonical basis (set of simple roots) of |rs|, which
  should hold all roots (or positive roots) of a root subsystem of |rd|

  Algorithm: compute the sum of the positive roots in |rs|; extract the
  roots whose scalar product with that sum is 2.
*/
RootList RootDatum::simpleBasis(RootSet rs) const
{
  // compute sum of positive roots
  latticetypes::Weight rho2=twoRho(rs);

  RootList result;

  for (RootSet::iterator i = rs.begin(); i(); ++i)
    if (scalarProduct(rho2,*i) == 2) result.push_back(*i);

  return result;
}

/*!
\brief Tells if a+b is a root.

  Precondition: a and b are roots;
*/
bool RootDatum::sumIsRoot(const latticetypes::Weight& a,
			  const latticetypes::Weight& b) const
{
  latticetypes::Weight v = a;
  v += b;
  return isRoot(v);
}

RootList RootDatum::high_roots() const
{
  RootList h;
  for (RootNbr alpha=0; alpha<numRoots(); ++alpha)
  {
    size_t i;
    for (i=0; i<semisimpleRank(); ++i)
      if (sumIsRoot(alpha,simpleRootNbr(i)))
	break; // alpha not highest
    if (i==semisimpleRank()) //previous loop ran to completion
      h.push_back(alpha);
  }

  return h;
}


/******** manipulators *******************************************************/

void RootDatum::swap(RootDatum& other)
{
  std::swap(d_rank,other.d_rank);
  std::swap(d_semisimpleRank,other.d_semisimpleRank);
  d_roots.swap(other.d_roots);
  d_coroots.swap(other.d_coroots);
  d_weights.swap(other.d_weights);
  d_coweights.swap(other.d_coweights);
  d_radicalBasis.swap(other.d_radicalBasis);
  d_coradicalBasis.swap(other.d_coradicalBasis);
  d_rootPermutation.swap(other.d_rootPermutation),
  d_2rho.swap(other.d_2rho);
  d_dual_2rho.swap(other.d_dual_2rho);
  d_status.swap(other.d_status);
}

/******** private member functions ******************************************/

void RootDatum::fillStatus()

/*!
\brief Fills in the status of the rootdatum.
*/

{
  using namespace latticetypes;
  using namespace matrix;
  using namespace smithnormal;
  using namespace tags;

  LatticeMatrix q(beginSimpleRoot(),endSimpleRoot(),IteratorTag());

  WeightList b;
  CoeffList invf;

  initBasis(b,d_rank);
  smithNormal(invf,b.begin(),q);

  d_status.set(IsAdjoint);

  for (size_t j = 0; j < invf.size(); ++j)
    if (invf[j] != 1) {
      d_status.reset(IsAdjoint);
      break;
    }

  LatticeMatrix qd(beginSimpleCoroot(),endSimpleCoroot(),IteratorTag());

  initBasis(b,d_rank);
  invf.clear();
  smithNormal(invf,b.begin(),qd);

  d_status.set(IsSimplyConnected);

  for (size_t j = 0; j < invf.size(); ++j)
    if (invf[j] != 1) {
      d_status.reset(IsSimplyConnected);
      break;
    }
}

} // namespace rootdata

/*****************************************************************************

        Chapter II -- Functions declared in rootdata.h

  This section defines the following functions, which were declared in
  rootdata.h :

******************************************************************************/

namespace rootdata {


/*!
\brief Puts in c the Cartan matrix of the root datum
*/
void cartanMatrix(latticetypes::LatticeMatrix& c, const RootDatum& rd)
{
  size_t r = rd.semisimpleRank();

  c.resize(r,r,0);

  for (size_t j = 0; j < r; ++j)
    for (size_t i = 0; i < r; ++i)
      c(i,j) = rd.cartan(i,j);
}


/*!
\brief Puts in c the Cartan matrix of the root basis rb.

  Precondition: rb contains a basis of a root subsystem of that of rd.
*/
void cartanMatrix(latticetypes::LatticeMatrix& c, const RootList& rb,
		  const RootDatum& rd)
{
  c=rd.cartanMatrix(rb);
}


/*!
\brief Puts i^vee in di.

  Precondition: i is an involution of rd as a _based_ root datum;

  Postcondition: di is an involution of the dual based root datum;

  Algorithm: di is (w_0^t)(-i^t).  (The first factor is the long
  element of the Weyl group, acting on the dual root datum, and the
  second factor is the negative transpose of i.)

  [DV 13 July 2006: since RootDatum no longer contains the involution
  defining the inner class, this function seems not to belong in the
  rootdata namespace.  Not sure where would be a better home.]
*/
void dualBasedInvolution(LT::LatticeMatrix& di, const LT::LatticeMatrix& i,
			 const RootDatum& rd)
{
  LT::LatticeMatrix w0;
  longest(w0,rd);

  di = i;
  di *= w0;
  di.negate();
  di.transpose();
}


LT::LatticeMatrix dualBasedInvolution // a functional version of previous one
  (const LT::LatticeMatrix& i, const RootDatum& rd)
{
  LT::LatticeMatrix di; dualBasedInvolution(di,i,rd);
  return di;
}

/*!
\brief puts in lt the Lie type of the root system spanned by rb.

  Precondition: rb contains a basis of a sub-rootsystem of the root system of
  rd.
*/
void lieType(lietype::LieType& lt, const RootList& rb, const RootDatum& rd)
{
  using namespace dynkin;
  using namespace latticetypes;

  LatticeMatrix cm;
  cartanMatrix(cm,rb,rd);
  dynkin::lieType(lt,cm);
}

/*!
\brief Puts in q the matrix of the action of w_0;

  Algorithm: w_0 is the element making -twoRho positive.

  NOTE: not intended for heavy use. Should be precomputed if that is the
  case.
*/
void longest(LT::LatticeMatrix& q, const RootDatum& rd)
{
  using namespace latticetypes;
  using namespace weyl;

  Weight v = rd.twoRho();
  v *= -1;

  WeylWord ww;
  toPositive(ww,v,rd);

  identityMatrix(q,rd.rank());

  for (size_t j = 0; j < ww.size(); ++j) {
    LatticeMatrix r;
    rd.rootReflection(r,rd.simpleRootNbr(ww[j]));
    q *= r;
  }

  return;
}


/*!
\brief Puts in orth the elements of rs which are orthogonal to all
  elements of rl.
*/
void makeOrthogonal(RootList& orth, const RootList& rl, const RootList& rs,
		    const RootDatum& rd)
{
  orth.resize(0);

  for (unsigned long i = 0; i < rs.size(); ++i) {
    for (unsigned long j = 0; j < rl.size(); ++j)
      if (!rd.isOrthogonal(rs[i],rl[j])) // rs[i] is not orthogonal to rl
	goto not_orthogonal;
    orth.push_back(rs[i]);
  not_orthogonal:
    continue;
  }
}


/*!
\brief Writes in qs the matrix of the reflection through root \#n.
*/
void reflectionMatrix(LT::LatticeMatrix& qs, RootNbr n, const RootDatum& rd)
{
  latticetypes::Weight vc = rd.coroot(n);
  qs.resize(rd.rank(),rd.rank());

  for (size_t j = 0; j < rd.rank(); ++j) {
    latticetypes::LatticeCoeff a = vc[j];
    latticetypes::Weight v = rd.root(n);
    v *= a;
    for (size_t i = 0; i < rd.rank(); ++i)
      qs(i,j) = -v[i];
    qs(j,j) += 1;
  }
}

/*!
\brief Puts in rb the canonical basis (set of simple roots) of rl.

  Precondition: rl holds the roots in a sub-root system of rd;

  Forwarded to the RootSet version. Therefore the order of the roots in |rl|
  is ignored! The roots of |rb| are by order of occurrence in |rd.roots()|
*/
void rootBasis(RootList& rb, const RootList& rl, const RootDatum& rd)
{
  RootSet rs(rd.numRoots());
  rs.insert(rl.begin(),rl.end());
  rootBasis(rb,rs,rd);
}


/*!
\brief puts in rb the canonical basis (set of simple roots) of rs.

  Precondition: rs holds the roots in a sub-root system of rd;

  Algorithm: compute the sum of the positive roots in rs; extract the
  positive roots whose scalar product with that sum is 2.
*/
void rootBasis(RootList& rb, RootSet rs, const RootDatum& rd)
{
  rs &= rd.posRootSet();

  // compute sum of positive roots

  latticetypes::Weight twoRho(rd.rank(),0);

  for (RootSet::iterator i = rs.begin(); i(); ++i)
    twoRho += rd.root(*i);

  rb.clear();

  for (RootSet::iterator i = rs.begin(); i(); ++i)
    if (rd.scalarProduct(twoRho,*i) == 2)
      rb.push_back(*i);
}



/*!
\brief Makes rl into a strongly orthogonal system.

  Precondition: rl is a set of pairwise orthogonal roots;

  Algorithm: for i,j in rl, the sum can be a root iff i,j span a subsystem
  of type B2, and are short there; we can then replace i and j by their sum
  and difference. Note that this will not create new bad pairs, as bad pairs
  are made up of short roots.
*/
void strongOrthogonalize(RootList& rl, const RootDatum& rd)
{
  for (size_t j = 0; j < rl.size(); ++j)
    for (size_t i = 0; i < j; ++i)
      if (rd.sumIsRoot(rl[i],rl[j]))
      {
	latticetypes::Weight v = rd.root(rl[i]);
	v += rd.root(rl[j]);
	latticetypes::Weight w = rd.root(rl[i]);
	w -= rd.root(rl[j]);
	rl[i] = rd.rootNbr(v);
	rl[j] = rd.rootNbr(w);
      }
}

void toDistinguished(latticetypes::LatticeMatrix& q, const RootDatum& rd)

/*!
\brief Transforms q into w.q, where w is the unique element such that
  w.q fixes the positive Weyl chamber.

  Note that wq is then automatically an involution; w_0.w.q permutes the simple
  roots. [DV: I don't understand this last remark.  Probably q is
  meant to be an involutive automorphism of order 2 of the (unbased)
  root datum.  This would make w.q an involution of the based root
  datum, but then w_0.w.q would send the simple roots to their
  negatives.]
*/

{
  latticetypes::Weight v(rd.rank());
  q.apply(v,rd.twoRho());

  weyl::WeylWord ww;
  toPositive(ww,v,rd);

  latticetypes::LatticeMatrix p;
  toMatrix(p,ww,rd);

  p *= q;
  q.swap(p);
}

void toMatrix(latticetypes::LatticeMatrix& q, const weyl::WeylWord& ww,
	      const RootDatum& rd)

/*!
\brief Writes in q the matrix represented by ww.

  NOTE: not intended for heavy use. If that were the case, it would be better
  to use the decomposition of ww into pieces, and multiply those together.
  However, that would be for the ComplexGroup to do, as it is it that has
  access to both the Weyl group and the root datum.
*/

{
  identityMatrix(q,rd.rank());

  for (size_t j = 0; j < ww.size(); ++j)
    q *= rd.rootReflection(rd.simpleRootNbr(ww[j]));
}

void toMatrix(latticetypes::LatticeMatrix& q,
	      const RootList& rl,
	      const RootDatum& rd)

/*!
\brief Writes in q the matrix represented by rl (the product of the
  root reflections for the various roots in rl.)

  NOTE: the products are written in the same order as the appearance of
  the roots in rl. In practice this will be used for sequences of orthogonal
  roots, so that the order doesn't matter.
*/

{
  identityMatrix(q,rd.rank());

  for (size_t j = 0; j < rl.size(); ++j) {
    latticetypes::LatticeMatrix r;
    rd.rootReflection(r,rl[j]);
    q *= r;
  }
}


/*!
\brief Puts in ww a list of simple reflections constituting a reduced
  expression of the unique shortest element w in the Weyl group such that
  w.v is in the positive chamber.

  Algorithm: the greedy algorithm -- if v is not positive, there is a
  simple coroot alpha^v such that <v,alpha^v> is < 0; then s_alpha.v takes
  v closer to the positive chamber.
*/
void toPositive(weyl::WeylWord& ww,
		const latticetypes::Weight& d_v,
		const RootDatum& rd)
{
  latticetypes::Weight v = d_v;
  ww.clear();

  for (;;) {
    size_t j = 0;
    for (; j < rd.semisimpleRank(); ++j)
      if (v.scalarProduct(rd.simpleCoroot(j)) < 0)
	goto add_reflection;
    goto end;

  add_reflection:
    ww.push_back(j);
    rd.simpleReflect(v,j);
  }

 end:

  // reverse ww
  std::reverse(ww.begin(),ww.end());
}

void toWeylWord(weyl::WeylWord& ww, RootNbr rn, const RootDatum& rd)

/*!
\brief Writes in ww the expression of the reflection about root \#rn
  as a product of simple reflections.
*/

{
  latticetypes::Weight v = rd.twoRho();
  rd.reflect(v,rn);
  toPositive(ww,v,rd);
}


} // namespace rootdata

/*****************************************************************************

                Chapter III -- Auxiliary methods.

******************************************************************************/

namespace rootdata {


/*!
\brief Fills in the list rl of all the positive roots in the system, and the
  list crl of all the co-roots.

  Begins with the data of the root-basis rb and the co-root basis crb. The
  idea is to start out from rb, and then saturate through successive
  applications of simple reflections.

  The main problem is not to loose track of the root/co-root relationship.
  We want it to be so that the coroot of rl[j] is crl[j]. This is why we
  work with root/co-root _pairs_
*/
void RootDatum::fill_positives(latticetypes::WeightList& rl,
			       latticetypes::WeightList& crl)
{
  typedef std::pair<latticetypes::Weight,latticetypes::Weight> RP;

  std::set<RP> roots;
  std::deque<RP> new_roots;

  // initialize roots and new_roots with simple pairs
  // at this point the simple roots are available in |d_roots| and |d_coroots|
  for (size_t i=0; i<semisimpleRank(); ++i)
  {
    new_roots.push_back(make_pair(d_roots[i],d_coroots[i]));
    roots.insert(new_roots.back());
  }

  // construct positive root list

  while (not new_roots.empty())
  {
    const RP& rp = new_roots.front();
    for (size_t j = 0; j < semisimpleRank(); ++j)
      if (rp.first.scalarProduct(coroot(j))<0) // avoid going negative
      {
	assert(rp.second.scalarProduct(root(j))<0); // symmetric relation
	RP rp_new = rp;
	// simple-relflect by |j|; |simpleReflect| method is not yet ready
	reflect(rp_new.first,j);    // currently root |j| is simple root |j|
	coreflect(rp_new.second,j); // and likewise for coroot |j|
	if (roots.insert(rp_new).second) // then we found a new root
	  new_roots.push_back(rp_new);
      }
    new_roots.pop_front();
  }

  rl.clear(); rl.reserve(roots.size());
  crl.clear(); crl.reserve(roots.size());

  /* now write to the output parameters, compute |d_2rho| and |d_dual_2rho| */
  for (std::set<RP>::iterator rpi = roots.begin(); rpi != roots.end(); ++rpi)
  {
    rl.push_back(rpi->first);
    crl.push_back(rpi->second);
    d_2rho += rpi->first;
    d_dual_2rho += rpi->second;
  }

} // |fill_positives|

// a class for making a compare object for indices, backwards lexicographic
class weight_compare
{
  const std::vector<latticetypes::Weight>& alpha; // weights being compared
  std::vector<latticetypes::Weight> phi; // coweights by increasing priority

public:
  weight_compare(const std::vector<latticetypes::Weight>& roots,
		 const std::vector<latticetypes::Weight>& f)
    : alpha(roots), phi(f) {}

  void add_coweight(const latticetypes::Weight& f) { phi.push_back(f); }

  bool operator() (size_t i, size_t j)
  {
    latticetypes::LatticeCoeff x,y;
    for (size_t k=phi.size(); k-->0; )
      if ((x=phi[k].scalarProduct(alpha[i]))!=
	  (y=phi[k].scalarProduct(alpha[j])))
	return x<y;

    return false; // weights compare equal under all coweights
  }
}; // |class weight_compare|


/*!
\brief  Sorts roots by height, then lexicographic by backwards root coordinates
*/
std::vector<size_t>
RootDatum::sort_roots(const latticetypes::WeightList& roots,
		      const latticetypes::WeightList& simple_coweights) const
{
  std::vector<size_t> permutation(roots.size());
  if (permutation.empty())
    return permutation; // avoid any fuss for pure tori

  for (size_t i=0; i<permutation.size(); ++i)
    permutation[i]=i;

  // sort by root coordinates, backwards (so simple roots are in order)
  weight_compare comp(roots,simple_coweights);
  comp.add_coweight(d_dual_2rho); // height dominates individual coweights

  // sort indices so that simple roots come first, in order
  std::stable_sort(permutation.begin(),permutation.end(),comp);

  return permutation;
} // |sort_roots|


} // |namespace rootdata|

} // |namespace atlas|
