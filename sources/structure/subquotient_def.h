/*!
  \file
  \brief Template definitions for the classes |Subspace| and |Subquotient|.

  These class templates deal with subspaces and subquotients of vector spaces
  over $Z/2Z$, elements of which are of type |BitVector|.
*/
/*
  This is subquotient_def.h.

  Copyright (C) 2004,2005 Fokko du Cloux
  part of the Atlas of Reductive Lie Groups

  For license information see the LICENSE file
*/

#include <cassert>

namespace atlas {

/*****************************************************************************

        Chapter I -- The Subspace class

*****************************************************************************/

namespace subquotient {


/*!
  \brief Constructs the normal subspace generated by the collection
  of |BitVectors| |b|, each of which has rank |n|.
*/
template<size_t dim> Subspace<dim>::
Subspace(const bitvector::BitVectorList<dim>& b, size_t n)
  : d_rank(n)
  , d_basis(b)
  , d_support()
{
  assert(b.size()==0 or b[0].size()==n);

  // change |d_basis| and set |d_support|:
  bitvector::normalize(d_support,d_basis);
}

/******** accessors **********************************************************/

/*!
  \brief Put in |r| the canonical representative of |v| modulo our subspace.

  This |r| is characterized by the vanishing of its bits in positions
  |d_support| (the leading bits of the canonical basis of our subspace). Note
  that we are making no reference to the space from which our subspace is
  divided out; this could be the whole space $(Z/2Z)^n$ (in any case |r| is
  expressed in its canonical basis) or some subspace containing our subspace.

  The algorithm projects v onto the subspace, the result |pv| being expressed
  in the canonical basis of the subspace: the coordinates of pv are just the
  entries of |v| in the coordinates flagged by |d_support|. Then |w| is
  computed as the corresponding |BitVector| in $(Z/2Z)^n$, given by combining
  the canonical basis with coefficients from |pv|.  Finally we set |r=v-w|.
*/
template<size_t dim>
void Subspace<dim>::representative
  (bitvector::BitVector<dim>& r, const bitvector::BitVector<dim>& v) const

{
  assert(v.size()==rank());

  // get projection to subspace expressed in d_basis
  bitvector::BitVector<dim> pv = v;
  pv.slice(d_support);

  assert(pv.size()==dimension());

  // expand that linear combination to an element of $(Z/2Z)^n$
  bitvector::BitVector<dim> w(v.size());
  combination(w,d_basis,pv.data());

  assert(w.size()==rank());

  r = v; r -= w; // set |r| to original vector minus (or plus) correction |w|
}

/******** manipulators *******************************************************/


/*!
  Synopsis: applies |r| to our subspace, normalizing the resulting subspace.

  Precondition: r is a matrix of the appropriate column size (it could go to a
  space of another dimension, even.)
*/
template<size_t dim>
void Subspace<dim>::apply(const bitvector::BitMatrix<dim>& r)
{
  assert(r.numColumns()==d_rank);

  bitvector::BitVectorList<dim> b = d_basis; // copy our basis

  for (size_t j = 0; j < b.size(); ++j) {
    r.apply(b[j],b[j]);
    assert(b[j].size()==r.numRows());
  }

  Subspace<dim> ns(b,r.numRows()); // construct (and normalize) new subspace
  swap(ns); // and install it in our place
}

template<size_t dim>
void Subspace<dim>::swap(Subspace& source)

{
  std::swap(d_rank,source.d_rank);
  d_basis.swap(source.d_basis);
  d_support.swap(source.d_support);
}

}

/*****************************************************************************

        Chapter II -- The Subquotient class

*****************************************************************************/

namespace subquotient {

template<size_t dim> Subquotient<dim>::
Subquotient(const bitvector::BitVectorList<dim>& bsp,
	    const bitvector::BitVectorList<dim>& bsub, size_t n)
  : d_space(bsp,n)
  , d_subspace(bsub,n)
  , d_rel_support()

/*!
  \brief constructs the subquotient where |bsp| generates the space,
  |bsub| the subspace.
*/

{
  assert(d_space.contains(bsub)); // check containment of subspaces
  assert(d_space.support().contains(d_subspace.support()));

  d_rel_support = d_space.support() - d_subspace.support(); // difference set
  d_rel_support.slice(d_space.support()); // only keep bits originally set

}

/******** manipulators *******************************************************/

template<size_t dim>
void Subquotient<dim>::apply(const bitvector::BitMatrix<dim>& r)

/*!
  Synopsis: applies |r| to the data.
*/

{
  d_space.apply(r);
  d_subspace.apply(r);

  // recompute the relative support
  d_rel_support = d_space.support();
  d_rel_support &= ~d_subspace.support();
  d_rel_support.slice(d_space.support());
}

template<size_t dim>
void Subquotient<dim>::swap(Subquotient& source)

{
  d_space.swap(source.d_space);
  d_subspace.swap(source.d_subspace);
  d_rel_support.swap(source.d_rel_support);
}

}

/*****************************************************************************

        Chapter III -- Functions declared in subquotient.h

*****************************************************************************/

namespace subquotient {

template<size_t dim>
  void subquotientMap(bitvector::BitMatrix<dim>& msq,
		      const Subquotient<dim>& source,
		      const Subquotient<dim>& dest,
		      const bitvector::BitMatrix<dim>& m)

/*!
  Synopsis: puts in |msq| the matrix of the map induced by |m| at the
  subquotient level.

  Precondition: |m| has |source.rank()| columns and |dest.rank()| rows, in
  other words it defines a map at the level of the ambient $Z/2Z$-vector
  spaces. Moreover it maps |source.space()| to |dest.space()| and
  |source.subspace()| to |dest.subspace()|. [This is a strong condition, which
  it is the caller's responsibility to ensure. It is _not_ sufficient that |m|
  gives rise to a mathematically well-defined map between the subquotients;
  for instance while for any subspaces $A,B$ there is a canonical isomorphism
  between the subquotients $(A+B)/A$ and $B/(A\cap B)$, the identity matrix
  might not produce such an isomorphism when applied from the former to the
  latter subquotient (although it would in the opposite direction). MvL]

  The subquotient matrix will be expressed in terms of the canonical bases for
  the subquotients (which are made up of those elements of the basis of the
  larger subspace |space()| that are zero on the bits supporting of the
  smaller subspace |subspace()|.) Therefore its size will be
  |source.dimension()| columns and |dest.dimension()| rows.

  Algorithm: take the image through |m| of the subquotient basis in |source|;
  then project onto the subquotient basis in dest. Note that this procedure
  inspects neither |source.subspace()| nor |dest.space()|.
*/

{
  assert(m.numColumns()==source.rank());
  assert(m.numRows()==dest.rank());

  msq.resize(dest.dimension(),0); // start with 0 columns, but of proper length

  // restrict m to source.space()
  for (size_t j = 0; j < source.space().dimension(); ++j)
    if (source.support().test(j)) {
      latticetypes::SmallBitVector v;
      m.apply(v,source.space().basis(j));
      assert(v.size()==dest.rank());

      /*
      // go to canonical representative modulo destination subspace
      dest.subspace().mod_reduce(v);
      assert(v.size()==dest.rank());

      // get coordinates in canonical basis
      v.slice(dest.space().support());  // express |v| in basis of |d_space|
      assert(v.size()==dest.space().dimension());

      v.slice(dest.support());
      */

      v=dest.toBasis(v);
      assert(v.size()==dest.dimension()); // dimension of the subquotient

      msq.addColumn(v);
    }
}

}

}
